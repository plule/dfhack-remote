// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `Basic.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct EnumItemName {
    // message fields
    value: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    bit_size: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnumItemName {
    fn default() -> &'a EnumItemName {
        <EnumItemName as ::protobuf::Message>::default_instance()
    }
}

impl EnumItemName {
    pub fn new() -> EnumItemName {
        ::std::default::Default::default()
    }

    // required int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 bit_size = 3;


    pub fn get_bit_size(&self) -> i32 {
        self.bit_size.unwrap_or(1i32)
    }
    pub fn clear_bit_size(&mut self) {
        self.bit_size = ::std::option::Option::None;
    }

    pub fn has_bit_size(&self) -> bool {
        self.bit_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bit_size(&mut self, v: i32) {
        self.bit_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EnumItemName {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bit_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bit_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.bit_size {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnumItemName {
        EnumItemName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &EnumItemName| { &m.value },
                |m: &mut EnumItemName| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &EnumItemName| { &m.name },
                |m: &mut EnumItemName| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bit_size",
                |m: &EnumItemName| { &m.bit_size },
                |m: &mut EnumItemName| { &mut m.bit_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnumItemName>(
                "EnumItemName",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnumItemName {
        static instance: ::protobuf::rt::LazyV2<EnumItemName> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnumItemName::new)
    }
}

impl ::protobuf::Clear for EnumItemName {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.name.clear();
        self.bit_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnumItemName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumItemName {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicMaterialId {
    // message fields
    field_type: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicMaterialId {
    fn default() -> &'a BasicMaterialId {
        <BasicMaterialId as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialId {
    pub fn new() -> BasicMaterialId {
        ::std::default::Default::default()
    }

    // required int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required sint32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BasicMaterialId {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicMaterialId {
        BasicMaterialId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &BasicMaterialId| { &m.field_type },
                |m: &mut BasicMaterialId| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "index",
                |m: &BasicMaterialId| { &m.index },
                |m: &mut BasicMaterialId| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicMaterialId>(
                "BasicMaterialId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicMaterialId {
        static instance: ::protobuf::rt::LazyV2<BasicMaterialId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicMaterialId::new)
    }
}

impl ::protobuf::Clear for BasicMaterialId {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicMaterialId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicMaterialInfo {
    // message fields
    field_type: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    token: ::protobuf::SingularField<::std::string::String>,
    pub flags: ::std::vec::Vec<i32>,
    subtype: ::std::option::Option<i32>,
    creature_id: ::std::option::Option<i32>,
    plant_id: ::std::option::Option<i32>,
    histfig_id: ::std::option::Option<i32>,
    name_prefix: ::protobuf::SingularField<::std::string::String>,
    pub state_color: ::std::vec::Vec<u32>,
    pub state_name: ::protobuf::RepeatedField<::std::string::String>,
    pub state_adj: ::protobuf::RepeatedField<::std::string::String>,
    pub reaction_class: ::protobuf::RepeatedField<::std::string::String>,
    pub reaction_product: ::protobuf::RepeatedField<BasicMaterialInfo_Product>,
    pub inorganic_flags: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicMaterialInfo {
    fn default() -> &'a BasicMaterialInfo {
        <BasicMaterialInfo as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialInfo {
    pub fn new() -> BasicMaterialInfo {
        ::std::default::Default::default()
    }

    // required int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required sint32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // required string token = 3;


    pub fn get_token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int32 flags = 4;


    pub fn get_flags(&self) -> &[i32] {
        &self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: ::std::vec::Vec<i32>) {
        self.flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flags(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.flags
    }

    // Take field
    pub fn take_flags(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.flags, ::std::vec::Vec::new())
    }

    // optional int32 subtype = 5;


    pub fn get_subtype(&self) -> i32 {
        self.subtype.unwrap_or(-1i32)
    }
    pub fn clear_subtype(&mut self) {
        self.subtype = ::std::option::Option::None;
    }

    pub fn has_subtype(&self) -> bool {
        self.subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subtype(&mut self, v: i32) {
        self.subtype = ::std::option::Option::Some(v);
    }

    // optional int32 creature_id = 6;


    pub fn get_creature_id(&self) -> i32 {
        self.creature_id.unwrap_or(-1i32)
    }
    pub fn clear_creature_id(&mut self) {
        self.creature_id = ::std::option::Option::None;
    }

    pub fn has_creature_id(&self) -> bool {
        self.creature_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_id(&mut self, v: i32) {
        self.creature_id = ::std::option::Option::Some(v);
    }

    // optional int32 plant_id = 7;


    pub fn get_plant_id(&self) -> i32 {
        self.plant_id.unwrap_or(-1i32)
    }
    pub fn clear_plant_id(&mut self) {
        self.plant_id = ::std::option::Option::None;
    }

    pub fn has_plant_id(&self) -> bool {
        self.plant_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plant_id(&mut self, v: i32) {
        self.plant_id = ::std::option::Option::Some(v);
    }

    // optional int32 histfig_id = 8;


    pub fn get_histfig_id(&self) -> i32 {
        self.histfig_id.unwrap_or(-1i32)
    }
    pub fn clear_histfig_id(&mut self) {
        self.histfig_id = ::std::option::Option::None;
    }

    pub fn has_histfig_id(&self) -> bool {
        self.histfig_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_histfig_id(&mut self, v: i32) {
        self.histfig_id = ::std::option::Option::Some(v);
    }

    // optional string name_prefix = 9;


    pub fn get_name_prefix(&self) -> &str {
        match self.name_prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name_prefix(&mut self) {
        self.name_prefix.clear();
    }

    pub fn has_name_prefix(&self) -> bool {
        self.name_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_prefix(&mut self, v: ::std::string::String) {
        self.name_prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_prefix(&mut self) -> &mut ::std::string::String {
        if self.name_prefix.is_none() {
            self.name_prefix.set_default();
        }
        self.name_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_prefix(&mut self) -> ::std::string::String {
        self.name_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed32 state_color = 10;


    pub fn get_state_color(&self) -> &[u32] {
        &self.state_color
    }
    pub fn clear_state_color(&mut self) {
        self.state_color.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_color(&mut self, v: ::std::vec::Vec<u32>) {
        self.state_color = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state_color(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.state_color
    }

    // Take field
    pub fn take_state_color(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.state_color, ::std::vec::Vec::new())
    }

    // repeated string state_name = 11;


    pub fn get_state_name(&self) -> &[::std::string::String] {
        &self.state_name
    }
    pub fn clear_state_name(&mut self) {
        self.state_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.state_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.state_name
    }

    // Take field
    pub fn take_state_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.state_name, ::protobuf::RepeatedField::new())
    }

    // repeated string state_adj = 12;


    pub fn get_state_adj(&self) -> &[::std::string::String] {
        &self.state_adj
    }
    pub fn clear_state_adj(&mut self) {
        self.state_adj.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_adj(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.state_adj = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state_adj(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.state_adj
    }

    // Take field
    pub fn take_state_adj(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.state_adj, ::protobuf::RepeatedField::new())
    }

    // repeated string reaction_class = 13;


    pub fn get_reaction_class(&self) -> &[::std::string::String] {
        &self.reaction_class
    }
    pub fn clear_reaction_class(&mut self) {
        self.reaction_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_reaction_class(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.reaction_class = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reaction_class(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.reaction_class
    }

    // Take field
    pub fn take_reaction_class(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.reaction_class, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.BasicMaterialInfo.Product reaction_product = 14;


    pub fn get_reaction_product(&self) -> &[BasicMaterialInfo_Product] {
        &self.reaction_product
    }
    pub fn clear_reaction_product(&mut self) {
        self.reaction_product.clear();
    }

    // Param is passed by value, moved
    pub fn set_reaction_product(&mut self, v: ::protobuf::RepeatedField<BasicMaterialInfo_Product>) {
        self.reaction_product = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reaction_product(&mut self) -> &mut ::protobuf::RepeatedField<BasicMaterialInfo_Product> {
        &mut self.reaction_product
    }

    // Take field
    pub fn take_reaction_product(&mut self) -> ::protobuf::RepeatedField<BasicMaterialInfo_Product> {
        ::std::mem::replace(&mut self.reaction_product, ::protobuf::RepeatedField::new())
    }

    // repeated int32 inorganic_flags = 15;


    pub fn get_inorganic_flags(&self) -> &[i32] {
        &self.inorganic_flags
    }
    pub fn clear_inorganic_flags(&mut self) {
        self.inorganic_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_inorganic_flags(&mut self, v: ::std::vec::Vec<i32>) {
        self.inorganic_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inorganic_flags(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.inorganic_flags
    }

    // Take field
    pub fn take_inorganic_flags(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.inorganic_flags, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BasicMaterialInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        if self.token.is_none() {
            return false;
        }
        for v in &self.reaction_product {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.flags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subtype = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.creature_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.plant_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.histfig_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_prefix)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.state_color)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.state_name)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.state_adj)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.reaction_class)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reaction_product)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.inorganic_flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.flags {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.subtype {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creature_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.plant_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.histfig_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += 5 * self.state_color.len() as u32;
        for value in &self.state_name {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.state_adj {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.reaction_class {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.reaction_product {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.inorganic_flags {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_sint32(2, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.flags {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.subtype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.creature_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.plant_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.histfig_id {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.name_prefix.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.state_color {
            os.write_fixed32(10, *v)?;
        };
        for v in &self.state_name {
            os.write_string(11, &v)?;
        };
        for v in &self.state_adj {
            os.write_string(12, &v)?;
        };
        for v in &self.reaction_class {
            os.write_string(13, &v)?;
        };
        for v in &self.reaction_product {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.inorganic_flags {
            os.write_int32(15, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicMaterialInfo {
        BasicMaterialInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &BasicMaterialInfo| { &m.field_type },
                |m: &mut BasicMaterialInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "index",
                |m: &BasicMaterialInfo| { &m.index },
                |m: &mut BasicMaterialInfo| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &BasicMaterialInfo| { &m.token },
                |m: &mut BasicMaterialInfo| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flags",
                |m: &BasicMaterialInfo| { &m.flags },
                |m: &mut BasicMaterialInfo| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "subtype",
                |m: &BasicMaterialInfo| { &m.subtype },
                |m: &mut BasicMaterialInfo| { &mut m.subtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "creature_id",
                |m: &BasicMaterialInfo| { &m.creature_id },
                |m: &mut BasicMaterialInfo| { &mut m.creature_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "plant_id",
                |m: &BasicMaterialInfo| { &m.plant_id },
                |m: &mut BasicMaterialInfo| { &mut m.plant_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "histfig_id",
                |m: &BasicMaterialInfo| { &m.histfig_id },
                |m: &mut BasicMaterialInfo| { &mut m.histfig_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name_prefix",
                |m: &BasicMaterialInfo| { &m.name_prefix },
                |m: &mut BasicMaterialInfo| { &mut m.name_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "state_color",
                |m: &BasicMaterialInfo| { &m.state_color },
                |m: &mut BasicMaterialInfo| { &mut m.state_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state_name",
                |m: &BasicMaterialInfo| { &m.state_name },
                |m: &mut BasicMaterialInfo| { &mut m.state_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state_adj",
                |m: &BasicMaterialInfo| { &m.state_adj },
                |m: &mut BasicMaterialInfo| { &mut m.state_adj },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reaction_class",
                |m: &BasicMaterialInfo| { &m.reaction_class },
                |m: &mut BasicMaterialInfo| { &mut m.reaction_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BasicMaterialInfo_Product>>(
                "reaction_product",
                |m: &BasicMaterialInfo| { &m.reaction_product },
                |m: &mut BasicMaterialInfo| { &mut m.reaction_product },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "inorganic_flags",
                |m: &BasicMaterialInfo| { &m.inorganic_flags },
                |m: &mut BasicMaterialInfo| { &mut m.inorganic_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicMaterialInfo>(
                "BasicMaterialInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicMaterialInfo {
        static instance: ::protobuf::rt::LazyV2<BasicMaterialInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicMaterialInfo::new)
    }
}

impl ::protobuf::Clear for BasicMaterialInfo {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.token.clear();
        self.flags.clear();
        self.subtype = ::std::option::Option::None;
        self.creature_id = ::std::option::Option::None;
        self.plant_id = ::std::option::Option::None;
        self.histfig_id = ::std::option::Option::None;
        self.name_prefix.clear();
        self.state_color.clear();
        self.state_name.clear();
        self.state_adj.clear();
        self.reaction_class.clear();
        self.reaction_product.clear();
        self.inorganic_flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicMaterialInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicMaterialInfo_Product {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicMaterialInfo_Product {
    fn default() -> &'a BasicMaterialInfo_Product {
        <BasicMaterialInfo_Product as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialInfo_Product {
    pub fn new() -> BasicMaterialInfo_Product {
        ::std::default::Default::default()
    }

    // required string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 type = 2;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required sint32 index = 3;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BasicMaterialInfo_Product {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.index {
            os.write_sint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicMaterialInfo_Product {
        BasicMaterialInfo_Product::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &BasicMaterialInfo_Product| { &m.id },
                |m: &mut BasicMaterialInfo_Product| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &BasicMaterialInfo_Product| { &m.field_type },
                |m: &mut BasicMaterialInfo_Product| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "index",
                |m: &BasicMaterialInfo_Product| { &m.index },
                |m: &mut BasicMaterialInfo_Product| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicMaterialInfo_Product>(
                "BasicMaterialInfo.Product",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicMaterialInfo_Product {
        static instance: ::protobuf::rt::LazyV2<BasicMaterialInfo_Product> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicMaterialInfo_Product::new)
    }
}

impl ::protobuf::Clear for BasicMaterialInfo_Product {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicMaterialInfo_Product {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialInfo_Product {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicMaterialInfoMask {
    // message fields
    pub states: ::std::vec::Vec<BasicMaterialInfoMask_StateType>,
    temperature: ::std::option::Option<i32>,
    flags: ::std::option::Option<bool>,
    reaction: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicMaterialInfoMask {
    fn default() -> &'a BasicMaterialInfoMask {
        <BasicMaterialInfoMask as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialInfoMask {
    pub fn new() -> BasicMaterialInfoMask {
        ::std::default::Default::default()
    }

    // repeated .dfproto.BasicMaterialInfoMask.StateType states = 1;


    pub fn get_states(&self) -> &[BasicMaterialInfoMask_StateType] {
        &self.states
    }
    pub fn clear_states(&mut self) {
        self.states.clear();
    }

    // Param is passed by value, moved
    pub fn set_states(&mut self, v: ::std::vec::Vec<BasicMaterialInfoMask_StateType>) {
        self.states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_states(&mut self) -> &mut ::std::vec::Vec<BasicMaterialInfoMask_StateType> {
        &mut self.states
    }

    // Take field
    pub fn take_states(&mut self) -> ::std::vec::Vec<BasicMaterialInfoMask_StateType> {
        ::std::mem::replace(&mut self.states, ::std::vec::Vec::new())
    }

    // optional int32 temperature = 4;


    pub fn get_temperature(&self) -> i32 {
        self.temperature.unwrap_or(10015i32)
    }
    pub fn clear_temperature(&mut self) {
        self.temperature = ::std::option::Option::None;
    }

    pub fn has_temperature(&self) -> bool {
        self.temperature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: i32) {
        self.temperature = ::std::option::Option::Some(v);
    }

    // optional bool flags = 2;


    pub fn get_flags(&self) -> bool {
        self.flags.unwrap_or(false)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: bool) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool reaction = 3;


    pub fn get_reaction(&self) -> bool {
        self.reaction.unwrap_or(false)
    }
    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: bool) {
        self.reaction = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BasicMaterialInfoMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.states, 1, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.temperature = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reaction = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.states {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        if let Some(v) = self.temperature {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += 2;
        }
        if let Some(v) = self.reaction {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.states {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.temperature {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.reaction {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicMaterialInfoMask {
        BasicMaterialInfoMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BasicMaterialInfoMask_StateType>>(
                "states",
                |m: &BasicMaterialInfoMask| { &m.states },
                |m: &mut BasicMaterialInfoMask| { &mut m.states },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "temperature",
                |m: &BasicMaterialInfoMask| { &m.temperature },
                |m: &mut BasicMaterialInfoMask| { &mut m.temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flags",
                |m: &BasicMaterialInfoMask| { &m.flags },
                |m: &mut BasicMaterialInfoMask| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reaction",
                |m: &BasicMaterialInfoMask| { &m.reaction },
                |m: &mut BasicMaterialInfoMask| { &mut m.reaction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicMaterialInfoMask>(
                "BasicMaterialInfoMask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicMaterialInfoMask {
        static instance: ::protobuf::rt::LazyV2<BasicMaterialInfoMask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicMaterialInfoMask::new)
    }
}

impl ::protobuf::Clear for BasicMaterialInfoMask {
    fn clear(&mut self) {
        self.states.clear();
        self.temperature = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicMaterialInfoMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialInfoMask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BasicMaterialInfoMask_StateType {
    Solid = 0,
    Liquid = 1,
    Gas = 2,
    Powder = 3,
    Paste = 4,
    Pressed = 5,
}

impl ::protobuf::ProtobufEnum for BasicMaterialInfoMask_StateType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BasicMaterialInfoMask_StateType> {
        match value {
            0 => ::std::option::Option::Some(BasicMaterialInfoMask_StateType::Solid),
            1 => ::std::option::Option::Some(BasicMaterialInfoMask_StateType::Liquid),
            2 => ::std::option::Option::Some(BasicMaterialInfoMask_StateType::Gas),
            3 => ::std::option::Option::Some(BasicMaterialInfoMask_StateType::Powder),
            4 => ::std::option::Option::Some(BasicMaterialInfoMask_StateType::Paste),
            5 => ::std::option::Option::Some(BasicMaterialInfoMask_StateType::Pressed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BasicMaterialInfoMask_StateType] = &[
            BasicMaterialInfoMask_StateType::Solid,
            BasicMaterialInfoMask_StateType::Liquid,
            BasicMaterialInfoMask_StateType::Gas,
            BasicMaterialInfoMask_StateType::Powder,
            BasicMaterialInfoMask_StateType::Paste,
            BasicMaterialInfoMask_StateType::Pressed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BasicMaterialInfoMask_StateType>("BasicMaterialInfoMask.StateType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BasicMaterialInfoMask_StateType {
}

impl ::std::default::Default for BasicMaterialInfoMask_StateType {
    fn default() -> Self {
        BasicMaterialInfoMask_StateType::Solid
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialInfoMask_StateType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobSkillAttr {
    // message fields
    id: ::std::option::Option<i32>,
    key: ::protobuf::SingularField<::std::string::String>,
    caption: ::protobuf::SingularField<::std::string::String>,
    caption_noun: ::protobuf::SingularField<::std::string::String>,
    profession: ::std::option::Option<i32>,
    labor: ::std::option::Option<i32>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JobSkillAttr {
    fn default() -> &'a JobSkillAttr {
        <JobSkillAttr as ::protobuf::Message>::default_instance()
    }
}

impl JobSkillAttr {
    pub fn new() -> JobSkillAttr {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption_noun = 4;


    pub fn get_caption_noun(&self) -> &str {
        match self.caption_noun.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption_noun(&mut self) {
        self.caption_noun.clear();
    }

    pub fn has_caption_noun(&self) -> bool {
        self.caption_noun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption_noun(&mut self, v: ::std::string::String) {
        self.caption_noun = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption_noun(&mut self) -> &mut ::std::string::String {
        if self.caption_noun.is_none() {
            self.caption_noun.set_default();
        }
        self.caption_noun.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption_noun(&mut self) -> ::std::string::String {
        self.caption_noun.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 profession = 5;


    pub fn get_profession(&self) -> i32 {
        self.profession.unwrap_or(0)
    }
    pub fn clear_profession(&mut self) {
        self.profession = ::std::option::Option::None;
    }

    pub fn has_profession(&self) -> bool {
        self.profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: i32) {
        self.profession = ::std::option::Option::Some(v);
    }

    // optional int32 labor = 6;


    pub fn get_labor(&self) -> i32 {
        self.labor.unwrap_or(0)
    }
    pub fn clear_labor(&mut self) {
        self.labor = ::std::option::Option::None;
    }

    pub fn has_labor(&self) -> bool {
        self.labor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labor(&mut self, v: i32) {
        self.labor = ::std::option::Option::Some(v);
    }

    // optional string type = 7;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for JobSkillAttr {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption_noun)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.profession = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.labor = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.caption_noun.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.profession {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.labor {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.caption_noun.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.profession {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.labor {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobSkillAttr {
        JobSkillAttr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &JobSkillAttr| { &m.id },
                |m: &mut JobSkillAttr| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &JobSkillAttr| { &m.key },
                |m: &mut JobSkillAttr| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &JobSkillAttr| { &m.caption },
                |m: &mut JobSkillAttr| { &mut m.caption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption_noun",
                |m: &JobSkillAttr| { &m.caption_noun },
                |m: &mut JobSkillAttr| { &mut m.caption_noun },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "profession",
                |m: &JobSkillAttr| { &m.profession },
                |m: &mut JobSkillAttr| { &mut m.profession },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "labor",
                |m: &JobSkillAttr| { &m.labor },
                |m: &mut JobSkillAttr| { &mut m.labor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &JobSkillAttr| { &m.field_type },
                |m: &mut JobSkillAttr| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JobSkillAttr>(
                "JobSkillAttr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JobSkillAttr {
        static instance: ::protobuf::rt::LazyV2<JobSkillAttr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JobSkillAttr::new)
    }
}

impl ::protobuf::Clear for JobSkillAttr {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key.clear();
        self.caption.clear();
        self.caption_noun.clear();
        self.profession = ::std::option::Option::None;
        self.labor = ::std::option::Option::None;
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobSkillAttr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobSkillAttr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProfessionAttr {
    // message fields
    id: ::std::option::Option<i32>,
    key: ::protobuf::SingularField<::std::string::String>,
    caption: ::protobuf::SingularField<::std::string::String>,
    military: ::std::option::Option<bool>,
    can_assign_labor: ::std::option::Option<bool>,
    parent: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfessionAttr {
    fn default() -> &'a ProfessionAttr {
        <ProfessionAttr as ::protobuf::Message>::default_instance()
    }
}

impl ProfessionAttr {
    pub fn new() -> ProfessionAttr {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool military = 4;


    pub fn get_military(&self) -> bool {
        self.military.unwrap_or(false)
    }
    pub fn clear_military(&mut self) {
        self.military = ::std::option::Option::None;
    }

    pub fn has_military(&self) -> bool {
        self.military.is_some()
    }

    // Param is passed by value, moved
    pub fn set_military(&mut self, v: bool) {
        self.military = ::std::option::Option::Some(v);
    }

    // optional bool can_assign_labor = 5;


    pub fn get_can_assign_labor(&self) -> bool {
        self.can_assign_labor.unwrap_or(false)
    }
    pub fn clear_can_assign_labor(&mut self) {
        self.can_assign_labor = ::std::option::Option::None;
    }

    pub fn has_can_assign_labor(&self) -> bool {
        self.can_assign_labor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_assign_labor(&mut self, v: bool) {
        self.can_assign_labor = ::std::option::Option::Some(v);
    }

    // optional int32 parent = 6;


    pub fn get_parent(&self) -> i32 {
        self.parent.unwrap_or(0)
    }
    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: i32) {
        self.parent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ProfessionAttr {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.military = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_assign_labor = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.parent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.military {
            my_size += 2;
        }
        if let Some(v) = self.can_assign_labor {
            my_size += 2;
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.military {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_assign_labor {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.parent {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfessionAttr {
        ProfessionAttr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &ProfessionAttr| { &m.id },
                |m: &mut ProfessionAttr| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &ProfessionAttr| { &m.key },
                |m: &mut ProfessionAttr| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &ProfessionAttr| { &m.caption },
                |m: &mut ProfessionAttr| { &mut m.caption },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "military",
                |m: &ProfessionAttr| { &m.military },
                |m: &mut ProfessionAttr| { &mut m.military },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_assign_labor",
                |m: &ProfessionAttr| { &m.can_assign_labor },
                |m: &mut ProfessionAttr| { &mut m.can_assign_labor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "parent",
                |m: &ProfessionAttr| { &m.parent },
                |m: &mut ProfessionAttr| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfessionAttr>(
                "ProfessionAttr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfessionAttr {
        static instance: ::protobuf::rt::LazyV2<ProfessionAttr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfessionAttr::new)
    }
}

impl ::protobuf::Clear for ProfessionAttr {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key.clear();
        self.caption.clear();
        self.military = ::std::option::Option::None;
        self.can_assign_labor = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfessionAttr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfessionAttr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitLaborAttr {
    // message fields
    id: ::std::option::Option<i32>,
    key: ::protobuf::SingularField<::std::string::String>,
    caption: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitLaborAttr {
    fn default() -> &'a UnitLaborAttr {
        <UnitLaborAttr as ::protobuf::Message>::default_instance()
    }
}

impl UnitLaborAttr {
    pub fn new() -> UnitLaborAttr {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnitLaborAttr {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitLaborAttr {
        UnitLaborAttr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &UnitLaborAttr| { &m.id },
                |m: &mut UnitLaborAttr| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &UnitLaborAttr| { &m.key },
                |m: &mut UnitLaborAttr| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &UnitLaborAttr| { &m.caption },
                |m: &mut UnitLaborAttr| { &mut m.caption },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitLaborAttr>(
                "UnitLaborAttr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitLaborAttr {
        static instance: ::protobuf::rt::LazyV2<UnitLaborAttr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitLaborAttr::new)
    }
}

impl ::protobuf::Clear for UnitLaborAttr {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key.clear();
        self.caption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitLaborAttr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitLaborAttr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NameInfo {
    // message fields
    first_name: ::protobuf::SingularField<::std::string::String>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    language_id: ::std::option::Option<i32>,
    last_name: ::protobuf::SingularField<::std::string::String>,
    english_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NameInfo {
    fn default() -> &'a NameInfo {
        <NameInfo as ::protobuf::Message>::default_instance()
    }
}

impl NameInfo {
    pub fn new() -> NameInfo {
        ::std::default::Default::default()
    }

    // optional string first_name = 1;


    pub fn get_first_name(&self) -> &str {
        match self.first_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_first_name(&mut self) {
        self.first_name.clear();
    }

    pub fn has_first_name(&self) -> bool {
        self.first_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        if self.first_name.is_none() {
            self.first_name.set_default();
        }
        self.first_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        self.first_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language_id = 3;


    pub fn get_language_id(&self) -> i32 {
        self.language_id.unwrap_or(-1i32)
    }
    pub fn clear_language_id(&mut self) {
        self.language_id = ::std::option::Option::None;
    }

    pub fn has_language_id(&self) -> bool {
        self.language_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_id(&mut self, v: i32) {
        self.language_id = ::std::option::Option::Some(v);
    }

    // optional string last_name = 4;


    pub fn get_last_name(&self) -> &str {
        match self.last_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_last_name(&mut self) {
        self.last_name.clear();
    }

    pub fn has_last_name(&self) -> bool {
        self.last_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        if self.last_name.is_none() {
            self.last_name.set_default();
        }
        self.last_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        self.last_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string english_name = 5;


    pub fn get_english_name(&self) -> &str {
        match self.english_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_english_name(&mut self) {
        self.english_name.clear();
    }

    pub fn has_english_name(&self) -> bool {
        self.english_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_english_name(&mut self, v: ::std::string::String) {
        self.english_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_english_name(&mut self) -> &mut ::std::string::String {
        if self.english_name.is_none() {
            self.english_name.set_default();
        }
        self.english_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_english_name(&mut self) -> ::std::string::String {
        self.english_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.first_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.english_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.first_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.last_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.english_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.first_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.language_id {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.last_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.english_name.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NameInfo {
        NameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "first_name",
                |m: &NameInfo| { &m.first_name },
                |m: &mut NameInfo| { &mut m.first_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &NameInfo| { &m.nickname },
                |m: &mut NameInfo| { &mut m.nickname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language_id",
                |m: &NameInfo| { &m.language_id },
                |m: &mut NameInfo| { &mut m.language_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_name",
                |m: &NameInfo| { &m.last_name },
                |m: &mut NameInfo| { &mut m.last_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "english_name",
                |m: &NameInfo| { &m.english_name },
                |m: &mut NameInfo| { &mut m.english_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NameInfo>(
                "NameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NameInfo {
        static instance: ::protobuf::rt::LazyV2<NameInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NameInfo::new)
    }
}

impl ::protobuf::Clear for NameInfo {
    fn clear(&mut self) {
        self.first_name.clear();
        self.nickname.clear();
        self.language_id = ::std::option::Option::None;
        self.last_name.clear();
        self.english_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NameTriple {
    // message fields
    normal: ::protobuf::SingularField<::std::string::String>,
    plural: ::protobuf::SingularField<::std::string::String>,
    adjective: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NameTriple {
    fn default() -> &'a NameTriple {
        <NameTriple as ::protobuf::Message>::default_instance()
    }
}

impl NameTriple {
    pub fn new() -> NameTriple {
        ::std::default::Default::default()
    }

    // required string normal = 1;


    pub fn get_normal(&self) -> &str {
        match self.normal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_normal(&mut self) {
        self.normal.clear();
    }

    pub fn has_normal(&self) -> bool {
        self.normal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal(&mut self, v: ::std::string::String) {
        self.normal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normal(&mut self) -> &mut ::std::string::String {
        if self.normal.is_none() {
            self.normal.set_default();
        }
        self.normal.as_mut().unwrap()
    }

    // Take field
    pub fn take_normal(&mut self) -> ::std::string::String {
        self.normal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string plural = 2;


    pub fn get_plural(&self) -> &str {
        match self.plural.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_plural(&mut self) {
        self.plural.clear();
    }

    pub fn has_plural(&self) -> bool {
        self.plural.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plural(&mut self, v: ::std::string::String) {
        self.plural = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plural(&mut self) -> &mut ::std::string::String {
        if self.plural.is_none() {
            self.plural.set_default();
        }
        self.plural.as_mut().unwrap()
    }

    // Take field
    pub fn take_plural(&mut self) -> ::std::string::String {
        self.plural.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string adjective = 3;


    pub fn get_adjective(&self) -> &str {
        match self.adjective.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_adjective(&mut self) {
        self.adjective.clear();
    }

    pub fn has_adjective(&self) -> bool {
        self.adjective.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjective(&mut self, v: ::std::string::String) {
        self.adjective = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjective(&mut self) -> &mut ::std::string::String {
        if self.adjective.is_none() {
            self.adjective.set_default();
        }
        self.adjective.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjective(&mut self) -> ::std::string::String {
        self.adjective.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NameTriple {
    fn is_initialized(&self) -> bool {
        if self.normal.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.normal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.plural)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.adjective)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.normal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.plural.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.adjective.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.normal.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.plural.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.adjective.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NameTriple {
        NameTriple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "normal",
                |m: &NameTriple| { &m.normal },
                |m: &mut NameTriple| { &mut m.normal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plural",
                |m: &NameTriple| { &m.plural },
                |m: &mut NameTriple| { &mut m.plural },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "adjective",
                |m: &NameTriple| { &m.adjective },
                |m: &mut NameTriple| { &mut m.adjective },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NameTriple>(
                "NameTriple",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NameTriple {
        static instance: ::protobuf::rt::LazyV2<NameTriple> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NameTriple::new)
    }
}

impl ::protobuf::Clear for NameTriple {
    fn clear(&mut self) {
        self.normal.clear();
        self.plural.clear();
        self.adjective.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NameTriple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameTriple {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitCurseInfo {
    // message fields
    add_tags1: ::std::option::Option<u32>,
    rem_tags1: ::std::option::Option<u32>,
    add_tags2: ::std::option::Option<u32>,
    rem_tags2: ::std::option::Option<u32>,
    pub name: ::protobuf::SingularPtrField<NameTriple>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitCurseInfo {
    fn default() -> &'a UnitCurseInfo {
        <UnitCurseInfo as ::protobuf::Message>::default_instance()
    }
}

impl UnitCurseInfo {
    pub fn new() -> UnitCurseInfo {
        ::std::default::Default::default()
    }

    // required fixed32 add_tags1 = 1;


    pub fn get_add_tags1(&self) -> u32 {
        self.add_tags1.unwrap_or(0)
    }
    pub fn clear_add_tags1(&mut self) {
        self.add_tags1 = ::std::option::Option::None;
    }

    pub fn has_add_tags1(&self) -> bool {
        self.add_tags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_tags1(&mut self, v: u32) {
        self.add_tags1 = ::std::option::Option::Some(v);
    }

    // required fixed32 rem_tags1 = 2;


    pub fn get_rem_tags1(&self) -> u32 {
        self.rem_tags1.unwrap_or(0)
    }
    pub fn clear_rem_tags1(&mut self) {
        self.rem_tags1 = ::std::option::Option::None;
    }

    pub fn has_rem_tags1(&self) -> bool {
        self.rem_tags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rem_tags1(&mut self, v: u32) {
        self.rem_tags1 = ::std::option::Option::Some(v);
    }

    // required fixed32 add_tags2 = 3;


    pub fn get_add_tags2(&self) -> u32 {
        self.add_tags2.unwrap_or(0)
    }
    pub fn clear_add_tags2(&mut self) {
        self.add_tags2 = ::std::option::Option::None;
    }

    pub fn has_add_tags2(&self) -> bool {
        self.add_tags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_tags2(&mut self, v: u32) {
        self.add_tags2 = ::std::option::Option::Some(v);
    }

    // required fixed32 rem_tags2 = 4;


    pub fn get_rem_tags2(&self) -> u32 {
        self.rem_tags2.unwrap_or(0)
    }
    pub fn clear_rem_tags2(&mut self) {
        self.rem_tags2 = ::std::option::Option::None;
    }

    pub fn has_rem_tags2(&self) -> bool {
        self.rem_tags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rem_tags2(&mut self, v: u32) {
        self.rem_tags2 = ::std::option::Option::Some(v);
    }

    // optional .dfproto.NameTriple name = 5;


    pub fn get_name(&self) -> &NameTriple {
        self.name.as_ref().unwrap_or_else(|| <NameTriple as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: NameTriple) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut NameTriple {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> NameTriple {
        self.name.take().unwrap_or_else(|| NameTriple::new())
    }
}

impl ::protobuf::Message for UnitCurseInfo {
    fn is_initialized(&self) -> bool {
        if self.add_tags1.is_none() {
            return false;
        }
        if self.rem_tags1.is_none() {
            return false;
        }
        if self.add_tags2.is_none() {
            return false;
        }
        if self.rem_tags2.is_none() {
            return false;
        }
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.add_tags1 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rem_tags1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.add_tags2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rem_tags2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.add_tags1 {
            my_size += 5;
        }
        if let Some(v) = self.rem_tags1 {
            my_size += 5;
        }
        if let Some(v) = self.add_tags2 {
            my_size += 5;
        }
        if let Some(v) = self.rem_tags2 {
            my_size += 5;
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.add_tags1 {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.rem_tags1 {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.add_tags2 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.rem_tags2 {
            os.write_fixed32(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitCurseInfo {
        UnitCurseInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "add_tags1",
                |m: &UnitCurseInfo| { &m.add_tags1 },
                |m: &mut UnitCurseInfo| { &mut m.add_tags1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rem_tags1",
                |m: &UnitCurseInfo| { &m.rem_tags1 },
                |m: &mut UnitCurseInfo| { &mut m.rem_tags1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "add_tags2",
                |m: &UnitCurseInfo| { &m.add_tags2 },
                |m: &mut UnitCurseInfo| { &mut m.add_tags2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rem_tags2",
                |m: &UnitCurseInfo| { &m.rem_tags2 },
                |m: &mut UnitCurseInfo| { &mut m.rem_tags2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NameTriple>>(
                "name",
                |m: &UnitCurseInfo| { &m.name },
                |m: &mut UnitCurseInfo| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitCurseInfo>(
                "UnitCurseInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitCurseInfo {
        static instance: ::protobuf::rt::LazyV2<UnitCurseInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitCurseInfo::new)
    }
}

impl ::protobuf::Clear for UnitCurseInfo {
    fn clear(&mut self) {
        self.add_tags1 = ::std::option::Option::None;
        self.rem_tags1 = ::std::option::Option::None;
        self.add_tags2 = ::std::option::Option::None;
        self.rem_tags2 = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitCurseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitCurseInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SkillInfo {
    // message fields
    id: ::std::option::Option<i32>,
    level: ::std::option::Option<i32>,
    experience: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SkillInfo {
    fn default() -> &'a SkillInfo {
        <SkillInfo as ::protobuf::Message>::default_instance()
    }
}

impl SkillInfo {
    pub fn new() -> SkillInfo {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required int32 level = 2;


    pub fn get_level(&self) -> i32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = ::std::option::Option::Some(v);
    }

    // required int32 experience = 3;


    pub fn get_experience(&self) -> i32 {
        self.experience.unwrap_or(0)
    }
    pub fn clear_experience(&mut self) {
        self.experience = ::std::option::Option::None;
    }

    pub fn has_experience(&self) -> bool {
        self.experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience(&mut self, v: i32) {
        self.experience = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SkillInfo {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.level.is_none() {
            return false;
        }
        if self.experience.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.experience = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.experience {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.level {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.experience {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SkillInfo {
        SkillInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &SkillInfo| { &m.id },
                |m: &mut SkillInfo| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "level",
                |m: &SkillInfo| { &m.level },
                |m: &mut SkillInfo| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "experience",
                |m: &SkillInfo| { &m.experience },
                |m: &mut SkillInfo| { &mut m.experience },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SkillInfo>(
                "SkillInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SkillInfo {
        static instance: ::protobuf::rt::LazyV2<SkillInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SkillInfo::new)
    }
}

impl ::protobuf::Clear for SkillInfo {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.experience = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SkillInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SkillInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitMiscTrait {
    // message fields
    id: ::std::option::Option<i32>,
    value: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitMiscTrait {
    fn default() -> &'a UnitMiscTrait {
        <UnitMiscTrait as ::protobuf::Message>::default_instance()
    }
}

impl UnitMiscTrait {
    pub fn new() -> UnitMiscTrait {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required int32 value = 2;


    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnitMiscTrait {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitMiscTrait {
        UnitMiscTrait::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &UnitMiscTrait| { &m.id },
                |m: &mut UnitMiscTrait| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &UnitMiscTrait| { &m.value },
                |m: &mut UnitMiscTrait| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitMiscTrait>(
                "UnitMiscTrait",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitMiscTrait {
        static instance: ::protobuf::rt::LazyV2<UnitMiscTrait> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitMiscTrait::new)
    }
}

impl ::protobuf::Clear for UnitMiscTrait {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitMiscTrait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitMiscTrait {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicUnitInfo {
    // message fields
    unit_id: ::std::option::Option<i32>,
    pos_x: ::std::option::Option<i32>,
    pos_y: ::std::option::Option<i32>,
    pos_z: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularPtrField<NameInfo>,
    flags1: ::std::option::Option<u32>,
    flags2: ::std::option::Option<u32>,
    flags3: ::std::option::Option<u32>,
    race: ::std::option::Option<i32>,
    caste: ::std::option::Option<i32>,
    gender: ::std::option::Option<i32>,
    civ_id: ::std::option::Option<i32>,
    histfig_id: ::std::option::Option<i32>,
    death_id: ::std::option::Option<i32>,
    death_flags: ::std::option::Option<u32>,
    squad_id: ::std::option::Option<i32>,
    squad_position: ::std::option::Option<i32>,
    profession: ::std::option::Option<i32>,
    custom_profession: ::protobuf::SingularField<::std::string::String>,
    pub labors: ::std::vec::Vec<i32>,
    pub skills: ::protobuf::RepeatedField<SkillInfo>,
    pub misc_traits: ::protobuf::RepeatedField<UnitMiscTrait>,
    pub curse: ::protobuf::SingularPtrField<UnitCurseInfo>,
    pub burrows: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicUnitInfo {
    fn default() -> &'a BasicUnitInfo {
        <BasicUnitInfo as ::protobuf::Message>::default_instance()
    }
}

impl BasicUnitInfo {
    pub fn new() -> BasicUnitInfo {
        ::std::default::Default::default()
    }

    // required int32 unit_id = 1;


    pub fn get_unit_id(&self) -> i32 {
        self.unit_id.unwrap_or(0)
    }
    pub fn clear_unit_id(&mut self) {
        self.unit_id = ::std::option::Option::None;
    }

    pub fn has_unit_id(&self) -> bool {
        self.unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_id(&mut self, v: i32) {
        self.unit_id = ::std::option::Option::Some(v);
    }

    // required int32 pos_x = 13;


    pub fn get_pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // required int32 pos_y = 14;


    pub fn get_pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // required int32 pos_z = 15;


    pub fn get_pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional .dfproto.NameInfo name = 2;


    pub fn get_name(&self) -> &NameInfo {
        self.name.as_ref().unwrap_or_else(|| <NameInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: NameInfo) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut NameInfo {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> NameInfo {
        self.name.take().unwrap_or_else(|| NameInfo::new())
    }

    // required fixed32 flags1 = 3;


    pub fn get_flags1(&self) -> u32 {
        self.flags1.unwrap_or(0)
    }
    pub fn clear_flags1(&mut self) {
        self.flags1 = ::std::option::Option::None;
    }

    pub fn has_flags1(&self) -> bool {
        self.flags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags1(&mut self, v: u32) {
        self.flags1 = ::std::option::Option::Some(v);
    }

    // required fixed32 flags2 = 4;


    pub fn get_flags2(&self) -> u32 {
        self.flags2.unwrap_or(0)
    }
    pub fn clear_flags2(&mut self) {
        self.flags2 = ::std::option::Option::None;
    }

    pub fn has_flags2(&self) -> bool {
        self.flags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags2(&mut self, v: u32) {
        self.flags2 = ::std::option::Option::Some(v);
    }

    // required fixed32 flags3 = 5;


    pub fn get_flags3(&self) -> u32 {
        self.flags3.unwrap_or(0)
    }
    pub fn clear_flags3(&mut self) {
        self.flags3 = ::std::option::Option::None;
    }

    pub fn has_flags3(&self) -> bool {
        self.flags3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags3(&mut self, v: u32) {
        self.flags3 = ::std::option::Option::Some(v);
    }

    // required int32 race = 6;


    pub fn get_race(&self) -> i32 {
        self.race.unwrap_or(0)
    }
    pub fn clear_race(&mut self) {
        self.race = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        self.race.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: i32) {
        self.race = ::std::option::Option::Some(v);
    }

    // required int32 caste = 7;


    pub fn get_caste(&self) -> i32 {
        self.caste.unwrap_or(0)
    }
    pub fn clear_caste(&mut self) {
        self.caste = ::std::option::Option::None;
    }

    pub fn has_caste(&self) -> bool {
        self.caste.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caste(&mut self, v: i32) {
        self.caste = ::std::option::Option::Some(v);
    }

    // optional int32 gender = 8;


    pub fn get_gender(&self) -> i32 {
        self.gender.unwrap_or(-1i32)
    }
    pub fn clear_gender(&mut self) {
        self.gender = ::std::option::Option::None;
    }

    pub fn has_gender(&self) -> bool {
        self.gender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: i32) {
        self.gender = ::std::option::Option::Some(v);
    }

    // optional int32 civ_id = 9;


    pub fn get_civ_id(&self) -> i32 {
        self.civ_id.unwrap_or(-1i32)
    }
    pub fn clear_civ_id(&mut self) {
        self.civ_id = ::std::option::Option::None;
    }

    pub fn has_civ_id(&self) -> bool {
        self.civ_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_civ_id(&mut self, v: i32) {
        self.civ_id = ::std::option::Option::Some(v);
    }

    // optional int32 histfig_id = 10;


    pub fn get_histfig_id(&self) -> i32 {
        self.histfig_id.unwrap_or(-1i32)
    }
    pub fn clear_histfig_id(&mut self) {
        self.histfig_id = ::std::option::Option::None;
    }

    pub fn has_histfig_id(&self) -> bool {
        self.histfig_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_histfig_id(&mut self, v: i32) {
        self.histfig_id = ::std::option::Option::Some(v);
    }

    // optional int32 death_id = 17;


    pub fn get_death_id(&self) -> i32 {
        self.death_id.unwrap_or(-1i32)
    }
    pub fn clear_death_id(&mut self) {
        self.death_id = ::std::option::Option::None;
    }

    pub fn has_death_id(&self) -> bool {
        self.death_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_id(&mut self, v: i32) {
        self.death_id = ::std::option::Option::Some(v);
    }

    // optional uint32 death_flags = 18;


    pub fn get_death_flags(&self) -> u32 {
        self.death_flags.unwrap_or(0)
    }
    pub fn clear_death_flags(&mut self) {
        self.death_flags = ::std::option::Option::None;
    }

    pub fn has_death_flags(&self) -> bool {
        self.death_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_flags(&mut self, v: u32) {
        self.death_flags = ::std::option::Option::Some(v);
    }

    // optional int32 squad_id = 19;


    pub fn get_squad_id(&self) -> i32 {
        self.squad_id.unwrap_or(-1i32)
    }
    pub fn clear_squad_id(&mut self) {
        self.squad_id = ::std::option::Option::None;
    }

    pub fn has_squad_id(&self) -> bool {
        self.squad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_id(&mut self, v: i32) {
        self.squad_id = ::std::option::Option::Some(v);
    }

    // optional int32 squad_position = 20;


    pub fn get_squad_position(&self) -> i32 {
        self.squad_position.unwrap_or(-1i32)
    }
    pub fn clear_squad_position(&mut self) {
        self.squad_position = ::std::option::Option::None;
    }

    pub fn has_squad_position(&self) -> bool {
        self.squad_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_position(&mut self, v: i32) {
        self.squad_position = ::std::option::Option::Some(v);
    }

    // optional int32 profession = 22;


    pub fn get_profession(&self) -> i32 {
        self.profession.unwrap_or(-1i32)
    }
    pub fn clear_profession(&mut self) {
        self.profession = ::std::option::Option::None;
    }

    pub fn has_profession(&self) -> bool {
        self.profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: i32) {
        self.profession = ::std::option::Option::Some(v);
    }

    // optional string custom_profession = 23;


    pub fn get_custom_profession(&self) -> &str {
        match self.custom_profession.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_custom_profession(&mut self) {
        self.custom_profession.clear();
    }

    pub fn has_custom_profession(&self) -> bool {
        self.custom_profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_profession(&mut self, v: ::std::string::String) {
        self.custom_profession = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_profession(&mut self) -> &mut ::std::string::String {
        if self.custom_profession.is_none() {
            self.custom_profession.set_default();
        }
        self.custom_profession.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_profession(&mut self) -> ::std::string::String {
        self.custom_profession.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int32 labors = 11;


    pub fn get_labors(&self) -> &[i32] {
        &self.labors
    }
    pub fn clear_labors(&mut self) {
        self.labors.clear();
    }

    // Param is passed by value, moved
    pub fn set_labors(&mut self, v: ::std::vec::Vec<i32>) {
        self.labors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labors(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.labors
    }

    // Take field
    pub fn take_labors(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.labors, ::std::vec::Vec::new())
    }

    // repeated .dfproto.SkillInfo skills = 12;


    pub fn get_skills(&self) -> &[SkillInfo] {
        &self.skills
    }
    pub fn clear_skills(&mut self) {
        self.skills.clear();
    }

    // Param is passed by value, moved
    pub fn set_skills(&mut self, v: ::protobuf::RepeatedField<SkillInfo>) {
        self.skills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_skills(&mut self) -> &mut ::protobuf::RepeatedField<SkillInfo> {
        &mut self.skills
    }

    // Take field
    pub fn take_skills(&mut self) -> ::protobuf::RepeatedField<SkillInfo> {
        ::std::mem::replace(&mut self.skills, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.UnitMiscTrait misc_traits = 24;


    pub fn get_misc_traits(&self) -> &[UnitMiscTrait] {
        &self.misc_traits
    }
    pub fn clear_misc_traits(&mut self) {
        self.misc_traits.clear();
    }

    // Param is passed by value, moved
    pub fn set_misc_traits(&mut self, v: ::protobuf::RepeatedField<UnitMiscTrait>) {
        self.misc_traits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_misc_traits(&mut self) -> &mut ::protobuf::RepeatedField<UnitMiscTrait> {
        &mut self.misc_traits
    }

    // Take field
    pub fn take_misc_traits(&mut self) -> ::protobuf::RepeatedField<UnitMiscTrait> {
        ::std::mem::replace(&mut self.misc_traits, ::protobuf::RepeatedField::new())
    }

    // optional .dfproto.UnitCurseInfo curse = 16;


    pub fn get_curse(&self) -> &UnitCurseInfo {
        self.curse.as_ref().unwrap_or_else(|| <UnitCurseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_curse(&mut self) {
        self.curse.clear();
    }

    pub fn has_curse(&self) -> bool {
        self.curse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curse(&mut self, v: UnitCurseInfo) {
        self.curse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_curse(&mut self) -> &mut UnitCurseInfo {
        if self.curse.is_none() {
            self.curse.set_default();
        }
        self.curse.as_mut().unwrap()
    }

    // Take field
    pub fn take_curse(&mut self) -> UnitCurseInfo {
        self.curse.take().unwrap_or_else(|| UnitCurseInfo::new())
    }

    // repeated int32 burrows = 21;


    pub fn get_burrows(&self) -> &[i32] {
        &self.burrows
    }
    pub fn clear_burrows(&mut self) {
        self.burrows.clear();
    }

    // Param is passed by value, moved
    pub fn set_burrows(&mut self, v: ::std::vec::Vec<i32>) {
        self.burrows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_burrows(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.burrows
    }

    // Take field
    pub fn take_burrows(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.burrows, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BasicUnitInfo {
    fn is_initialized(&self) -> bool {
        if self.unit_id.is_none() {
            return false;
        }
        if self.pos_x.is_none() {
            return false;
        }
        if self.pos_y.is_none() {
            return false;
        }
        if self.pos_z.is_none() {
            return false;
        }
        if self.flags1.is_none() {
            return false;
        }
        if self.flags2.is_none() {
            return false;
        }
        if self.flags3.is_none() {
            return false;
        }
        if self.race.is_none() {
            return false;
        }
        if self.caste.is_none() {
            return false;
        }
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.skills {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.misc_traits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.curse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.flags1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.flags2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.flags3 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.race = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.caste = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gender = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.civ_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.histfig_id = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.death_id = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.death_flags = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.squad_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.squad_position = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.profession = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_profession)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.labors)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.skills)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.misc_traits)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.curse)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.burrows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags1 {
            my_size += 5;
        }
        if let Some(v) = self.flags2 {
            my_size += 5;
        }
        if let Some(v) = self.flags3 {
            my_size += 5;
        }
        if let Some(v) = self.race {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caste {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gender {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.civ_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.histfig_id {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death_id {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death_flags {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.squad_id {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.squad_position {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.profession {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.custom_profession.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        for value in &self.labors {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.skills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.misc_traits {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.curse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.burrows {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(15, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags1 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.flags2 {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.flags3 {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.race {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.caste {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.gender {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.civ_id {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.histfig_id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.death_id {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.death_flags {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.squad_id {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.squad_position {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.profession {
            os.write_int32(22, v)?;
        }
        if let Some(ref v) = self.custom_profession.as_ref() {
            os.write_string(23, &v)?;
        }
        for v in &self.labors {
            os.write_int32(11, *v)?;
        };
        for v in &self.skills {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.misc_traits {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.curse.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.burrows {
            os.write_int32(21, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicUnitInfo {
        BasicUnitInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit_id",
                |m: &BasicUnitInfo| { &m.unit_id },
                |m: &mut BasicUnitInfo| { &mut m.unit_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x",
                |m: &BasicUnitInfo| { &m.pos_x },
                |m: &mut BasicUnitInfo| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y",
                |m: &BasicUnitInfo| { &m.pos_y },
                |m: &mut BasicUnitInfo| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_z",
                |m: &BasicUnitInfo| { &m.pos_z },
                |m: &mut BasicUnitInfo| { &mut m.pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NameInfo>>(
                "name",
                |m: &BasicUnitInfo| { &m.name },
                |m: &mut BasicUnitInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "flags1",
                |m: &BasicUnitInfo| { &m.flags1 },
                |m: &mut BasicUnitInfo| { &mut m.flags1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "flags2",
                |m: &BasicUnitInfo| { &m.flags2 },
                |m: &mut BasicUnitInfo| { &mut m.flags2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "flags3",
                |m: &BasicUnitInfo| { &m.flags3 },
                |m: &mut BasicUnitInfo| { &mut m.flags3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "race",
                |m: &BasicUnitInfo| { &m.race },
                |m: &mut BasicUnitInfo| { &mut m.race },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "caste",
                |m: &BasicUnitInfo| { &m.caste },
                |m: &mut BasicUnitInfo| { &mut m.caste },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gender",
                |m: &BasicUnitInfo| { &m.gender },
                |m: &mut BasicUnitInfo| { &mut m.gender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "civ_id",
                |m: &BasicUnitInfo| { &m.civ_id },
                |m: &mut BasicUnitInfo| { &mut m.civ_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "histfig_id",
                |m: &BasicUnitInfo| { &m.histfig_id },
                |m: &mut BasicUnitInfo| { &mut m.histfig_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "death_id",
                |m: &BasicUnitInfo| { &m.death_id },
                |m: &mut BasicUnitInfo| { &mut m.death_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "death_flags",
                |m: &BasicUnitInfo| { &m.death_flags },
                |m: &mut BasicUnitInfo| { &mut m.death_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "squad_id",
                |m: &BasicUnitInfo| { &m.squad_id },
                |m: &mut BasicUnitInfo| { &mut m.squad_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "squad_position",
                |m: &BasicUnitInfo| { &m.squad_position },
                |m: &mut BasicUnitInfo| { &mut m.squad_position },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "profession",
                |m: &BasicUnitInfo| { &m.profession },
                |m: &mut BasicUnitInfo| { &mut m.profession },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_profession",
                |m: &BasicUnitInfo| { &m.custom_profession },
                |m: &mut BasicUnitInfo| { &mut m.custom_profession },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "labors",
                |m: &BasicUnitInfo| { &m.labors },
                |m: &mut BasicUnitInfo| { &mut m.labors },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SkillInfo>>(
                "skills",
                |m: &BasicUnitInfo| { &m.skills },
                |m: &mut BasicUnitInfo| { &mut m.skills },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitMiscTrait>>(
                "misc_traits",
                |m: &BasicUnitInfo| { &m.misc_traits },
                |m: &mut BasicUnitInfo| { &mut m.misc_traits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitCurseInfo>>(
                "curse",
                |m: &BasicUnitInfo| { &m.curse },
                |m: &mut BasicUnitInfo| { &mut m.curse },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "burrows",
                |m: &BasicUnitInfo| { &m.burrows },
                |m: &mut BasicUnitInfo| { &mut m.burrows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicUnitInfo>(
                "BasicUnitInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicUnitInfo {
        static instance: ::protobuf::rt::LazyV2<BasicUnitInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicUnitInfo::new)
    }
}

impl ::protobuf::Clear for BasicUnitInfo {
    fn clear(&mut self) {
        self.unit_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.name.clear();
        self.flags1 = ::std::option::Option::None;
        self.flags2 = ::std::option::Option::None;
        self.flags3 = ::std::option::Option::None;
        self.race = ::std::option::Option::None;
        self.caste = ::std::option::Option::None;
        self.gender = ::std::option::Option::None;
        self.civ_id = ::std::option::Option::None;
        self.histfig_id = ::std::option::Option::None;
        self.death_id = ::std::option::Option::None;
        self.death_flags = ::std::option::Option::None;
        self.squad_id = ::std::option::Option::None;
        self.squad_position = ::std::option::Option::None;
        self.profession = ::std::option::Option::None;
        self.custom_profession.clear();
        self.labors.clear();
        self.skills.clear();
        self.misc_traits.clear();
        self.curse.clear();
        self.burrows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicUnitInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicUnitInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicUnitInfoMask {
    // message fields
    labors: ::std::option::Option<bool>,
    skills: ::std::option::Option<bool>,
    profession: ::std::option::Option<bool>,
    misc_traits: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicUnitInfoMask {
    fn default() -> &'a BasicUnitInfoMask {
        <BasicUnitInfoMask as ::protobuf::Message>::default_instance()
    }
}

impl BasicUnitInfoMask {
    pub fn new() -> BasicUnitInfoMask {
        ::std::default::Default::default()
    }

    // optional bool labors = 1;


    pub fn get_labors(&self) -> bool {
        self.labors.unwrap_or(false)
    }
    pub fn clear_labors(&mut self) {
        self.labors = ::std::option::Option::None;
    }

    pub fn has_labors(&self) -> bool {
        self.labors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labors(&mut self, v: bool) {
        self.labors = ::std::option::Option::Some(v);
    }

    // optional bool skills = 2;


    pub fn get_skills(&self) -> bool {
        self.skills.unwrap_or(false)
    }
    pub fn clear_skills(&mut self) {
        self.skills = ::std::option::Option::None;
    }

    pub fn has_skills(&self) -> bool {
        self.skills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skills(&mut self, v: bool) {
        self.skills = ::std::option::Option::Some(v);
    }

    // optional bool profession = 3;


    pub fn get_profession(&self) -> bool {
        self.profession.unwrap_or(false)
    }
    pub fn clear_profession(&mut self) {
        self.profession = ::std::option::Option::None;
    }

    pub fn has_profession(&self) -> bool {
        self.profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: bool) {
        self.profession = ::std::option::Option::Some(v);
    }

    // optional bool misc_traits = 4;


    pub fn get_misc_traits(&self) -> bool {
        self.misc_traits.unwrap_or(false)
    }
    pub fn clear_misc_traits(&mut self) {
        self.misc_traits = ::std::option::Option::None;
    }

    pub fn has_misc_traits(&self) -> bool {
        self.misc_traits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_misc_traits(&mut self, v: bool) {
        self.misc_traits = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BasicUnitInfoMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.labors = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.profession = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.misc_traits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.labors {
            my_size += 2;
        }
        if let Some(v) = self.skills {
            my_size += 2;
        }
        if let Some(v) = self.profession {
            my_size += 2;
        }
        if let Some(v) = self.misc_traits {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.labors {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.skills {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.profession {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.misc_traits {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicUnitInfoMask {
        BasicUnitInfoMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "labors",
                |m: &BasicUnitInfoMask| { &m.labors },
                |m: &mut BasicUnitInfoMask| { &mut m.labors },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skills",
                |m: &BasicUnitInfoMask| { &m.skills },
                |m: &mut BasicUnitInfoMask| { &mut m.skills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "profession",
                |m: &BasicUnitInfoMask| { &m.profession },
                |m: &mut BasicUnitInfoMask| { &mut m.profession },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "misc_traits",
                |m: &BasicUnitInfoMask| { &m.misc_traits },
                |m: &mut BasicUnitInfoMask| { &mut m.misc_traits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicUnitInfoMask>(
                "BasicUnitInfoMask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicUnitInfoMask {
        static instance: ::protobuf::rt::LazyV2<BasicUnitInfoMask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicUnitInfoMask::new)
    }
}

impl ::protobuf::Clear for BasicUnitInfoMask {
    fn clear(&mut self) {
        self.labors = ::std::option::Option::None;
        self.skills = ::std::option::Option::None;
        self.profession = ::std::option::Option::None;
        self.misc_traits = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicUnitInfoMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicUnitInfoMask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicSquadInfo {
    // message fields
    squad_id: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularPtrField<NameInfo>,
    alias: ::protobuf::SingularField<::std::string::String>,
    pub members: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicSquadInfo {
    fn default() -> &'a BasicSquadInfo {
        <BasicSquadInfo as ::protobuf::Message>::default_instance()
    }
}

impl BasicSquadInfo {
    pub fn new() -> BasicSquadInfo {
        ::std::default::Default::default()
    }

    // required int32 squad_id = 1;


    pub fn get_squad_id(&self) -> i32 {
        self.squad_id.unwrap_or(0)
    }
    pub fn clear_squad_id(&mut self) {
        self.squad_id = ::std::option::Option::None;
    }

    pub fn has_squad_id(&self) -> bool {
        self.squad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_id(&mut self, v: i32) {
        self.squad_id = ::std::option::Option::Some(v);
    }

    // optional .dfproto.NameInfo name = 2;


    pub fn get_name(&self) -> &NameInfo {
        self.name.as_ref().unwrap_or_else(|| <NameInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: NameInfo) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut NameInfo {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> NameInfo {
        self.name.take().unwrap_or_else(|| NameInfo::new())
    }

    // optional string alias = 3;


    pub fn get_alias(&self) -> &str {
        match self.alias.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    pub fn has_alias(&self) -> bool {
        self.alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        if self.alias.is_none() {
            self.alias.set_default();
        }
        self.alias.as_mut().unwrap()
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        self.alias.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated sint32 members = 4;


    pub fn get_members(&self) -> &[i32] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::std::vec::Vec<i32>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.members, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BasicSquadInfo {
    fn is_initialized(&self) -> bool {
        if self.squad_id.is_none() {
            return false;
        }
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.squad_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.squad_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.alias.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.members {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.squad_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.alias.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.members {
            os.write_sint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicSquadInfo {
        BasicSquadInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "squad_id",
                |m: &BasicSquadInfo| { &m.squad_id },
                |m: &mut BasicSquadInfo| { &mut m.squad_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NameInfo>>(
                "name",
                |m: &BasicSquadInfo| { &m.name },
                |m: &mut BasicSquadInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alias",
                |m: &BasicSquadInfo| { &m.alias },
                |m: &mut BasicSquadInfo| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "members",
                |m: &BasicSquadInfo| { &m.members },
                |m: &mut BasicSquadInfo| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicSquadInfo>(
                "BasicSquadInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicSquadInfo {
        static instance: ::protobuf::rt::LazyV2<BasicSquadInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicSquadInfo::new)
    }
}

impl ::protobuf::Clear for BasicSquadInfo {
    fn clear(&mut self) {
        self.squad_id = ::std::option::Option::None;
        self.name.clear();
        self.alias.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicSquadInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicSquadInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitLaborState {
    // message fields
    unit_id: ::std::option::Option<i32>,
    labor: ::std::option::Option<i32>,
    value: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitLaborState {
    fn default() -> &'a UnitLaborState {
        <UnitLaborState as ::protobuf::Message>::default_instance()
    }
}

impl UnitLaborState {
    pub fn new() -> UnitLaborState {
        ::std::default::Default::default()
    }

    // required int32 unit_id = 1;


    pub fn get_unit_id(&self) -> i32 {
        self.unit_id.unwrap_or(0)
    }
    pub fn clear_unit_id(&mut self) {
        self.unit_id = ::std::option::Option::None;
    }

    pub fn has_unit_id(&self) -> bool {
        self.unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_id(&mut self, v: i32) {
        self.unit_id = ::std::option::Option::Some(v);
    }

    // required int32 labor = 2;


    pub fn get_labor(&self) -> i32 {
        self.labor.unwrap_or(0)
    }
    pub fn clear_labor(&mut self) {
        self.labor = ::std::option::Option::None;
    }

    pub fn has_labor(&self) -> bool {
        self.labor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labor(&mut self, v: i32) {
        self.labor = ::std::option::Option::Some(v);
    }

    // required bool value = 3;


    pub fn get_value(&self) -> bool {
        self.value.unwrap_or(false)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnitLaborState {
    fn is_initialized(&self) -> bool {
        if self.unit_id.is_none() {
            return false;
        }
        if self.labor.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.labor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.labor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.labor {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitLaborState {
        UnitLaborState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit_id",
                |m: &UnitLaborState| { &m.unit_id },
                |m: &mut UnitLaborState| { &mut m.unit_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "labor",
                |m: &UnitLaborState| { &m.labor },
                |m: &mut UnitLaborState| { &mut m.labor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "value",
                |m: &UnitLaborState| { &m.value },
                |m: &mut UnitLaborState| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitLaborState>(
                "UnitLaborState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitLaborState {
        static instance: ::protobuf::rt::LazyV2<UnitLaborState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitLaborState::new)
    }
}

impl ::protobuf::Clear for UnitLaborState {
    fn clear(&mut self) {
        self.unit_id = ::std::option::Option::None;
        self.labor = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitLaborState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitLaborState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bBasic.proto\x12\x07dfproto\"^\n\x0cEnumItemName\x12\x16\n\x05value\
    \x18\x01\x20\x02(\x05R\x05valueB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\
    \x04nameB\0\x12\x1e\n\x08bit_size\x18\x03\x20\x01(\x05:\x011R\x07bitSize\
    B\0:\0\"A\n\x0fBasicMaterialId\x12\x14\n\x04type\x18\x01\x20\x02(\x05R\
    \x04typeB\0\x12\x16\n\x05index\x18\x02\x20\x02(\x11R\x05indexB\0:\0\"\
    \xfa\x04\n\x11BasicMaterialInfo\x12\x14\n\x04type\x18\x01\x20\x02(\x05R\
    \x04typeB\0\x12\x16\n\x05index\x18\x02\x20\x02(\x11R\x05indexB\0\x12\x16\
    \n\x05token\x18\x03\x20\x02(\tR\x05tokenB\0\x12\x16\n\x05flags\x18\x04\
    \x20\x03(\x05R\x05flagsB\0\x12\x1e\n\x07subtype\x18\x05\x20\x01(\x05:\
    \x02-1R\x07subtypeB\0\x12%\n\x0bcreature_id\x18\x06\x20\x01(\x05:\x02-1R\
    \ncreatureIdB\0\x12\x1f\n\x08plant_id\x18\x07\x20\x01(\x05:\x02-1R\x07pl\
    antIdB\0\x12#\n\nhistfig_id\x18\x08\x20\x01(\x05:\x02-1R\thistfigIdB\0\
    \x12#\n\x0bname_prefix\x18\t\x20\x01(\t:\0R\nnamePrefixB\0\x12!\n\x0bsta\
    te_color\x18\n\x20\x03(\x07R\nstateColorB\0\x12\x1f\n\nstate_name\x18\
    \x0b\x20\x03(\tR\tstateNameB\0\x12\x1d\n\tstate_adj\x18\x0c\x20\x03(\tR\
    \x08stateAdjB\0\x12'\n\x0ereaction_class\x18\r\x20\x03(\tR\rreactionClas\
    sB\0\x12O\n\x10reaction_product\x18\x0e\x20\x03(\x0b2\".dfproto.BasicMat\
    erialInfo.ProductR\x0freactionProductB\0\x12)\n\x0finorganic_flags\x18\
    \x0f\x20\x03(\x05R\x0einorganicFlagsB\0\x1aK\n\x07Product\x12\x10\n\x02i\
    d\x18\x01\x20\x02(\tR\x02idB\0\x12\x14\n\x04type\x18\x02\x20\x02(\x05R\
    \x04typeB\0\x12\x16\n\x05index\x18\x03\x20\x02(\x11R\x05indexB\0:\0:\0\"\
    \x9f\x02\n\x15BasicMaterialInfoMask\x12B\n\x06states\x18\x01\x20\x03(\
    \x0e2(.dfproto.BasicMaterialInfoMask.StateTypeR\x06statesB\0\x12)\n\x0bt\
    emperature\x18\x04\x20\x01(\x05:\x0510015R\x0btemperatureB\0\x12\x1d\n\
    \x05flags\x18\x02\x20\x01(\x08:\x05falseR\x05flagsB\0\x12#\n\x08reaction\
    \x18\x03\x20\x01(\x08:\x05falseR\x08reactionB\0\"Q\n\tStateType\x12\t\n\
    \x05Solid\x10\0\x12\n\n\x06Liquid\x10\x01\x12\x07\n\x03Gas\x10\x02\x12\n\
    \n\x06Powder\x10\x03\x12\t\n\x05Paste\x10\x04\x12\x0b\n\x07Pressed\x10\
    \x05\x1a\0:\0\"\xc7\x01\n\x0cJobSkillAttr\x12\x10\n\x02id\x18\x01\x20\
    \x02(\x05R\x02idB\0\x12\x12\n\x03key\x18\x02\x20\x02(\tR\x03keyB\0\x12\
    \x1a\n\x07caption\x18\x03\x20\x01(\tR\x07captionB\0\x12#\n\x0ccaption_no\
    un\x18\x04\x20\x01(\tR\x0bcaptionNounB\0\x12\x20\n\nprofession\x18\x05\
    \x20\x01(\x05R\nprofessionB\0\x12\x16\n\x05labor\x18\x06\x20\x01(\x05R\
    \x05laborB\0\x12\x14\n\x04type\x18\x07\x20\x01(\tR\x04typeB\0:\0\"\xb8\
    \x01\n\x0eProfessionAttr\x12\x10\n\x02id\x18\x01\x20\x02(\x05R\x02idB\0\
    \x12\x12\n\x03key\x18\x02\x20\x02(\tR\x03keyB\0\x12\x1a\n\x07caption\x18\
    \x03\x20\x01(\tR\x07captionB\0\x12\x1c\n\x08military\x18\x04\x20\x01(\
    \x08R\x08militaryB\0\x12*\n\x10can_assign_labor\x18\x05\x20\x01(\x08R\
    \x0ecanAssignLaborB\0\x12\x18\n\x06parent\x18\x06\x20\x01(\x05R\x06paren\
    tB\0:\0\"S\n\rUnitLaborAttr\x12\x10\n\x02id\x18\x01\x20\x02(\x05R\x02idB\
    \0\x12\x12\n\x03key\x18\x02\x20\x02(\tR\x03keyB\0\x12\x1a\n\x07caption\
    \x18\x03\x20\x01(\tR\x07captionB\0:\0\"\xb6\x01\n\x08NameInfo\x12\x1f\n\
    \nfirst_name\x18\x01\x20\x01(\tR\tfirstNameB\0\x12\x1c\n\x08nickname\x18\
    \x02\x20\x01(\tR\x08nicknameB\0\x12%\n\x0blanguage_id\x18\x03\x20\x01(\
    \x05:\x02-1R\nlanguageIdB\0\x12\x1d\n\tlast_name\x18\x04\x20\x01(\tR\x08\
    lastNameB\0\x12#\n\x0cenglish_name\x18\x05\x20\x01(\tR\x0benglishNameB\0\
    :\0\"b\n\nNameTriple\x12\x18\n\x06normal\x18\x01\x20\x02(\tR\x06normalB\
    \0\x12\x18\n\x06plural\x18\x02\x20\x01(\tR\x06pluralB\0\x12\x1e\n\tadjec\
    tive\x18\x03\x20\x01(\tR\tadjectiveB\0:\0\"\xb8\x01\n\rUnitCurseInfo\x12\
    \x1d\n\tadd_tags1\x18\x01\x20\x02(\x07R\x08addTags1B\0\x12\x1d\n\trem_ta\
    gs1\x18\x02\x20\x02(\x07R\x08remTags1B\0\x12\x1d\n\tadd_tags2\x18\x03\
    \x20\x02(\x07R\x08addTags2B\0\x12\x1d\n\trem_tags2\x18\x04\x20\x02(\x07R\
    \x08remTags2B\0\x12)\n\x04name\x18\x05\x20\x01(\x0b2\x13.dfproto.NameTri\
    pleR\x04nameB\0:\0\"Y\n\tSkillInfo\x12\x10\n\x02id\x18\x01\x20\x02(\x05R\
    \x02idB\0\x12\x16\n\x05level\x18\x02\x20\x02(\x05R\x05levelB\0\x12\x20\n\
    \nexperience\x18\x03\x20\x02(\x05R\nexperienceB\0:\0\";\n\rUnitMiscTrait\
    \x12\x10\n\x02id\x18\x01\x20\x02(\x05R\x02idB\0\x12\x16\n\x05value\x18\
    \x02\x20\x02(\x05R\x05valueB\0:\0\"\xac\x06\n\rBasicUnitInfo\x12\x19\n\
    \x07unit_id\x18\x01\x20\x02(\x05R\x06unitIdB\0\x12\x15\n\x05pos_x\x18\r\
    \x20\x02(\x05R\x04posXB\0\x12\x15\n\x05pos_y\x18\x0e\x20\x02(\x05R\x04po\
    sYB\0\x12\x15\n\x05pos_z\x18\x0f\x20\x02(\x05R\x04posZB\0\x12'\n\x04name\
    \x18\x02\x20\x01(\x0b2\x11.dfproto.NameInfoR\x04nameB\0\x12\x18\n\x06fla\
    gs1\x18\x03\x20\x02(\x07R\x06flags1B\0\x12\x18\n\x06flags2\x18\x04\x20\
    \x02(\x07R\x06flags2B\0\x12\x18\n\x06flags3\x18\x05\x20\x02(\x07R\x06fla\
    gs3B\0\x12\x14\n\x04race\x18\x06\x20\x02(\x05R\x04raceB\0\x12\x16\n\x05c\
    aste\x18\x07\x20\x02(\x05R\x05casteB\0\x12\x1c\n\x06gender\x18\x08\x20\
    \x01(\x05:\x02-1R\x06genderB\0\x12\x1b\n\x06civ_id\x18\t\x20\x01(\x05:\
    \x02-1R\x05civIdB\0\x12#\n\nhistfig_id\x18\n\x20\x01(\x05:\x02-1R\thistf\
    igIdB\0\x12\x1f\n\x08death_id\x18\x11\x20\x01(\x05:\x02-1R\x07deathIdB\0\
    \x12!\n\x0bdeath_flags\x18\x12\x20\x01(\rR\ndeathFlagsB\0\x12\x1f\n\x08s\
    quad_id\x18\x13\x20\x01(\x05:\x02-1R\x07squadIdB\0\x12+\n\x0esquad_posit\
    ion\x18\x14\x20\x01(\x05:\x02-1R\rsquadPositionB\0\x12$\n\nprofession\
    \x18\x16\x20\x01(\x05:\x02-1R\nprofessionB\0\x12-\n\x11custom_profession\
    \x18\x17\x20\x01(\tR\x10customProfessionB\0\x12\x18\n\x06labors\x18\x0b\
    \x20\x03(\x05R\x06laborsB\0\x12,\n\x06skills\x18\x0c\x20\x03(\x0b2\x12.d\
    fproto.SkillInfoR\x06skillsB\0\x129\n\x0bmisc_traits\x18\x18\x20\x03(\
    \x0b2\x16.dfproto.UnitMiscTraitR\nmiscTraitsB\0\x12.\n\x05curse\x18\x10\
    \x20\x01(\x0b2\x16.dfproto.UnitCurseInfoR\x05curseB\0\x12\x1a\n\x07burro\
    ws\x18\x15\x20\x03(\x05R\x07burrowsB\0:\0\"\xaa\x01\n\x11BasicUnitInfoMa\
    sk\x12\x1f\n\x06labors\x18\x01\x20\x01(\x08:\x05falseR\x06laborsB\0\x12\
    \x1f\n\x06skills\x18\x02\x20\x01(\x08:\x05falseR\x06skillsB\0\x12'\n\npr\
    ofession\x18\x03\x20\x01(\x08:\x05falseR\nprofessionB\0\x12(\n\x0bmisc_t\
    raits\x18\x04\x20\x01(\x08:\x05falseR\nmiscTraitsB\0:\0\"\x8c\x01\n\x0eB\
    asicSquadInfo\x12\x1b\n\x08squad_id\x18\x01\x20\x02(\x05R\x07squadIdB\0\
    \x12'\n\x04name\x18\x02\x20\x01(\x0b2\x11.dfproto.NameInfoR\x04nameB\0\
    \x12\x16\n\x05alias\x18\x03\x20\x01(\tR\x05aliasB\0\x12\x1a\n\x07members\
    \x18\x04\x20\x03(\x11R\x07membersB\0:\0\"]\n\x0eUnitLaborState\x12\x19\n\
    \x07unit_id\x18\x01\x20\x02(\x05R\x06unitIdB\0\x12\x16\n\x05labor\x18\
    \x02\x20\x02(\x05R\x05laborB\0\x12\x16\n\x05value\x18\x03\x20\x02(\x08R\
    \x05valueB\0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
