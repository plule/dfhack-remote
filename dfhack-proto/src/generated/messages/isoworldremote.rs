// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `isoworldremote.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:isoworldremote.ColorDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ColorDefinition {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.ColorDefinition.red)
    pub red: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.ColorDefinition.green)
    pub green: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.ColorDefinition.blue)
    pub blue: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.ColorDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorDefinition {
    fn default() -> &'a ColorDefinition {
        <ColorDefinition as ::protobuf::Message>::default_instance()
    }
}

impl ColorDefinition {
    pub fn new() -> ColorDefinition {
        ::std::default::Default::default()
    }

    // required int32 red = 1;

    pub fn red(&self) -> i32 {
        self.red.unwrap_or(0)
    }

    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: i32) {
        self.red = ::std::option::Option::Some(v);
    }

    // required int32 green = 2;

    pub fn green(&self) -> i32 {
        self.green.unwrap_or(0)
    }

    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: i32) {
        self.green = ::std::option::Option::Some(v);
    }

    // required int32 blue = 3;

    pub fn blue(&self) -> i32 {
        self.blue.unwrap_or(0)
    }

    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: i32) {
        self.blue = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "red",
            |m: &ColorDefinition| { &m.red },
            |m: &mut ColorDefinition| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "green",
            |m: &ColorDefinition| { &m.green },
            |m: &mut ColorDefinition| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blue",
            |m: &ColorDefinition| { &m.blue },
            |m: &mut ColorDefinition| { &mut m.blue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorDefinition>(
            "ColorDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorDefinition {
    const NAME: &'static str = "ColorDefinition";

    fn is_initialized(&self) -> bool {
        if self.red.is_none() {
            return false;
        }
        if self.green.is_none() {
            return false;
        }
        if self.blue.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.red = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.green = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.blue = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.red {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.green {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.blue {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorDefinition {
        ColorDefinition::new()
    }

    fn clear(&mut self) {
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorDefinition {
        static instance: ColorDefinition = ColorDefinition {
            red: ::std::option::Option::None,
            green: ::std::option::Option::None,
            blue: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:isoworldremote.EmbarkTileLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EmbarkTileLayer {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTileLayer.mat_type_table)
    pub mat_type_table: ::std::vec::Vec<::protobuf::EnumOrUnknown<BasicMaterial>>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTileLayer.mat_subtype_table)
    pub mat_subtype_table: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTileLayer.tile_shape_table)
    pub tile_shape_table: ::std::vec::Vec<::protobuf::EnumOrUnknown<BasicShape>>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTileLayer.tile_color_table)
    pub tile_color_table: ::std::vec::Vec<ColorDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.EmbarkTileLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmbarkTileLayer {
    fn default() -> &'a EmbarkTileLayer {
        <EmbarkTileLayer as ::protobuf::Message>::default_instance()
    }
}

impl EmbarkTileLayer {
    pub fn new() -> EmbarkTileLayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mat_type_table",
            |m: &EmbarkTileLayer| { &m.mat_type_table },
            |m: &mut EmbarkTileLayer| { &mut m.mat_type_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mat_subtype_table",
            |m: &EmbarkTileLayer| { &m.mat_subtype_table },
            |m: &mut EmbarkTileLayer| { &mut m.mat_subtype_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tile_shape_table",
            |m: &EmbarkTileLayer| { &m.tile_shape_table },
            |m: &mut EmbarkTileLayer| { &mut m.tile_shape_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tile_color_table",
            |m: &EmbarkTileLayer| { &m.tile_color_table },
            |m: &mut EmbarkTileLayer| { &mut m.tile_color_table },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmbarkTileLayer>(
            "EmbarkTileLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmbarkTileLayer {
    const NAME: &'static str = "EmbarkTileLayer";

    fn is_initialized(&self) -> bool {
        for v in &self.tile_color_table {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.mat_type_table.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.mat_type_table)?
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.mat_subtype_table)?;
                },
                40 => {
                    self.mat_subtype_table.push(is.read_int32()?);
                },
                48 => {
                    self.tile_shape_table.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.tile_shape_table)?
                },
                58 => {
                    self.tile_color_table.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.mat_type_table);
        my_size += ::protobuf::rt::vec_packed_int32_size(5, &self.mat_subtype_table);
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(6, &self.tile_shape_table);
        for value in &self.tile_color_table {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_enum_or_unknown(4, &self.mat_type_table)?;
        os.write_repeated_packed_int32(5, &self.mat_subtype_table)?;
        os.write_repeated_packed_enum_or_unknown(6, &self.tile_shape_table)?;
        for v in &self.tile_color_table {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmbarkTileLayer {
        EmbarkTileLayer::new()
    }

    fn clear(&mut self) {
        self.mat_type_table.clear();
        self.mat_subtype_table.clear();
        self.tile_shape_table.clear();
        self.tile_color_table.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmbarkTileLayer {
        static instance: EmbarkTileLayer = EmbarkTileLayer {
            mat_type_table: ::std::vec::Vec::new(),
            mat_subtype_table: ::std::vec::Vec::new(),
            tile_shape_table: ::std::vec::Vec::new(),
            tile_color_table: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmbarkTileLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmbarkTileLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmbarkTileLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmbarkTileLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:isoworldremote.EmbarkTile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EmbarkTile {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.world_x)
    pub world_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.world_y)
    pub world_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.world_z)
    pub world_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.tile_layer)
    pub tile_layer: ::std::vec::Vec<EmbarkTileLayer>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.current_year)
    pub current_year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.current_season)
    pub current_season: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.EmbarkTile.is_valid)
    pub is_valid: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.EmbarkTile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmbarkTile {
    fn default() -> &'a EmbarkTile {
        <EmbarkTile as ::protobuf::Message>::default_instance()
    }
}

impl EmbarkTile {
    pub fn new() -> EmbarkTile {
        ::std::default::Default::default()
    }

    // required int32 world_x = 1;

    pub fn world_x(&self) -> i32 {
        self.world_x.unwrap_or(0)
    }

    pub fn clear_world_x(&mut self) {
        self.world_x = ::std::option::Option::None;
    }

    pub fn has_world_x(&self) -> bool {
        self.world_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_x(&mut self, v: i32) {
        self.world_x = ::std::option::Option::Some(v);
    }

    // required int32 world_y = 2;

    pub fn world_y(&self) -> i32 {
        self.world_y.unwrap_or(0)
    }

    pub fn clear_world_y(&mut self) {
        self.world_y = ::std::option::Option::None;
    }

    pub fn has_world_y(&self) -> bool {
        self.world_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_y(&mut self, v: i32) {
        self.world_y = ::std::option::Option::Some(v);
    }

    // required sint32 world_z = 3;

    pub fn world_z(&self) -> i32 {
        self.world_z.unwrap_or(0)
    }

    pub fn clear_world_z(&mut self) {
        self.world_z = ::std::option::Option::None;
    }

    pub fn has_world_z(&self) -> bool {
        self.world_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_z(&mut self, v: i32) {
        self.world_z = ::std::option::Option::Some(v);
    }

    // optional int32 current_year = 5;

    pub fn current_year(&self) -> i32 {
        self.current_year.unwrap_or(0)
    }

    pub fn clear_current_year(&mut self) {
        self.current_year = ::std::option::Option::None;
    }

    pub fn has_current_year(&self) -> bool {
        self.current_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_year(&mut self, v: i32) {
        self.current_year = ::std::option::Option::Some(v);
    }

    // optional int32 current_season = 6;

    pub fn current_season(&self) -> i32 {
        self.current_season.unwrap_or(0)
    }

    pub fn clear_current_season(&mut self) {
        self.current_season = ::std::option::Option::None;
    }

    pub fn has_current_season(&self) -> bool {
        self.current_season.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_season(&mut self, v: i32) {
        self.current_season = ::std::option::Option::Some(v);
    }

    // optional bool is_valid = 7;

    pub fn is_valid(&self) -> bool {
        self.is_valid.unwrap_or(false)
    }

    pub fn clear_is_valid(&mut self) {
        self.is_valid = ::std::option::Option::None;
    }

    pub fn has_is_valid(&self) -> bool {
        self.is_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valid(&mut self, v: bool) {
        self.is_valid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_x",
            |m: &EmbarkTile| { &m.world_x },
            |m: &mut EmbarkTile| { &mut m.world_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_y",
            |m: &EmbarkTile| { &m.world_y },
            |m: &mut EmbarkTile| { &mut m.world_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_z",
            |m: &EmbarkTile| { &m.world_z },
            |m: &mut EmbarkTile| { &mut m.world_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tile_layer",
            |m: &EmbarkTile| { &m.tile_layer },
            |m: &mut EmbarkTile| { &mut m.tile_layer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_year",
            |m: &EmbarkTile| { &m.current_year },
            |m: &mut EmbarkTile| { &mut m.current_year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_season",
            |m: &EmbarkTile| { &m.current_season },
            |m: &mut EmbarkTile| { &mut m.current_season },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_valid",
            |m: &EmbarkTile| { &m.is_valid },
            |m: &mut EmbarkTile| { &mut m.is_valid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmbarkTile>(
            "EmbarkTile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmbarkTile {
    const NAME: &'static str = "EmbarkTile";

    fn is_initialized(&self) -> bool {
        if self.world_x.is_none() {
            return false;
        }
        if self.world_y.is_none() {
            return false;
        }
        if self.world_z.is_none() {
            return false;
        }
        for v in &self.tile_layer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.world_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.world_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.world_z = ::std::option::Option::Some(is.read_sint32()?);
                },
                34 => {
                    self.tile_layer.push(is.read_message()?);
                },
                40 => {
                    self.current_year = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.current_season = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.is_valid = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.world_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.world_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.world_z {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        for value in &self.tile_layer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.current_year {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.current_season {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.is_valid {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.world_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.world_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.world_z {
            os.write_sint32(3, v)?;
        }
        for v in &self.tile_layer {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.current_year {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.current_season {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.is_valid {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmbarkTile {
        EmbarkTile::new()
    }

    fn clear(&mut self) {
        self.world_x = ::std::option::Option::None;
        self.world_y = ::std::option::Option::None;
        self.world_z = ::std::option::Option::None;
        self.tile_layer.clear();
        self.current_year = ::std::option::Option::None;
        self.current_season = ::std::option::Option::None;
        self.is_valid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmbarkTile {
        static instance: EmbarkTile = EmbarkTile {
            world_x: ::std::option::Option::None,
            world_y: ::std::option::Option::None,
            world_z: ::std::option::Option::None,
            tile_layer: ::std::vec::Vec::new(),
            current_year: ::std::option::Option::None,
            current_season: ::std::option::Option::None,
            is_valid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmbarkTile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmbarkTile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmbarkTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmbarkTile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:isoworldremote.TileRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TileRequest {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.TileRequest.want_x)
    pub want_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.TileRequest.want_y)
    pub want_y: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.TileRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TileRequest {
    fn default() -> &'a TileRequest {
        <TileRequest as ::protobuf::Message>::default_instance()
    }
}

impl TileRequest {
    pub fn new() -> TileRequest {
        ::std::default::Default::default()
    }

    // optional int32 want_x = 1;

    pub fn want_x(&self) -> i32 {
        self.want_x.unwrap_or(0)
    }

    pub fn clear_want_x(&mut self) {
        self.want_x = ::std::option::Option::None;
    }

    pub fn has_want_x(&self) -> bool {
        self.want_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_want_x(&mut self, v: i32) {
        self.want_x = ::std::option::Option::Some(v);
    }

    // optional int32 want_y = 2;

    pub fn want_y(&self) -> i32 {
        self.want_y.unwrap_or(0)
    }

    pub fn clear_want_y(&mut self) {
        self.want_y = ::std::option::Option::None;
    }

    pub fn has_want_y(&self) -> bool {
        self.want_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_want_y(&mut self, v: i32) {
        self.want_y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "want_x",
            |m: &TileRequest| { &m.want_x },
            |m: &mut TileRequest| { &mut m.want_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "want_y",
            |m: &TileRequest| { &m.want_y },
            |m: &mut TileRequest| { &mut m.want_y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TileRequest>(
            "TileRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TileRequest {
    const NAME: &'static str = "TileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.want_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.want_y = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.want_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.want_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.want_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.want_y {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TileRequest {
        TileRequest::new()
    }

    fn clear(&mut self) {
        self.want_x = ::std::option::Option::None;
        self.want_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TileRequest {
        static instance: TileRequest = TileRequest {
            want_x: ::std::option::Option::None,
            want_y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TileRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TileRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TileRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:isoworldremote.MapRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapRequest {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.MapRequest.save_folder)
    pub save_folder: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.MapRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapRequest {
    fn default() -> &'a MapRequest {
        <MapRequest as ::protobuf::Message>::default_instance()
    }
}

impl MapRequest {
    pub fn new() -> MapRequest {
        ::std::default::Default::default()
    }

    // optional string save_folder = 1;

    pub fn save_folder(&self) -> &str {
        match self.save_folder.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_save_folder(&mut self) {
        self.save_folder = ::std::option::Option::None;
    }

    pub fn has_save_folder(&self) -> bool {
        self.save_folder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_folder(&mut self, v: ::std::string::String) {
        self.save_folder = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_folder(&mut self) -> &mut ::std::string::String {
        if self.save_folder.is_none() {
            self.save_folder = ::std::option::Option::Some(::std::string::String::new());
        }
        self.save_folder.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_folder(&mut self) -> ::std::string::String {
        self.save_folder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_folder",
            |m: &MapRequest| { &m.save_folder },
            |m: &mut MapRequest| { &mut m.save_folder },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapRequest>(
            "MapRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapRequest {
    const NAME: &'static str = "MapRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.save_folder = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.save_folder.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.save_folder.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapRequest {
        MapRequest::new()
    }

    fn clear(&mut self) {
        self.save_folder = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapRequest {
        static instance: MapRequest = MapRequest {
            save_folder: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:isoworldremote.MapReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapReply {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.MapReply.available)
    pub available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:isoworldremote.MapReply.region_x)
    pub region_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.MapReply.region_y)
    pub region_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.MapReply.region_size_x)
    pub region_size_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.MapReply.region_size_y)
    pub region_size_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.MapReply.current_year)
    pub current_year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:isoworldremote.MapReply.current_season)
    pub current_season: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.MapReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapReply {
    fn default() -> &'a MapReply {
        <MapReply as ::protobuf::Message>::default_instance()
    }
}

impl MapReply {
    pub fn new() -> MapReply {
        ::std::default::Default::default()
    }

    // required bool available = 1;

    pub fn available(&self) -> bool {
        self.available.unwrap_or(false)
    }

    pub fn clear_available(&mut self) {
        self.available = ::std::option::Option::None;
    }

    pub fn has_available(&self) -> bool {
        self.available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = ::std::option::Option::Some(v);
    }

    // optional int32 region_x = 2;

    pub fn region_x(&self) -> i32 {
        self.region_x.unwrap_or(0)
    }

    pub fn clear_region_x(&mut self) {
        self.region_x = ::std::option::Option::None;
    }

    pub fn has_region_x(&self) -> bool {
        self.region_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_x(&mut self, v: i32) {
        self.region_x = ::std::option::Option::Some(v);
    }

    // optional int32 region_y = 3;

    pub fn region_y(&self) -> i32 {
        self.region_y.unwrap_or(0)
    }

    pub fn clear_region_y(&mut self) {
        self.region_y = ::std::option::Option::None;
    }

    pub fn has_region_y(&self) -> bool {
        self.region_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_y(&mut self, v: i32) {
        self.region_y = ::std::option::Option::Some(v);
    }

    // optional int32 region_size_x = 4;

    pub fn region_size_x(&self) -> i32 {
        self.region_size_x.unwrap_or(0)
    }

    pub fn clear_region_size_x(&mut self) {
        self.region_size_x = ::std::option::Option::None;
    }

    pub fn has_region_size_x(&self) -> bool {
        self.region_size_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_size_x(&mut self, v: i32) {
        self.region_size_x = ::std::option::Option::Some(v);
    }

    // optional int32 region_size_y = 5;

    pub fn region_size_y(&self) -> i32 {
        self.region_size_y.unwrap_or(0)
    }

    pub fn clear_region_size_y(&mut self) {
        self.region_size_y = ::std::option::Option::None;
    }

    pub fn has_region_size_y(&self) -> bool {
        self.region_size_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_size_y(&mut self, v: i32) {
        self.region_size_y = ::std::option::Option::Some(v);
    }

    // optional int32 current_year = 6;

    pub fn current_year(&self) -> i32 {
        self.current_year.unwrap_or(0)
    }

    pub fn clear_current_year(&mut self) {
        self.current_year = ::std::option::Option::None;
    }

    pub fn has_current_year(&self) -> bool {
        self.current_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_year(&mut self, v: i32) {
        self.current_year = ::std::option::Option::Some(v);
    }

    // optional int32 current_season = 7;

    pub fn current_season(&self) -> i32 {
        self.current_season.unwrap_or(0)
    }

    pub fn clear_current_season(&mut self) {
        self.current_season = ::std::option::Option::None;
    }

    pub fn has_current_season(&self) -> bool {
        self.current_season.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_season(&mut self, v: i32) {
        self.current_season = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available",
            |m: &MapReply| { &m.available },
            |m: &mut MapReply| { &mut m.available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_x",
            |m: &MapReply| { &m.region_x },
            |m: &mut MapReply| { &mut m.region_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_y",
            |m: &MapReply| { &m.region_y },
            |m: &mut MapReply| { &mut m.region_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_size_x",
            |m: &MapReply| { &m.region_size_x },
            |m: &mut MapReply| { &mut m.region_size_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_size_y",
            |m: &MapReply| { &m.region_size_y },
            |m: &mut MapReply| { &mut m.region_size_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_year",
            |m: &MapReply| { &m.current_year },
            |m: &mut MapReply| { &mut m.current_year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_season",
            |m: &MapReply| { &m.current_season },
            |m: &mut MapReply| { &mut m.current_season },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapReply>(
            "MapReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapReply {
    const NAME: &'static str = "MapReply";

    fn is_initialized(&self) -> bool {
        if self.available.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.available = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.region_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.region_y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.region_size_x = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.region_size_y = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.current_year = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.current_season = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.region_x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.region_y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.region_size_x {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.region_size_y {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.current_year {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.current_season {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.available {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.region_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.region_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.region_size_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.region_size_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.current_year {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.current_season {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapReply {
        MapReply::new()
    }

    fn clear(&mut self) {
        self.available = ::std::option::Option::None;
        self.region_x = ::std::option::Option::None;
        self.region_y = ::std::option::Option::None;
        self.region_size_x = ::std::option::Option::None;
        self.region_size_y = ::std::option::Option::None;
        self.current_year = ::std::option::Option::None;
        self.current_season = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapReply {
        static instance: MapReply = MapReply {
            available: ::std::option::Option::None,
            region_x: ::std::option::Option::None,
            region_y: ::std::option::Option::None,
            region_size_x: ::std::option::Option::None,
            region_size_y: ::std::option::Option::None,
            current_year: ::std::option::Option::None,
            current_season: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:isoworldremote.RawNames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RawNames {
    // message fields
    // @@protoc_insertion_point(field:isoworldremote.RawNames.available)
    pub available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:isoworldremote.RawNames.inorganic)
    pub inorganic: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:isoworldremote.RawNames.organic)
    pub organic: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:isoworldremote.RawNames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RawNames {
    fn default() -> &'a RawNames {
        <RawNames as ::protobuf::Message>::default_instance()
    }
}

impl RawNames {
    pub fn new() -> RawNames {
        ::std::default::Default::default()
    }

    // required bool available = 1;

    pub fn available(&self) -> bool {
        self.available.unwrap_or(false)
    }

    pub fn clear_available(&mut self) {
        self.available = ::std::option::Option::None;
    }

    pub fn has_available(&self) -> bool {
        self.available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available",
            |m: &RawNames| { &m.available },
            |m: &mut RawNames| { &mut m.available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inorganic",
            |m: &RawNames| { &m.inorganic },
            |m: &mut RawNames| { &mut m.inorganic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "organic",
            |m: &RawNames| { &m.organic },
            |m: &mut RawNames| { &mut m.organic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RawNames>(
            "RawNames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RawNames {
    const NAME: &'static str = "RawNames";

    fn is_initialized(&self) -> bool {
        if self.available.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.available = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.inorganic.push(is.read_string()?);
                },
                26 => {
                    self.organic.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.available {
            my_size += 1 + 1;
        }
        for value in &self.inorganic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.organic {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.available {
            os.write_bool(1, v)?;
        }
        for v in &self.inorganic {
            os.write_string(2, &v)?;
        };
        for v in &self.organic {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RawNames {
        RawNames::new()
    }

    fn clear(&mut self) {
        self.available = ::std::option::Option::None;
        self.inorganic.clear();
        self.organic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RawNames {
        static instance: RawNames = RawNames {
            available: ::std::option::Option::None,
            inorganic: ::std::vec::Vec::new(),
            organic: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RawNames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RawNames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RawNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawNames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:isoworldremote.BasicMaterial)
pub enum BasicMaterial {
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicMaterial.AIR)
    AIR = 0,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicMaterial.OTHER)
    OTHER = 1,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicMaterial.INORGANIC)
    INORGANIC = 2,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicMaterial.LIQUID)
    LIQUID = 3,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicMaterial.PLANT)
    PLANT = 4,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicMaterial.WOOD)
    WOOD = 5,
}

impl ::protobuf::Enum for BasicMaterial {
    const NAME: &'static str = "BasicMaterial";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BasicMaterial> {
        match value {
            0 => ::std::option::Option::Some(BasicMaterial::AIR),
            1 => ::std::option::Option::Some(BasicMaterial::OTHER),
            2 => ::std::option::Option::Some(BasicMaterial::INORGANIC),
            3 => ::std::option::Option::Some(BasicMaterial::LIQUID),
            4 => ::std::option::Option::Some(BasicMaterial::PLANT),
            5 => ::std::option::Option::Some(BasicMaterial::WOOD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BasicMaterial> {
        match str {
            "AIR" => ::std::option::Option::Some(BasicMaterial::AIR),
            "OTHER" => ::std::option::Option::Some(BasicMaterial::OTHER),
            "INORGANIC" => ::std::option::Option::Some(BasicMaterial::INORGANIC),
            "LIQUID" => ::std::option::Option::Some(BasicMaterial::LIQUID),
            "PLANT" => ::std::option::Option::Some(BasicMaterial::PLANT),
            "WOOD" => ::std::option::Option::Some(BasicMaterial::WOOD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BasicMaterial] = &[
        BasicMaterial::AIR,
        BasicMaterial::OTHER,
        BasicMaterial::INORGANIC,
        BasicMaterial::LIQUID,
        BasicMaterial::PLANT,
        BasicMaterial::WOOD,
    ];
}

impl ::protobuf::EnumFull for BasicMaterial {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BasicMaterial").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BasicMaterial {
    fn default() -> Self {
        BasicMaterial::AIR
    }
}

impl BasicMaterial {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BasicMaterial>("BasicMaterial")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:isoworldremote.LiquidType)
pub enum LiquidType {
    // @@protoc_insertion_point(enum_value:isoworldremote.LiquidType.ICE)
    ICE = 0,
    // @@protoc_insertion_point(enum_value:isoworldremote.LiquidType.WATER)
    WATER = 1,
    // @@protoc_insertion_point(enum_value:isoworldremote.LiquidType.MAGMA)
    MAGMA = 2,
}

impl ::protobuf::Enum for LiquidType {
    const NAME: &'static str = "LiquidType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LiquidType> {
        match value {
            0 => ::std::option::Option::Some(LiquidType::ICE),
            1 => ::std::option::Option::Some(LiquidType::WATER),
            2 => ::std::option::Option::Some(LiquidType::MAGMA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LiquidType> {
        match str {
            "ICE" => ::std::option::Option::Some(LiquidType::ICE),
            "WATER" => ::std::option::Option::Some(LiquidType::WATER),
            "MAGMA" => ::std::option::Option::Some(LiquidType::MAGMA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LiquidType] = &[
        LiquidType::ICE,
        LiquidType::WATER,
        LiquidType::MAGMA,
    ];
}

impl ::protobuf::EnumFull for LiquidType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LiquidType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LiquidType {
    fn default() -> Self {
        LiquidType::ICE
    }
}

impl LiquidType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LiquidType>("LiquidType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:isoworldremote.BasicShape)
pub enum BasicShape {
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicShape.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicShape.OPEN)
    OPEN = 1,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicShape.WALL)
    WALL = 3,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicShape.FLOOR)
    FLOOR = 4,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicShape.RAMP_UP)
    RAMP_UP = 5,
    // @@protoc_insertion_point(enum_value:isoworldremote.BasicShape.RAMP_DOWN)
    RAMP_DOWN = 6,
}

impl ::protobuf::Enum for BasicShape {
    const NAME: &'static str = "BasicShape";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BasicShape> {
        match value {
            0 => ::std::option::Option::Some(BasicShape::NONE),
            1 => ::std::option::Option::Some(BasicShape::OPEN),
            3 => ::std::option::Option::Some(BasicShape::WALL),
            4 => ::std::option::Option::Some(BasicShape::FLOOR),
            5 => ::std::option::Option::Some(BasicShape::RAMP_UP),
            6 => ::std::option::Option::Some(BasicShape::RAMP_DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BasicShape> {
        match str {
            "NONE" => ::std::option::Option::Some(BasicShape::NONE),
            "OPEN" => ::std::option::Option::Some(BasicShape::OPEN),
            "WALL" => ::std::option::Option::Some(BasicShape::WALL),
            "FLOOR" => ::std::option::Option::Some(BasicShape::FLOOR),
            "RAMP_UP" => ::std::option::Option::Some(BasicShape::RAMP_UP),
            "RAMP_DOWN" => ::std::option::Option::Some(BasicShape::RAMP_DOWN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BasicShape] = &[
        BasicShape::NONE,
        BasicShape::OPEN,
        BasicShape::WALL,
        BasicShape::FLOOR,
        BasicShape::RAMP_UP,
        BasicShape::RAMP_DOWN,
    ];
}

impl ::protobuf::EnumFull for BasicShape {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BasicShape").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            BasicShape::NONE => 0,
            BasicShape::OPEN => 1,
            BasicShape::WALL => 2,
            BasicShape::FLOOR => 3,
            BasicShape::RAMP_UP => 4,
            BasicShape::RAMP_DOWN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BasicShape {
    fn default() -> Self {
        BasicShape::NONE
    }
}

impl BasicShape {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BasicShape>("BasicShape")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14isoworldremote.proto\x12\x0eisoworldremote\"M\n\x0fColorDefinition\
    \x12\x10\n\x03red\x18\x01\x20\x02(\x05R\x03red\x12\x14\n\x05green\x18\
    \x02\x20\x02(\x05R\x05green\x12\x12\n\x04blue\x18\x03\x20\x02(\x05R\x04b\
    lue\"\x9f\x02\n\x0fEmbarkTileLayer\x12G\n\x0emat_type_table\x18\x04\x20\
    \x03(\x0e2\x1d.isoworldremote.BasicMaterialR\x0cmatTypeTableB\x02\x10\
    \x01\x12.\n\x11mat_subtype_table\x18\x05\x20\x03(\x05R\x0fmatSubtypeTabl\
    eB\x02\x10\x01\x12H\n\x10tile_shape_table\x18\x06\x20\x03(\x0e2\x1a.isow\
    orldremote.BasicShapeR\x0etileShapeTableB\x02\x10\x01\x12I\n\x10tile_col\
    or_table\x18\x07\x20\x03(\x0b2\x1f.isoworldremote.ColorDefinitionR\x0eti\
    leColorTable\"\xfc\x01\n\nEmbarkTile\x12\x17\n\x07world_x\x18\x01\x20\
    \x02(\x05R\x06worldX\x12\x17\n\x07world_y\x18\x02\x20\x02(\x05R\x06world\
    Y\x12\x17\n\x07world_z\x18\x03\x20\x02(\x11R\x06worldZ\x12>\n\ntile_laye\
    r\x18\x04\x20\x03(\x0b2\x1f.isoworldremote.EmbarkTileLayerR\ttileLayer\
    \x12!\n\x0ccurrent_year\x18\x05\x20\x01(\x05R\x0bcurrentYear\x12%\n\x0ec\
    urrent_season\x18\x06\x20\x01(\x05R\rcurrentSeason\x12\x19\n\x08is_valid\
    \x18\x07\x20\x01(\x08R\x07isValid\";\n\x0bTileRequest\x12\x15\n\x06want_\
    x\x18\x01\x20\x01(\x05R\x05wantX\x12\x15\n\x06want_y\x18\x02\x20\x01(\
    \x05R\x05wantY\"-\n\nMapRequest\x12\x1f\n\x0bsave_folder\x18\x01\x20\x01\
    (\tR\nsaveFolder\"\xf0\x01\n\x08MapReply\x12\x1c\n\tavailable\x18\x01\
    \x20\x02(\x08R\tavailable\x12\x19\n\x08region_x\x18\x02\x20\x01(\x05R\
    \x07regionX\x12\x19\n\x08region_y\x18\x03\x20\x01(\x05R\x07regionY\x12\"\
    \n\rregion_size_x\x18\x04\x20\x01(\x05R\x0bregionSizeX\x12\"\n\rregion_s\
    ize_y\x18\x05\x20\x01(\x05R\x0bregionSizeY\x12!\n\x0ccurrent_year\x18\
    \x06\x20\x01(\x05R\x0bcurrentYear\x12%\n\x0ecurrent_season\x18\x07\x20\
    \x01(\x05R\rcurrentSeason\"`\n\x08RawNames\x12\x1c\n\tavailable\x18\x01\
    \x20\x02(\x08R\tavailable\x12\x1c\n\tinorganic\x18\x02\x20\x03(\tR\tinor\
    ganic\x12\x18\n\x07organic\x18\x03\x20\x03(\tR\x07organic*S\n\rBasicMate\
    rial\x12\x07\n\x03AIR\x10\0\x12\t\n\x05OTHER\x10\x01\x12\r\n\tINORGANIC\
    \x10\x02\x12\n\n\x06LIQUID\x10\x03\x12\t\n\x05PLANT\x10\x04\x12\x08\n\
    \x04WOOD\x10\x05*+\n\nLiquidType\x12\x07\n\x03ICE\x10\0\x12\t\n\x05WATER\
    \x10\x01\x12\t\n\x05MAGMA\x10\x02*Q\n\nBasicShape\x12\x08\n\x04NONE\x10\
    \0\x12\x08\n\x04OPEN\x10\x01\x12\x08\n\x04WALL\x10\x03\x12\t\n\x05FLOOR\
    \x10\x04\x12\x0b\n\x07RAMP_UP\x10\x05\x12\r\n\tRAMP_DOWN\x10\x06B\x02H\
    \x03b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(ColorDefinition::generated_message_descriptor_data());
            messages.push(EmbarkTileLayer::generated_message_descriptor_data());
            messages.push(EmbarkTile::generated_message_descriptor_data());
            messages.push(TileRequest::generated_message_descriptor_data());
            messages.push(MapRequest::generated_message_descriptor_data());
            messages.push(MapReply::generated_message_descriptor_data());
            messages.push(RawNames::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(BasicMaterial::generated_enum_descriptor_data());
            enums.push(LiquidType::generated_enum_descriptor_data());
            enums.push(BasicShape::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
