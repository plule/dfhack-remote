// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `isoworldremote.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct ColorDefinition {
    // message fields
    red: ::std::option::Option<i32>,
    green: ::std::option::Option<i32>,
    blue: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorDefinition {
    fn default() -> &'a ColorDefinition {
        <ColorDefinition as ::protobuf::Message>::default_instance()
    }
}

impl ColorDefinition {
    pub fn new() -> ColorDefinition {
        ::std::default::Default::default()
    }

    // required int32 red = 1;


    pub fn get_red(&self) -> i32 {
        self.red.unwrap_or(0)
    }
    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: i32) {
        self.red = ::std::option::Option::Some(v);
    }

    // required int32 green = 2;


    pub fn get_green(&self) -> i32 {
        self.green.unwrap_or(0)
    }
    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: i32) {
        self.green = ::std::option::Option::Some(v);
    }

    // required int32 blue = 3;


    pub fn get_blue(&self) -> i32 {
        self.blue.unwrap_or(0)
    }
    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: i32) {
        self.blue = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ColorDefinition {
    fn is_initialized(&self) -> bool {
        if self.red.is_none() {
            return false;
        }
        if self.green.is_none() {
            return false;
        }
        if self.blue.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.red = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.green = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blue = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.red {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.green {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.blue {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorDefinition {
        ColorDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "red",
                |m: &ColorDefinition| { &m.red },
                |m: &mut ColorDefinition| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "green",
                |m: &ColorDefinition| { &m.green },
                |m: &mut ColorDefinition| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blue",
                |m: &ColorDefinition| { &m.blue },
                |m: &mut ColorDefinition| { &mut m.blue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColorDefinition>(
                "ColorDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColorDefinition {
        static instance: ::protobuf::rt::LazyV2<ColorDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColorDefinition::new)
    }
}

impl ::protobuf::Clear for ColorDefinition {
    fn clear(&mut self) {
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmbarkTileLayer {
    // message fields
    pub mat_type_table: ::std::vec::Vec<BasicMaterial>,
    pub mat_subtype_table: ::std::vec::Vec<i32>,
    pub tile_shape_table: ::std::vec::Vec<BasicShape>,
    pub tile_color_table: ::protobuf::RepeatedField<ColorDefinition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmbarkTileLayer {
    fn default() -> &'a EmbarkTileLayer {
        <EmbarkTileLayer as ::protobuf::Message>::default_instance()
    }
}

impl EmbarkTileLayer {
    pub fn new() -> EmbarkTileLayer {
        ::std::default::Default::default()
    }

    // repeated .isoworldremote.BasicMaterial mat_type_table = 4;


    pub fn get_mat_type_table(&self) -> &[BasicMaterial] {
        &self.mat_type_table
    }
    pub fn clear_mat_type_table(&mut self) {
        self.mat_type_table.clear();
    }

    // Param is passed by value, moved
    pub fn set_mat_type_table(&mut self, v: ::std::vec::Vec<BasicMaterial>) {
        self.mat_type_table = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mat_type_table(&mut self) -> &mut ::std::vec::Vec<BasicMaterial> {
        &mut self.mat_type_table
    }

    // Take field
    pub fn take_mat_type_table(&mut self) -> ::std::vec::Vec<BasicMaterial> {
        ::std::mem::replace(&mut self.mat_type_table, ::std::vec::Vec::new())
    }

    // repeated int32 mat_subtype_table = 5;


    pub fn get_mat_subtype_table(&self) -> &[i32] {
        &self.mat_subtype_table
    }
    pub fn clear_mat_subtype_table(&mut self) {
        self.mat_subtype_table.clear();
    }

    // Param is passed by value, moved
    pub fn set_mat_subtype_table(&mut self, v: ::std::vec::Vec<i32>) {
        self.mat_subtype_table = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mat_subtype_table(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.mat_subtype_table
    }

    // Take field
    pub fn take_mat_subtype_table(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.mat_subtype_table, ::std::vec::Vec::new())
    }

    // repeated .isoworldremote.BasicShape tile_shape_table = 6;


    pub fn get_tile_shape_table(&self) -> &[BasicShape] {
        &self.tile_shape_table
    }
    pub fn clear_tile_shape_table(&mut self) {
        self.tile_shape_table.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_shape_table(&mut self, v: ::std::vec::Vec<BasicShape>) {
        self.tile_shape_table = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_shape_table(&mut self) -> &mut ::std::vec::Vec<BasicShape> {
        &mut self.tile_shape_table
    }

    // Take field
    pub fn take_tile_shape_table(&mut self) -> ::std::vec::Vec<BasicShape> {
        ::std::mem::replace(&mut self.tile_shape_table, ::std::vec::Vec::new())
    }

    // repeated .isoworldremote.ColorDefinition tile_color_table = 7;


    pub fn get_tile_color_table(&self) -> &[ColorDefinition] {
        &self.tile_color_table
    }
    pub fn clear_tile_color_table(&mut self) {
        self.tile_color_table.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_color_table(&mut self, v: ::protobuf::RepeatedField<ColorDefinition>) {
        self.tile_color_table = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_color_table(&mut self) -> &mut ::protobuf::RepeatedField<ColorDefinition> {
        &mut self.tile_color_table
    }

    // Take field
    pub fn take_tile_color_table(&mut self) -> ::protobuf::RepeatedField<ColorDefinition> {
        ::std::mem::replace(&mut self.tile_color_table, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EmbarkTileLayer {
    fn is_initialized(&self) -> bool {
        for v in &self.tile_color_table {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.mat_type_table, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.mat_subtype_table)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.tile_shape_table, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tile_color_table)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mat_type_table.is_empty() {
            my_size += ::protobuf::rt::vec_packed_enum_size(4, &self.mat_type_table);
        }
        if !self.mat_subtype_table.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(5, &self.mat_subtype_table);
        }
        if !self.tile_shape_table.is_empty() {
            my_size += ::protobuf::rt::vec_packed_enum_size(6, &self.tile_shape_table);
        }
        for value in &self.tile_color_table {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mat_type_table.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_enum_data_size(&self.mat_type_table))?;
            for v in &self.mat_type_table {
                os.write_enum_no_tag(::protobuf::ProtobufEnum::value(v))?;
            };
        }
        if !self.mat_subtype_table.is_empty() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.mat_subtype_table))?;
            for v in &self.mat_subtype_table {
                os.write_int32_no_tag(*v)?;
            };
        }
        if !self.tile_shape_table.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_enum_data_size(&self.tile_shape_table))?;
            for v in &self.tile_shape_table {
                os.write_enum_no_tag(::protobuf::ProtobufEnum::value(v))?;
            };
        }
        for v in &self.tile_color_table {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmbarkTileLayer {
        EmbarkTileLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BasicMaterial>>(
                "mat_type_table",
                |m: &EmbarkTileLayer| { &m.mat_type_table },
                |m: &mut EmbarkTileLayer| { &mut m.mat_type_table },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mat_subtype_table",
                |m: &EmbarkTileLayer| { &m.mat_subtype_table },
                |m: &mut EmbarkTileLayer| { &mut m.mat_subtype_table },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BasicShape>>(
                "tile_shape_table",
                |m: &EmbarkTileLayer| { &m.tile_shape_table },
                |m: &mut EmbarkTileLayer| { &mut m.tile_shape_table },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "tile_color_table",
                |m: &EmbarkTileLayer| { &m.tile_color_table },
                |m: &mut EmbarkTileLayer| { &mut m.tile_color_table },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmbarkTileLayer>(
                "EmbarkTileLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmbarkTileLayer {
        static instance: ::protobuf::rt::LazyV2<EmbarkTileLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmbarkTileLayer::new)
    }
}

impl ::protobuf::Clear for EmbarkTileLayer {
    fn clear(&mut self) {
        self.mat_type_table.clear();
        self.mat_subtype_table.clear();
        self.tile_shape_table.clear();
        self.tile_color_table.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmbarkTileLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmbarkTileLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmbarkTile {
    // message fields
    world_x: ::std::option::Option<i32>,
    world_y: ::std::option::Option<i32>,
    world_z: ::std::option::Option<i32>,
    pub tile_layer: ::protobuf::RepeatedField<EmbarkTileLayer>,
    current_year: ::std::option::Option<i32>,
    current_season: ::std::option::Option<i32>,
    is_valid: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmbarkTile {
    fn default() -> &'a EmbarkTile {
        <EmbarkTile as ::protobuf::Message>::default_instance()
    }
}

impl EmbarkTile {
    pub fn new() -> EmbarkTile {
        ::std::default::Default::default()
    }

    // required int32 world_x = 1;


    pub fn get_world_x(&self) -> i32 {
        self.world_x.unwrap_or(0)
    }
    pub fn clear_world_x(&mut self) {
        self.world_x = ::std::option::Option::None;
    }

    pub fn has_world_x(&self) -> bool {
        self.world_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_x(&mut self, v: i32) {
        self.world_x = ::std::option::Option::Some(v);
    }

    // required int32 world_y = 2;


    pub fn get_world_y(&self) -> i32 {
        self.world_y.unwrap_or(0)
    }
    pub fn clear_world_y(&mut self) {
        self.world_y = ::std::option::Option::None;
    }

    pub fn has_world_y(&self) -> bool {
        self.world_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_y(&mut self, v: i32) {
        self.world_y = ::std::option::Option::Some(v);
    }

    // required sint32 world_z = 3;


    pub fn get_world_z(&self) -> i32 {
        self.world_z.unwrap_or(0)
    }
    pub fn clear_world_z(&mut self) {
        self.world_z = ::std::option::Option::None;
    }

    pub fn has_world_z(&self) -> bool {
        self.world_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_z(&mut self, v: i32) {
        self.world_z = ::std::option::Option::Some(v);
    }

    // repeated .isoworldremote.EmbarkTileLayer tile_layer = 4;


    pub fn get_tile_layer(&self) -> &[EmbarkTileLayer] {
        &self.tile_layer
    }
    pub fn clear_tile_layer(&mut self) {
        self.tile_layer.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_layer(&mut self, v: ::protobuf::RepeatedField<EmbarkTileLayer>) {
        self.tile_layer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_layer(&mut self) -> &mut ::protobuf::RepeatedField<EmbarkTileLayer> {
        &mut self.tile_layer
    }

    // Take field
    pub fn take_tile_layer(&mut self) -> ::protobuf::RepeatedField<EmbarkTileLayer> {
        ::std::mem::replace(&mut self.tile_layer, ::protobuf::RepeatedField::new())
    }

    // optional int32 current_year = 5;


    pub fn get_current_year(&self) -> i32 {
        self.current_year.unwrap_or(0)
    }
    pub fn clear_current_year(&mut self) {
        self.current_year = ::std::option::Option::None;
    }

    pub fn has_current_year(&self) -> bool {
        self.current_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_year(&mut self, v: i32) {
        self.current_year = ::std::option::Option::Some(v);
    }

    // optional int32 current_season = 6;


    pub fn get_current_season(&self) -> i32 {
        self.current_season.unwrap_or(0)
    }
    pub fn clear_current_season(&mut self) {
        self.current_season = ::std::option::Option::None;
    }

    pub fn has_current_season(&self) -> bool {
        self.current_season.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_season(&mut self, v: i32) {
        self.current_season = ::std::option::Option::Some(v);
    }

    // optional bool is_valid = 7;


    pub fn get_is_valid(&self) -> bool {
        self.is_valid.unwrap_or(false)
    }
    pub fn clear_is_valid(&mut self) {
        self.is_valid = ::std::option::Option::None;
    }

    pub fn has_is_valid(&self) -> bool {
        self.is_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valid(&mut self, v: bool) {
        self.is_valid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EmbarkTile {
    fn is_initialized(&self) -> bool {
        if self.world_x.is_none() {
            return false;
        }
        if self.world_y.is_none() {
            return false;
        }
        if self.world_z.is_none() {
            return false;
        }
        for v in &self.tile_layer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.world_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.world_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.world_z = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tile_layer)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_year = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_season = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_valid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.world_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.world_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.world_z {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        for value in &self.tile_layer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.current_year {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_season {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_valid {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.world_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.world_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.world_z {
            os.write_sint32(3, v)?;
        }
        for v in &self.tile_layer {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.current_year {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.current_season {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.is_valid {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmbarkTile {
        EmbarkTile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "world_x",
                |m: &EmbarkTile| { &m.world_x },
                |m: &mut EmbarkTile| { &mut m.world_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "world_y",
                |m: &EmbarkTile| { &m.world_y },
                |m: &mut EmbarkTile| { &mut m.world_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "world_z",
                |m: &EmbarkTile| { &m.world_z },
                |m: &mut EmbarkTile| { &mut m.world_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EmbarkTileLayer>>(
                "tile_layer",
                |m: &EmbarkTile| { &m.tile_layer },
                |m: &mut EmbarkTile| { &mut m.tile_layer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_year",
                |m: &EmbarkTile| { &m.current_year },
                |m: &mut EmbarkTile| { &mut m.current_year },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_season",
                |m: &EmbarkTile| { &m.current_season },
                |m: &mut EmbarkTile| { &mut m.current_season },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_valid",
                |m: &EmbarkTile| { &m.is_valid },
                |m: &mut EmbarkTile| { &mut m.is_valid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmbarkTile>(
                "EmbarkTile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmbarkTile {
        static instance: ::protobuf::rt::LazyV2<EmbarkTile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmbarkTile::new)
    }
}

impl ::protobuf::Clear for EmbarkTile {
    fn clear(&mut self) {
        self.world_x = ::std::option::Option::None;
        self.world_y = ::std::option::Option::None;
        self.world_z = ::std::option::Option::None;
        self.tile_layer.clear();
        self.current_year = ::std::option::Option::None;
        self.current_season = ::std::option::Option::None;
        self.is_valid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmbarkTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmbarkTile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TileRequest {
    // message fields
    want_x: ::std::option::Option<i32>,
    want_y: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TileRequest {
    fn default() -> &'a TileRequest {
        <TileRequest as ::protobuf::Message>::default_instance()
    }
}

impl TileRequest {
    pub fn new() -> TileRequest {
        ::std::default::Default::default()
    }

    // optional int32 want_x = 1;


    pub fn get_want_x(&self) -> i32 {
        self.want_x.unwrap_or(0)
    }
    pub fn clear_want_x(&mut self) {
        self.want_x = ::std::option::Option::None;
    }

    pub fn has_want_x(&self) -> bool {
        self.want_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_want_x(&mut self, v: i32) {
        self.want_x = ::std::option::Option::Some(v);
    }

    // optional int32 want_y = 2;


    pub fn get_want_y(&self) -> i32 {
        self.want_y.unwrap_or(0)
    }
    pub fn clear_want_y(&mut self) {
        self.want_y = ::std::option::Option::None;
    }

    pub fn has_want_y(&self) -> bool {
        self.want_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_want_y(&mut self, v: i32) {
        self.want_y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.want_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.want_y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.want_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.want_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.want_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.want_y {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TileRequest {
        TileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "want_x",
                |m: &TileRequest| { &m.want_x },
                |m: &mut TileRequest| { &mut m.want_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "want_y",
                |m: &TileRequest| { &m.want_y },
                |m: &mut TileRequest| { &mut m.want_y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TileRequest>(
                "TileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TileRequest {
        static instance: ::protobuf::rt::LazyV2<TileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TileRequest::new)
    }
}

impl ::protobuf::Clear for TileRequest {
    fn clear(&mut self) {
        self.want_x = ::std::option::Option::None;
        self.want_y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapRequest {
    // message fields
    save_folder: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapRequest {
    fn default() -> &'a MapRequest {
        <MapRequest as ::protobuf::Message>::default_instance()
    }
}

impl MapRequest {
    pub fn new() -> MapRequest {
        ::std::default::Default::default()
    }

    // optional string save_folder = 1;


    pub fn get_save_folder(&self) -> &str {
        match self.save_folder.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_save_folder(&mut self) {
        self.save_folder.clear();
    }

    pub fn has_save_folder(&self) -> bool {
        self.save_folder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_folder(&mut self, v: ::std::string::String) {
        self.save_folder = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_folder(&mut self) -> &mut ::std::string::String {
        if self.save_folder.is_none() {
            self.save_folder.set_default();
        }
        self.save_folder.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_folder(&mut self) -> ::std::string::String {
        self.save_folder.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MapRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.save_folder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.save_folder.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.save_folder.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapRequest {
        MapRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "save_folder",
                |m: &MapRequest| { &m.save_folder },
                |m: &mut MapRequest| { &mut m.save_folder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapRequest>(
                "MapRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapRequest {
        static instance: ::protobuf::rt::LazyV2<MapRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapRequest::new)
    }
}

impl ::protobuf::Clear for MapRequest {
    fn clear(&mut self) {
        self.save_folder.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapReply {
    // message fields
    available: ::std::option::Option<bool>,
    region_x: ::std::option::Option<i32>,
    region_y: ::std::option::Option<i32>,
    region_size_x: ::std::option::Option<i32>,
    region_size_y: ::std::option::Option<i32>,
    current_year: ::std::option::Option<i32>,
    current_season: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapReply {
    fn default() -> &'a MapReply {
        <MapReply as ::protobuf::Message>::default_instance()
    }
}

impl MapReply {
    pub fn new() -> MapReply {
        ::std::default::Default::default()
    }

    // required bool available = 1;


    pub fn get_available(&self) -> bool {
        self.available.unwrap_or(false)
    }
    pub fn clear_available(&mut self) {
        self.available = ::std::option::Option::None;
    }

    pub fn has_available(&self) -> bool {
        self.available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = ::std::option::Option::Some(v);
    }

    // optional int32 region_x = 2;


    pub fn get_region_x(&self) -> i32 {
        self.region_x.unwrap_or(0)
    }
    pub fn clear_region_x(&mut self) {
        self.region_x = ::std::option::Option::None;
    }

    pub fn has_region_x(&self) -> bool {
        self.region_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_x(&mut self, v: i32) {
        self.region_x = ::std::option::Option::Some(v);
    }

    // optional int32 region_y = 3;


    pub fn get_region_y(&self) -> i32 {
        self.region_y.unwrap_or(0)
    }
    pub fn clear_region_y(&mut self) {
        self.region_y = ::std::option::Option::None;
    }

    pub fn has_region_y(&self) -> bool {
        self.region_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_y(&mut self, v: i32) {
        self.region_y = ::std::option::Option::Some(v);
    }

    // optional int32 region_size_x = 4;


    pub fn get_region_size_x(&self) -> i32 {
        self.region_size_x.unwrap_or(0)
    }
    pub fn clear_region_size_x(&mut self) {
        self.region_size_x = ::std::option::Option::None;
    }

    pub fn has_region_size_x(&self) -> bool {
        self.region_size_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_size_x(&mut self, v: i32) {
        self.region_size_x = ::std::option::Option::Some(v);
    }

    // optional int32 region_size_y = 5;


    pub fn get_region_size_y(&self) -> i32 {
        self.region_size_y.unwrap_or(0)
    }
    pub fn clear_region_size_y(&mut self) {
        self.region_size_y = ::std::option::Option::None;
    }

    pub fn has_region_size_y(&self) -> bool {
        self.region_size_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_size_y(&mut self, v: i32) {
        self.region_size_y = ::std::option::Option::Some(v);
    }

    // optional int32 current_year = 6;


    pub fn get_current_year(&self) -> i32 {
        self.current_year.unwrap_or(0)
    }
    pub fn clear_current_year(&mut self) {
        self.current_year = ::std::option::Option::None;
    }

    pub fn has_current_year(&self) -> bool {
        self.current_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_year(&mut self, v: i32) {
        self.current_year = ::std::option::Option::Some(v);
    }

    // optional int32 current_season = 7;


    pub fn get_current_season(&self) -> i32 {
        self.current_season.unwrap_or(0)
    }
    pub fn clear_current_season(&mut self) {
        self.current_season = ::std::option::Option::None;
    }

    pub fn has_current_season(&self) -> bool {
        self.current_season.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_season(&mut self, v: i32) {
        self.current_season = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MapReply {
    fn is_initialized(&self) -> bool {
        if self.available.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.available = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region_size_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region_size_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_year = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_season = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.available {
            my_size += 2;
        }
        if let Some(v) = self.region_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_size_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_size_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_year {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_season {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.available {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.region_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.region_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.region_size_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.region_size_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.current_year {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.current_season {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapReply {
        MapReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "available",
                |m: &MapReply| { &m.available },
                |m: &mut MapReply| { &mut m.available },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "region_x",
                |m: &MapReply| { &m.region_x },
                |m: &mut MapReply| { &mut m.region_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "region_y",
                |m: &MapReply| { &m.region_y },
                |m: &mut MapReply| { &mut m.region_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "region_size_x",
                |m: &MapReply| { &m.region_size_x },
                |m: &mut MapReply| { &mut m.region_size_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "region_size_y",
                |m: &MapReply| { &m.region_size_y },
                |m: &mut MapReply| { &mut m.region_size_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_year",
                |m: &MapReply| { &m.current_year },
                |m: &mut MapReply| { &mut m.current_year },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_season",
                |m: &MapReply| { &m.current_season },
                |m: &mut MapReply| { &mut m.current_season },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapReply>(
                "MapReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapReply {
        static instance: ::protobuf::rt::LazyV2<MapReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapReply::new)
    }
}

impl ::protobuf::Clear for MapReply {
    fn clear(&mut self) {
        self.available = ::std::option::Option::None;
        self.region_x = ::std::option::Option::None;
        self.region_y = ::std::option::Option::None;
        self.region_size_x = ::std::option::Option::None;
        self.region_size_y = ::std::option::Option::None;
        self.current_year = ::std::option::Option::None;
        self.current_season = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawNames {
    // message fields
    available: ::std::option::Option<bool>,
    pub inorganic: ::protobuf::RepeatedField<::std::string::String>,
    pub organic: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawNames {
    fn default() -> &'a RawNames {
        <RawNames as ::protobuf::Message>::default_instance()
    }
}

impl RawNames {
    pub fn new() -> RawNames {
        ::std::default::Default::default()
    }

    // required bool available = 1;


    pub fn get_available(&self) -> bool {
        self.available.unwrap_or(false)
    }
    pub fn clear_available(&mut self) {
        self.available = ::std::option::Option::None;
    }

    pub fn has_available(&self) -> bool {
        self.available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = ::std::option::Option::Some(v);
    }

    // repeated string inorganic = 2;


    pub fn get_inorganic(&self) -> &[::std::string::String] {
        &self.inorganic
    }
    pub fn clear_inorganic(&mut self) {
        self.inorganic.clear();
    }

    // Param is passed by value, moved
    pub fn set_inorganic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.inorganic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inorganic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.inorganic
    }

    // Take field
    pub fn take_inorganic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.inorganic, ::protobuf::RepeatedField::new())
    }

    // repeated string organic = 3;


    pub fn get_organic(&self) -> &[::std::string::String] {
        &self.organic
    }
    pub fn clear_organic(&mut self) {
        self.organic.clear();
    }

    // Param is passed by value, moved
    pub fn set_organic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.organic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_organic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.organic
    }

    // Take field
    pub fn take_organic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.organic, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawNames {
    fn is_initialized(&self) -> bool {
        if self.available.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.available = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.inorganic)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.organic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.available {
            my_size += 2;
        }
        for value in &self.inorganic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.organic {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.available {
            os.write_bool(1, v)?;
        }
        for v in &self.inorganic {
            os.write_string(2, &v)?;
        };
        for v in &self.organic {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawNames {
        RawNames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "available",
                |m: &RawNames| { &m.available },
                |m: &mut RawNames| { &mut m.available },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inorganic",
                |m: &RawNames| { &m.inorganic },
                |m: &mut RawNames| { &mut m.inorganic },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "organic",
                |m: &RawNames| { &m.organic },
                |m: &mut RawNames| { &mut m.organic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RawNames>(
                "RawNames",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RawNames {
        static instance: ::protobuf::rt::LazyV2<RawNames> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RawNames::new)
    }
}

impl ::protobuf::Clear for RawNames {
    fn clear(&mut self) {
        self.available = ::std::option::Option::None;
        self.inorganic.clear();
        self.organic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawNames {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BasicMaterial {
    AIR = 0,
    OTHER = 1,
    INORGANIC = 2,
    LIQUID = 3,
    PLANT = 4,
    WOOD = 5,
}

impl ::protobuf::ProtobufEnum for BasicMaterial {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BasicMaterial> {
        match value {
            0 => ::std::option::Option::Some(BasicMaterial::AIR),
            1 => ::std::option::Option::Some(BasicMaterial::OTHER),
            2 => ::std::option::Option::Some(BasicMaterial::INORGANIC),
            3 => ::std::option::Option::Some(BasicMaterial::LIQUID),
            4 => ::std::option::Option::Some(BasicMaterial::PLANT),
            5 => ::std::option::Option::Some(BasicMaterial::WOOD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BasicMaterial] = &[
            BasicMaterial::AIR,
            BasicMaterial::OTHER,
            BasicMaterial::INORGANIC,
            BasicMaterial::LIQUID,
            BasicMaterial::PLANT,
            BasicMaterial::WOOD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BasicMaterial>("BasicMaterial", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BasicMaterial {
}

impl ::std::default::Default for BasicMaterial {
    fn default() -> Self {
        BasicMaterial::AIR
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterial {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LiquidType {
    ICE = 0,
    WATER = 1,
    MAGMA = 2,
}

impl ::protobuf::ProtobufEnum for LiquidType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LiquidType> {
        match value {
            0 => ::std::option::Option::Some(LiquidType::ICE),
            1 => ::std::option::Option::Some(LiquidType::WATER),
            2 => ::std::option::Option::Some(LiquidType::MAGMA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LiquidType] = &[
            LiquidType::ICE,
            LiquidType::WATER,
            LiquidType::MAGMA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LiquidType>("LiquidType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LiquidType {
}

impl ::std::default::Default for LiquidType {
    fn default() -> Self {
        LiquidType::ICE
    }
}

impl ::protobuf::reflect::ProtobufValue for LiquidType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BasicShape {
    NONE = 0,
    OPEN = 1,
    WALL = 3,
    FLOOR = 4,
    RAMP_UP = 5,
    RAMP_DOWN = 6,
}

impl ::protobuf::ProtobufEnum for BasicShape {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BasicShape> {
        match value {
            0 => ::std::option::Option::Some(BasicShape::NONE),
            1 => ::std::option::Option::Some(BasicShape::OPEN),
            3 => ::std::option::Option::Some(BasicShape::WALL),
            4 => ::std::option::Option::Some(BasicShape::FLOOR),
            5 => ::std::option::Option::Some(BasicShape::RAMP_UP),
            6 => ::std::option::Option::Some(BasicShape::RAMP_DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BasicShape] = &[
            BasicShape::NONE,
            BasicShape::OPEN,
            BasicShape::WALL,
            BasicShape::FLOOR,
            BasicShape::RAMP_UP,
            BasicShape::RAMP_DOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BasicShape>("BasicShape", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BasicShape {
}

impl ::std::default::Default for BasicShape {
    fn default() -> Self {
        BasicShape::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicShape {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14isoworldremote.proto\x12\x0eisoworldremote\"U\n\x0fColorDefinition\
    \x12\x12\n\x03red\x18\x01\x20\x02(\x05R\x03redB\0\x12\x16\n\x05green\x18\
    \x02\x20\x02(\x05R\x05greenB\0\x12\x14\n\x04blue\x18\x03\x20\x02(\x05R\
    \x04blueB\0:\0\"\xa3\x02\n\x0fEmbarkTileLayer\x12G\n\x0emat_type_table\
    \x18\x04\x20\x03(\x0e2\x1d.isoworldremote.BasicMaterialR\x0cmatTypeTable\
    B\x02\x10\x01\x12.\n\x11mat_subtype_table\x18\x05\x20\x03(\x05R\x0fmatSu\
    btypeTableB\x02\x10\x01\x12H\n\x10tile_shape_table\x18\x06\x20\x03(\x0e2\
    \x1a.isoworldremote.BasicShapeR\x0etileShapeTableB\x02\x10\x01\x12K\n\
    \x10tile_color_table\x18\x07\x20\x03(\x0b2\x1f.isoworldremote.ColorDefin\
    itionR\x0etileColorTableB\0:\0\"\x8c\x02\n\nEmbarkTile\x12\x19\n\x07worl\
    d_x\x18\x01\x20\x02(\x05R\x06worldXB\0\x12\x19\n\x07world_y\x18\x02\x20\
    \x02(\x05R\x06worldYB\0\x12\x19\n\x07world_z\x18\x03\x20\x02(\x11R\x06wo\
    rldZB\0\x12@\n\ntile_layer\x18\x04\x20\x03(\x0b2\x1f.isoworldremote.Emba\
    rkTileLayerR\ttileLayerB\0\x12#\n\x0ccurrent_year\x18\x05\x20\x01(\x05R\
    \x0bcurrentYearB\0\x12'\n\x0ecurrent_season\x18\x06\x20\x01(\x05R\rcurre\
    ntSeasonB\0\x12\x1b\n\x08is_valid\x18\x07\x20\x01(\x08R\x07isValidB\0:\0\
    \"A\n\x0bTileRequest\x12\x17\n\x06want_x\x18\x01\x20\x01(\x05R\x05wantXB\
    \0\x12\x17\n\x06want_y\x18\x02\x20\x01(\x05R\x05wantYB\0:\0\"1\n\nMapReq\
    uest\x12!\n\x0bsave_folder\x18\x01\x20\x01(\tR\nsaveFolderB\0:\0\"\x80\
    \x02\n\x08MapReply\x12\x1e\n\tavailable\x18\x01\x20\x02(\x08R\tavailable\
    B\0\x12\x1b\n\x08region_x\x18\x02\x20\x01(\x05R\x07regionXB\0\x12\x1b\n\
    \x08region_y\x18\x03\x20\x01(\x05R\x07regionYB\0\x12$\n\rregion_size_x\
    \x18\x04\x20\x01(\x05R\x0bregionSizeXB\0\x12$\n\rregion_size_y\x18\x05\
    \x20\x01(\x05R\x0bregionSizeYB\0\x12#\n\x0ccurrent_year\x18\x06\x20\x01(\
    \x05R\x0bcurrentYearB\0\x12'\n\x0ecurrent_season\x18\x07\x20\x01(\x05R\r\
    currentSeasonB\0:\0\"h\n\x08RawNames\x12\x1e\n\tavailable\x18\x01\x20\
    \x02(\x08R\tavailableB\0\x12\x1e\n\tinorganic\x18\x02\x20\x03(\tR\tinorg\
    anicB\0\x12\x1a\n\x07organic\x18\x03\x20\x03(\tR\x07organicB\0:\0*U\n\rB\
    asicMaterial\x12\x07\n\x03AIR\x10\0\x12\t\n\x05OTHER\x10\x01\x12\r\n\tIN\
    ORGANIC\x10\x02\x12\n\n\x06LIQUID\x10\x03\x12\t\n\x05PLANT\x10\x04\x12\
    \x08\n\x04WOOD\x10\x05\x1a\0*-\n\nLiquidType\x12\x07\n\x03ICE\x10\0\x12\
    \t\n\x05WATER\x10\x01\x12\t\n\x05MAGMA\x10\x02\x1a\0*S\n\nBasicShape\x12\
    \x08\n\x04NONE\x10\0\x12\x08\n\x04OPEN\x10\x01\x12\x08\n\x04WALL\x10\x03\
    \x12\t\n\x05FLOOR\x10\x04\x12\x0b\n\x07RAMP_UP\x10\x05\x12\r\n\tRAMP_DOW\
    N\x10\x06\x1a\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
