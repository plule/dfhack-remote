// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `RemoteFortressReader.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Coord {
    // message fields
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    z: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Coord {
    fn default() -> &'a Coord {
        <Coord as ::protobuf::Message>::default_instance()
    }
}

impl Coord {
    pub fn new() -> Coord {
        ::std::default::Default::default()
    }

    // optional int32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 z = 3;


    pub fn get_z(&self) -> i32 {
        self.z.unwrap_or(0)
    }
    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: i32) {
        self.z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Coord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.z {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Coord {
        Coord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "x",
                |m: &Coord| { &m.x },
                |m: &mut Coord| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "y",
                |m: &Coord| { &m.y },
                |m: &mut Coord| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "z",
                |m: &Coord| { &m.z },
                |m: &mut Coord| { &mut m.z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Coord>(
                "Coord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Coord {
        static instance: ::protobuf::rt::LazyV2<Coord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Coord::new)
    }
}

impl ::protobuf::Clear for Coord {
    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Coord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Coord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tiletype {
    // message fields
    id: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    caption: ::protobuf::SingularField<::std::string::String>,
    shape: ::std::option::Option<TiletypeShape>,
    special: ::std::option::Option<TiletypeSpecial>,
    material: ::std::option::Option<TiletypeMaterial>,
    variant: ::std::option::Option<TiletypeVariant>,
    direction: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tiletype {
    fn default() -> &'a Tiletype {
        <Tiletype as ::protobuf::Message>::default_instance()
    }
}

impl Tiletype {
    pub fn new() -> Tiletype {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.TiletypeShape shape = 4;


    pub fn get_shape(&self) -> TiletypeShape {
        self.shape.unwrap_or(TiletypeShape::NO_SHAPE)
    }
    pub fn clear_shape(&mut self) {
        self.shape = ::std::option::Option::None;
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: TiletypeShape) {
        self.shape = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.TiletypeSpecial special = 5;


    pub fn get_special(&self) -> TiletypeSpecial {
        self.special.unwrap_or(TiletypeSpecial::NO_SPECIAL)
    }
    pub fn clear_special(&mut self) {
        self.special = ::std::option::Option::None;
    }

    pub fn has_special(&self) -> bool {
        self.special.is_some()
    }

    // Param is passed by value, moved
    pub fn set_special(&mut self, v: TiletypeSpecial) {
        self.special = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.TiletypeMaterial material = 6;


    pub fn get_material(&self) -> TiletypeMaterial {
        self.material.unwrap_or(TiletypeMaterial::NO_MATERIAL)
    }
    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: TiletypeMaterial) {
        self.material = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.TiletypeVariant variant = 7;


    pub fn get_variant(&self) -> TiletypeVariant {
        self.variant.unwrap_or(TiletypeVariant::NO_VARIANT)
    }
    pub fn clear_variant(&mut self) {
        self.variant = ::std::option::Option::None;
    }

    pub fn has_variant(&self) -> bool {
        self.variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: TiletypeVariant) {
        self.variant = ::std::option::Option::Some(v);
    }

    // optional string direction = 8;


    pub fn get_direction(&self) -> &str {
        match self.direction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        if self.direction.is_none() {
            self.direction.set_default();
        }
        self.direction.as_mut().unwrap()
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        self.direction.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Tiletype {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.shape, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.special, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.material, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.variant, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.direction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.shape {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.special {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.variant {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(ref v) = self.direction.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.shape {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.special {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.material {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.variant {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.direction.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tiletype {
        Tiletype::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Tiletype| { &m.id },
                |m: &mut Tiletype| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Tiletype| { &m.name },
                |m: &mut Tiletype| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &Tiletype| { &m.caption },
                |m: &mut Tiletype| { &mut m.caption },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TiletypeShape>>(
                "shape",
                |m: &Tiletype| { &m.shape },
                |m: &mut Tiletype| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TiletypeSpecial>>(
                "special",
                |m: &Tiletype| { &m.special },
                |m: &mut Tiletype| { &mut m.special },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TiletypeMaterial>>(
                "material",
                |m: &Tiletype| { &m.material },
                |m: &mut Tiletype| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TiletypeVariant>>(
                "variant",
                |m: &Tiletype| { &m.variant },
                |m: &mut Tiletype| { &mut m.variant },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "direction",
                |m: &Tiletype| { &m.direction },
                |m: &mut Tiletype| { &mut m.direction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tiletype>(
                "Tiletype",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tiletype {
        static instance: ::protobuf::rt::LazyV2<Tiletype> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tiletype::new)
    }
}

impl ::protobuf::Clear for Tiletype {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.caption.clear();
        self.shape = ::std::option::Option::None;
        self.special = ::std::option::Option::None;
        self.material = ::std::option::Option::None;
        self.variant = ::std::option::Option::None;
        self.direction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tiletype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tiletype {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TiletypeList {
    // message fields
    pub tiletype_list: ::protobuf::RepeatedField<Tiletype>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TiletypeList {
    fn default() -> &'a TiletypeList {
        <TiletypeList as ::protobuf::Message>::default_instance()
    }
}

impl TiletypeList {
    pub fn new() -> TiletypeList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.Tiletype tiletype_list = 1;


    pub fn get_tiletype_list(&self) -> &[Tiletype] {
        &self.tiletype_list
    }
    pub fn clear_tiletype_list(&mut self) {
        self.tiletype_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiletype_list(&mut self, v: ::protobuf::RepeatedField<Tiletype>) {
        self.tiletype_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiletype_list(&mut self) -> &mut ::protobuf::RepeatedField<Tiletype> {
        &mut self.tiletype_list
    }

    // Take field
    pub fn take_tiletype_list(&mut self) -> ::protobuf::RepeatedField<Tiletype> {
        ::std::mem::replace(&mut self.tiletype_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TiletypeList {
    fn is_initialized(&self) -> bool {
        for v in &self.tiletype_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tiletype_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tiletype_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tiletype_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TiletypeList {
        TiletypeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tiletype>>(
                "tiletype_list",
                |m: &TiletypeList| { &m.tiletype_list },
                |m: &mut TiletypeList| { &mut m.tiletype_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TiletypeList>(
                "TiletypeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TiletypeList {
        static instance: ::protobuf::rt::LazyV2<TiletypeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TiletypeList::new)
    }
}

impl ::protobuf::Clear for TiletypeList {
    fn clear(&mut self) {
        self.tiletype_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TiletypeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TiletypeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildingExtents {
    // message fields
    pos_x: ::std::option::Option<i32>,
    pos_y: ::std::option::Option<i32>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    pub extents: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildingExtents {
    fn default() -> &'a BuildingExtents {
        <BuildingExtents as ::protobuf::Message>::default_instance()
    }
}

impl BuildingExtents {
    pub fn new() -> BuildingExtents {
        ::std::default::Default::default()
    }

    // required int32 pos_x = 1;


    pub fn get_pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // required int32 pos_y = 2;


    pub fn get_pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // required int32 width = 3;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required int32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // repeated int32 extents = 5;


    pub fn get_extents(&self) -> &[i32] {
        &self.extents
    }
    pub fn clear_extents(&mut self) {
        self.extents.clear();
    }

    // Param is passed by value, moved
    pub fn set_extents(&mut self, v: ::std::vec::Vec<i32>) {
        self.extents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extents(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.extents
    }

    // Take field
    pub fn take_extents(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.extents, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BuildingExtents {
    fn is_initialized(&self) -> bool {
        if self.pos_x.is_none() {
            return false;
        }
        if self.pos_y.is_none() {
            return false;
        }
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.extents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.extents {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pos_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        for v in &self.extents {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildingExtents {
        BuildingExtents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x",
                |m: &BuildingExtents| { &m.pos_x },
                |m: &mut BuildingExtents| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y",
                |m: &BuildingExtents| { &m.pos_y },
                |m: &mut BuildingExtents| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &BuildingExtents| { &m.width },
                |m: &mut BuildingExtents| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &BuildingExtents| { &m.height },
                |m: &mut BuildingExtents| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "extents",
                |m: &BuildingExtents| { &m.extents },
                |m: &mut BuildingExtents| { &mut m.extents },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildingExtents>(
                "BuildingExtents",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildingExtents {
        static instance: ::protobuf::rt::LazyV2<BuildingExtents> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildingExtents::new)
    }
}

impl ::protobuf::Clear for BuildingExtents {
    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.extents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildingExtents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingExtents {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildingItem {
    // message fields
    pub item: ::protobuf::SingularPtrField<Item>,
    mode: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildingItem {
    fn default() -> &'a BuildingItem {
        <BuildingItem as ::protobuf::Message>::default_instance()
    }
}

impl BuildingItem {
    pub fn new() -> BuildingItem {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.Item item = 1;


    pub fn get_item(&self) -> &Item {
        self.item.as_ref().unwrap_or_else(|| <Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        self.item.take().unwrap_or_else(|| Item::new())
    }

    // optional int32 mode = 2;


    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BuildingItem {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildingItem {
        BuildingItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Item>>(
                "item",
                |m: &BuildingItem| { &m.item },
                |m: &mut BuildingItem| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mode",
                |m: &BuildingItem| { &m.mode },
                |m: &mut BuildingItem| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildingItem>(
                "BuildingItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildingItem {
        static instance: ::protobuf::rt::LazyV2<BuildingItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildingItem::new)
    }
}

impl ::protobuf::Clear for BuildingItem {
    fn clear(&mut self) {
        self.item.clear();
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildingItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildingInstance {
    // message fields
    index: ::std::option::Option<i32>,
    pos_x_min: ::std::option::Option<i32>,
    pos_y_min: ::std::option::Option<i32>,
    pos_z_min: ::std::option::Option<i32>,
    pos_x_max: ::std::option::Option<i32>,
    pos_y_max: ::std::option::Option<i32>,
    pos_z_max: ::std::option::Option<i32>,
    pub building_type: ::protobuf::SingularPtrField<BuildingType>,
    pub material: ::protobuf::SingularPtrField<MatPair>,
    building_flags: ::std::option::Option<u32>,
    is_room: ::std::option::Option<bool>,
    pub room: ::protobuf::SingularPtrField<BuildingExtents>,
    direction: ::std::option::Option<BuildingDirection>,
    pub items: ::protobuf::RepeatedField<BuildingItem>,
    active: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildingInstance {
    fn default() -> &'a BuildingInstance {
        <BuildingInstance as ::protobuf::Message>::default_instance()
    }
}

impl BuildingInstance {
    pub fn new() -> BuildingInstance {
        ::std::default::Default::default()
    }

    // required int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x_min = 2;


    pub fn get_pos_x_min(&self) -> i32 {
        self.pos_x_min.unwrap_or(0)
    }
    pub fn clear_pos_x_min(&mut self) {
        self.pos_x_min = ::std::option::Option::None;
    }

    pub fn has_pos_x_min(&self) -> bool {
        self.pos_x_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x_min(&mut self, v: i32) {
        self.pos_x_min = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y_min = 3;


    pub fn get_pos_y_min(&self) -> i32 {
        self.pos_y_min.unwrap_or(0)
    }
    pub fn clear_pos_y_min(&mut self) {
        self.pos_y_min = ::std::option::Option::None;
    }

    pub fn has_pos_y_min(&self) -> bool {
        self.pos_y_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y_min(&mut self, v: i32) {
        self.pos_y_min = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z_min = 4;


    pub fn get_pos_z_min(&self) -> i32 {
        self.pos_z_min.unwrap_or(0)
    }
    pub fn clear_pos_z_min(&mut self) {
        self.pos_z_min = ::std::option::Option::None;
    }

    pub fn has_pos_z_min(&self) -> bool {
        self.pos_z_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z_min(&mut self, v: i32) {
        self.pos_z_min = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x_max = 5;


    pub fn get_pos_x_max(&self) -> i32 {
        self.pos_x_max.unwrap_or(0)
    }
    pub fn clear_pos_x_max(&mut self) {
        self.pos_x_max = ::std::option::Option::None;
    }

    pub fn has_pos_x_max(&self) -> bool {
        self.pos_x_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x_max(&mut self, v: i32) {
        self.pos_x_max = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y_max = 6;


    pub fn get_pos_y_max(&self) -> i32 {
        self.pos_y_max.unwrap_or(0)
    }
    pub fn clear_pos_y_max(&mut self) {
        self.pos_y_max = ::std::option::Option::None;
    }

    pub fn has_pos_y_max(&self) -> bool {
        self.pos_y_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y_max(&mut self, v: i32) {
        self.pos_y_max = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z_max = 7;


    pub fn get_pos_z_max(&self) -> i32 {
        self.pos_z_max.unwrap_or(0)
    }
    pub fn clear_pos_z_max(&mut self) {
        self.pos_z_max = ::std::option::Option::None;
    }

    pub fn has_pos_z_max(&self) -> bool {
        self.pos_z_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z_max(&mut self, v: i32) {
        self.pos_z_max = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.BuildingType building_type = 8;


    pub fn get_building_type(&self) -> &BuildingType {
        self.building_type.as_ref().unwrap_or_else(|| <BuildingType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_building_type(&mut self) {
        self.building_type.clear();
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: BuildingType) {
        self.building_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_building_type(&mut self) -> &mut BuildingType {
        if self.building_type.is_none() {
            self.building_type.set_default();
        }
        self.building_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_building_type(&mut self) -> BuildingType {
        self.building_type.take().unwrap_or_else(|| BuildingType::new())
    }

    // optional .RemoteFortressReader.MatPair material = 9;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional uint32 building_flags = 10;


    pub fn get_building_flags(&self) -> u32 {
        self.building_flags.unwrap_or(0)
    }
    pub fn clear_building_flags(&mut self) {
        self.building_flags = ::std::option::Option::None;
    }

    pub fn has_building_flags(&self) -> bool {
        self.building_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_flags(&mut self, v: u32) {
        self.building_flags = ::std::option::Option::Some(v);
    }

    // optional bool is_room = 11;


    pub fn get_is_room(&self) -> bool {
        self.is_room.unwrap_or(false)
    }
    pub fn clear_is_room(&mut self) {
        self.is_room = ::std::option::Option::None;
    }

    pub fn has_is_room(&self) -> bool {
        self.is_room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_room(&mut self, v: bool) {
        self.is_room = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.BuildingExtents room = 12;


    pub fn get_room(&self) -> &BuildingExtents {
        self.room.as_ref().unwrap_or_else(|| <BuildingExtents as ::protobuf::Message>::default_instance())
    }
    pub fn clear_room(&mut self) {
        self.room.clear();
    }

    pub fn has_room(&self) -> bool {
        self.room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_room(&mut self, v: BuildingExtents) {
        self.room = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_room(&mut self) -> &mut BuildingExtents {
        if self.room.is_none() {
            self.room.set_default();
        }
        self.room.as_mut().unwrap()
    }

    // Take field
    pub fn take_room(&mut self) -> BuildingExtents {
        self.room.take().unwrap_or_else(|| BuildingExtents::new())
    }

    // optional .RemoteFortressReader.BuildingDirection direction = 13;


    pub fn get_direction(&self) -> BuildingDirection {
        self.direction.unwrap_or(BuildingDirection::NORTH)
    }
    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: BuildingDirection) {
        self.direction = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.BuildingItem items = 14;


    pub fn get_items(&self) -> &[BuildingItem] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<BuildingItem>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<BuildingItem> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<BuildingItem> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional int32 active = 15;


    pub fn get_active(&self) -> i32 {
        self.active.unwrap_or(0)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: i32) {
        self.active = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BuildingInstance {
    fn is_initialized(&self) -> bool {
        if self.index.is_none() {
            return false;
        }
        for v in &self.building_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.room {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x_min = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y_min = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_z_min = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x_max = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y_max = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_z_max = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.building_type)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.building_flags = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_room = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.room)?;
                },
                13 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x_min {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y_min {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_z_min {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x_max {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y_max {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_z_max {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.building_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.building_flags {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_room {
            my_size += 2;
        }
        if let Some(ref v) = self.room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::enum_size(13, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.active {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x_min {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos_y_min {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos_z_min {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.pos_x_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.pos_y_max {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pos_z_max {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.building_type.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.building_flags {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.is_room {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.room.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.items {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.active {
            os.write_int32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildingInstance {
        BuildingInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &BuildingInstance| { &m.index },
                |m: &mut BuildingInstance| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x_min",
                |m: &BuildingInstance| { &m.pos_x_min },
                |m: &mut BuildingInstance| { &mut m.pos_x_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y_min",
                |m: &BuildingInstance| { &m.pos_y_min },
                |m: &mut BuildingInstance| { &mut m.pos_y_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_z_min",
                |m: &BuildingInstance| { &m.pos_z_min },
                |m: &mut BuildingInstance| { &mut m.pos_z_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x_max",
                |m: &BuildingInstance| { &m.pos_x_max },
                |m: &mut BuildingInstance| { &mut m.pos_x_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y_max",
                |m: &BuildingInstance| { &m.pos_y_max },
                |m: &mut BuildingInstance| { &mut m.pos_y_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_z_max",
                |m: &BuildingInstance| { &m.pos_z_max },
                |m: &mut BuildingInstance| { &mut m.pos_z_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildingType>>(
                "building_type",
                |m: &BuildingInstance| { &m.building_type },
                |m: &mut BuildingInstance| { &mut m.building_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &BuildingInstance| { &m.material },
                |m: &mut BuildingInstance| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "building_flags",
                |m: &BuildingInstance| { &m.building_flags },
                |m: &mut BuildingInstance| { &mut m.building_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_room",
                |m: &BuildingInstance| { &m.is_room },
                |m: &mut BuildingInstance| { &mut m.is_room },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildingExtents>>(
                "room",
                |m: &BuildingInstance| { &m.room },
                |m: &mut BuildingInstance| { &mut m.room },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BuildingDirection>>(
                "direction",
                |m: &BuildingInstance| { &m.direction },
                |m: &mut BuildingInstance| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildingItem>>(
                "items",
                |m: &BuildingInstance| { &m.items },
                |m: &mut BuildingInstance| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "active",
                |m: &BuildingInstance| { &m.active },
                |m: &mut BuildingInstance| { &mut m.active },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildingInstance>(
                "BuildingInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildingInstance {
        static instance: ::protobuf::rt::LazyV2<BuildingInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildingInstance::new)
    }
}

impl ::protobuf::Clear for BuildingInstance {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.pos_x_min = ::std::option::Option::None;
        self.pos_y_min = ::std::option::Option::None;
        self.pos_z_min = ::std::option::Option::None;
        self.pos_x_max = ::std::option::Option::None;
        self.pos_y_max = ::std::option::Option::None;
        self.pos_z_max = ::std::option::Option::None;
        self.building_type.clear();
        self.material.clear();
        self.building_flags = ::std::option::Option::None;
        self.is_room = ::std::option::Option::None;
        self.room.clear();
        self.direction = ::std::option::Option::None;
        self.items.clear();
        self.active = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildingInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RiverEdge {
    // message fields
    min_pos: ::std::option::Option<i32>,
    max_pos: ::std::option::Option<i32>,
    active: ::std::option::Option<i32>,
    elevation: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RiverEdge {
    fn default() -> &'a RiverEdge {
        <RiverEdge as ::protobuf::Message>::default_instance()
    }
}

impl RiverEdge {
    pub fn new() -> RiverEdge {
        ::std::default::Default::default()
    }

    // optional int32 min_pos = 1;


    pub fn get_min_pos(&self) -> i32 {
        self.min_pos.unwrap_or(0)
    }
    pub fn clear_min_pos(&mut self) {
        self.min_pos = ::std::option::Option::None;
    }

    pub fn has_min_pos(&self) -> bool {
        self.min_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_pos(&mut self, v: i32) {
        self.min_pos = ::std::option::Option::Some(v);
    }

    // optional int32 max_pos = 2;


    pub fn get_max_pos(&self) -> i32 {
        self.max_pos.unwrap_or(0)
    }
    pub fn clear_max_pos(&mut self) {
        self.max_pos = ::std::option::Option::None;
    }

    pub fn has_max_pos(&self) -> bool {
        self.max_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_pos(&mut self, v: i32) {
        self.max_pos = ::std::option::Option::Some(v);
    }

    // optional int32 active = 3;


    pub fn get_active(&self) -> i32 {
        self.active.unwrap_or(0)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: i32) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional int32 elevation = 4;


    pub fn get_elevation(&self) -> i32 {
        self.elevation.unwrap_or(0)
    }
    pub fn clear_elevation(&mut self) {
        self.elevation = ::std::option::Option::None;
    }

    pub fn has_elevation(&self) -> bool {
        self.elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevation(&mut self, v: i32) {
        self.elevation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RiverEdge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_pos = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_pos = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.elevation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.min_pos {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_pos {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.elevation {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.min_pos {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.max_pos {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.active {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.elevation {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiverEdge {
        RiverEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_pos",
                |m: &RiverEdge| { &m.min_pos },
                |m: &mut RiverEdge| { &mut m.min_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_pos",
                |m: &RiverEdge| { &m.max_pos },
                |m: &mut RiverEdge| { &mut m.max_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "active",
                |m: &RiverEdge| { &m.active },
                |m: &mut RiverEdge| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "elevation",
                |m: &RiverEdge| { &m.elevation },
                |m: &mut RiverEdge| { &mut m.elevation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RiverEdge>(
                "RiverEdge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RiverEdge {
        static instance: ::protobuf::rt::LazyV2<RiverEdge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RiverEdge::new)
    }
}

impl ::protobuf::Clear for RiverEdge {
    fn clear(&mut self) {
        self.min_pos = ::std::option::Option::None;
        self.max_pos = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.elevation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiverEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiverEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RiverTile {
    // message fields
    pub north: ::protobuf::SingularPtrField<RiverEdge>,
    pub south: ::protobuf::SingularPtrField<RiverEdge>,
    pub east: ::protobuf::SingularPtrField<RiverEdge>,
    pub west: ::protobuf::SingularPtrField<RiverEdge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RiverTile {
    fn default() -> &'a RiverTile {
        <RiverTile as ::protobuf::Message>::default_instance()
    }
}

impl RiverTile {
    pub fn new() -> RiverTile {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.RiverEdge north = 1;


    pub fn get_north(&self) -> &RiverEdge {
        self.north.as_ref().unwrap_or_else(|| <RiverEdge as ::protobuf::Message>::default_instance())
    }
    pub fn clear_north(&mut self) {
        self.north.clear();
    }

    pub fn has_north(&self) -> bool {
        self.north.is_some()
    }

    // Param is passed by value, moved
    pub fn set_north(&mut self, v: RiverEdge) {
        self.north = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_north(&mut self) -> &mut RiverEdge {
        if self.north.is_none() {
            self.north.set_default();
        }
        self.north.as_mut().unwrap()
    }

    // Take field
    pub fn take_north(&mut self) -> RiverEdge {
        self.north.take().unwrap_or_else(|| RiverEdge::new())
    }

    // optional .RemoteFortressReader.RiverEdge south = 2;


    pub fn get_south(&self) -> &RiverEdge {
        self.south.as_ref().unwrap_or_else(|| <RiverEdge as ::protobuf::Message>::default_instance())
    }
    pub fn clear_south(&mut self) {
        self.south.clear();
    }

    pub fn has_south(&self) -> bool {
        self.south.is_some()
    }

    // Param is passed by value, moved
    pub fn set_south(&mut self, v: RiverEdge) {
        self.south = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_south(&mut self) -> &mut RiverEdge {
        if self.south.is_none() {
            self.south.set_default();
        }
        self.south.as_mut().unwrap()
    }

    // Take field
    pub fn take_south(&mut self) -> RiverEdge {
        self.south.take().unwrap_or_else(|| RiverEdge::new())
    }

    // optional .RemoteFortressReader.RiverEdge east = 3;


    pub fn get_east(&self) -> &RiverEdge {
        self.east.as_ref().unwrap_or_else(|| <RiverEdge as ::protobuf::Message>::default_instance())
    }
    pub fn clear_east(&mut self) {
        self.east.clear();
    }

    pub fn has_east(&self) -> bool {
        self.east.is_some()
    }

    // Param is passed by value, moved
    pub fn set_east(&mut self, v: RiverEdge) {
        self.east = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_east(&mut self) -> &mut RiverEdge {
        if self.east.is_none() {
            self.east.set_default();
        }
        self.east.as_mut().unwrap()
    }

    // Take field
    pub fn take_east(&mut self) -> RiverEdge {
        self.east.take().unwrap_or_else(|| RiverEdge::new())
    }

    // optional .RemoteFortressReader.RiverEdge west = 4;


    pub fn get_west(&self) -> &RiverEdge {
        self.west.as_ref().unwrap_or_else(|| <RiverEdge as ::protobuf::Message>::default_instance())
    }
    pub fn clear_west(&mut self) {
        self.west.clear();
    }

    pub fn has_west(&self) -> bool {
        self.west.is_some()
    }

    // Param is passed by value, moved
    pub fn set_west(&mut self, v: RiverEdge) {
        self.west = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_west(&mut self) -> &mut RiverEdge {
        if self.west.is_none() {
            self.west.set_default();
        }
        self.west.as_mut().unwrap()
    }

    // Take field
    pub fn take_west(&mut self) -> RiverEdge {
        self.west.take().unwrap_or_else(|| RiverEdge::new())
    }
}

impl ::protobuf::Message for RiverTile {
    fn is_initialized(&self) -> bool {
        for v in &self.north {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.south {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.east {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.west {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.north)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.south)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.east)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.west)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.north.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.south.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.east.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.west.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.north.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.south.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.east.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.west.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiverTile {
        RiverTile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiverEdge>>(
                "north",
                |m: &RiverTile| { &m.north },
                |m: &mut RiverTile| { &mut m.north },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiverEdge>>(
                "south",
                |m: &RiverTile| { &m.south },
                |m: &mut RiverTile| { &mut m.south },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiverEdge>>(
                "east",
                |m: &RiverTile| { &m.east },
                |m: &mut RiverTile| { &mut m.east },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiverEdge>>(
                "west",
                |m: &RiverTile| { &m.west },
                |m: &mut RiverTile| { &mut m.west },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RiverTile>(
                "RiverTile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RiverTile {
        static instance: ::protobuf::rt::LazyV2<RiverTile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RiverTile::new)
    }
}

impl ::protobuf::Clear for RiverTile {
    fn clear(&mut self) {
        self.north.clear();
        self.south.clear();
        self.east.clear();
        self.west.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiverTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiverTile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Spatter {
    // message fields
    pub material: ::protobuf::SingularPtrField<MatPair>,
    amount: ::std::option::Option<i32>,
    state: ::std::option::Option<MatterState>,
    pub item: ::protobuf::SingularPtrField<MatPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Spatter {
    fn default() -> &'a Spatter {
        <Spatter as ::protobuf::Message>::default_instance()
    }
}

impl Spatter {
    pub fn new() -> Spatter {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.MatPair material = 1;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional int32 amount = 2;


    pub fn get_amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatterState state = 3;


    pub fn get_state(&self) -> MatterState {
        self.state.unwrap_or(MatterState::Solid)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: MatterState) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair item = 4;


    pub fn get_item(&self) -> &MatPair {
        self.item.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: MatPair) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut MatPair {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> MatPair {
        self.item.take().unwrap_or_else(|| MatPair::new())
    }
}

impl ::protobuf::Message for Spatter {
    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.amount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Spatter {
        Spatter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &Spatter| { &m.material },
                |m: &mut Spatter| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "amount",
                |m: &Spatter| { &m.amount },
                |m: &mut Spatter| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MatterState>>(
                "state",
                |m: &Spatter| { &m.state },
                |m: &mut Spatter| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "item",
                |m: &Spatter| { &m.item },
                |m: &mut Spatter| { &mut m.item },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Spatter>(
                "Spatter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Spatter {
        static instance: ::protobuf::rt::LazyV2<Spatter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Spatter::new)
    }
}

impl ::protobuf::Clear for Spatter {
    fn clear(&mut self) {
        self.material.clear();
        self.amount = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Spatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Spatter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpatterPile {
    // message fields
    pub spatters: ::protobuf::RepeatedField<Spatter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpatterPile {
    fn default() -> &'a SpatterPile {
        <SpatterPile as ::protobuf::Message>::default_instance()
    }
}

impl SpatterPile {
    pub fn new() -> SpatterPile {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.Spatter spatters = 1;


    pub fn get_spatters(&self) -> &[Spatter] {
        &self.spatters
    }
    pub fn clear_spatters(&mut self) {
        self.spatters.clear();
    }

    // Param is passed by value, moved
    pub fn set_spatters(&mut self, v: ::protobuf::RepeatedField<Spatter>) {
        self.spatters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spatters(&mut self) -> &mut ::protobuf::RepeatedField<Spatter> {
        &mut self.spatters
    }

    // Take field
    pub fn take_spatters(&mut self) -> ::protobuf::RepeatedField<Spatter> {
        ::std::mem::replace(&mut self.spatters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SpatterPile {
    fn is_initialized(&self) -> bool {
        for v in &self.spatters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spatters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.spatters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.spatters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpatterPile {
        SpatterPile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Spatter>>(
                "spatters",
                |m: &SpatterPile| { &m.spatters },
                |m: &mut SpatterPile| { &mut m.spatters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpatterPile>(
                "SpatterPile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpatterPile {
        static instance: ::protobuf::rt::LazyV2<SpatterPile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpatterPile::new)
    }
}

impl ::protobuf::Clear for SpatterPile {
    fn clear(&mut self) {
        self.spatters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpatterPile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatterPile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Item {
    // message fields
    id: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<Coord>,
    flags1: ::std::option::Option<u32>,
    flags2: ::std::option::Option<u32>,
    pub field_type: ::protobuf::SingularPtrField<MatPair>,
    pub material: ::protobuf::SingularPtrField<MatPair>,
    pub dye: ::protobuf::SingularPtrField<ColorDefinition>,
    stack_size: ::std::option::Option<i32>,
    subpos_x: ::std::option::Option<f32>,
    subpos_y: ::std::option::Option<f32>,
    subpos_z: ::std::option::Option<f32>,
    projectile: ::std::option::Option<bool>,
    velocity_x: ::std::option::Option<f32>,
    velocity_y: ::std::option::Option<f32>,
    velocity_z: ::std::option::Option<f32>,
    volume: ::std::option::Option<i32>,
    pub improvements: ::protobuf::RepeatedField<ItemImprovement>,
    pub image: ::protobuf::SingularPtrField<ArtImage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Item {
    fn default() -> &'a Item {
        <Item as ::protobuf::Message>::default_instance()
    }
}

impl Item {
    pub fn new() -> Item {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord pos = 2;


    pub fn get_pos(&self) -> &Coord {
        self.pos.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Coord) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Coord {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Coord {
        self.pos.take().unwrap_or_else(|| Coord::new())
    }

    // optional uint32 flags1 = 3;


    pub fn get_flags1(&self) -> u32 {
        self.flags1.unwrap_or(0)
    }
    pub fn clear_flags1(&mut self) {
        self.flags1 = ::std::option::Option::None;
    }

    pub fn has_flags1(&self) -> bool {
        self.flags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags1(&mut self, v: u32) {
        self.flags1 = ::std::option::Option::Some(v);
    }

    // optional uint32 flags2 = 4;


    pub fn get_flags2(&self) -> u32 {
        self.flags2.unwrap_or(0)
    }
    pub fn clear_flags2(&mut self) {
        self.flags2 = ::std::option::Option::None;
    }

    pub fn has_flags2(&self) -> bool {
        self.flags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags2(&mut self, v: u32) {
        self.flags2 = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair type = 5;


    pub fn get_field_type(&self) -> &MatPair {
        self.field_type.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: MatPair) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut MatPair {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> MatPair {
        self.field_type.take().unwrap_or_else(|| MatPair::new())
    }

    // optional .RemoteFortressReader.MatPair material = 6;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional .RemoteFortressReader.ColorDefinition dye = 7;


    pub fn get_dye(&self) -> &ColorDefinition {
        self.dye.as_ref().unwrap_or_else(|| <ColorDefinition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dye(&mut self) {
        self.dye.clear();
    }

    pub fn has_dye(&self) -> bool {
        self.dye.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dye(&mut self, v: ColorDefinition) {
        self.dye = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dye(&mut self) -> &mut ColorDefinition {
        if self.dye.is_none() {
            self.dye.set_default();
        }
        self.dye.as_mut().unwrap()
    }

    // Take field
    pub fn take_dye(&mut self) -> ColorDefinition {
        self.dye.take().unwrap_or_else(|| ColorDefinition::new())
    }

    // optional int32 stack_size = 8;


    pub fn get_stack_size(&self) -> i32 {
        self.stack_size.unwrap_or(0)
    }
    pub fn clear_stack_size(&mut self) {
        self.stack_size = ::std::option::Option::None;
    }

    pub fn has_stack_size(&self) -> bool {
        self.stack_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_size(&mut self, v: i32) {
        self.stack_size = ::std::option::Option::Some(v);
    }

    // optional float subpos_x = 9;


    pub fn get_subpos_x(&self) -> f32 {
        self.subpos_x.unwrap_or(0.)
    }
    pub fn clear_subpos_x(&mut self) {
        self.subpos_x = ::std::option::Option::None;
    }

    pub fn has_subpos_x(&self) -> bool {
        self.subpos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_x(&mut self, v: f32) {
        self.subpos_x = ::std::option::Option::Some(v);
    }

    // optional float subpos_y = 10;


    pub fn get_subpos_y(&self) -> f32 {
        self.subpos_y.unwrap_or(0.)
    }
    pub fn clear_subpos_y(&mut self) {
        self.subpos_y = ::std::option::Option::None;
    }

    pub fn has_subpos_y(&self) -> bool {
        self.subpos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_y(&mut self, v: f32) {
        self.subpos_y = ::std::option::Option::Some(v);
    }

    // optional float subpos_z = 11;


    pub fn get_subpos_z(&self) -> f32 {
        self.subpos_z.unwrap_or(0.)
    }
    pub fn clear_subpos_z(&mut self) {
        self.subpos_z = ::std::option::Option::None;
    }

    pub fn has_subpos_z(&self) -> bool {
        self.subpos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_z(&mut self, v: f32) {
        self.subpos_z = ::std::option::Option::Some(v);
    }

    // optional bool projectile = 12;


    pub fn get_projectile(&self) -> bool {
        self.projectile.unwrap_or(false)
    }
    pub fn clear_projectile(&mut self) {
        self.projectile = ::std::option::Option::None;
    }

    pub fn has_projectile(&self) -> bool {
        self.projectile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectile(&mut self, v: bool) {
        self.projectile = ::std::option::Option::Some(v);
    }

    // optional float velocity_x = 13;


    pub fn get_velocity_x(&self) -> f32 {
        self.velocity_x.unwrap_or(0.)
    }
    pub fn clear_velocity_x(&mut self) {
        self.velocity_x = ::std::option::Option::None;
    }

    pub fn has_velocity_x(&self) -> bool {
        self.velocity_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_x(&mut self, v: f32) {
        self.velocity_x = ::std::option::Option::Some(v);
    }

    // optional float velocity_y = 14;


    pub fn get_velocity_y(&self) -> f32 {
        self.velocity_y.unwrap_or(0.)
    }
    pub fn clear_velocity_y(&mut self) {
        self.velocity_y = ::std::option::Option::None;
    }

    pub fn has_velocity_y(&self) -> bool {
        self.velocity_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_y(&mut self, v: f32) {
        self.velocity_y = ::std::option::Option::Some(v);
    }

    // optional float velocity_z = 15;


    pub fn get_velocity_z(&self) -> f32 {
        self.velocity_z.unwrap_or(0.)
    }
    pub fn clear_velocity_z(&mut self) {
        self.velocity_z = ::std::option::Option::None;
    }

    pub fn has_velocity_z(&self) -> bool {
        self.velocity_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_z(&mut self, v: f32) {
        self.velocity_z = ::std::option::Option::Some(v);
    }

    // optional int32 volume = 16;


    pub fn get_volume(&self) -> i32 {
        self.volume.unwrap_or(0)
    }
    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i32) {
        self.volume = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.ItemImprovement improvements = 17;


    pub fn get_improvements(&self) -> &[ItemImprovement] {
        &self.improvements
    }
    pub fn clear_improvements(&mut self) {
        self.improvements.clear();
    }

    // Param is passed by value, moved
    pub fn set_improvements(&mut self, v: ::protobuf::RepeatedField<ItemImprovement>) {
        self.improvements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_improvements(&mut self) -> &mut ::protobuf::RepeatedField<ItemImprovement> {
        &mut self.improvements
    }

    // Take field
    pub fn take_improvements(&mut self) -> ::protobuf::RepeatedField<ItemImprovement> {
        ::std::mem::replace(&mut self.improvements, ::protobuf::RepeatedField::new())
    }

    // optional .RemoteFortressReader.ArtImage image = 18;


    pub fn get_image(&self) -> &ArtImage {
        self.image.as_ref().unwrap_or_else(|| <ArtImage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ArtImage) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ArtImage {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ArtImage {
        self.image.take().unwrap_or_else(|| ArtImage::new())
    }
}

impl ::protobuf::Message for Item {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dye {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.improvements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dye)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stack_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.subpos_x = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.subpos_y = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.subpos_z = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.projectile = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_x = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_y = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_z = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.volume = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.improvements)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags1 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags2 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dye.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stack_size {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subpos_x {
            my_size += 5;
        }
        if let Some(v) = self.subpos_y {
            my_size += 5;
        }
        if let Some(v) = self.subpos_z {
            my_size += 5;
        }
        if let Some(v) = self.projectile {
            my_size += 2;
        }
        if let Some(v) = self.velocity_x {
            my_size += 5;
        }
        if let Some(v) = self.velocity_y {
            my_size += 5;
        }
        if let Some(v) = self.velocity_z {
            my_size += 5;
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.improvements {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.flags2 {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dye.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stack_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.subpos_x {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.subpos_y {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.subpos_z {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.projectile {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.velocity_x {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.velocity_y {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.velocity_z {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int32(16, v)?;
        }
        for v in &self.improvements {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Item {
        Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Item| { &m.id },
                |m: &mut Item| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "pos",
                |m: &Item| { &m.pos },
                |m: &mut Item| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags1",
                |m: &Item| { &m.flags1 },
                |m: &mut Item| { &mut m.flags1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags2",
                |m: &Item| { &m.flags2 },
                |m: &mut Item| { &mut m.flags2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "type",
                |m: &Item| { &m.field_type },
                |m: &mut Item| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &Item| { &m.material },
                |m: &mut Item| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "dye",
                |m: &Item| { &m.dye },
                |m: &mut Item| { &mut m.dye },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stack_size",
                |m: &Item| { &m.stack_size },
                |m: &mut Item| { &mut m.stack_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "subpos_x",
                |m: &Item| { &m.subpos_x },
                |m: &mut Item| { &mut m.subpos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "subpos_y",
                |m: &Item| { &m.subpos_y },
                |m: &mut Item| { &mut m.subpos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "subpos_z",
                |m: &Item| { &m.subpos_z },
                |m: &mut Item| { &mut m.subpos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "projectile",
                |m: &Item| { &m.projectile },
                |m: &mut Item| { &mut m.projectile },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "velocity_x",
                |m: &Item| { &m.velocity_x },
                |m: &mut Item| { &mut m.velocity_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "velocity_y",
                |m: &Item| { &m.velocity_y },
                |m: &mut Item| { &mut m.velocity_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "velocity_z",
                |m: &Item| { &m.velocity_z },
                |m: &mut Item| { &mut m.velocity_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "volume",
                |m: &Item| { &m.volume },
                |m: &mut Item| { &mut m.volume },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ItemImprovement>>(
                "improvements",
                |m: &Item| { &m.improvements },
                |m: &mut Item| { &mut m.improvements },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtImage>>(
                "image",
                |m: &Item| { &m.image },
                |m: &mut Item| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Item>(
                "Item",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Item {
        static instance: ::protobuf::rt::LazyV2<Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Item::new)
    }
}

impl ::protobuf::Clear for Item {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.pos.clear();
        self.flags1 = ::std::option::Option::None;
        self.flags2 = ::std::option::Option::None;
        self.field_type.clear();
        self.material.clear();
        self.dye.clear();
        self.stack_size = ::std::option::Option::None;
        self.subpos_x = ::std::option::Option::None;
        self.subpos_y = ::std::option::Option::None;
        self.subpos_z = ::std::option::Option::None;
        self.projectile = ::std::option::Option::None;
        self.velocity_x = ::std::option::Option::None;
        self.velocity_y = ::std::option::Option::None;
        self.velocity_z = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.improvements.clear();
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlantTile {
    // message fields
    trunk: ::std::option::Option<bool>,
    connection_east: ::std::option::Option<bool>,
    connection_south: ::std::option::Option<bool>,
    connection_west: ::std::option::Option<bool>,
    connection_north: ::std::option::Option<bool>,
    branches: ::std::option::Option<bool>,
    twigs: ::std::option::Option<bool>,
    tile_type: ::std::option::Option<TiletypeSpecial>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlantTile {
    fn default() -> &'a PlantTile {
        <PlantTile as ::protobuf::Message>::default_instance()
    }
}

impl PlantTile {
    pub fn new() -> PlantTile {
        ::std::default::Default::default()
    }

    // optional bool trunk = 1;


    pub fn get_trunk(&self) -> bool {
        self.trunk.unwrap_or(false)
    }
    pub fn clear_trunk(&mut self) {
        self.trunk = ::std::option::Option::None;
    }

    pub fn has_trunk(&self) -> bool {
        self.trunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk(&mut self, v: bool) {
        self.trunk = ::std::option::Option::Some(v);
    }

    // optional bool connection_east = 2;


    pub fn get_connection_east(&self) -> bool {
        self.connection_east.unwrap_or(false)
    }
    pub fn clear_connection_east(&mut self) {
        self.connection_east = ::std::option::Option::None;
    }

    pub fn has_connection_east(&self) -> bool {
        self.connection_east.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_east(&mut self, v: bool) {
        self.connection_east = ::std::option::Option::Some(v);
    }

    // optional bool connection_south = 3;


    pub fn get_connection_south(&self) -> bool {
        self.connection_south.unwrap_or(false)
    }
    pub fn clear_connection_south(&mut self) {
        self.connection_south = ::std::option::Option::None;
    }

    pub fn has_connection_south(&self) -> bool {
        self.connection_south.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_south(&mut self, v: bool) {
        self.connection_south = ::std::option::Option::Some(v);
    }

    // optional bool connection_west = 4;


    pub fn get_connection_west(&self) -> bool {
        self.connection_west.unwrap_or(false)
    }
    pub fn clear_connection_west(&mut self) {
        self.connection_west = ::std::option::Option::None;
    }

    pub fn has_connection_west(&self) -> bool {
        self.connection_west.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_west(&mut self, v: bool) {
        self.connection_west = ::std::option::Option::Some(v);
    }

    // optional bool connection_north = 5;


    pub fn get_connection_north(&self) -> bool {
        self.connection_north.unwrap_or(false)
    }
    pub fn clear_connection_north(&mut self) {
        self.connection_north = ::std::option::Option::None;
    }

    pub fn has_connection_north(&self) -> bool {
        self.connection_north.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_north(&mut self, v: bool) {
        self.connection_north = ::std::option::Option::Some(v);
    }

    // optional bool branches = 6;


    pub fn get_branches(&self) -> bool {
        self.branches.unwrap_or(false)
    }
    pub fn clear_branches(&mut self) {
        self.branches = ::std::option::Option::None;
    }

    pub fn has_branches(&self) -> bool {
        self.branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branches(&mut self, v: bool) {
        self.branches = ::std::option::Option::Some(v);
    }

    // optional bool twigs = 7;


    pub fn get_twigs(&self) -> bool {
        self.twigs.unwrap_or(false)
    }
    pub fn clear_twigs(&mut self) {
        self.twigs = ::std::option::Option::None;
    }

    pub fn has_twigs(&self) -> bool {
        self.twigs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twigs(&mut self, v: bool) {
        self.twigs = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.TiletypeSpecial tile_type = 8;


    pub fn get_tile_type(&self) -> TiletypeSpecial {
        self.tile_type.unwrap_or(TiletypeSpecial::NO_SPECIAL)
    }
    pub fn clear_tile_type(&mut self) {
        self.tile_type = ::std::option::Option::None;
    }

    pub fn has_tile_type(&self) -> bool {
        self.tile_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile_type(&mut self, v: TiletypeSpecial) {
        self.tile_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlantTile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trunk = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connection_east = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connection_south = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connection_west = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connection_north = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.branches = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.twigs = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.tile_type, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trunk {
            my_size += 2;
        }
        if let Some(v) = self.connection_east {
            my_size += 2;
        }
        if let Some(v) = self.connection_south {
            my_size += 2;
        }
        if let Some(v) = self.connection_west {
            my_size += 2;
        }
        if let Some(v) = self.connection_north {
            my_size += 2;
        }
        if let Some(v) = self.branches {
            my_size += 2;
        }
        if let Some(v) = self.twigs {
            my_size += 2;
        }
        if let Some(v) = self.tile_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trunk {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.connection_east {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.connection_south {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.connection_west {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.connection_north {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.branches {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.twigs {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.tile_type {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlantTile {
        PlantTile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trunk",
                |m: &PlantTile| { &m.trunk },
                |m: &mut PlantTile| { &mut m.trunk },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connection_east",
                |m: &PlantTile| { &m.connection_east },
                |m: &mut PlantTile| { &mut m.connection_east },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connection_south",
                |m: &PlantTile| { &m.connection_south },
                |m: &mut PlantTile| { &mut m.connection_south },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connection_west",
                |m: &PlantTile| { &m.connection_west },
                |m: &mut PlantTile| { &mut m.connection_west },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connection_north",
                |m: &PlantTile| { &m.connection_north },
                |m: &mut PlantTile| { &mut m.connection_north },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "branches",
                |m: &PlantTile| { &m.branches },
                |m: &mut PlantTile| { &mut m.branches },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "twigs",
                |m: &PlantTile| { &m.twigs },
                |m: &mut PlantTile| { &mut m.twigs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TiletypeSpecial>>(
                "tile_type",
                |m: &PlantTile| { &m.tile_type },
                |m: &mut PlantTile| { &mut m.tile_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlantTile>(
                "PlantTile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlantTile {
        static instance: ::protobuf::rt::LazyV2<PlantTile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlantTile::new)
    }
}

impl ::protobuf::Clear for PlantTile {
    fn clear(&mut self) {
        self.trunk = ::std::option::Option::None;
        self.connection_east = ::std::option::Option::None;
        self.connection_south = ::std::option::Option::None;
        self.connection_west = ::std::option::Option::None;
        self.connection_north = ::std::option::Option::None;
        self.branches = ::std::option::Option::None;
        self.twigs = ::std::option::Option::None;
        self.tile_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlantTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantTile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TreeInfo {
    // message fields
    pub size: ::protobuf::SingularPtrField<Coord>,
    pub tiles: ::protobuf::RepeatedField<PlantTile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TreeInfo {
    fn default() -> &'a TreeInfo {
        <TreeInfo as ::protobuf::Message>::default_instance()
    }
}

impl TreeInfo {
    pub fn new() -> TreeInfo {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.Coord size = 1;


    pub fn get_size(&self) -> &Coord {
        self.size.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_size(&mut self) {
        self.size.clear();
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: Coord) {
        self.size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size(&mut self) -> &mut Coord {
        if self.size.is_none() {
            self.size.set_default();
        }
        self.size.as_mut().unwrap()
    }

    // Take field
    pub fn take_size(&mut self) -> Coord {
        self.size.take().unwrap_or_else(|| Coord::new())
    }

    // repeated .RemoteFortressReader.PlantTile tiles = 2;


    pub fn get_tiles(&self) -> &[PlantTile] {
        &self.tiles
    }
    pub fn clear_tiles(&mut self) {
        self.tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiles(&mut self, v: ::protobuf::RepeatedField<PlantTile>) {
        self.tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiles(&mut self) -> &mut ::protobuf::RepeatedField<PlantTile> {
        &mut self.tiles
    }

    // Take field
    pub fn take_tiles(&mut self) -> ::protobuf::RepeatedField<PlantTile> {
        ::std::mem::replace(&mut self.tiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TreeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.size {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.size.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tiles {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TreeInfo {
        TreeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "size",
                |m: &TreeInfo| { &m.size },
                |m: &mut TreeInfo| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlantTile>>(
                "tiles",
                |m: &TreeInfo| { &m.tiles },
                |m: &mut TreeInfo| { &mut m.tiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TreeInfo>(
                "TreeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TreeInfo {
        static instance: ::protobuf::rt::LazyV2<TreeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TreeInfo::new)
    }
}

impl ::protobuf::Clear for TreeInfo {
    fn clear(&mut self) {
        self.size.clear();
        self.tiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TreeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlantInstance {
    // message fields
    plant_type: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<Coord>,
    pub tree_info: ::protobuf::SingularPtrField<TreeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlantInstance {
    fn default() -> &'a PlantInstance {
        <PlantInstance as ::protobuf::Message>::default_instance()
    }
}

impl PlantInstance {
    pub fn new() -> PlantInstance {
        ::std::default::Default::default()
    }

    // optional int32 plant_type = 1;


    pub fn get_plant_type(&self) -> i32 {
        self.plant_type.unwrap_or(0)
    }
    pub fn clear_plant_type(&mut self) {
        self.plant_type = ::std::option::Option::None;
    }

    pub fn has_plant_type(&self) -> bool {
        self.plant_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plant_type(&mut self, v: i32) {
        self.plant_type = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord pos = 2;


    pub fn get_pos(&self) -> &Coord {
        self.pos.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Coord) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Coord {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Coord {
        self.pos.take().unwrap_or_else(|| Coord::new())
    }

    // optional .RemoteFortressReader.TreeInfo tree_info = 3;


    pub fn get_tree_info(&self) -> &TreeInfo {
        self.tree_info.as_ref().unwrap_or_else(|| <TreeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tree_info(&mut self) {
        self.tree_info.clear();
    }

    pub fn has_tree_info(&self) -> bool {
        self.tree_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tree_info(&mut self, v: TreeInfo) {
        self.tree_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tree_info(&mut self) -> &mut TreeInfo {
        if self.tree_info.is_none() {
            self.tree_info.set_default();
        }
        self.tree_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tree_info(&mut self) -> TreeInfo {
        self.tree_info.take().unwrap_or_else(|| TreeInfo::new())
    }
}

impl ::protobuf::Message for PlantInstance {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tree_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.plant_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tree_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.plant_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tree_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.plant_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tree_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlantInstance {
        PlantInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "plant_type",
                |m: &PlantInstance| { &m.plant_type },
                |m: &mut PlantInstance| { &mut m.plant_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "pos",
                |m: &PlantInstance| { &m.pos },
                |m: &mut PlantInstance| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TreeInfo>>(
                "tree_info",
                |m: &PlantInstance| { &m.tree_info },
                |m: &mut PlantInstance| { &mut m.tree_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlantInstance>(
                "PlantInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlantInstance {
        static instance: ::protobuf::rt::LazyV2<PlantInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlantInstance::new)
    }
}

impl ::protobuf::Clear for PlantInstance {
    fn clear(&mut self) {
        self.plant_type = ::std::option::Option::None;
        self.pos.clear();
        self.tree_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlantInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapBlock {
    // message fields
    map_x: ::std::option::Option<i32>,
    map_y: ::std::option::Option<i32>,
    map_z: ::std::option::Option<i32>,
    pub tiles: ::std::vec::Vec<i32>,
    pub materials: ::protobuf::RepeatedField<MatPair>,
    pub layer_materials: ::protobuf::RepeatedField<MatPair>,
    pub vein_materials: ::protobuf::RepeatedField<MatPair>,
    pub base_materials: ::protobuf::RepeatedField<MatPair>,
    pub magma: ::std::vec::Vec<i32>,
    pub water: ::std::vec::Vec<i32>,
    pub hidden: ::std::vec::Vec<bool>,
    pub light: ::std::vec::Vec<bool>,
    pub subterranean: ::std::vec::Vec<bool>,
    pub outside: ::std::vec::Vec<bool>,
    pub aquifer: ::std::vec::Vec<bool>,
    pub water_stagnant: ::std::vec::Vec<bool>,
    pub water_salt: ::std::vec::Vec<bool>,
    pub construction_items: ::protobuf::RepeatedField<MatPair>,
    pub buildings: ::protobuf::RepeatedField<BuildingInstance>,
    pub tree_percent: ::std::vec::Vec<i32>,
    pub tree_x: ::std::vec::Vec<i32>,
    pub tree_y: ::std::vec::Vec<i32>,
    pub tree_z: ::std::vec::Vec<i32>,
    pub tile_dig_designation: ::std::vec::Vec<TileDigDesignation>,
    pub spatterPile: ::protobuf::RepeatedField<SpatterPile>,
    pub items: ::protobuf::RepeatedField<Item>,
    pub tile_dig_designation_marker: ::std::vec::Vec<bool>,
    pub tile_dig_designation_auto: ::std::vec::Vec<bool>,
    pub grass_percent: ::std::vec::Vec<i32>,
    pub flows: ::protobuf::RepeatedField<FlowInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapBlock {
    fn default() -> &'a MapBlock {
        <MapBlock as ::protobuf::Message>::default_instance()
    }
}

impl MapBlock {
    pub fn new() -> MapBlock {
        ::std::default::Default::default()
    }

    // required int32 map_x = 1;


    pub fn get_map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }
    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // required int32 map_y = 2;


    pub fn get_map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }
    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // required int32 map_z = 3;


    pub fn get_map_z(&self) -> i32 {
        self.map_z.unwrap_or(0)
    }
    pub fn clear_map_z(&mut self) {
        self.map_z = ::std::option::Option::None;
    }

    pub fn has_map_z(&self) -> bool {
        self.map_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_z(&mut self, v: i32) {
        self.map_z = ::std::option::Option::Some(v);
    }

    // repeated int32 tiles = 4;


    pub fn get_tiles(&self) -> &[i32] {
        &self.tiles
    }
    pub fn clear_tiles(&mut self) {
        self.tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiles(&mut self, v: ::std::vec::Vec<i32>) {
        self.tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiles(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tiles
    }

    // Take field
    pub fn take_tiles(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tiles, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.MatPair materials = 5;


    pub fn get_materials(&self) -> &[MatPair] {
        &self.materials
    }
    pub fn clear_materials(&mut self) {
        self.materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.materials
    }

    // Take field
    pub fn take_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.materials, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.MatPair layer_materials = 6;


    pub fn get_layer_materials(&self) -> &[MatPair] {
        &self.layer_materials
    }
    pub fn clear_layer_materials(&mut self) {
        self.layer_materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_layer_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.layer_materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_layer_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.layer_materials
    }

    // Take field
    pub fn take_layer_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.layer_materials, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.MatPair vein_materials = 7;


    pub fn get_vein_materials(&self) -> &[MatPair] {
        &self.vein_materials
    }
    pub fn clear_vein_materials(&mut self) {
        self.vein_materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_vein_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.vein_materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vein_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.vein_materials
    }

    // Take field
    pub fn take_vein_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.vein_materials, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.MatPair base_materials = 8;


    pub fn get_base_materials(&self) -> &[MatPair] {
        &self.base_materials
    }
    pub fn clear_base_materials(&mut self) {
        self.base_materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.base_materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_base_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.base_materials
    }

    // Take field
    pub fn take_base_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.base_materials, ::protobuf::RepeatedField::new())
    }

    // repeated int32 magma = 9;


    pub fn get_magma(&self) -> &[i32] {
        &self.magma
    }
    pub fn clear_magma(&mut self) {
        self.magma.clear();
    }

    // Param is passed by value, moved
    pub fn set_magma(&mut self, v: ::std::vec::Vec<i32>) {
        self.magma = v;
    }

    // Mutable pointer to the field.
    pub fn mut_magma(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.magma
    }

    // Take field
    pub fn take_magma(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.magma, ::std::vec::Vec::new())
    }

    // repeated int32 water = 10;


    pub fn get_water(&self) -> &[i32] {
        &self.water
    }
    pub fn clear_water(&mut self) {
        self.water.clear();
    }

    // Param is passed by value, moved
    pub fn set_water(&mut self, v: ::std::vec::Vec<i32>) {
        self.water = v;
    }

    // Mutable pointer to the field.
    pub fn mut_water(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.water
    }

    // Take field
    pub fn take_water(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.water, ::std::vec::Vec::new())
    }

    // repeated bool hidden = 11;


    pub fn get_hidden(&self) -> &[bool] {
        &self.hidden
    }
    pub fn clear_hidden(&mut self) {
        self.hidden.clear();
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: ::std::vec::Vec<bool>) {
        self.hidden = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hidden(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.hidden
    }

    // Take field
    pub fn take_hidden(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.hidden, ::std::vec::Vec::new())
    }

    // repeated bool light = 12;


    pub fn get_light(&self) -> &[bool] {
        &self.light
    }
    pub fn clear_light(&mut self) {
        self.light.clear();
    }

    // Param is passed by value, moved
    pub fn set_light(&mut self, v: ::std::vec::Vec<bool>) {
        self.light = v;
    }

    // Mutable pointer to the field.
    pub fn mut_light(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.light
    }

    // Take field
    pub fn take_light(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.light, ::std::vec::Vec::new())
    }

    // repeated bool subterranean = 13;


    pub fn get_subterranean(&self) -> &[bool] {
        &self.subterranean
    }
    pub fn clear_subterranean(&mut self) {
        self.subterranean.clear();
    }

    // Param is passed by value, moved
    pub fn set_subterranean(&mut self, v: ::std::vec::Vec<bool>) {
        self.subterranean = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subterranean(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.subterranean
    }

    // Take field
    pub fn take_subterranean(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.subterranean, ::std::vec::Vec::new())
    }

    // repeated bool outside = 14;


    pub fn get_outside(&self) -> &[bool] {
        &self.outside
    }
    pub fn clear_outside(&mut self) {
        self.outside.clear();
    }

    // Param is passed by value, moved
    pub fn set_outside(&mut self, v: ::std::vec::Vec<bool>) {
        self.outside = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outside(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.outside
    }

    // Take field
    pub fn take_outside(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.outside, ::std::vec::Vec::new())
    }

    // repeated bool aquifer = 15;


    pub fn get_aquifer(&self) -> &[bool] {
        &self.aquifer
    }
    pub fn clear_aquifer(&mut self) {
        self.aquifer.clear();
    }

    // Param is passed by value, moved
    pub fn set_aquifer(&mut self, v: ::std::vec::Vec<bool>) {
        self.aquifer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aquifer(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.aquifer
    }

    // Take field
    pub fn take_aquifer(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.aquifer, ::std::vec::Vec::new())
    }

    // repeated bool water_stagnant = 16;


    pub fn get_water_stagnant(&self) -> &[bool] {
        &self.water_stagnant
    }
    pub fn clear_water_stagnant(&mut self) {
        self.water_stagnant.clear();
    }

    // Param is passed by value, moved
    pub fn set_water_stagnant(&mut self, v: ::std::vec::Vec<bool>) {
        self.water_stagnant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_water_stagnant(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.water_stagnant
    }

    // Take field
    pub fn take_water_stagnant(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.water_stagnant, ::std::vec::Vec::new())
    }

    // repeated bool water_salt = 17;


    pub fn get_water_salt(&self) -> &[bool] {
        &self.water_salt
    }
    pub fn clear_water_salt(&mut self) {
        self.water_salt.clear();
    }

    // Param is passed by value, moved
    pub fn set_water_salt(&mut self, v: ::std::vec::Vec<bool>) {
        self.water_salt = v;
    }

    // Mutable pointer to the field.
    pub fn mut_water_salt(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.water_salt
    }

    // Take field
    pub fn take_water_salt(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.water_salt, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.MatPair construction_items = 18;


    pub fn get_construction_items(&self) -> &[MatPair] {
        &self.construction_items
    }
    pub fn clear_construction_items(&mut self) {
        self.construction_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_construction_items(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.construction_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_construction_items(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.construction_items
    }

    // Take field
    pub fn take_construction_items(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.construction_items, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.BuildingInstance buildings = 19;


    pub fn get_buildings(&self) -> &[BuildingInstance] {
        &self.buildings
    }
    pub fn clear_buildings(&mut self) {
        self.buildings.clear();
    }

    // Param is passed by value, moved
    pub fn set_buildings(&mut self, v: ::protobuf::RepeatedField<BuildingInstance>) {
        self.buildings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buildings(&mut self) -> &mut ::protobuf::RepeatedField<BuildingInstance> {
        &mut self.buildings
    }

    // Take field
    pub fn take_buildings(&mut self) -> ::protobuf::RepeatedField<BuildingInstance> {
        ::std::mem::replace(&mut self.buildings, ::protobuf::RepeatedField::new())
    }

    // repeated int32 tree_percent = 20;


    pub fn get_tree_percent(&self) -> &[i32] {
        &self.tree_percent
    }
    pub fn clear_tree_percent(&mut self) {
        self.tree_percent.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_percent(&mut self, v: ::std::vec::Vec<i32>) {
        self.tree_percent = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_percent(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tree_percent
    }

    // Take field
    pub fn take_tree_percent(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tree_percent, ::std::vec::Vec::new())
    }

    // repeated int32 tree_x = 21;


    pub fn get_tree_x(&self) -> &[i32] {
        &self.tree_x
    }
    pub fn clear_tree_x(&mut self) {
        self.tree_x.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_x(&mut self, v: ::std::vec::Vec<i32>) {
        self.tree_x = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_x(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tree_x
    }

    // Take field
    pub fn take_tree_x(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tree_x, ::std::vec::Vec::new())
    }

    // repeated int32 tree_y = 22;


    pub fn get_tree_y(&self) -> &[i32] {
        &self.tree_y
    }
    pub fn clear_tree_y(&mut self) {
        self.tree_y.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_y(&mut self, v: ::std::vec::Vec<i32>) {
        self.tree_y = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_y(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tree_y
    }

    // Take field
    pub fn take_tree_y(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tree_y, ::std::vec::Vec::new())
    }

    // repeated int32 tree_z = 23;


    pub fn get_tree_z(&self) -> &[i32] {
        &self.tree_z
    }
    pub fn clear_tree_z(&mut self) {
        self.tree_z.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_z(&mut self, v: ::std::vec::Vec<i32>) {
        self.tree_z = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_z(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tree_z
    }

    // Take field
    pub fn take_tree_z(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tree_z, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.TileDigDesignation tile_dig_designation = 24;


    pub fn get_tile_dig_designation(&self) -> &[TileDigDesignation] {
        &self.tile_dig_designation
    }
    pub fn clear_tile_dig_designation(&mut self) {
        self.tile_dig_designation.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_dig_designation(&mut self, v: ::std::vec::Vec<TileDigDesignation>) {
        self.tile_dig_designation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_dig_designation(&mut self) -> &mut ::std::vec::Vec<TileDigDesignation> {
        &mut self.tile_dig_designation
    }

    // Take field
    pub fn take_tile_dig_designation(&mut self) -> ::std::vec::Vec<TileDigDesignation> {
        ::std::mem::replace(&mut self.tile_dig_designation, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.SpatterPile spatterPile = 25;


    pub fn get_spatterPile(&self) -> &[SpatterPile] {
        &self.spatterPile
    }
    pub fn clear_spatterPile(&mut self) {
        self.spatterPile.clear();
    }

    // Param is passed by value, moved
    pub fn set_spatterPile(&mut self, v: ::protobuf::RepeatedField<SpatterPile>) {
        self.spatterPile = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spatterPile(&mut self) -> &mut ::protobuf::RepeatedField<SpatterPile> {
        &mut self.spatterPile
    }

    // Take field
    pub fn take_spatterPile(&mut self) -> ::protobuf::RepeatedField<SpatterPile> {
        ::std::mem::replace(&mut self.spatterPile, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.Item items = 26;


    pub fn get_items(&self) -> &[Item] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // repeated bool tile_dig_designation_marker = 27;


    pub fn get_tile_dig_designation_marker(&self) -> &[bool] {
        &self.tile_dig_designation_marker
    }
    pub fn clear_tile_dig_designation_marker(&mut self) {
        self.tile_dig_designation_marker.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_dig_designation_marker(&mut self, v: ::std::vec::Vec<bool>) {
        self.tile_dig_designation_marker = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_dig_designation_marker(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.tile_dig_designation_marker
    }

    // Take field
    pub fn take_tile_dig_designation_marker(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.tile_dig_designation_marker, ::std::vec::Vec::new())
    }

    // repeated bool tile_dig_designation_auto = 28;


    pub fn get_tile_dig_designation_auto(&self) -> &[bool] {
        &self.tile_dig_designation_auto
    }
    pub fn clear_tile_dig_designation_auto(&mut self) {
        self.tile_dig_designation_auto.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_dig_designation_auto(&mut self, v: ::std::vec::Vec<bool>) {
        self.tile_dig_designation_auto = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_dig_designation_auto(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.tile_dig_designation_auto
    }

    // Take field
    pub fn take_tile_dig_designation_auto(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.tile_dig_designation_auto, ::std::vec::Vec::new())
    }

    // repeated int32 grass_percent = 29;


    pub fn get_grass_percent(&self) -> &[i32] {
        &self.grass_percent
    }
    pub fn clear_grass_percent(&mut self) {
        self.grass_percent.clear();
    }

    // Param is passed by value, moved
    pub fn set_grass_percent(&mut self, v: ::std::vec::Vec<i32>) {
        self.grass_percent = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grass_percent(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.grass_percent
    }

    // Take field
    pub fn take_grass_percent(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.grass_percent, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.FlowInfo flows = 30;


    pub fn get_flows(&self) -> &[FlowInfo] {
        &self.flows
    }
    pub fn clear_flows(&mut self) {
        self.flows.clear();
    }

    // Param is passed by value, moved
    pub fn set_flows(&mut self, v: ::protobuf::RepeatedField<FlowInfo>) {
        self.flows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flows(&mut self) -> &mut ::protobuf::RepeatedField<FlowInfo> {
        &mut self.flows
    }

    // Take field
    pub fn take_flows(&mut self) -> ::protobuf::RepeatedField<FlowInfo> {
        ::std::mem::replace(&mut self.flows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MapBlock {
    fn is_initialized(&self) -> bool {
        if self.map_x.is_none() {
            return false;
        }
        if self.map_y.is_none() {
            return false;
        }
        if self.map_z.is_none() {
            return false;
        }
        for v in &self.materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.layer_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vein_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.base_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.construction_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spatterPile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_z = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tiles)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.materials)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.layer_materials)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vein_materials)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.base_materials)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.magma)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.water)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.hidden)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.light)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.subterranean)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.outside)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.aquifer)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.water_stagnant)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.water_salt)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.construction_items)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buildings)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tree_percent)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tree_x)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tree_y)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tree_z)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.tile_dig_designation, 24, &mut self.unknown_fields)?
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spatterPile)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                27 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.tile_dig_designation_marker)?;
                },
                28 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.tile_dig_designation_auto)?;
                },
                29 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.grass_percent)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.flows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_z {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tiles {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.layer_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.vein_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.base_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.magma {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.water {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 2 * self.hidden.len() as u32;
        my_size += 2 * self.light.len() as u32;
        my_size += 2 * self.subterranean.len() as u32;
        my_size += 2 * self.outside.len() as u32;
        my_size += 2 * self.aquifer.len() as u32;
        my_size += 3 * self.water_stagnant.len() as u32;
        my_size += 3 * self.water_salt.len() as u32;
        for value in &self.construction_items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tree_percent {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tree_x {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tree_y {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tree_z {
            my_size += ::protobuf::rt::value_size(23, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tile_dig_designation {
            my_size += ::protobuf::rt::enum_size(24, *value);
        };
        for value in &self.spatterPile {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 3 * self.tile_dig_designation_marker.len() as u32;
        my_size += 3 * self.tile_dig_designation_auto.len() as u32;
        for value in &self.grass_percent {
            my_size += ::protobuf::rt::value_size(29, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.flows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.map_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.map_z {
            os.write_int32(3, v)?;
        }
        for v in &self.tiles {
            os.write_int32(4, *v)?;
        };
        for v in &self.materials {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.layer_materials {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.vein_materials {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.base_materials {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.magma {
            os.write_int32(9, *v)?;
        };
        for v in &self.water {
            os.write_int32(10, *v)?;
        };
        for v in &self.hidden {
            os.write_bool(11, *v)?;
        };
        for v in &self.light {
            os.write_bool(12, *v)?;
        };
        for v in &self.subterranean {
            os.write_bool(13, *v)?;
        };
        for v in &self.outside {
            os.write_bool(14, *v)?;
        };
        for v in &self.aquifer {
            os.write_bool(15, *v)?;
        };
        for v in &self.water_stagnant {
            os.write_bool(16, *v)?;
        };
        for v in &self.water_salt {
            os.write_bool(17, *v)?;
        };
        for v in &self.construction_items {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buildings {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tree_percent {
            os.write_int32(20, *v)?;
        };
        for v in &self.tree_x {
            os.write_int32(21, *v)?;
        };
        for v in &self.tree_y {
            os.write_int32(22, *v)?;
        };
        for v in &self.tree_z {
            os.write_int32(23, *v)?;
        };
        for v in &self.tile_dig_designation {
            os.write_enum(24, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.spatterPile {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.items {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tile_dig_designation_marker {
            os.write_bool(27, *v)?;
        };
        for v in &self.tile_dig_designation_auto {
            os.write_bool(28, *v)?;
        };
        for v in &self.grass_percent {
            os.write_int32(29, *v)?;
        };
        for v in &self.flows {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapBlock {
        MapBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_x",
                |m: &MapBlock| { &m.map_x },
                |m: &mut MapBlock| { &mut m.map_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_y",
                |m: &MapBlock| { &m.map_y },
                |m: &mut MapBlock| { &mut m.map_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_z",
                |m: &MapBlock| { &m.map_z },
                |m: &mut MapBlock| { &mut m.map_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tiles",
                |m: &MapBlock| { &m.tiles },
                |m: &mut MapBlock| { &mut m.tiles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "materials",
                |m: &MapBlock| { &m.materials },
                |m: &mut MapBlock| { &mut m.materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "layer_materials",
                |m: &MapBlock| { &m.layer_materials },
                |m: &mut MapBlock| { &mut m.layer_materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "vein_materials",
                |m: &MapBlock| { &m.vein_materials },
                |m: &mut MapBlock| { &mut m.vein_materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "base_materials",
                |m: &MapBlock| { &m.base_materials },
                |m: &mut MapBlock| { &mut m.base_materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "magma",
                |m: &MapBlock| { &m.magma },
                |m: &mut MapBlock| { &mut m.magma },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "water",
                |m: &MapBlock| { &m.water },
                |m: &mut MapBlock| { &mut m.water },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hidden",
                |m: &MapBlock| { &m.hidden },
                |m: &mut MapBlock| { &mut m.hidden },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "light",
                |m: &MapBlock| { &m.light },
                |m: &mut MapBlock| { &mut m.light },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "subterranean",
                |m: &MapBlock| { &m.subterranean },
                |m: &mut MapBlock| { &mut m.subterranean },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "outside",
                |m: &MapBlock| { &m.outside },
                |m: &mut MapBlock| { &mut m.outside },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "aquifer",
                |m: &MapBlock| { &m.aquifer },
                |m: &mut MapBlock| { &mut m.aquifer },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "water_stagnant",
                |m: &MapBlock| { &m.water_stagnant },
                |m: &mut MapBlock| { &mut m.water_stagnant },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "water_salt",
                |m: &MapBlock| { &m.water_salt },
                |m: &mut MapBlock| { &mut m.water_salt },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "construction_items",
                |m: &MapBlock| { &m.construction_items },
                |m: &mut MapBlock| { &mut m.construction_items },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildingInstance>>(
                "buildings",
                |m: &MapBlock| { &m.buildings },
                |m: &mut MapBlock| { &mut m.buildings },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tree_percent",
                |m: &MapBlock| { &m.tree_percent },
                |m: &mut MapBlock| { &mut m.tree_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tree_x",
                |m: &MapBlock| { &m.tree_x },
                |m: &mut MapBlock| { &mut m.tree_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tree_y",
                |m: &MapBlock| { &m.tree_y },
                |m: &mut MapBlock| { &mut m.tree_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tree_z",
                |m: &MapBlock| { &m.tree_z },
                |m: &mut MapBlock| { &mut m.tree_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TileDigDesignation>>(
                "tile_dig_designation",
                |m: &MapBlock| { &m.tile_dig_designation },
                |m: &mut MapBlock| { &mut m.tile_dig_designation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatterPile>>(
                "spatterPile",
                |m: &MapBlock| { &m.spatterPile },
                |m: &mut MapBlock| { &mut m.spatterPile },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Item>>(
                "items",
                |m: &MapBlock| { &m.items },
                |m: &mut MapBlock| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tile_dig_designation_marker",
                |m: &MapBlock| { &m.tile_dig_designation_marker },
                |m: &mut MapBlock| { &mut m.tile_dig_designation_marker },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tile_dig_designation_auto",
                |m: &MapBlock| { &m.tile_dig_designation_auto },
                |m: &mut MapBlock| { &mut m.tile_dig_designation_auto },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "grass_percent",
                |m: &MapBlock| { &m.grass_percent },
                |m: &mut MapBlock| { &mut m.grass_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlowInfo>>(
                "flows",
                |m: &MapBlock| { &m.flows },
                |m: &mut MapBlock| { &mut m.flows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapBlock>(
                "MapBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapBlock {
        static instance: ::protobuf::rt::LazyV2<MapBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapBlock::new)
    }
}

impl ::protobuf::Clear for MapBlock {
    fn clear(&mut self) {
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.map_z = ::std::option::Option::None;
        self.tiles.clear();
        self.materials.clear();
        self.layer_materials.clear();
        self.vein_materials.clear();
        self.base_materials.clear();
        self.magma.clear();
        self.water.clear();
        self.hidden.clear();
        self.light.clear();
        self.subterranean.clear();
        self.outside.clear();
        self.aquifer.clear();
        self.water_stagnant.clear();
        self.water_salt.clear();
        self.construction_items.clear();
        self.buildings.clear();
        self.tree_percent.clear();
        self.tree_x.clear();
        self.tree_y.clear();
        self.tree_z.clear();
        self.tile_dig_designation.clear();
        self.spatterPile.clear();
        self.items.clear();
        self.tile_dig_designation_marker.clear();
        self.tile_dig_designation_auto.clear();
        self.grass_percent.clear();
        self.flows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatPair {
    // message fields
    mat_type: ::std::option::Option<i32>,
    mat_index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MatPair {
    fn default() -> &'a MatPair {
        <MatPair as ::protobuf::Message>::default_instance()
    }
}

impl MatPair {
    pub fn new() -> MatPair {
        ::std::default::Default::default()
    }

    // required int32 mat_type = 1;


    pub fn get_mat_type(&self) -> i32 {
        self.mat_type.unwrap_or(0)
    }
    pub fn clear_mat_type(&mut self) {
        self.mat_type = ::std::option::Option::None;
    }

    pub fn has_mat_type(&self) -> bool {
        self.mat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mat_type(&mut self, v: i32) {
        self.mat_type = ::std::option::Option::Some(v);
    }

    // required int32 mat_index = 2;


    pub fn get_mat_index(&self) -> i32 {
        self.mat_index.unwrap_or(0)
    }
    pub fn clear_mat_index(&mut self) {
        self.mat_index = ::std::option::Option::None;
    }

    pub fn has_mat_index(&self) -> bool {
        self.mat_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mat_index(&mut self, v: i32) {
        self.mat_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MatPair {
    fn is_initialized(&self) -> bool {
        if self.mat_type.is_none() {
            return false;
        }
        if self.mat_index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mat_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mat_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mat_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mat_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mat_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mat_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatPair {
        MatPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mat_type",
                |m: &MatPair| { &m.mat_type },
                |m: &mut MatPair| { &mut m.mat_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mat_index",
                |m: &MatPair| { &m.mat_index },
                |m: &mut MatPair| { &mut m.mat_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MatPair>(
                "MatPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MatPair {
        static instance: ::protobuf::rt::LazyV2<MatPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MatPair::new)
    }
}

impl ::protobuf::Clear for MatPair {
    fn clear(&mut self) {
        self.mat_type = ::std::option::Option::None;
        self.mat_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColorDefinition {
    // message fields
    red: ::std::option::Option<i32>,
    green: ::std::option::Option<i32>,
    blue: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorDefinition {
    fn default() -> &'a ColorDefinition {
        <ColorDefinition as ::protobuf::Message>::default_instance()
    }
}

impl ColorDefinition {
    pub fn new() -> ColorDefinition {
        ::std::default::Default::default()
    }

    // required int32 red = 1;


    pub fn get_red(&self) -> i32 {
        self.red.unwrap_or(0)
    }
    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: i32) {
        self.red = ::std::option::Option::Some(v);
    }

    // required int32 green = 2;


    pub fn get_green(&self) -> i32 {
        self.green.unwrap_or(0)
    }
    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: i32) {
        self.green = ::std::option::Option::Some(v);
    }

    // required int32 blue = 3;


    pub fn get_blue(&self) -> i32 {
        self.blue.unwrap_or(0)
    }
    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: i32) {
        self.blue = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ColorDefinition {
    fn is_initialized(&self) -> bool {
        if self.red.is_none() {
            return false;
        }
        if self.green.is_none() {
            return false;
        }
        if self.blue.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.red = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.green = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blue = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.red {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.green {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.blue {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorDefinition {
        ColorDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "red",
                |m: &ColorDefinition| { &m.red },
                |m: &mut ColorDefinition| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "green",
                |m: &ColorDefinition| { &m.green },
                |m: &mut ColorDefinition| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blue",
                |m: &ColorDefinition| { &m.blue },
                |m: &mut ColorDefinition| { &mut m.blue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColorDefinition>(
                "ColorDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColorDefinition {
        static instance: ::protobuf::rt::LazyV2<ColorDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColorDefinition::new)
    }
}

impl ::protobuf::Clear for ColorDefinition {
    fn clear(&mut self) {
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaterialDefinition {
    // message fields
    pub mat_pair: ::protobuf::SingularPtrField<MatPair>,
    id: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub state_color: ::protobuf::SingularPtrField<ColorDefinition>,
    pub instrument: ::protobuf::SingularPtrField<super::ItemdefInstrument::InstrumentDef>,
    up_step: ::std::option::Option<i32>,
    down_step: ::std::option::Option<i32>,
    layer: ::std::option::Option<ArmorLayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaterialDefinition {
    fn default() -> &'a MaterialDefinition {
        <MaterialDefinition as ::protobuf::Message>::default_instance()
    }
}

impl MaterialDefinition {
    pub fn new() -> MaterialDefinition {
        ::std::default::Default::default()
    }

    // required .RemoteFortressReader.MatPair mat_pair = 1;


    pub fn get_mat_pair(&self) -> &MatPair {
        self.mat_pair.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mat_pair(&mut self) {
        self.mat_pair.clear();
    }

    pub fn has_mat_pair(&self) -> bool {
        self.mat_pair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mat_pair(&mut self, v: MatPair) {
        self.mat_pair = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mat_pair(&mut self) -> &mut MatPair {
        if self.mat_pair.is_none() {
            self.mat_pair.set_default();
        }
        self.mat_pair.as_mut().unwrap()
    }

    // Take field
    pub fn take_mat_pair(&mut self) -> MatPair {
        self.mat_pair.take().unwrap_or_else(|| MatPair::new())
    }

    // optional string id = 2;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.ColorDefinition state_color = 4;


    pub fn get_state_color(&self) -> &ColorDefinition {
        self.state_color.as_ref().unwrap_or_else(|| <ColorDefinition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state_color(&mut self) {
        self.state_color.clear();
    }

    pub fn has_state_color(&self) -> bool {
        self.state_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_color(&mut self, v: ColorDefinition) {
        self.state_color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_color(&mut self) -> &mut ColorDefinition {
        if self.state_color.is_none() {
            self.state_color.set_default();
        }
        self.state_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_color(&mut self) -> ColorDefinition {
        self.state_color.take().unwrap_or_else(|| ColorDefinition::new())
    }

    // optional .ItemdefInstrument.InstrumentDef instrument = 5;


    pub fn get_instrument(&self) -> &super::ItemdefInstrument::InstrumentDef {
        self.instrument.as_ref().unwrap_or_else(|| <super::ItemdefInstrument::InstrumentDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instrument(&mut self) {
        self.instrument.clear();
    }

    pub fn has_instrument(&self) -> bool {
        self.instrument.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instrument(&mut self, v: super::ItemdefInstrument::InstrumentDef) {
        self.instrument = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instrument(&mut self) -> &mut super::ItemdefInstrument::InstrumentDef {
        if self.instrument.is_none() {
            self.instrument.set_default();
        }
        self.instrument.as_mut().unwrap()
    }

    // Take field
    pub fn take_instrument(&mut self) -> super::ItemdefInstrument::InstrumentDef {
        self.instrument.take().unwrap_or_else(|| super::ItemdefInstrument::InstrumentDef::new())
    }

    // optional int32 up_step = 6;


    pub fn get_up_step(&self) -> i32 {
        self.up_step.unwrap_or(0)
    }
    pub fn clear_up_step(&mut self) {
        self.up_step = ::std::option::Option::None;
    }

    pub fn has_up_step(&self) -> bool {
        self.up_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up_step(&mut self, v: i32) {
        self.up_step = ::std::option::Option::Some(v);
    }

    // optional int32 down_step = 7;


    pub fn get_down_step(&self) -> i32 {
        self.down_step.unwrap_or(0)
    }
    pub fn clear_down_step(&mut self) {
        self.down_step = ::std::option::Option::None;
    }

    pub fn has_down_step(&self) -> bool {
        self.down_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_down_step(&mut self, v: i32) {
        self.down_step = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArmorLayer layer = 8;


    pub fn get_layer(&self) -> ArmorLayer {
        self.layer.unwrap_or(ArmorLayer::LAYER_UNDER)
    }
    pub fn clear_layer(&mut self) {
        self.layer = ::std::option::Option::None;
    }

    pub fn has_layer(&self) -> bool {
        self.layer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer(&mut self, v: ArmorLayer) {
        self.layer = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MaterialDefinition {
    fn is_initialized(&self) -> bool {
        if self.mat_pair.is_none() {
            return false;
        }
        for v in &self.mat_pair {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mat_pair)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state_color)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instrument)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.up_step = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.down_step = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.layer, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mat_pair.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.state_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.up_step {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.down_step {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.layer {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mat_pair.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.state_color.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instrument.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.up_step {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.down_step {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.layer {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaterialDefinition {
        MaterialDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "mat_pair",
                |m: &MaterialDefinition| { &m.mat_pair },
                |m: &mut MaterialDefinition| { &mut m.mat_pair },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MaterialDefinition| { &m.id },
                |m: &mut MaterialDefinition| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &MaterialDefinition| { &m.name },
                |m: &mut MaterialDefinition| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "state_color",
                |m: &MaterialDefinition| { &m.state_color },
                |m: &mut MaterialDefinition| { &mut m.state_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ItemdefInstrument::InstrumentDef>>(
                "instrument",
                |m: &MaterialDefinition| { &m.instrument },
                |m: &mut MaterialDefinition| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "up_step",
                |m: &MaterialDefinition| { &m.up_step },
                |m: &mut MaterialDefinition| { &mut m.up_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "down_step",
                |m: &MaterialDefinition| { &m.down_step },
                |m: &mut MaterialDefinition| { &mut m.down_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ArmorLayer>>(
                "layer",
                |m: &MaterialDefinition| { &m.layer },
                |m: &mut MaterialDefinition| { &mut m.layer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MaterialDefinition>(
                "MaterialDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MaterialDefinition {
        static instance: ::protobuf::rt::LazyV2<MaterialDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MaterialDefinition::new)
    }
}

impl ::protobuf::Clear for MaterialDefinition {
    fn clear(&mut self) {
        self.mat_pair.clear();
        self.id.clear();
        self.name.clear();
        self.state_color.clear();
        self.instrument.clear();
        self.up_step = ::std::option::Option::None;
        self.down_step = ::std::option::Option::None;
        self.layer = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaterialDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildingType {
    // message fields
    building_type: ::std::option::Option<i32>,
    building_subtype: ::std::option::Option<i32>,
    building_custom: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildingType {
    fn default() -> &'a BuildingType {
        <BuildingType as ::protobuf::Message>::default_instance()
    }
}

impl BuildingType {
    pub fn new() -> BuildingType {
        ::std::default::Default::default()
    }

    // required int32 building_type = 1;


    pub fn get_building_type(&self) -> i32 {
        self.building_type.unwrap_or(0)
    }
    pub fn clear_building_type(&mut self) {
        self.building_type = ::std::option::Option::None;
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: i32) {
        self.building_type = ::std::option::Option::Some(v);
    }

    // required int32 building_subtype = 2;


    pub fn get_building_subtype(&self) -> i32 {
        self.building_subtype.unwrap_or(0)
    }
    pub fn clear_building_subtype(&mut self) {
        self.building_subtype = ::std::option::Option::None;
    }

    pub fn has_building_subtype(&self) -> bool {
        self.building_subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_subtype(&mut self, v: i32) {
        self.building_subtype = ::std::option::Option::Some(v);
    }

    // required int32 building_custom = 3;


    pub fn get_building_custom(&self) -> i32 {
        self.building_custom.unwrap_or(0)
    }
    pub fn clear_building_custom(&mut self) {
        self.building_custom = ::std::option::Option::None;
    }

    pub fn has_building_custom(&self) -> bool {
        self.building_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_custom(&mut self, v: i32) {
        self.building_custom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BuildingType {
    fn is_initialized(&self) -> bool {
        if self.building_type.is_none() {
            return false;
        }
        if self.building_subtype.is_none() {
            return false;
        }
        if self.building_custom.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.building_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.building_subtype = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.building_custom = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.building_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.building_subtype {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.building_custom {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.building_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.building_subtype {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.building_custom {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildingType {
        BuildingType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "building_type",
                |m: &BuildingType| { &m.building_type },
                |m: &mut BuildingType| { &mut m.building_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "building_subtype",
                |m: &BuildingType| { &m.building_subtype },
                |m: &mut BuildingType| { &mut m.building_subtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "building_custom",
                |m: &BuildingType| { &m.building_custom },
                |m: &mut BuildingType| { &mut m.building_custom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildingType>(
                "BuildingType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildingType {
        static instance: ::protobuf::rt::LazyV2<BuildingType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildingType::new)
    }
}

impl ::protobuf::Clear for BuildingType {
    fn clear(&mut self) {
        self.building_type = ::std::option::Option::None;
        self.building_subtype = ::std::option::Option::None;
        self.building_custom = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildingDefinition {
    // message fields
    pub building_type: ::protobuf::SingularPtrField<BuildingType>,
    id: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildingDefinition {
    fn default() -> &'a BuildingDefinition {
        <BuildingDefinition as ::protobuf::Message>::default_instance()
    }
}

impl BuildingDefinition {
    pub fn new() -> BuildingDefinition {
        ::std::default::Default::default()
    }

    // required .RemoteFortressReader.BuildingType building_type = 1;


    pub fn get_building_type(&self) -> &BuildingType {
        self.building_type.as_ref().unwrap_or_else(|| <BuildingType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_building_type(&mut self) {
        self.building_type.clear();
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: BuildingType) {
        self.building_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_building_type(&mut self) -> &mut BuildingType {
        if self.building_type.is_none() {
            self.building_type.set_default();
        }
        self.building_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_building_type(&mut self) -> BuildingType {
        self.building_type.take().unwrap_or_else(|| BuildingType::new())
    }

    // optional string id = 2;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for BuildingDefinition {
    fn is_initialized(&self) -> bool {
        if self.building_type.is_none() {
            return false;
        }
        for v in &self.building_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.building_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.building_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.building_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildingDefinition {
        BuildingDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildingType>>(
                "building_type",
                |m: &BuildingDefinition| { &m.building_type },
                |m: &mut BuildingDefinition| { &mut m.building_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &BuildingDefinition| { &m.id },
                |m: &mut BuildingDefinition| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BuildingDefinition| { &m.name },
                |m: &mut BuildingDefinition| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildingDefinition>(
                "BuildingDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildingDefinition {
        static instance: ::protobuf::rt::LazyV2<BuildingDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildingDefinition::new)
    }
}

impl ::protobuf::Clear for BuildingDefinition {
    fn clear(&mut self) {
        self.building_type.clear();
        self.id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildingDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildingList {
    // message fields
    pub building_list: ::protobuf::RepeatedField<BuildingDefinition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildingList {
    fn default() -> &'a BuildingList {
        <BuildingList as ::protobuf::Message>::default_instance()
    }
}

impl BuildingList {
    pub fn new() -> BuildingList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.BuildingDefinition building_list = 1;


    pub fn get_building_list(&self) -> &[BuildingDefinition] {
        &self.building_list
    }
    pub fn clear_building_list(&mut self) {
        self.building_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_building_list(&mut self, v: ::protobuf::RepeatedField<BuildingDefinition>) {
        self.building_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_building_list(&mut self) -> &mut ::protobuf::RepeatedField<BuildingDefinition> {
        &mut self.building_list
    }

    // Take field
    pub fn take_building_list(&mut self) -> ::protobuf::RepeatedField<BuildingDefinition> {
        ::std::mem::replace(&mut self.building_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BuildingList {
    fn is_initialized(&self) -> bool {
        for v in &self.building_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.building_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.building_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.building_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildingList {
        BuildingList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildingDefinition>>(
                "building_list",
                |m: &BuildingList| { &m.building_list },
                |m: &mut BuildingList| { &mut m.building_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildingList>(
                "BuildingList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildingList {
        static instance: ::protobuf::rt::LazyV2<BuildingList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildingList::new)
    }
}

impl ::protobuf::Clear for BuildingList {
    fn clear(&mut self) {
        self.building_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaterialList {
    // message fields
    pub material_list: ::protobuf::RepeatedField<MaterialDefinition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaterialList {
    fn default() -> &'a MaterialList {
        <MaterialList as ::protobuf::Message>::default_instance()
    }
}

impl MaterialList {
    pub fn new() -> MaterialList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.MaterialDefinition material_list = 1;


    pub fn get_material_list(&self) -> &[MaterialDefinition] {
        &self.material_list
    }
    pub fn clear_material_list(&mut self) {
        self.material_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_material_list(&mut self, v: ::protobuf::RepeatedField<MaterialDefinition>) {
        self.material_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_material_list(&mut self) -> &mut ::protobuf::RepeatedField<MaterialDefinition> {
        &mut self.material_list
    }

    // Take field
    pub fn take_material_list(&mut self) -> ::protobuf::RepeatedField<MaterialDefinition> {
        ::std::mem::replace(&mut self.material_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MaterialList {
    fn is_initialized(&self) -> bool {
        for v in &self.material_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.material_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.material_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.material_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaterialList {
        MaterialList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaterialDefinition>>(
                "material_list",
                |m: &MaterialList| { &m.material_list },
                |m: &mut MaterialList| { &mut m.material_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MaterialList>(
                "MaterialList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MaterialList {
        static instance: ::protobuf::rt::LazyV2<MaterialList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MaterialList::new)
    }
}

impl ::protobuf::Clear for MaterialList {
    fn clear(&mut self) {
        self.material_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaterialList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hair {
    // message fields
    length: ::std::option::Option<i32>,
    style: ::std::option::Option<HairStyle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hair {
    fn default() -> &'a Hair {
        <Hair as ::protobuf::Message>::default_instance()
    }
}

impl Hair {
    pub fn new() -> Hair {
        ::std::default::Default::default()
    }

    // optional int32 length = 1;


    pub fn get_length(&self) -> i32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.HairStyle style = 2;


    pub fn get_style(&self) -> HairStyle {
        self.style.unwrap_or(HairStyle::UNKEMPT)
    }
    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: HairStyle) {
        self.style = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Hair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.style, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.length {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.style {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hair {
        Hair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "length",
                |m: &Hair| { &m.length },
                |m: &mut Hair| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HairStyle>>(
                "style",
                |m: &Hair| { &m.style },
                |m: &mut Hair| { &mut m.style },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hair>(
                "Hair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Hair {
        static instance: ::protobuf::rt::LazyV2<Hair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Hair::new)
    }
}

impl ::protobuf::Clear for Hair {
    fn clear(&mut self) {
        self.length = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BodySizeInfo {
    // message fields
    size_cur: ::std::option::Option<i32>,
    size_base: ::std::option::Option<i32>,
    area_cur: ::std::option::Option<i32>,
    area_base: ::std::option::Option<i32>,
    length_cur: ::std::option::Option<i32>,
    length_base: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BodySizeInfo {
    fn default() -> &'a BodySizeInfo {
        <BodySizeInfo as ::protobuf::Message>::default_instance()
    }
}

impl BodySizeInfo {
    pub fn new() -> BodySizeInfo {
        ::std::default::Default::default()
    }

    // optional int32 size_cur = 1;


    pub fn get_size_cur(&self) -> i32 {
        self.size_cur.unwrap_or(0)
    }
    pub fn clear_size_cur(&mut self) {
        self.size_cur = ::std::option::Option::None;
    }

    pub fn has_size_cur(&self) -> bool {
        self.size_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_cur(&mut self, v: i32) {
        self.size_cur = ::std::option::Option::Some(v);
    }

    // optional int32 size_base = 2;


    pub fn get_size_base(&self) -> i32 {
        self.size_base.unwrap_or(0)
    }
    pub fn clear_size_base(&mut self) {
        self.size_base = ::std::option::Option::None;
    }

    pub fn has_size_base(&self) -> bool {
        self.size_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_base(&mut self, v: i32) {
        self.size_base = ::std::option::Option::Some(v);
    }

    // optional int32 area_cur = 3;


    pub fn get_area_cur(&self) -> i32 {
        self.area_cur.unwrap_or(0)
    }
    pub fn clear_area_cur(&mut self) {
        self.area_cur = ::std::option::Option::None;
    }

    pub fn has_area_cur(&self) -> bool {
        self.area_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_area_cur(&mut self, v: i32) {
        self.area_cur = ::std::option::Option::Some(v);
    }

    // optional int32 area_base = 4;


    pub fn get_area_base(&self) -> i32 {
        self.area_base.unwrap_or(0)
    }
    pub fn clear_area_base(&mut self) {
        self.area_base = ::std::option::Option::None;
    }

    pub fn has_area_base(&self) -> bool {
        self.area_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_area_base(&mut self, v: i32) {
        self.area_base = ::std::option::Option::Some(v);
    }

    // optional int32 length_cur = 5;


    pub fn get_length_cur(&self) -> i32 {
        self.length_cur.unwrap_or(0)
    }
    pub fn clear_length_cur(&mut self) {
        self.length_cur = ::std::option::Option::None;
    }

    pub fn has_length_cur(&self) -> bool {
        self.length_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_cur(&mut self, v: i32) {
        self.length_cur = ::std::option::Option::Some(v);
    }

    // optional int32 length_base = 6;


    pub fn get_length_base(&self) -> i32 {
        self.length_base.unwrap_or(0)
    }
    pub fn clear_length_base(&mut self) {
        self.length_base = ::std::option::Option::None;
    }

    pub fn has_length_base(&self) -> bool {
        self.length_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_base(&mut self, v: i32) {
        self.length_base = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BodySizeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size_cur = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size_base = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.area_cur = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.area_base = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length_cur = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length_base = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.size_cur {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size_base {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.area_cur {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.area_base {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length_cur {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length_base {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.size_cur {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.size_base {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.area_cur {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.area_base {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.length_cur {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.length_base {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BodySizeInfo {
        BodySizeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size_cur",
                |m: &BodySizeInfo| { &m.size_cur },
                |m: &mut BodySizeInfo| { &mut m.size_cur },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size_base",
                |m: &BodySizeInfo| { &m.size_base },
                |m: &mut BodySizeInfo| { &mut m.size_base },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "area_cur",
                |m: &BodySizeInfo| { &m.area_cur },
                |m: &mut BodySizeInfo| { &mut m.area_cur },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "area_base",
                |m: &BodySizeInfo| { &m.area_base },
                |m: &mut BodySizeInfo| { &mut m.area_base },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "length_cur",
                |m: &BodySizeInfo| { &m.length_cur },
                |m: &mut BodySizeInfo| { &mut m.length_cur },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "length_base",
                |m: &BodySizeInfo| { &m.length_base },
                |m: &mut BodySizeInfo| { &mut m.length_base },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BodySizeInfo>(
                "BodySizeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BodySizeInfo {
        static instance: ::protobuf::rt::LazyV2<BodySizeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BodySizeInfo::new)
    }
}

impl ::protobuf::Clear for BodySizeInfo {
    fn clear(&mut self) {
        self.size_cur = ::std::option::Option::None;
        self.size_base = ::std::option::Option::None;
        self.area_cur = ::std::option::Option::None;
        self.area_base = ::std::option::Option::None;
        self.length_cur = ::std::option::Option::None;
        self.length_base = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BodySizeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodySizeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitAppearance {
    // message fields
    pub body_modifiers: ::std::vec::Vec<i32>,
    pub bp_modifiers: ::std::vec::Vec<i32>,
    size_modifier: ::std::option::Option<i32>,
    pub colors: ::std::vec::Vec<i32>,
    pub hair: ::protobuf::SingularPtrField<Hair>,
    pub beard: ::protobuf::SingularPtrField<Hair>,
    pub moustache: ::protobuf::SingularPtrField<Hair>,
    pub sideburns: ::protobuf::SingularPtrField<Hair>,
    physical_description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitAppearance {
    fn default() -> &'a UnitAppearance {
        <UnitAppearance as ::protobuf::Message>::default_instance()
    }
}

impl UnitAppearance {
    pub fn new() -> UnitAppearance {
        ::std::default::Default::default()
    }

    // repeated int32 body_modifiers = 1;


    pub fn get_body_modifiers(&self) -> &[i32] {
        &self.body_modifiers
    }
    pub fn clear_body_modifiers(&mut self) {
        self.body_modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_modifiers(&mut self, v: ::std::vec::Vec<i32>) {
        self.body_modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_modifiers(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.body_modifiers
    }

    // Take field
    pub fn take_body_modifiers(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.body_modifiers, ::std::vec::Vec::new())
    }

    // repeated int32 bp_modifiers = 2;


    pub fn get_bp_modifiers(&self) -> &[i32] {
        &self.bp_modifiers
    }
    pub fn clear_bp_modifiers(&mut self) {
        self.bp_modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_bp_modifiers(&mut self, v: ::std::vec::Vec<i32>) {
        self.bp_modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bp_modifiers(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.bp_modifiers
    }

    // Take field
    pub fn take_bp_modifiers(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.bp_modifiers, ::std::vec::Vec::new())
    }

    // optional int32 size_modifier = 3;


    pub fn get_size_modifier(&self) -> i32 {
        self.size_modifier.unwrap_or(0)
    }
    pub fn clear_size_modifier(&mut self) {
        self.size_modifier = ::std::option::Option::None;
    }

    pub fn has_size_modifier(&self) -> bool {
        self.size_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_modifier(&mut self, v: i32) {
        self.size_modifier = ::std::option::Option::Some(v);
    }

    // repeated int32 colors = 4;


    pub fn get_colors(&self) -> &[i32] {
        &self.colors
    }
    pub fn clear_colors(&mut self) {
        self.colors.clear();
    }

    // Param is passed by value, moved
    pub fn set_colors(&mut self, v: ::std::vec::Vec<i32>) {
        self.colors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colors(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.colors
    }

    // Take field
    pub fn take_colors(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.colors, ::std::vec::Vec::new())
    }

    // optional .RemoteFortressReader.Hair hair = 5;


    pub fn get_hair(&self) -> &Hair {
        self.hair.as_ref().unwrap_or_else(|| <Hair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hair(&mut self) {
        self.hair.clear();
    }

    pub fn has_hair(&self) -> bool {
        self.hair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hair(&mut self, v: Hair) {
        self.hair = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hair(&mut self) -> &mut Hair {
        if self.hair.is_none() {
            self.hair.set_default();
        }
        self.hair.as_mut().unwrap()
    }

    // Take field
    pub fn take_hair(&mut self) -> Hair {
        self.hair.take().unwrap_or_else(|| Hair::new())
    }

    // optional .RemoteFortressReader.Hair beard = 6;


    pub fn get_beard(&self) -> &Hair {
        self.beard.as_ref().unwrap_or_else(|| <Hair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_beard(&mut self) {
        self.beard.clear();
    }

    pub fn has_beard(&self) -> bool {
        self.beard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beard(&mut self, v: Hair) {
        self.beard = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_beard(&mut self) -> &mut Hair {
        if self.beard.is_none() {
            self.beard.set_default();
        }
        self.beard.as_mut().unwrap()
    }

    // Take field
    pub fn take_beard(&mut self) -> Hair {
        self.beard.take().unwrap_or_else(|| Hair::new())
    }

    // optional .RemoteFortressReader.Hair moustache = 7;


    pub fn get_moustache(&self) -> &Hair {
        self.moustache.as_ref().unwrap_or_else(|| <Hair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_moustache(&mut self) {
        self.moustache.clear();
    }

    pub fn has_moustache(&self) -> bool {
        self.moustache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moustache(&mut self, v: Hair) {
        self.moustache = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moustache(&mut self) -> &mut Hair {
        if self.moustache.is_none() {
            self.moustache.set_default();
        }
        self.moustache.as_mut().unwrap()
    }

    // Take field
    pub fn take_moustache(&mut self) -> Hair {
        self.moustache.take().unwrap_or_else(|| Hair::new())
    }

    // optional .RemoteFortressReader.Hair sideburns = 8;


    pub fn get_sideburns(&self) -> &Hair {
        self.sideburns.as_ref().unwrap_or_else(|| <Hair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sideburns(&mut self) {
        self.sideburns.clear();
    }

    pub fn has_sideburns(&self) -> bool {
        self.sideburns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sideburns(&mut self, v: Hair) {
        self.sideburns = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sideburns(&mut self) -> &mut Hair {
        if self.sideburns.is_none() {
            self.sideburns.set_default();
        }
        self.sideburns.as_mut().unwrap()
    }

    // Take field
    pub fn take_sideburns(&mut self) -> Hair {
        self.sideburns.take().unwrap_or_else(|| Hair::new())
    }

    // optional string physical_description = 9;


    pub fn get_physical_description(&self) -> &str {
        match self.physical_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_physical_description(&mut self) {
        self.physical_description.clear();
    }

    pub fn has_physical_description(&self) -> bool {
        self.physical_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_physical_description(&mut self, v: ::std::string::String) {
        self.physical_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_physical_description(&mut self) -> &mut ::std::string::String {
        if self.physical_description.is_none() {
            self.physical_description.set_default();
        }
        self.physical_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_physical_description(&mut self) -> ::std::string::String {
        self.physical_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnitAppearance {
    fn is_initialized(&self) -> bool {
        for v in &self.hair {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.beard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.moustache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sideburns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.body_modifiers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.bp_modifiers)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size_modifier = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.colors)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hair)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.beard)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.moustache)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sideburns)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.physical_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.body_modifiers {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.bp_modifiers {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.size_modifier {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.colors {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.hair.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.beard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.moustache.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sideburns.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.physical_description.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.body_modifiers {
            os.write_int32(1, *v)?;
        };
        for v in &self.bp_modifiers {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.size_modifier {
            os.write_int32(3, v)?;
        }
        for v in &self.colors {
            os.write_int32(4, *v)?;
        };
        if let Some(ref v) = self.hair.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.beard.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.moustache.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sideburns.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.physical_description.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitAppearance {
        UnitAppearance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "body_modifiers",
                |m: &UnitAppearance| { &m.body_modifiers },
                |m: &mut UnitAppearance| { &mut m.body_modifiers },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bp_modifiers",
                |m: &UnitAppearance| { &m.bp_modifiers },
                |m: &mut UnitAppearance| { &mut m.bp_modifiers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size_modifier",
                |m: &UnitAppearance| { &m.size_modifier },
                |m: &mut UnitAppearance| { &mut m.size_modifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "colors",
                |m: &UnitAppearance| { &m.colors },
                |m: &mut UnitAppearance| { &mut m.colors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hair>>(
                "hair",
                |m: &UnitAppearance| { &m.hair },
                |m: &mut UnitAppearance| { &mut m.hair },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hair>>(
                "beard",
                |m: &UnitAppearance| { &m.beard },
                |m: &mut UnitAppearance| { &mut m.beard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hair>>(
                "moustache",
                |m: &UnitAppearance| { &m.moustache },
                |m: &mut UnitAppearance| { &mut m.moustache },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hair>>(
                "sideburns",
                |m: &UnitAppearance| { &m.sideburns },
                |m: &mut UnitAppearance| { &mut m.sideburns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "physical_description",
                |m: &UnitAppearance| { &m.physical_description },
                |m: &mut UnitAppearance| { &mut m.physical_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitAppearance>(
                "UnitAppearance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitAppearance {
        static instance: ::protobuf::rt::LazyV2<UnitAppearance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitAppearance::new)
    }
}

impl ::protobuf::Clear for UnitAppearance {
    fn clear(&mut self) {
        self.body_modifiers.clear();
        self.bp_modifiers.clear();
        self.size_modifier = ::std::option::Option::None;
        self.colors.clear();
        self.hair.clear();
        self.beard.clear();
        self.moustache.clear();
        self.sideburns.clear();
        self.physical_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitAppearance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitAppearance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InventoryItem {
    // message fields
    mode: ::std::option::Option<InventoryMode>,
    pub item: ::protobuf::SingularPtrField<Item>,
    body_part_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InventoryItem {
    fn default() -> &'a InventoryItem {
        <InventoryItem as ::protobuf::Message>::default_instance()
    }
}

impl InventoryItem {
    pub fn new() -> InventoryItem {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.InventoryMode mode = 1;


    pub fn get_mode(&self) -> InventoryMode {
        self.mode.unwrap_or(InventoryMode::Hauled)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: InventoryMode) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Item item = 2;


    pub fn get_item(&self) -> &Item {
        self.item.as_ref().unwrap_or_else(|| <Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        self.item.take().unwrap_or_else(|| Item::new())
    }

    // optional int32 body_part_id = 3;


    pub fn get_body_part_id(&self) -> i32 {
        self.body_part_id.unwrap_or(0)
    }
    pub fn clear_body_part_id(&mut self) {
        self.body_part_id = ::std::option::Option::None;
    }

    pub fn has_body_part_id(&self) -> bool {
        self.body_part_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_part_id(&mut self, v: i32) {
        self.body_part_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for InventoryItem {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.body_part_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.body_part_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.body_part_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InventoryItem {
        InventoryItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InventoryMode>>(
                "mode",
                |m: &InventoryItem| { &m.mode },
                |m: &mut InventoryItem| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Item>>(
                "item",
                |m: &InventoryItem| { &m.item },
                |m: &mut InventoryItem| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "body_part_id",
                |m: &InventoryItem| { &m.body_part_id },
                |m: &mut InventoryItem| { &mut m.body_part_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InventoryItem>(
                "InventoryItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InventoryItem {
        static instance: ::protobuf::rt::LazyV2<InventoryItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InventoryItem::new)
    }
}

impl ::protobuf::Clear for InventoryItem {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.item.clear();
        self.body_part_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InventoryItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InventoryItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WoundPart {
    // message fields
    global_layer_idx: ::std::option::Option<i32>,
    body_part_id: ::std::option::Option<i32>,
    layer_idx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WoundPart {
    fn default() -> &'a WoundPart {
        <WoundPart as ::protobuf::Message>::default_instance()
    }
}

impl WoundPart {
    pub fn new() -> WoundPart {
        ::std::default::Default::default()
    }

    // optional int32 global_layer_idx = 1;


    pub fn get_global_layer_idx(&self) -> i32 {
        self.global_layer_idx.unwrap_or(0)
    }
    pub fn clear_global_layer_idx(&mut self) {
        self.global_layer_idx = ::std::option::Option::None;
    }

    pub fn has_global_layer_idx(&self) -> bool {
        self.global_layer_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_layer_idx(&mut self, v: i32) {
        self.global_layer_idx = ::std::option::Option::Some(v);
    }

    // optional int32 body_part_id = 2;


    pub fn get_body_part_id(&self) -> i32 {
        self.body_part_id.unwrap_or(0)
    }
    pub fn clear_body_part_id(&mut self) {
        self.body_part_id = ::std::option::Option::None;
    }

    pub fn has_body_part_id(&self) -> bool {
        self.body_part_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_part_id(&mut self, v: i32) {
        self.body_part_id = ::std::option::Option::Some(v);
    }

    // optional int32 layer_idx = 3;


    pub fn get_layer_idx(&self) -> i32 {
        self.layer_idx.unwrap_or(0)
    }
    pub fn clear_layer_idx(&mut self) {
        self.layer_idx = ::std::option::Option::None;
    }

    pub fn has_layer_idx(&self) -> bool {
        self.layer_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_idx(&mut self, v: i32) {
        self.layer_idx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WoundPart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.global_layer_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.body_part_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.layer_idx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.global_layer_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.body_part_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.layer_idx {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.global_layer_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.body_part_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.layer_idx {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WoundPart {
        WoundPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "global_layer_idx",
                |m: &WoundPart| { &m.global_layer_idx },
                |m: &mut WoundPart| { &mut m.global_layer_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "body_part_id",
                |m: &WoundPart| { &m.body_part_id },
                |m: &mut WoundPart| { &mut m.body_part_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "layer_idx",
                |m: &WoundPart| { &m.layer_idx },
                |m: &mut WoundPart| { &mut m.layer_idx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WoundPart>(
                "WoundPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WoundPart {
        static instance: ::protobuf::rt::LazyV2<WoundPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WoundPart::new)
    }
}

impl ::protobuf::Clear for WoundPart {
    fn clear(&mut self) {
        self.global_layer_idx = ::std::option::Option::None;
        self.body_part_id = ::std::option::Option::None;
        self.layer_idx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WoundPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WoundPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitWound {
    // message fields
    pub parts: ::protobuf::RepeatedField<WoundPart>,
    severed_part: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitWound {
    fn default() -> &'a UnitWound {
        <UnitWound as ::protobuf::Message>::default_instance()
    }
}

impl UnitWound {
    pub fn new() -> UnitWound {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.WoundPart parts = 1;


    pub fn get_parts(&self) -> &[WoundPart] {
        &self.parts
    }
    pub fn clear_parts(&mut self) {
        self.parts.clear();
    }

    // Param is passed by value, moved
    pub fn set_parts(&mut self, v: ::protobuf::RepeatedField<WoundPart>) {
        self.parts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parts(&mut self) -> &mut ::protobuf::RepeatedField<WoundPart> {
        &mut self.parts
    }

    // Take field
    pub fn take_parts(&mut self) -> ::protobuf::RepeatedField<WoundPart> {
        ::std::mem::replace(&mut self.parts, ::protobuf::RepeatedField::new())
    }

    // optional bool severed_part = 2;


    pub fn get_severed_part(&self) -> bool {
        self.severed_part.unwrap_or(false)
    }
    pub fn clear_severed_part(&mut self) {
        self.severed_part = ::std::option::Option::None;
    }

    pub fn has_severed_part(&self) -> bool {
        self.severed_part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severed_part(&mut self, v: bool) {
        self.severed_part = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnitWound {
    fn is_initialized(&self) -> bool {
        for v in &self.parts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parts)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.severed_part = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.severed_part {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.parts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.severed_part {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitWound {
        UnitWound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WoundPart>>(
                "parts",
                |m: &UnitWound| { &m.parts },
                |m: &mut UnitWound| { &mut m.parts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "severed_part",
                |m: &UnitWound| { &m.severed_part },
                |m: &mut UnitWound| { &mut m.severed_part },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitWound>(
                "UnitWound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitWound {
        static instance: ::protobuf::rt::LazyV2<UnitWound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitWound::new)
    }
}

impl ::protobuf::Clear for UnitWound {
    fn clear(&mut self) {
        self.parts.clear();
        self.severed_part = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitWound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitWound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitDefinition {
    // message fields
    id: ::std::option::Option<i32>,
    isValid: ::std::option::Option<bool>,
    pos_x: ::std::option::Option<i32>,
    pos_y: ::std::option::Option<i32>,
    pos_z: ::std::option::Option<i32>,
    pub race: ::protobuf::SingularPtrField<MatPair>,
    pub profession_color: ::protobuf::SingularPtrField<ColorDefinition>,
    flags1: ::std::option::Option<u32>,
    flags2: ::std::option::Option<u32>,
    flags3: ::std::option::Option<u32>,
    is_soldier: ::std::option::Option<bool>,
    pub size_info: ::protobuf::SingularPtrField<BodySizeInfo>,
    name: ::protobuf::SingularField<::std::string::String>,
    blood_max: ::std::option::Option<i32>,
    blood_count: ::std::option::Option<i32>,
    pub appearance: ::protobuf::SingularPtrField<UnitAppearance>,
    profession_id: ::std::option::Option<i32>,
    pub noble_positions: ::protobuf::RepeatedField<::std::string::String>,
    rider_id: ::std::option::Option<i32>,
    pub inventory: ::protobuf::RepeatedField<InventoryItem>,
    subpos_x: ::std::option::Option<f32>,
    subpos_y: ::std::option::Option<f32>,
    subpos_z: ::std::option::Option<f32>,
    pub facing: ::protobuf::SingularPtrField<Coord>,
    age: ::std::option::Option<i32>,
    pub wounds: ::protobuf::RepeatedField<UnitWound>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitDefinition {
    fn default() -> &'a UnitDefinition {
        <UnitDefinition as ::protobuf::Message>::default_instance()
    }
}

impl UnitDefinition {
    pub fn new() -> UnitDefinition {
        ::std::default::Default::default()
    }

    // required int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bool isValid = 2;


    pub fn get_isValid(&self) -> bool {
        self.isValid.unwrap_or(false)
    }
    pub fn clear_isValid(&mut self) {
        self.isValid = ::std::option::Option::None;
    }

    pub fn has_isValid(&self) -> bool {
        self.isValid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isValid(&mut self, v: bool) {
        self.isValid = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x = 3;


    pub fn get_pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y = 4;


    pub fn get_pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z = 5;


    pub fn get_pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair race = 6;


    pub fn get_race(&self) -> &MatPair {
        self.race.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_race(&mut self) {
        self.race.clear();
    }

    pub fn has_race(&self) -> bool {
        self.race.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: MatPair) {
        self.race = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_race(&mut self) -> &mut MatPair {
        if self.race.is_none() {
            self.race.set_default();
        }
        self.race.as_mut().unwrap()
    }

    // Take field
    pub fn take_race(&mut self) -> MatPair {
        self.race.take().unwrap_or_else(|| MatPair::new())
    }

    // optional .RemoteFortressReader.ColorDefinition profession_color = 7;


    pub fn get_profession_color(&self) -> &ColorDefinition {
        self.profession_color.as_ref().unwrap_or_else(|| <ColorDefinition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profession_color(&mut self) {
        self.profession_color.clear();
    }

    pub fn has_profession_color(&self) -> bool {
        self.profession_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession_color(&mut self, v: ColorDefinition) {
        self.profession_color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profession_color(&mut self) -> &mut ColorDefinition {
        if self.profession_color.is_none() {
            self.profession_color.set_default();
        }
        self.profession_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_profession_color(&mut self) -> ColorDefinition {
        self.profession_color.take().unwrap_or_else(|| ColorDefinition::new())
    }

    // optional uint32 flags1 = 8;


    pub fn get_flags1(&self) -> u32 {
        self.flags1.unwrap_or(0)
    }
    pub fn clear_flags1(&mut self) {
        self.flags1 = ::std::option::Option::None;
    }

    pub fn has_flags1(&self) -> bool {
        self.flags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags1(&mut self, v: u32) {
        self.flags1 = ::std::option::Option::Some(v);
    }

    // optional uint32 flags2 = 9;


    pub fn get_flags2(&self) -> u32 {
        self.flags2.unwrap_or(0)
    }
    pub fn clear_flags2(&mut self) {
        self.flags2 = ::std::option::Option::None;
    }

    pub fn has_flags2(&self) -> bool {
        self.flags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags2(&mut self, v: u32) {
        self.flags2 = ::std::option::Option::Some(v);
    }

    // optional uint32 flags3 = 10;


    pub fn get_flags3(&self) -> u32 {
        self.flags3.unwrap_or(0)
    }
    pub fn clear_flags3(&mut self) {
        self.flags3 = ::std::option::Option::None;
    }

    pub fn has_flags3(&self) -> bool {
        self.flags3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags3(&mut self, v: u32) {
        self.flags3 = ::std::option::Option::Some(v);
    }

    // optional bool is_soldier = 11;


    pub fn get_is_soldier(&self) -> bool {
        self.is_soldier.unwrap_or(false)
    }
    pub fn clear_is_soldier(&mut self) {
        self.is_soldier = ::std::option::Option::None;
    }

    pub fn has_is_soldier(&self) -> bool {
        self.is_soldier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_soldier(&mut self, v: bool) {
        self.is_soldier = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.BodySizeInfo size_info = 12;


    pub fn get_size_info(&self) -> &BodySizeInfo {
        self.size_info.as_ref().unwrap_or_else(|| <BodySizeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_size_info(&mut self) {
        self.size_info.clear();
    }

    pub fn has_size_info(&self) -> bool {
        self.size_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_info(&mut self, v: BodySizeInfo) {
        self.size_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size_info(&mut self) -> &mut BodySizeInfo {
        if self.size_info.is_none() {
            self.size_info.set_default();
        }
        self.size_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_size_info(&mut self) -> BodySizeInfo {
        self.size_info.take().unwrap_or_else(|| BodySizeInfo::new())
    }

    // optional string name = 13;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 blood_max = 14;


    pub fn get_blood_max(&self) -> i32 {
        self.blood_max.unwrap_or(0)
    }
    pub fn clear_blood_max(&mut self) {
        self.blood_max = ::std::option::Option::None;
    }

    pub fn has_blood_max(&self) -> bool {
        self.blood_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blood_max(&mut self, v: i32) {
        self.blood_max = ::std::option::Option::Some(v);
    }

    // optional int32 blood_count = 15;


    pub fn get_blood_count(&self) -> i32 {
        self.blood_count.unwrap_or(0)
    }
    pub fn clear_blood_count(&mut self) {
        self.blood_count = ::std::option::Option::None;
    }

    pub fn has_blood_count(&self) -> bool {
        self.blood_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blood_count(&mut self, v: i32) {
        self.blood_count = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.UnitAppearance appearance = 16;


    pub fn get_appearance(&self) -> &UnitAppearance {
        self.appearance.as_ref().unwrap_or_else(|| <UnitAppearance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_appearance(&mut self) {
        self.appearance.clear();
    }

    pub fn has_appearance(&self) -> bool {
        self.appearance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appearance(&mut self, v: UnitAppearance) {
        self.appearance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appearance(&mut self) -> &mut UnitAppearance {
        if self.appearance.is_none() {
            self.appearance.set_default();
        }
        self.appearance.as_mut().unwrap()
    }

    // Take field
    pub fn take_appearance(&mut self) -> UnitAppearance {
        self.appearance.take().unwrap_or_else(|| UnitAppearance::new())
    }

    // optional int32 profession_id = 17;


    pub fn get_profession_id(&self) -> i32 {
        self.profession_id.unwrap_or(0)
    }
    pub fn clear_profession_id(&mut self) {
        self.profession_id = ::std::option::Option::None;
    }

    pub fn has_profession_id(&self) -> bool {
        self.profession_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession_id(&mut self, v: i32) {
        self.profession_id = ::std::option::Option::Some(v);
    }

    // repeated string noble_positions = 18;


    pub fn get_noble_positions(&self) -> &[::std::string::String] {
        &self.noble_positions
    }
    pub fn clear_noble_positions(&mut self) {
        self.noble_positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_noble_positions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.noble_positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_noble_positions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.noble_positions
    }

    // Take field
    pub fn take_noble_positions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.noble_positions, ::protobuf::RepeatedField::new())
    }

    // optional int32 rider_id = 19;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id.unwrap_or(0)
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = ::std::option::Option::None;
    }

    pub fn has_rider_id(&self) -> bool {
        self.rider_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.InventoryItem inventory = 20;


    pub fn get_inventory(&self) -> &[InventoryItem] {
        &self.inventory
    }
    pub fn clear_inventory(&mut self) {
        self.inventory.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: ::protobuf::RepeatedField<InventoryItem>) {
        self.inventory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventory(&mut self) -> &mut ::protobuf::RepeatedField<InventoryItem> {
        &mut self.inventory
    }

    // Take field
    pub fn take_inventory(&mut self) -> ::protobuf::RepeatedField<InventoryItem> {
        ::std::mem::replace(&mut self.inventory, ::protobuf::RepeatedField::new())
    }

    // optional float subpos_x = 21;


    pub fn get_subpos_x(&self) -> f32 {
        self.subpos_x.unwrap_or(0.)
    }
    pub fn clear_subpos_x(&mut self) {
        self.subpos_x = ::std::option::Option::None;
    }

    pub fn has_subpos_x(&self) -> bool {
        self.subpos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_x(&mut self, v: f32) {
        self.subpos_x = ::std::option::Option::Some(v);
    }

    // optional float subpos_y = 22;


    pub fn get_subpos_y(&self) -> f32 {
        self.subpos_y.unwrap_or(0.)
    }
    pub fn clear_subpos_y(&mut self) {
        self.subpos_y = ::std::option::Option::None;
    }

    pub fn has_subpos_y(&self) -> bool {
        self.subpos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_y(&mut self, v: f32) {
        self.subpos_y = ::std::option::Option::Some(v);
    }

    // optional float subpos_z = 23;


    pub fn get_subpos_z(&self) -> f32 {
        self.subpos_z.unwrap_or(0.)
    }
    pub fn clear_subpos_z(&mut self) {
        self.subpos_z = ::std::option::Option::None;
    }

    pub fn has_subpos_z(&self) -> bool {
        self.subpos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_z(&mut self, v: f32) {
        self.subpos_z = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord facing = 24;


    pub fn get_facing(&self) -> &Coord {
        self.facing.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_facing(&mut self) {
        self.facing.clear();
    }

    pub fn has_facing(&self) -> bool {
        self.facing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facing(&mut self, v: Coord) {
        self.facing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_facing(&mut self) -> &mut Coord {
        if self.facing.is_none() {
            self.facing.set_default();
        }
        self.facing.as_mut().unwrap()
    }

    // Take field
    pub fn take_facing(&mut self) -> Coord {
        self.facing.take().unwrap_or_else(|| Coord::new())
    }

    // optional int32 age = 25;


    pub fn get_age(&self) -> i32 {
        self.age.unwrap_or(0)
    }
    pub fn clear_age(&mut self) {
        self.age = ::std::option::Option::None;
    }

    pub fn has_age(&self) -> bool {
        self.age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_age(&mut self, v: i32) {
        self.age = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.UnitWound wounds = 26;


    pub fn get_wounds(&self) -> &[UnitWound] {
        &self.wounds
    }
    pub fn clear_wounds(&mut self) {
        self.wounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_wounds(&mut self, v: ::protobuf::RepeatedField<UnitWound>) {
        self.wounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wounds(&mut self) -> &mut ::protobuf::RepeatedField<UnitWound> {
        &mut self.wounds
    }

    // Take field
    pub fn take_wounds(&mut self) -> ::protobuf::RepeatedField<UnitWound> {
        ::std::mem::replace(&mut self.wounds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UnitDefinition {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.race {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profession_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.size_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appearance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.facing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wounds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isValid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.race)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profession_color)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags1 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags2 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags3 = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_soldier = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size_info)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blood_max = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blood_count = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appearance)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.profession_id = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.noble_positions)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inventory)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.subpos_x = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.subpos_y = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.subpos_z = ::std::option::Option::Some(tmp);
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.facing)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.age = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.wounds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isValid {
            my_size += 2;
        }
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.race.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profession_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags1 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags2 {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags3 {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_soldier {
            my_size += 2;
        }
        if let Some(ref v) = self.size_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.blood_max {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blood_count {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.appearance.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.profession_id {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.noble_positions {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        if let Some(v) = self.rider_id {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.inventory {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.subpos_x {
            my_size += 6;
        }
        if let Some(v) = self.subpos_y {
            my_size += 6;
        }
        if let Some(v) = self.subpos_z {
            my_size += 6;
        }
        if let Some(ref v) = self.facing.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.age {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.wounds {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.isValid {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.race.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profession_color.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags1 {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.flags2 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.flags3 {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.is_soldier {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.size_info.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.blood_max {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.blood_count {
            os.write_int32(15, v)?;
        }
        if let Some(ref v) = self.appearance.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.profession_id {
            os.write_int32(17, v)?;
        }
        for v in &self.noble_positions {
            os.write_string(18, &v)?;
        };
        if let Some(v) = self.rider_id {
            os.write_int32(19, v)?;
        }
        for v in &self.inventory {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.subpos_x {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.subpos_y {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.subpos_z {
            os.write_float(23, v)?;
        }
        if let Some(ref v) = self.facing.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.age {
            os.write_int32(25, v)?;
        }
        for v in &self.wounds {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitDefinition {
        UnitDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &UnitDefinition| { &m.id },
                |m: &mut UnitDefinition| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isValid",
                |m: &UnitDefinition| { &m.isValid },
                |m: &mut UnitDefinition| { &mut m.isValid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x",
                |m: &UnitDefinition| { &m.pos_x },
                |m: &mut UnitDefinition| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y",
                |m: &UnitDefinition| { &m.pos_y },
                |m: &mut UnitDefinition| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_z",
                |m: &UnitDefinition| { &m.pos_z },
                |m: &mut UnitDefinition| { &mut m.pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "race",
                |m: &UnitDefinition| { &m.race },
                |m: &mut UnitDefinition| { &mut m.race },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "profession_color",
                |m: &UnitDefinition| { &m.profession_color },
                |m: &mut UnitDefinition| { &mut m.profession_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags1",
                |m: &UnitDefinition| { &m.flags1 },
                |m: &mut UnitDefinition| { &mut m.flags1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags2",
                |m: &UnitDefinition| { &m.flags2 },
                |m: &mut UnitDefinition| { &mut m.flags2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags3",
                |m: &UnitDefinition| { &m.flags3 },
                |m: &mut UnitDefinition| { &mut m.flags3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_soldier",
                |m: &UnitDefinition| { &m.is_soldier },
                |m: &mut UnitDefinition| { &mut m.is_soldier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BodySizeInfo>>(
                "size_info",
                |m: &UnitDefinition| { &m.size_info },
                |m: &mut UnitDefinition| { &mut m.size_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UnitDefinition| { &m.name },
                |m: &mut UnitDefinition| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blood_max",
                |m: &UnitDefinition| { &m.blood_max },
                |m: &mut UnitDefinition| { &mut m.blood_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blood_count",
                |m: &UnitDefinition| { &m.blood_count },
                |m: &mut UnitDefinition| { &mut m.blood_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitAppearance>>(
                "appearance",
                |m: &UnitDefinition| { &m.appearance },
                |m: &mut UnitDefinition| { &mut m.appearance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "profession_id",
                |m: &UnitDefinition| { &m.profession_id },
                |m: &mut UnitDefinition| { &mut m.profession_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "noble_positions",
                |m: &UnitDefinition| { &m.noble_positions },
                |m: &mut UnitDefinition| { &mut m.noble_positions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &UnitDefinition| { &m.rider_id },
                |m: &mut UnitDefinition| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InventoryItem>>(
                "inventory",
                |m: &UnitDefinition| { &m.inventory },
                |m: &mut UnitDefinition| { &mut m.inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "subpos_x",
                |m: &UnitDefinition| { &m.subpos_x },
                |m: &mut UnitDefinition| { &mut m.subpos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "subpos_y",
                |m: &UnitDefinition| { &m.subpos_y },
                |m: &mut UnitDefinition| { &mut m.subpos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "subpos_z",
                |m: &UnitDefinition| { &m.subpos_z },
                |m: &mut UnitDefinition| { &mut m.subpos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "facing",
                |m: &UnitDefinition| { &m.facing },
                |m: &mut UnitDefinition| { &mut m.facing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "age",
                |m: &UnitDefinition| { &m.age },
                |m: &mut UnitDefinition| { &mut m.age },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitWound>>(
                "wounds",
                |m: &UnitDefinition| { &m.wounds },
                |m: &mut UnitDefinition| { &mut m.wounds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitDefinition>(
                "UnitDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitDefinition {
        static instance: ::protobuf::rt::LazyV2<UnitDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitDefinition::new)
    }
}

impl ::protobuf::Clear for UnitDefinition {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.isValid = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.race.clear();
        self.profession_color.clear();
        self.flags1 = ::std::option::Option::None;
        self.flags2 = ::std::option::Option::None;
        self.flags3 = ::std::option::Option::None;
        self.is_soldier = ::std::option::Option::None;
        self.size_info.clear();
        self.name.clear();
        self.blood_max = ::std::option::Option::None;
        self.blood_count = ::std::option::Option::None;
        self.appearance.clear();
        self.profession_id = ::std::option::Option::None;
        self.noble_positions.clear();
        self.rider_id = ::std::option::Option::None;
        self.inventory.clear();
        self.subpos_x = ::std::option::Option::None;
        self.subpos_y = ::std::option::Option::None;
        self.subpos_z = ::std::option::Option::None;
        self.facing.clear();
        self.age = ::std::option::Option::None;
        self.wounds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitList {
    // message fields
    pub creature_list: ::protobuf::RepeatedField<UnitDefinition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitList {
    fn default() -> &'a UnitList {
        <UnitList as ::protobuf::Message>::default_instance()
    }
}

impl UnitList {
    pub fn new() -> UnitList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.UnitDefinition creature_list = 1;


    pub fn get_creature_list(&self) -> &[UnitDefinition] {
        &self.creature_list
    }
    pub fn clear_creature_list(&mut self) {
        self.creature_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_creature_list(&mut self, v: ::protobuf::RepeatedField<UnitDefinition>) {
        self.creature_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_creature_list(&mut self) -> &mut ::protobuf::RepeatedField<UnitDefinition> {
        &mut self.creature_list
    }

    // Take field
    pub fn take_creature_list(&mut self) -> ::protobuf::RepeatedField<UnitDefinition> {
        ::std::mem::replace(&mut self.creature_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UnitList {
    fn is_initialized(&self) -> bool {
        for v in &self.creature_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.creature_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.creature_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.creature_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitList {
        UnitList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitDefinition>>(
                "creature_list",
                |m: &UnitList| { &m.creature_list },
                |m: &mut UnitList| { &mut m.creature_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitList>(
                "UnitList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitList {
        static instance: ::protobuf::rt::LazyV2<UnitList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitList::new)
    }
}

impl ::protobuf::Clear for UnitList {
    fn clear(&mut self) {
        self.creature_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockRequest {
    // message fields
    blocks_needed: ::std::option::Option<i32>,
    min_x: ::std::option::Option<i32>,
    max_x: ::std::option::Option<i32>,
    min_y: ::std::option::Option<i32>,
    max_y: ::std::option::Option<i32>,
    min_z: ::std::option::Option<i32>,
    max_z: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockRequest {
    fn default() -> &'a BlockRequest {
        <BlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockRequest {
    pub fn new() -> BlockRequest {
        ::std::default::Default::default()
    }

    // optional int32 blocks_needed = 1;


    pub fn get_blocks_needed(&self) -> i32 {
        self.blocks_needed.unwrap_or(0)
    }
    pub fn clear_blocks_needed(&mut self) {
        self.blocks_needed = ::std::option::Option::None;
    }

    pub fn has_blocks_needed(&self) -> bool {
        self.blocks_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_needed(&mut self, v: i32) {
        self.blocks_needed = ::std::option::Option::Some(v);
    }

    // optional int32 min_x = 2;


    pub fn get_min_x(&self) -> i32 {
        self.min_x.unwrap_or(0)
    }
    pub fn clear_min_x(&mut self) {
        self.min_x = ::std::option::Option::None;
    }

    pub fn has_min_x(&self) -> bool {
        self.min_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_x(&mut self, v: i32) {
        self.min_x = ::std::option::Option::Some(v);
    }

    // optional int32 max_x = 3;


    pub fn get_max_x(&self) -> i32 {
        self.max_x.unwrap_or(0)
    }
    pub fn clear_max_x(&mut self) {
        self.max_x = ::std::option::Option::None;
    }

    pub fn has_max_x(&self) -> bool {
        self.max_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_x(&mut self, v: i32) {
        self.max_x = ::std::option::Option::Some(v);
    }

    // optional int32 min_y = 4;


    pub fn get_min_y(&self) -> i32 {
        self.min_y.unwrap_or(0)
    }
    pub fn clear_min_y(&mut self) {
        self.min_y = ::std::option::Option::None;
    }

    pub fn has_min_y(&self) -> bool {
        self.min_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_y(&mut self, v: i32) {
        self.min_y = ::std::option::Option::Some(v);
    }

    // optional int32 max_y = 5;


    pub fn get_max_y(&self) -> i32 {
        self.max_y.unwrap_or(0)
    }
    pub fn clear_max_y(&mut self) {
        self.max_y = ::std::option::Option::None;
    }

    pub fn has_max_y(&self) -> bool {
        self.max_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_y(&mut self, v: i32) {
        self.max_y = ::std::option::Option::Some(v);
    }

    // optional int32 min_z = 6;


    pub fn get_min_z(&self) -> i32 {
        self.min_z.unwrap_or(0)
    }
    pub fn clear_min_z(&mut self) {
        self.min_z = ::std::option::Option::None;
    }

    pub fn has_min_z(&self) -> bool {
        self.min_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_z(&mut self, v: i32) {
        self.min_z = ::std::option::Option::Some(v);
    }

    // optional int32 max_z = 7;


    pub fn get_max_z(&self) -> i32 {
        self.max_z.unwrap_or(0)
    }
    pub fn clear_max_z(&mut self) {
        self.max_z = ::std::option::Option::None;
    }

    pub fn has_max_z(&self) -> bool {
        self.max_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_z(&mut self, v: i32) {
        self.max_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_needed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_z = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.blocks_needed {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_z {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_z {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.blocks_needed {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.max_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.min_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.max_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.min_z {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.max_z {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockRequest {
        BlockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blocks_needed",
                |m: &BlockRequest| { &m.blocks_needed },
                |m: &mut BlockRequest| { &mut m.blocks_needed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_x",
                |m: &BlockRequest| { &m.min_x },
                |m: &mut BlockRequest| { &mut m.min_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_x",
                |m: &BlockRequest| { &m.max_x },
                |m: &mut BlockRequest| { &mut m.max_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_y",
                |m: &BlockRequest| { &m.min_y },
                |m: &mut BlockRequest| { &mut m.min_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_y",
                |m: &BlockRequest| { &m.max_y },
                |m: &mut BlockRequest| { &mut m.max_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_z",
                |m: &BlockRequest| { &m.min_z },
                |m: &mut BlockRequest| { &mut m.min_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_z",
                |m: &BlockRequest| { &m.max_z },
                |m: &mut BlockRequest| { &mut m.max_z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockRequest>(
                "BlockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockRequest {
        static instance: ::protobuf::rt::LazyV2<BlockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockRequest::new)
    }
}

impl ::protobuf::Clear for BlockRequest {
    fn clear(&mut self) {
        self.blocks_needed = ::std::option::Option::None;
        self.min_x = ::std::option::Option::None;
        self.max_x = ::std::option::Option::None;
        self.min_y = ::std::option::Option::None;
        self.max_y = ::std::option::Option::None;
        self.min_z = ::std::option::Option::None;
        self.max_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockList {
    // message fields
    pub map_blocks: ::protobuf::RepeatedField<MapBlock>,
    map_x: ::std::option::Option<i32>,
    map_y: ::std::option::Option<i32>,
    pub engravings: ::protobuf::RepeatedField<Engraving>,
    pub ocean_waves: ::protobuf::RepeatedField<Wave>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockList {
    fn default() -> &'a BlockList {
        <BlockList as ::protobuf::Message>::default_instance()
    }
}

impl BlockList {
    pub fn new() -> BlockList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.MapBlock map_blocks = 1;


    pub fn get_map_blocks(&self) -> &[MapBlock] {
        &self.map_blocks
    }
    pub fn clear_map_blocks(&mut self) {
        self.map_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_map_blocks(&mut self, v: ::protobuf::RepeatedField<MapBlock>) {
        self.map_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_map_blocks(&mut self) -> &mut ::protobuf::RepeatedField<MapBlock> {
        &mut self.map_blocks
    }

    // Take field
    pub fn take_map_blocks(&mut self) -> ::protobuf::RepeatedField<MapBlock> {
        ::std::mem::replace(&mut self.map_blocks, ::protobuf::RepeatedField::new())
    }

    // optional int32 map_x = 2;


    pub fn get_map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }
    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // optional int32 map_y = 3;


    pub fn get_map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }
    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.Engraving engravings = 4;


    pub fn get_engravings(&self) -> &[Engraving] {
        &self.engravings
    }
    pub fn clear_engravings(&mut self) {
        self.engravings.clear();
    }

    // Param is passed by value, moved
    pub fn set_engravings(&mut self, v: ::protobuf::RepeatedField<Engraving>) {
        self.engravings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_engravings(&mut self) -> &mut ::protobuf::RepeatedField<Engraving> {
        &mut self.engravings
    }

    // Take field
    pub fn take_engravings(&mut self) -> ::protobuf::RepeatedField<Engraving> {
        ::std::mem::replace(&mut self.engravings, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.Wave ocean_waves = 5;


    pub fn get_ocean_waves(&self) -> &[Wave] {
        &self.ocean_waves
    }
    pub fn clear_ocean_waves(&mut self) {
        self.ocean_waves.clear();
    }

    // Param is passed by value, moved
    pub fn set_ocean_waves(&mut self, v: ::protobuf::RepeatedField<Wave>) {
        self.ocean_waves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ocean_waves(&mut self) -> &mut ::protobuf::RepeatedField<Wave> {
        &mut self.ocean_waves
    }

    // Take field
    pub fn take_ocean_waves(&mut self) -> ::protobuf::RepeatedField<Wave> {
        ::std::mem::replace(&mut self.ocean_waves, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockList {
    fn is_initialized(&self) -> bool {
        for v in &self.map_blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.engravings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ocean_waves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.map_blocks)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.engravings)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ocean_waves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.map_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.engravings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ocean_waves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.map_blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.map_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(3, v)?;
        }
        for v in &self.engravings {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ocean_waves {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockList {
        BlockList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MapBlock>>(
                "map_blocks",
                |m: &BlockList| { &m.map_blocks },
                |m: &mut BlockList| { &mut m.map_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_x",
                |m: &BlockList| { &m.map_x },
                |m: &mut BlockList| { &mut m.map_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_y",
                |m: &BlockList| { &m.map_y },
                |m: &mut BlockList| { &mut m.map_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Engraving>>(
                "engravings",
                |m: &BlockList| { &m.engravings },
                |m: &mut BlockList| { &mut m.engravings },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Wave>>(
                "ocean_waves",
                |m: &BlockList| { &m.ocean_waves },
                |m: &mut BlockList| { &mut m.ocean_waves },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockList>(
                "BlockList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockList {
        static instance: ::protobuf::rt::LazyV2<BlockList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockList::new)
    }
}

impl ::protobuf::Clear for BlockList {
    fn clear(&mut self) {
        self.map_blocks.clear();
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.engravings.clear();
        self.ocean_waves.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlantDef {
    // message fields
    pos_x: ::std::option::Option<i32>,
    pos_y: ::std::option::Option<i32>,
    pos_z: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlantDef {
    fn default() -> &'a PlantDef {
        <PlantDef as ::protobuf::Message>::default_instance()
    }
}

impl PlantDef {
    pub fn new() -> PlantDef {
        ::std::default::Default::default()
    }

    // required int32 pos_x = 1;


    pub fn get_pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // required int32 pos_y = 2;


    pub fn get_pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // required int32 pos_z = 3;


    pub fn get_pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // required int32 index = 4;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlantDef {
    fn is_initialized(&self) -> bool {
        if self.pos_x.is_none() {
            return false;
        }
        if self.pos_y.is_none() {
            return false;
        }
        if self.pos_z.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pos_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlantDef {
        PlantDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x",
                |m: &PlantDef| { &m.pos_x },
                |m: &mut PlantDef| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y",
                |m: &PlantDef| { &m.pos_y },
                |m: &mut PlantDef| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_z",
                |m: &PlantDef| { &m.pos_z },
                |m: &mut PlantDef| { &mut m.pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &PlantDef| { &m.index },
                |m: &mut PlantDef| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlantDef>(
                "PlantDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlantDef {
        static instance: ::protobuf::rt::LazyV2<PlantDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlantDef::new)
    }
}

impl ::protobuf::Clear for PlantDef {
    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlantDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlantList {
    // message fields
    pub plant_list: ::protobuf::RepeatedField<PlantDef>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlantList {
    fn default() -> &'a PlantList {
        <PlantList as ::protobuf::Message>::default_instance()
    }
}

impl PlantList {
    pub fn new() -> PlantList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.PlantDef plant_list = 1;


    pub fn get_plant_list(&self) -> &[PlantDef] {
        &self.plant_list
    }
    pub fn clear_plant_list(&mut self) {
        self.plant_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_plant_list(&mut self, v: ::protobuf::RepeatedField<PlantDef>) {
        self.plant_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plant_list(&mut self) -> &mut ::protobuf::RepeatedField<PlantDef> {
        &mut self.plant_list
    }

    // Take field
    pub fn take_plant_list(&mut self) -> ::protobuf::RepeatedField<PlantDef> {
        ::std::mem::replace(&mut self.plant_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlantList {
    fn is_initialized(&self) -> bool {
        for v in &self.plant_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plant_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.plant_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.plant_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlantList {
        PlantList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlantDef>>(
                "plant_list",
                |m: &PlantList| { &m.plant_list },
                |m: &mut PlantList| { &mut m.plant_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlantList>(
                "PlantList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlantList {
        static instance: ::protobuf::rt::LazyV2<PlantList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlantList::new)
    }
}

impl ::protobuf::Clear for PlantList {
    fn clear(&mut self) {
        self.plant_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlantList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ViewInfo {
    // message fields
    view_pos_x: ::std::option::Option<i32>,
    view_pos_y: ::std::option::Option<i32>,
    view_pos_z: ::std::option::Option<i32>,
    view_size_x: ::std::option::Option<i32>,
    view_size_y: ::std::option::Option<i32>,
    cursor_pos_x: ::std::option::Option<i32>,
    cursor_pos_y: ::std::option::Option<i32>,
    cursor_pos_z: ::std::option::Option<i32>,
    follow_unit_id: ::std::option::Option<i32>,
    follow_item_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ViewInfo {
    fn default() -> &'a ViewInfo {
        <ViewInfo as ::protobuf::Message>::default_instance()
    }
}

impl ViewInfo {
    pub fn new() -> ViewInfo {
        ::std::default::Default::default()
    }

    // optional int32 view_pos_x = 1;


    pub fn get_view_pos_x(&self) -> i32 {
        self.view_pos_x.unwrap_or(0)
    }
    pub fn clear_view_pos_x(&mut self) {
        self.view_pos_x = ::std::option::Option::None;
    }

    pub fn has_view_pos_x(&self) -> bool {
        self.view_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_pos_x(&mut self, v: i32) {
        self.view_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 view_pos_y = 2;


    pub fn get_view_pos_y(&self) -> i32 {
        self.view_pos_y.unwrap_or(0)
    }
    pub fn clear_view_pos_y(&mut self) {
        self.view_pos_y = ::std::option::Option::None;
    }

    pub fn has_view_pos_y(&self) -> bool {
        self.view_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_pos_y(&mut self, v: i32) {
        self.view_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 view_pos_z = 3;


    pub fn get_view_pos_z(&self) -> i32 {
        self.view_pos_z.unwrap_or(0)
    }
    pub fn clear_view_pos_z(&mut self) {
        self.view_pos_z = ::std::option::Option::None;
    }

    pub fn has_view_pos_z(&self) -> bool {
        self.view_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_pos_z(&mut self, v: i32) {
        self.view_pos_z = ::std::option::Option::Some(v);
    }

    // optional int32 view_size_x = 4;


    pub fn get_view_size_x(&self) -> i32 {
        self.view_size_x.unwrap_or(0)
    }
    pub fn clear_view_size_x(&mut self) {
        self.view_size_x = ::std::option::Option::None;
    }

    pub fn has_view_size_x(&self) -> bool {
        self.view_size_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_size_x(&mut self, v: i32) {
        self.view_size_x = ::std::option::Option::Some(v);
    }

    // optional int32 view_size_y = 5;


    pub fn get_view_size_y(&self) -> i32 {
        self.view_size_y.unwrap_or(0)
    }
    pub fn clear_view_size_y(&mut self) {
        self.view_size_y = ::std::option::Option::None;
    }

    pub fn has_view_size_y(&self) -> bool {
        self.view_size_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_size_y(&mut self, v: i32) {
        self.view_size_y = ::std::option::Option::Some(v);
    }

    // optional int32 cursor_pos_x = 6;


    pub fn get_cursor_pos_x(&self) -> i32 {
        self.cursor_pos_x.unwrap_or(0)
    }
    pub fn clear_cursor_pos_x(&mut self) {
        self.cursor_pos_x = ::std::option::Option::None;
    }

    pub fn has_cursor_pos_x(&self) -> bool {
        self.cursor_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_pos_x(&mut self, v: i32) {
        self.cursor_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 cursor_pos_y = 7;


    pub fn get_cursor_pos_y(&self) -> i32 {
        self.cursor_pos_y.unwrap_or(0)
    }
    pub fn clear_cursor_pos_y(&mut self) {
        self.cursor_pos_y = ::std::option::Option::None;
    }

    pub fn has_cursor_pos_y(&self) -> bool {
        self.cursor_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_pos_y(&mut self, v: i32) {
        self.cursor_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 cursor_pos_z = 8;


    pub fn get_cursor_pos_z(&self) -> i32 {
        self.cursor_pos_z.unwrap_or(0)
    }
    pub fn clear_cursor_pos_z(&mut self) {
        self.cursor_pos_z = ::std::option::Option::None;
    }

    pub fn has_cursor_pos_z(&self) -> bool {
        self.cursor_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_pos_z(&mut self, v: i32) {
        self.cursor_pos_z = ::std::option::Option::Some(v);
    }

    // optional int32 follow_unit_id = 9;


    pub fn get_follow_unit_id(&self) -> i32 {
        self.follow_unit_id.unwrap_or(-1i32)
    }
    pub fn clear_follow_unit_id(&mut self) {
        self.follow_unit_id = ::std::option::Option::None;
    }

    pub fn has_follow_unit_id(&self) -> bool {
        self.follow_unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow_unit_id(&mut self, v: i32) {
        self.follow_unit_id = ::std::option::Option::Some(v);
    }

    // optional int32 follow_item_id = 10;


    pub fn get_follow_item_id(&self) -> i32 {
        self.follow_item_id.unwrap_or(-1i32)
    }
    pub fn clear_follow_item_id(&mut self) {
        self.follow_item_id = ::std::option::Option::None;
    }

    pub fn has_follow_item_id(&self) -> bool {
        self.follow_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow_item_id(&mut self, v: i32) {
        self.follow_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ViewInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.view_pos_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.view_pos_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.view_pos_z = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.view_size_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.view_size_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cursor_pos_x = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cursor_pos_y = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cursor_pos_z = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.follow_unit_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.follow_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.view_pos_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_pos_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_pos_z {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_size_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_size_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cursor_pos_x {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cursor_pos_y {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cursor_pos_z {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.follow_unit_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.follow_item_id {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.view_pos_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.view_pos_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.view_pos_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.view_size_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.view_size_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cursor_pos_x {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.cursor_pos_y {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.cursor_pos_z {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.follow_unit_id {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.follow_item_id {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ViewInfo {
        ViewInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "view_pos_x",
                |m: &ViewInfo| { &m.view_pos_x },
                |m: &mut ViewInfo| { &mut m.view_pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "view_pos_y",
                |m: &ViewInfo| { &m.view_pos_y },
                |m: &mut ViewInfo| { &mut m.view_pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "view_pos_z",
                |m: &ViewInfo| { &m.view_pos_z },
                |m: &mut ViewInfo| { &mut m.view_pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "view_size_x",
                |m: &ViewInfo| { &m.view_size_x },
                |m: &mut ViewInfo| { &mut m.view_size_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "view_size_y",
                |m: &ViewInfo| { &m.view_size_y },
                |m: &mut ViewInfo| { &mut m.view_size_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cursor_pos_x",
                |m: &ViewInfo| { &m.cursor_pos_x },
                |m: &mut ViewInfo| { &mut m.cursor_pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cursor_pos_y",
                |m: &ViewInfo| { &m.cursor_pos_y },
                |m: &mut ViewInfo| { &mut m.cursor_pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cursor_pos_z",
                |m: &ViewInfo| { &m.cursor_pos_z },
                |m: &mut ViewInfo| { &mut m.cursor_pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "follow_unit_id",
                |m: &ViewInfo| { &m.follow_unit_id },
                |m: &mut ViewInfo| { &mut m.follow_unit_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "follow_item_id",
                |m: &ViewInfo| { &m.follow_item_id },
                |m: &mut ViewInfo| { &mut m.follow_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ViewInfo>(
                "ViewInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ViewInfo {
        static instance: ::protobuf::rt::LazyV2<ViewInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ViewInfo::new)
    }
}

impl ::protobuf::Clear for ViewInfo {
    fn clear(&mut self) {
        self.view_pos_x = ::std::option::Option::None;
        self.view_pos_y = ::std::option::Option::None;
        self.view_pos_z = ::std::option::Option::None;
        self.view_size_x = ::std::option::Option::None;
        self.view_size_y = ::std::option::Option::None;
        self.cursor_pos_x = ::std::option::Option::None;
        self.cursor_pos_y = ::std::option::Option::None;
        self.cursor_pos_z = ::std::option::Option::None;
        self.follow_unit_id = ::std::option::Option::None;
        self.follow_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ViewInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapInfo {
    // message fields
    block_size_x: ::std::option::Option<i32>,
    block_size_y: ::std::option::Option<i32>,
    block_size_z: ::std::option::Option<i32>,
    block_pos_x: ::std::option::Option<i32>,
    block_pos_y: ::std::option::Option<i32>,
    block_pos_z: ::std::option::Option<i32>,
    world_name: ::protobuf::SingularField<::std::string::String>,
    world_name_english: ::protobuf::SingularField<::std::string::String>,
    save_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapInfo {
    fn default() -> &'a MapInfo {
        <MapInfo as ::protobuf::Message>::default_instance()
    }
}

impl MapInfo {
    pub fn new() -> MapInfo {
        ::std::default::Default::default()
    }

    // optional int32 block_size_x = 1;


    pub fn get_block_size_x(&self) -> i32 {
        self.block_size_x.unwrap_or(0)
    }
    pub fn clear_block_size_x(&mut self) {
        self.block_size_x = ::std::option::Option::None;
    }

    pub fn has_block_size_x(&self) -> bool {
        self.block_size_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size_x(&mut self, v: i32) {
        self.block_size_x = ::std::option::Option::Some(v);
    }

    // optional int32 block_size_y = 2;


    pub fn get_block_size_y(&self) -> i32 {
        self.block_size_y.unwrap_or(0)
    }
    pub fn clear_block_size_y(&mut self) {
        self.block_size_y = ::std::option::Option::None;
    }

    pub fn has_block_size_y(&self) -> bool {
        self.block_size_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size_y(&mut self, v: i32) {
        self.block_size_y = ::std::option::Option::Some(v);
    }

    // optional int32 block_size_z = 3;


    pub fn get_block_size_z(&self) -> i32 {
        self.block_size_z.unwrap_or(0)
    }
    pub fn clear_block_size_z(&mut self) {
        self.block_size_z = ::std::option::Option::None;
    }

    pub fn has_block_size_z(&self) -> bool {
        self.block_size_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size_z(&mut self, v: i32) {
        self.block_size_z = ::std::option::Option::Some(v);
    }

    // optional int32 block_pos_x = 4;


    pub fn get_block_pos_x(&self) -> i32 {
        self.block_pos_x.unwrap_or(0)
    }
    pub fn clear_block_pos_x(&mut self) {
        self.block_pos_x = ::std::option::Option::None;
    }

    pub fn has_block_pos_x(&self) -> bool {
        self.block_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_pos_x(&mut self, v: i32) {
        self.block_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 block_pos_y = 5;


    pub fn get_block_pos_y(&self) -> i32 {
        self.block_pos_y.unwrap_or(0)
    }
    pub fn clear_block_pos_y(&mut self) {
        self.block_pos_y = ::std::option::Option::None;
    }

    pub fn has_block_pos_y(&self) -> bool {
        self.block_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_pos_y(&mut self, v: i32) {
        self.block_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 block_pos_z = 6;


    pub fn get_block_pos_z(&self) -> i32 {
        self.block_pos_z.unwrap_or(0)
    }
    pub fn clear_block_pos_z(&mut self) {
        self.block_pos_z = ::std::option::Option::None;
    }

    pub fn has_block_pos_z(&self) -> bool {
        self.block_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_pos_z(&mut self, v: i32) {
        self.block_pos_z = ::std::option::Option::Some(v);
    }

    // optional string world_name = 7;


    pub fn get_world_name(&self) -> &str {
        match self.world_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_world_name(&mut self) {
        self.world_name.clear();
    }

    pub fn has_world_name(&self) -> bool {
        self.world_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_name(&mut self, v: ::std::string::String) {
        self.world_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_name(&mut self) -> &mut ::std::string::String {
        if self.world_name.is_none() {
            self.world_name.set_default();
        }
        self.world_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_name(&mut self) -> ::std::string::String {
        self.world_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string world_name_english = 8;


    pub fn get_world_name_english(&self) -> &str {
        match self.world_name_english.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_world_name_english(&mut self) {
        self.world_name_english.clear();
    }

    pub fn has_world_name_english(&self) -> bool {
        self.world_name_english.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_name_english(&mut self, v: ::std::string::String) {
        self.world_name_english = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_name_english(&mut self) -> &mut ::std::string::String {
        if self.world_name_english.is_none() {
            self.world_name_english.set_default();
        }
        self.world_name_english.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_name_english(&mut self) -> ::std::string::String {
        self.world_name_english.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string save_name = 9;


    pub fn get_save_name(&self) -> &str {
        match self.save_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_save_name(&mut self) {
        self.save_name.clear();
    }

    pub fn has_save_name(&self) -> bool {
        self.save_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_name(&mut self, v: ::std::string::String) {
        self.save_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_name(&mut self) -> &mut ::std::string::String {
        if self.save_name.is_none() {
            self.save_name.set_default();
        }
        self.save_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_name(&mut self) -> ::std::string::String {
        self.save_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MapInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_size_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_size_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_size_z = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_pos_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_pos_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_pos_z = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.world_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.world_name_english)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.save_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.block_size_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.block_size_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.block_size_z {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.block_pos_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.block_pos_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.block_pos_z {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.world_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.world_name_english.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.save_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block_size_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.block_size_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.block_size_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.block_pos_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.block_pos_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.block_pos_z {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.world_name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.world_name_english.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.save_name.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapInfo {
        MapInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_size_x",
                |m: &MapInfo| { &m.block_size_x },
                |m: &mut MapInfo| { &mut m.block_size_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_size_y",
                |m: &MapInfo| { &m.block_size_y },
                |m: &mut MapInfo| { &mut m.block_size_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_size_z",
                |m: &MapInfo| { &m.block_size_z },
                |m: &mut MapInfo| { &mut m.block_size_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_pos_x",
                |m: &MapInfo| { &m.block_pos_x },
                |m: &mut MapInfo| { &mut m.block_pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_pos_y",
                |m: &MapInfo| { &m.block_pos_y },
                |m: &mut MapInfo| { &mut m.block_pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_pos_z",
                |m: &MapInfo| { &m.block_pos_z },
                |m: &mut MapInfo| { &mut m.block_pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "world_name",
                |m: &MapInfo| { &m.world_name },
                |m: &mut MapInfo| { &mut m.world_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "world_name_english",
                |m: &MapInfo| { &m.world_name_english },
                |m: &mut MapInfo| { &mut m.world_name_english },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "save_name",
                |m: &MapInfo| { &m.save_name },
                |m: &mut MapInfo| { &mut m.save_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapInfo>(
                "MapInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapInfo {
        static instance: ::protobuf::rt::LazyV2<MapInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapInfo::new)
    }
}

impl ::protobuf::Clear for MapInfo {
    fn clear(&mut self) {
        self.block_size_x = ::std::option::Option::None;
        self.block_size_y = ::std::option::Option::None;
        self.block_size_z = ::std::option::Option::None;
        self.block_pos_x = ::std::option::Option::None;
        self.block_pos_y = ::std::option::Option::None;
        self.block_pos_z = ::std::option::Option::None;
        self.world_name.clear();
        self.world_name_english.clear();
        self.save_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cloud {
    // message fields
    front: ::std::option::Option<FrontType>,
    cumulus: ::std::option::Option<CumulusType>,
    cirrus: ::std::option::Option<bool>,
    stratus: ::std::option::Option<StratusType>,
    fog: ::std::option::Option<FogType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cloud {
    fn default() -> &'a Cloud {
        <Cloud as ::protobuf::Message>::default_instance()
    }
}

impl Cloud {
    pub fn new() -> Cloud {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.FrontType front = 1;


    pub fn get_front(&self) -> FrontType {
        self.front.unwrap_or(FrontType::FRONT_NONE)
    }
    pub fn clear_front(&mut self) {
        self.front = ::std::option::Option::None;
    }

    pub fn has_front(&self) -> bool {
        self.front.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front(&mut self, v: FrontType) {
        self.front = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.CumulusType cumulus = 2;


    pub fn get_cumulus(&self) -> CumulusType {
        self.cumulus.unwrap_or(CumulusType::CUMULUS_NONE)
    }
    pub fn clear_cumulus(&mut self) {
        self.cumulus = ::std::option::Option::None;
    }

    pub fn has_cumulus(&self) -> bool {
        self.cumulus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cumulus(&mut self, v: CumulusType) {
        self.cumulus = ::std::option::Option::Some(v);
    }

    // optional bool cirrus = 3;


    pub fn get_cirrus(&self) -> bool {
        self.cirrus.unwrap_or(false)
    }
    pub fn clear_cirrus(&mut self) {
        self.cirrus = ::std::option::Option::None;
    }

    pub fn has_cirrus(&self) -> bool {
        self.cirrus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cirrus(&mut self, v: bool) {
        self.cirrus = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.StratusType stratus = 4;


    pub fn get_stratus(&self) -> StratusType {
        self.stratus.unwrap_or(StratusType::STRATUS_NONE)
    }
    pub fn clear_stratus(&mut self) {
        self.stratus = ::std::option::Option::None;
    }

    pub fn has_stratus(&self) -> bool {
        self.stratus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stratus(&mut self, v: StratusType) {
        self.stratus = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.FogType fog = 5;


    pub fn get_fog(&self) -> FogType {
        self.fog.unwrap_or(FogType::FOG_NONE)
    }
    pub fn clear_fog(&mut self) {
        self.fog = ::std::option::Option::None;
    }

    pub fn has_fog(&self) -> bool {
        self.fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fog(&mut self, v: FogType) {
        self.fog = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Cloud {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.front, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cumulus, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cirrus = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stratus, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.fog, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.front {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.cumulus {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.cirrus {
            my_size += 2;
        }
        if let Some(v) = self.stratus {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.fog {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.front {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.cumulus {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.cirrus {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.stratus {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.fog {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cloud {
        Cloud::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FrontType>>(
                "front",
                |m: &Cloud| { &m.front },
                |m: &mut Cloud| { &mut m.front },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CumulusType>>(
                "cumulus",
                |m: &Cloud| { &m.cumulus },
                |m: &mut Cloud| { &mut m.cumulus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cirrus",
                |m: &Cloud| { &m.cirrus },
                |m: &mut Cloud| { &mut m.cirrus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StratusType>>(
                "stratus",
                |m: &Cloud| { &m.stratus },
                |m: &mut Cloud| { &mut m.stratus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FogType>>(
                "fog",
                |m: &Cloud| { &m.fog },
                |m: &mut Cloud| { &mut m.fog },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cloud>(
                "Cloud",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cloud {
        static instance: ::protobuf::rt::LazyV2<Cloud> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cloud::new)
    }
}

impl ::protobuf::Clear for Cloud {
    fn clear(&mut self) {
        self.front = ::std::option::Option::None;
        self.cumulus = ::std::option::Option::None;
        self.cirrus = ::std::option::Option::None;
        self.stratus = ::std::option::Option::None;
        self.fog = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cloud {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cloud {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorldMap {
    // message fields
    world_width: ::std::option::Option<i32>,
    world_height: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    name_english: ::protobuf::SingularField<::std::string::String>,
    pub elevation: ::std::vec::Vec<i32>,
    pub rainfall: ::std::vec::Vec<i32>,
    pub vegetation: ::std::vec::Vec<i32>,
    pub temperature: ::std::vec::Vec<i32>,
    pub evilness: ::std::vec::Vec<i32>,
    pub drainage: ::std::vec::Vec<i32>,
    pub volcanism: ::std::vec::Vec<i32>,
    pub savagery: ::std::vec::Vec<i32>,
    pub clouds: ::protobuf::RepeatedField<Cloud>,
    pub salinity: ::std::vec::Vec<i32>,
    map_x: ::std::option::Option<i32>,
    map_y: ::std::option::Option<i32>,
    center_x: ::std::option::Option<i32>,
    center_y: ::std::option::Option<i32>,
    center_z: ::std::option::Option<i32>,
    cur_year: ::std::option::Option<i32>,
    cur_year_tick: ::std::option::Option<i32>,
    world_poles: ::std::option::Option<WorldPoles>,
    pub river_tiles: ::protobuf::RepeatedField<RiverTile>,
    pub water_elevation: ::std::vec::Vec<i32>,
    pub region_tiles: ::protobuf::RepeatedField<RegionTile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorldMap {
    fn default() -> &'a WorldMap {
        <WorldMap as ::protobuf::Message>::default_instance()
    }
}

impl WorldMap {
    pub fn new() -> WorldMap {
        ::std::default::Default::default()
    }

    // required int32 world_width = 1;


    pub fn get_world_width(&self) -> i32 {
        self.world_width.unwrap_or(0)
    }
    pub fn clear_world_width(&mut self) {
        self.world_width = ::std::option::Option::None;
    }

    pub fn has_world_width(&self) -> bool {
        self.world_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_width(&mut self, v: i32) {
        self.world_width = ::std::option::Option::Some(v);
    }

    // required int32 world_height = 2;


    pub fn get_world_height(&self) -> i32 {
        self.world_height.unwrap_or(0)
    }
    pub fn clear_world_height(&mut self) {
        self.world_height = ::std::option::Option::None;
    }

    pub fn has_world_height(&self) -> bool {
        self.world_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_height(&mut self, v: i32) {
        self.world_height = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_english = 4;


    pub fn get_name_english(&self) -> &str {
        match self.name_english.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name_english(&mut self) {
        self.name_english.clear();
    }

    pub fn has_name_english(&self) -> bool {
        self.name_english.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_english(&mut self, v: ::std::string::String) {
        self.name_english = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_english(&mut self) -> &mut ::std::string::String {
        if self.name_english.is_none() {
            self.name_english.set_default();
        }
        self.name_english.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_english(&mut self) -> ::std::string::String {
        self.name_english.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int32 elevation = 5;


    pub fn get_elevation(&self) -> &[i32] {
        &self.elevation
    }
    pub fn clear_elevation(&mut self) {
        self.elevation.clear();
    }

    // Param is passed by value, moved
    pub fn set_elevation(&mut self, v: ::std::vec::Vec<i32>) {
        self.elevation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elevation(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.elevation
    }

    // Take field
    pub fn take_elevation(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.elevation, ::std::vec::Vec::new())
    }

    // repeated int32 rainfall = 6;


    pub fn get_rainfall(&self) -> &[i32] {
        &self.rainfall
    }
    pub fn clear_rainfall(&mut self) {
        self.rainfall.clear();
    }

    // Param is passed by value, moved
    pub fn set_rainfall(&mut self, v: ::std::vec::Vec<i32>) {
        self.rainfall = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rainfall(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.rainfall
    }

    // Take field
    pub fn take_rainfall(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.rainfall, ::std::vec::Vec::new())
    }

    // repeated int32 vegetation = 7;


    pub fn get_vegetation(&self) -> &[i32] {
        &self.vegetation
    }
    pub fn clear_vegetation(&mut self) {
        self.vegetation.clear();
    }

    // Param is passed by value, moved
    pub fn set_vegetation(&mut self, v: ::std::vec::Vec<i32>) {
        self.vegetation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vegetation(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.vegetation
    }

    // Take field
    pub fn take_vegetation(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.vegetation, ::std::vec::Vec::new())
    }

    // repeated int32 temperature = 8;


    pub fn get_temperature(&self) -> &[i32] {
        &self.temperature
    }
    pub fn clear_temperature(&mut self) {
        self.temperature.clear();
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: ::std::vec::Vec<i32>) {
        self.temperature = v;
    }

    // Mutable pointer to the field.
    pub fn mut_temperature(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.temperature
    }

    // Take field
    pub fn take_temperature(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.temperature, ::std::vec::Vec::new())
    }

    // repeated int32 evilness = 9;


    pub fn get_evilness(&self) -> &[i32] {
        &self.evilness
    }
    pub fn clear_evilness(&mut self) {
        self.evilness.clear();
    }

    // Param is passed by value, moved
    pub fn set_evilness(&mut self, v: ::std::vec::Vec<i32>) {
        self.evilness = v;
    }

    // Mutable pointer to the field.
    pub fn mut_evilness(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.evilness
    }

    // Take field
    pub fn take_evilness(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.evilness, ::std::vec::Vec::new())
    }

    // repeated int32 drainage = 10;


    pub fn get_drainage(&self) -> &[i32] {
        &self.drainage
    }
    pub fn clear_drainage(&mut self) {
        self.drainage.clear();
    }

    // Param is passed by value, moved
    pub fn set_drainage(&mut self, v: ::std::vec::Vec<i32>) {
        self.drainage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drainage(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.drainage
    }

    // Take field
    pub fn take_drainage(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.drainage, ::std::vec::Vec::new())
    }

    // repeated int32 volcanism = 11;


    pub fn get_volcanism(&self) -> &[i32] {
        &self.volcanism
    }
    pub fn clear_volcanism(&mut self) {
        self.volcanism.clear();
    }

    // Param is passed by value, moved
    pub fn set_volcanism(&mut self, v: ::std::vec::Vec<i32>) {
        self.volcanism = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volcanism(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.volcanism
    }

    // Take field
    pub fn take_volcanism(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.volcanism, ::std::vec::Vec::new())
    }

    // repeated int32 savagery = 12;


    pub fn get_savagery(&self) -> &[i32] {
        &self.savagery
    }
    pub fn clear_savagery(&mut self) {
        self.savagery.clear();
    }

    // Param is passed by value, moved
    pub fn set_savagery(&mut self, v: ::std::vec::Vec<i32>) {
        self.savagery = v;
    }

    // Mutable pointer to the field.
    pub fn mut_savagery(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.savagery
    }

    // Take field
    pub fn take_savagery(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.savagery, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.Cloud clouds = 13;


    pub fn get_clouds(&self) -> &[Cloud] {
        &self.clouds
    }
    pub fn clear_clouds(&mut self) {
        self.clouds.clear();
    }

    // Param is passed by value, moved
    pub fn set_clouds(&mut self, v: ::protobuf::RepeatedField<Cloud>) {
        self.clouds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clouds(&mut self) -> &mut ::protobuf::RepeatedField<Cloud> {
        &mut self.clouds
    }

    // Take field
    pub fn take_clouds(&mut self) -> ::protobuf::RepeatedField<Cloud> {
        ::std::mem::replace(&mut self.clouds, ::protobuf::RepeatedField::new())
    }

    // repeated int32 salinity = 14;


    pub fn get_salinity(&self) -> &[i32] {
        &self.salinity
    }
    pub fn clear_salinity(&mut self) {
        self.salinity.clear();
    }

    // Param is passed by value, moved
    pub fn set_salinity(&mut self, v: ::std::vec::Vec<i32>) {
        self.salinity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_salinity(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.salinity
    }

    // Take field
    pub fn take_salinity(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.salinity, ::std::vec::Vec::new())
    }

    // optional int32 map_x = 15;


    pub fn get_map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }
    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // optional int32 map_y = 16;


    pub fn get_map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }
    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // optional int32 center_x = 17;


    pub fn get_center_x(&self) -> i32 {
        self.center_x.unwrap_or(0)
    }
    pub fn clear_center_x(&mut self) {
        self.center_x = ::std::option::Option::None;
    }

    pub fn has_center_x(&self) -> bool {
        self.center_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_x(&mut self, v: i32) {
        self.center_x = ::std::option::Option::Some(v);
    }

    // optional int32 center_y = 18;


    pub fn get_center_y(&self) -> i32 {
        self.center_y.unwrap_or(0)
    }
    pub fn clear_center_y(&mut self) {
        self.center_y = ::std::option::Option::None;
    }

    pub fn has_center_y(&self) -> bool {
        self.center_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_y(&mut self, v: i32) {
        self.center_y = ::std::option::Option::Some(v);
    }

    // optional int32 center_z = 19;


    pub fn get_center_z(&self) -> i32 {
        self.center_z.unwrap_or(0)
    }
    pub fn clear_center_z(&mut self) {
        self.center_z = ::std::option::Option::None;
    }

    pub fn has_center_z(&self) -> bool {
        self.center_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_z(&mut self, v: i32) {
        self.center_z = ::std::option::Option::Some(v);
    }

    // optional int32 cur_year = 20;


    pub fn get_cur_year(&self) -> i32 {
        self.cur_year.unwrap_or(0)
    }
    pub fn clear_cur_year(&mut self) {
        self.cur_year = ::std::option::Option::None;
    }

    pub fn has_cur_year(&self) -> bool {
        self.cur_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_year(&mut self, v: i32) {
        self.cur_year = ::std::option::Option::Some(v);
    }

    // optional int32 cur_year_tick = 21;


    pub fn get_cur_year_tick(&self) -> i32 {
        self.cur_year_tick.unwrap_or(0)
    }
    pub fn clear_cur_year_tick(&mut self) {
        self.cur_year_tick = ::std::option::Option::None;
    }

    pub fn has_cur_year_tick(&self) -> bool {
        self.cur_year_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_year_tick(&mut self, v: i32) {
        self.cur_year_tick = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.WorldPoles world_poles = 22;


    pub fn get_world_poles(&self) -> WorldPoles {
        self.world_poles.unwrap_or(WorldPoles::NO_POLES)
    }
    pub fn clear_world_poles(&mut self) {
        self.world_poles = ::std::option::Option::None;
    }

    pub fn has_world_poles(&self) -> bool {
        self.world_poles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_poles(&mut self, v: WorldPoles) {
        self.world_poles = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.RiverTile river_tiles = 23;


    pub fn get_river_tiles(&self) -> &[RiverTile] {
        &self.river_tiles
    }
    pub fn clear_river_tiles(&mut self) {
        self.river_tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_river_tiles(&mut self, v: ::protobuf::RepeatedField<RiverTile>) {
        self.river_tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_river_tiles(&mut self) -> &mut ::protobuf::RepeatedField<RiverTile> {
        &mut self.river_tiles
    }

    // Take field
    pub fn take_river_tiles(&mut self) -> ::protobuf::RepeatedField<RiverTile> {
        ::std::mem::replace(&mut self.river_tiles, ::protobuf::RepeatedField::new())
    }

    // repeated int32 water_elevation = 24;


    pub fn get_water_elevation(&self) -> &[i32] {
        &self.water_elevation
    }
    pub fn clear_water_elevation(&mut self) {
        self.water_elevation.clear();
    }

    // Param is passed by value, moved
    pub fn set_water_elevation(&mut self, v: ::std::vec::Vec<i32>) {
        self.water_elevation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_water_elevation(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.water_elevation
    }

    // Take field
    pub fn take_water_elevation(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.water_elevation, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.RegionTile region_tiles = 25;


    pub fn get_region_tiles(&self) -> &[RegionTile] {
        &self.region_tiles
    }
    pub fn clear_region_tiles(&mut self) {
        self.region_tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_region_tiles(&mut self, v: ::protobuf::RepeatedField<RegionTile>) {
        self.region_tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_region_tiles(&mut self) -> &mut ::protobuf::RepeatedField<RegionTile> {
        &mut self.region_tiles
    }

    // Take field
    pub fn take_region_tiles(&mut self) -> ::protobuf::RepeatedField<RegionTile> {
        ::std::mem::replace(&mut self.region_tiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WorldMap {
    fn is_initialized(&self) -> bool {
        if self.world_width.is_none() {
            return false;
        }
        if self.world_height.is_none() {
            return false;
        }
        for v in &self.clouds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.river_tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.world_width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.world_height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_english)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.elevation)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.rainfall)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.vegetation)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.temperature)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.evilness)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.drainage)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.volcanism)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.savagery)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clouds)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.salinity)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_x = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_y = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.center_x = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.center_y = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.center_z = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cur_year = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cur_year_tick = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.world_poles, 22, &mut self.unknown_fields)?
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.river_tiles)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.water_elevation)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.region_tiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.world_width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.world_height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.name_english.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.elevation {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.rainfall {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.vegetation {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.temperature {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.evilness {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.drainage {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.volcanism {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.savagery {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.clouds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.salinity {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.center_x {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.center_y {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.center_z {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cur_year {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cur_year_tick {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.world_poles {
            my_size += ::protobuf::rt::enum_size(22, v);
        }
        for value in &self.river_tiles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.water_elevation {
            my_size += ::protobuf::rt::value_size(24, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.region_tiles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.world_width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.world_height {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.name_english.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.elevation {
            os.write_int32(5, *v)?;
        };
        for v in &self.rainfall {
            os.write_int32(6, *v)?;
        };
        for v in &self.vegetation {
            os.write_int32(7, *v)?;
        };
        for v in &self.temperature {
            os.write_int32(8, *v)?;
        };
        for v in &self.evilness {
            os.write_int32(9, *v)?;
        };
        for v in &self.drainage {
            os.write_int32(10, *v)?;
        };
        for v in &self.volcanism {
            os.write_int32(11, *v)?;
        };
        for v in &self.savagery {
            os.write_int32(12, *v)?;
        };
        for v in &self.clouds {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.salinity {
            os.write_int32(14, *v)?;
        };
        if let Some(v) = self.map_x {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.center_x {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.center_y {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.center_z {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.cur_year {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.cur_year_tick {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.world_poles {
            os.write_enum(22, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.river_tiles {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.water_elevation {
            os.write_int32(24, *v)?;
        };
        for v in &self.region_tiles {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorldMap {
        WorldMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "world_width",
                |m: &WorldMap| { &m.world_width },
                |m: &mut WorldMap| { &mut m.world_width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "world_height",
                |m: &WorldMap| { &m.world_height },
                |m: &mut WorldMap| { &mut m.world_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &WorldMap| { &m.name },
                |m: &mut WorldMap| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name_english",
                |m: &WorldMap| { &m.name_english },
                |m: &mut WorldMap| { &mut m.name_english },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "elevation",
                |m: &WorldMap| { &m.elevation },
                |m: &mut WorldMap| { &mut m.elevation },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rainfall",
                |m: &WorldMap| { &m.rainfall },
                |m: &mut WorldMap| { &mut m.rainfall },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vegetation",
                |m: &WorldMap| { &m.vegetation },
                |m: &mut WorldMap| { &mut m.vegetation },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "temperature",
                |m: &WorldMap| { &m.temperature },
                |m: &mut WorldMap| { &mut m.temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "evilness",
                |m: &WorldMap| { &m.evilness },
                |m: &mut WorldMap| { &mut m.evilness },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "drainage",
                |m: &WorldMap| { &m.drainage },
                |m: &mut WorldMap| { &mut m.drainage },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "volcanism",
                |m: &WorldMap| { &m.volcanism },
                |m: &mut WorldMap| { &mut m.volcanism },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "savagery",
                |m: &WorldMap| { &m.savagery },
                |m: &mut WorldMap| { &mut m.savagery },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cloud>>(
                "clouds",
                |m: &WorldMap| { &m.clouds },
                |m: &mut WorldMap| { &mut m.clouds },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "salinity",
                |m: &WorldMap| { &m.salinity },
                |m: &mut WorldMap| { &mut m.salinity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_x",
                |m: &WorldMap| { &m.map_x },
                |m: &mut WorldMap| { &mut m.map_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_y",
                |m: &WorldMap| { &m.map_y },
                |m: &mut WorldMap| { &mut m.map_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "center_x",
                |m: &WorldMap| { &m.center_x },
                |m: &mut WorldMap| { &mut m.center_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "center_y",
                |m: &WorldMap| { &m.center_y },
                |m: &mut WorldMap| { &mut m.center_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "center_z",
                |m: &WorldMap| { &m.center_z },
                |m: &mut WorldMap| { &mut m.center_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cur_year",
                |m: &WorldMap| { &m.cur_year },
                |m: &mut WorldMap| { &mut m.cur_year },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cur_year_tick",
                |m: &WorldMap| { &m.cur_year_tick },
                |m: &mut WorldMap| { &mut m.cur_year_tick },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorldPoles>>(
                "world_poles",
                |m: &WorldMap| { &m.world_poles },
                |m: &mut WorldMap| { &mut m.world_poles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiverTile>>(
                "river_tiles",
                |m: &WorldMap| { &m.river_tiles },
                |m: &mut WorldMap| { &mut m.river_tiles },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "water_elevation",
                |m: &WorldMap| { &m.water_elevation },
                |m: &mut WorldMap| { &mut m.water_elevation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegionTile>>(
                "region_tiles",
                |m: &WorldMap| { &m.region_tiles },
                |m: &mut WorldMap| { &mut m.region_tiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorldMap>(
                "WorldMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorldMap {
        static instance: ::protobuf::rt::LazyV2<WorldMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorldMap::new)
    }
}

impl ::protobuf::Clear for WorldMap {
    fn clear(&mut self) {
        self.world_width = ::std::option::Option::None;
        self.world_height = ::std::option::Option::None;
        self.name.clear();
        self.name_english.clear();
        self.elevation.clear();
        self.rainfall.clear();
        self.vegetation.clear();
        self.temperature.clear();
        self.evilness.clear();
        self.drainage.clear();
        self.volcanism.clear();
        self.savagery.clear();
        self.clouds.clear();
        self.salinity.clear();
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.center_x = ::std::option::Option::None;
        self.center_y = ::std::option::Option::None;
        self.center_z = ::std::option::Option::None;
        self.cur_year = ::std::option::Option::None;
        self.cur_year_tick = ::std::option::Option::None;
        self.world_poles = ::std::option::Option::None;
        self.river_tiles.clear();
        self.water_elevation.clear();
        self.region_tiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorldMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SiteRealizationBuildingWall {
    // message fields
    start_x: ::std::option::Option<i32>,
    start_y: ::std::option::Option<i32>,
    start_z: ::std::option::Option<i32>,
    end_x: ::std::option::Option<i32>,
    end_y: ::std::option::Option<i32>,
    end_z: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuildingWall {
    fn default() -> &'a SiteRealizationBuildingWall {
        <SiteRealizationBuildingWall as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuildingWall {
    pub fn new() -> SiteRealizationBuildingWall {
        ::std::default::Default::default()
    }

    // optional int32 start_x = 1;


    pub fn get_start_x(&self) -> i32 {
        self.start_x.unwrap_or(0)
    }
    pub fn clear_start_x(&mut self) {
        self.start_x = ::std::option::Option::None;
    }

    pub fn has_start_x(&self) -> bool {
        self.start_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_x(&mut self, v: i32) {
        self.start_x = ::std::option::Option::Some(v);
    }

    // optional int32 start_y = 2;


    pub fn get_start_y(&self) -> i32 {
        self.start_y.unwrap_or(0)
    }
    pub fn clear_start_y(&mut self) {
        self.start_y = ::std::option::Option::None;
    }

    pub fn has_start_y(&self) -> bool {
        self.start_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_y(&mut self, v: i32) {
        self.start_y = ::std::option::Option::Some(v);
    }

    // optional int32 start_z = 3;


    pub fn get_start_z(&self) -> i32 {
        self.start_z.unwrap_or(0)
    }
    pub fn clear_start_z(&mut self) {
        self.start_z = ::std::option::Option::None;
    }

    pub fn has_start_z(&self) -> bool {
        self.start_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_z(&mut self, v: i32) {
        self.start_z = ::std::option::Option::Some(v);
    }

    // optional int32 end_x = 4;


    pub fn get_end_x(&self) -> i32 {
        self.end_x.unwrap_or(0)
    }
    pub fn clear_end_x(&mut self) {
        self.end_x = ::std::option::Option::None;
    }

    pub fn has_end_x(&self) -> bool {
        self.end_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_x(&mut self, v: i32) {
        self.end_x = ::std::option::Option::Some(v);
    }

    // optional int32 end_y = 5;


    pub fn get_end_y(&self) -> i32 {
        self.end_y.unwrap_or(0)
    }
    pub fn clear_end_y(&mut self) {
        self.end_y = ::std::option::Option::None;
    }

    pub fn has_end_y(&self) -> bool {
        self.end_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_y(&mut self, v: i32) {
        self.end_y = ::std::option::Option::Some(v);
    }

    // optional int32 end_z = 6;


    pub fn get_end_z(&self) -> i32 {
        self.end_z.unwrap_or(0)
    }
    pub fn clear_end_z(&mut self) {
        self.end_z = ::std::option::Option::None;
    }

    pub fn has_end_z(&self) -> bool {
        self.end_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_z(&mut self, v: i32) {
        self.end_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SiteRealizationBuildingWall {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_z = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_z {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_z {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.start_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.start_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.end_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.end_z {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SiteRealizationBuildingWall {
        SiteRealizationBuildingWall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start_x",
                |m: &SiteRealizationBuildingWall| { &m.start_x },
                |m: &mut SiteRealizationBuildingWall| { &mut m.start_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start_y",
                |m: &SiteRealizationBuildingWall| { &m.start_y },
                |m: &mut SiteRealizationBuildingWall| { &mut m.start_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start_z",
                |m: &SiteRealizationBuildingWall| { &m.start_z },
                |m: &mut SiteRealizationBuildingWall| { &mut m.start_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end_x",
                |m: &SiteRealizationBuildingWall| { &m.end_x },
                |m: &mut SiteRealizationBuildingWall| { &mut m.end_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end_y",
                |m: &SiteRealizationBuildingWall| { &m.end_y },
                |m: &mut SiteRealizationBuildingWall| { &mut m.end_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end_z",
                |m: &SiteRealizationBuildingWall| { &m.end_z },
                |m: &mut SiteRealizationBuildingWall| { &mut m.end_z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SiteRealizationBuildingWall>(
                "SiteRealizationBuildingWall",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SiteRealizationBuildingWall {
        static instance: ::protobuf::rt::LazyV2<SiteRealizationBuildingWall> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SiteRealizationBuildingWall::new)
    }
}

impl ::protobuf::Clear for SiteRealizationBuildingWall {
    fn clear(&mut self) {
        self.start_x = ::std::option::Option::None;
        self.start_y = ::std::option::Option::None;
        self.start_z = ::std::option::Option::None;
        self.end_x = ::std::option::Option::None;
        self.end_y = ::std::option::Option::None;
        self.end_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SiteRealizationBuildingWall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuildingWall {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SiteRealizationBuildingTower {
    // message fields
    roof_z: ::std::option::Option<i32>,
    round: ::std::option::Option<bool>,
    goblin: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuildingTower {
    fn default() -> &'a SiteRealizationBuildingTower {
        <SiteRealizationBuildingTower as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuildingTower {
    pub fn new() -> SiteRealizationBuildingTower {
        ::std::default::Default::default()
    }

    // optional int32 roof_z = 1;


    pub fn get_roof_z(&self) -> i32 {
        self.roof_z.unwrap_or(0)
    }
    pub fn clear_roof_z(&mut self) {
        self.roof_z = ::std::option::Option::None;
    }

    pub fn has_roof_z(&self) -> bool {
        self.roof_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roof_z(&mut self, v: i32) {
        self.roof_z = ::std::option::Option::Some(v);
    }

    // optional bool round = 2;


    pub fn get_round(&self) -> bool {
        self.round.unwrap_or(false)
    }
    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: bool) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional bool goblin = 3;


    pub fn get_goblin(&self) -> bool {
        self.goblin.unwrap_or(false)
    }
    pub fn clear_goblin(&mut self) {
        self.goblin = ::std::option::Option::None;
    }

    pub fn has_goblin(&self) -> bool {
        self.goblin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goblin(&mut self, v: bool) {
        self.goblin = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SiteRealizationBuildingTower {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.roof_z = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.round = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.goblin = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.roof_z {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.round {
            my_size += 2;
        }
        if let Some(v) = self.goblin {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.roof_z {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.round {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.goblin {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SiteRealizationBuildingTower {
        SiteRealizationBuildingTower::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "roof_z",
                |m: &SiteRealizationBuildingTower| { &m.roof_z },
                |m: &mut SiteRealizationBuildingTower| { &mut m.roof_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "round",
                |m: &SiteRealizationBuildingTower| { &m.round },
                |m: &mut SiteRealizationBuildingTower| { &mut m.round },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "goblin",
                |m: &SiteRealizationBuildingTower| { &m.goblin },
                |m: &mut SiteRealizationBuildingTower| { &mut m.goblin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SiteRealizationBuildingTower>(
                "SiteRealizationBuildingTower",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SiteRealizationBuildingTower {
        static instance: ::protobuf::rt::LazyV2<SiteRealizationBuildingTower> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SiteRealizationBuildingTower::new)
    }
}

impl ::protobuf::Clear for SiteRealizationBuildingTower {
    fn clear(&mut self) {
        self.roof_z = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.goblin = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SiteRealizationBuildingTower {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuildingTower {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrenchSpoke {
    // message fields
    mound_start: ::std::option::Option<i32>,
    trench_start: ::std::option::Option<i32>,
    trench_end: ::std::option::Option<i32>,
    mound_end: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrenchSpoke {
    fn default() -> &'a TrenchSpoke {
        <TrenchSpoke as ::protobuf::Message>::default_instance()
    }
}

impl TrenchSpoke {
    pub fn new() -> TrenchSpoke {
        ::std::default::Default::default()
    }

    // optional int32 mound_start = 1;


    pub fn get_mound_start(&self) -> i32 {
        self.mound_start.unwrap_or(0)
    }
    pub fn clear_mound_start(&mut self) {
        self.mound_start = ::std::option::Option::None;
    }

    pub fn has_mound_start(&self) -> bool {
        self.mound_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mound_start(&mut self, v: i32) {
        self.mound_start = ::std::option::Option::Some(v);
    }

    // optional int32 trench_start = 2;


    pub fn get_trench_start(&self) -> i32 {
        self.trench_start.unwrap_or(0)
    }
    pub fn clear_trench_start(&mut self) {
        self.trench_start = ::std::option::Option::None;
    }

    pub fn has_trench_start(&self) -> bool {
        self.trench_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trench_start(&mut self, v: i32) {
        self.trench_start = ::std::option::Option::Some(v);
    }

    // optional int32 trench_end = 3;


    pub fn get_trench_end(&self) -> i32 {
        self.trench_end.unwrap_or(0)
    }
    pub fn clear_trench_end(&mut self) {
        self.trench_end = ::std::option::Option::None;
    }

    pub fn has_trench_end(&self) -> bool {
        self.trench_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trench_end(&mut self, v: i32) {
        self.trench_end = ::std::option::Option::Some(v);
    }

    // optional int32 mound_end = 4;


    pub fn get_mound_end(&self) -> i32 {
        self.mound_end.unwrap_or(0)
    }
    pub fn clear_mound_end(&mut self) {
        self.mound_end = ::std::option::Option::None;
    }

    pub fn has_mound_end(&self) -> bool {
        self.mound_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mound_end(&mut self, v: i32) {
        self.mound_end = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TrenchSpoke {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mound_start = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trench_start = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trench_end = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mound_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mound_start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trench_start {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trench_end {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mound_end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mound_start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.trench_start {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.trench_end {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mound_end {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrenchSpoke {
        TrenchSpoke::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mound_start",
                |m: &TrenchSpoke| { &m.mound_start },
                |m: &mut TrenchSpoke| { &mut m.mound_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trench_start",
                |m: &TrenchSpoke| { &m.trench_start },
                |m: &mut TrenchSpoke| { &mut m.trench_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trench_end",
                |m: &TrenchSpoke| { &m.trench_end },
                |m: &mut TrenchSpoke| { &mut m.trench_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mound_end",
                |m: &TrenchSpoke| { &m.mound_end },
                |m: &mut TrenchSpoke| { &mut m.mound_end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrenchSpoke>(
                "TrenchSpoke",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrenchSpoke {
        static instance: ::protobuf::rt::LazyV2<TrenchSpoke> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrenchSpoke::new)
    }
}

impl ::protobuf::Clear for TrenchSpoke {
    fn clear(&mut self) {
        self.mound_start = ::std::option::Option::None;
        self.trench_start = ::std::option::Option::None;
        self.trench_end = ::std::option::Option::None;
        self.mound_end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrenchSpoke {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrenchSpoke {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SiteRealizationBuildingTrenches {
    // message fields
    pub spokes: ::protobuf::RepeatedField<TrenchSpoke>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuildingTrenches {
    fn default() -> &'a SiteRealizationBuildingTrenches {
        <SiteRealizationBuildingTrenches as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuildingTrenches {
    pub fn new() -> SiteRealizationBuildingTrenches {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.TrenchSpoke spokes = 1;


    pub fn get_spokes(&self) -> &[TrenchSpoke] {
        &self.spokes
    }
    pub fn clear_spokes(&mut self) {
        self.spokes.clear();
    }

    // Param is passed by value, moved
    pub fn set_spokes(&mut self, v: ::protobuf::RepeatedField<TrenchSpoke>) {
        self.spokes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spokes(&mut self) -> &mut ::protobuf::RepeatedField<TrenchSpoke> {
        &mut self.spokes
    }

    // Take field
    pub fn take_spokes(&mut self) -> ::protobuf::RepeatedField<TrenchSpoke> {
        ::std::mem::replace(&mut self.spokes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SiteRealizationBuildingTrenches {
    fn is_initialized(&self) -> bool {
        for v in &self.spokes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spokes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.spokes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.spokes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SiteRealizationBuildingTrenches {
        SiteRealizationBuildingTrenches::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrenchSpoke>>(
                "spokes",
                |m: &SiteRealizationBuildingTrenches| { &m.spokes },
                |m: &mut SiteRealizationBuildingTrenches| { &mut m.spokes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SiteRealizationBuildingTrenches>(
                "SiteRealizationBuildingTrenches",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SiteRealizationBuildingTrenches {
        static instance: ::protobuf::rt::LazyV2<SiteRealizationBuildingTrenches> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SiteRealizationBuildingTrenches::new)
    }
}

impl ::protobuf::Clear for SiteRealizationBuildingTrenches {
    fn clear(&mut self) {
        self.spokes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SiteRealizationBuildingTrenches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuildingTrenches {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SiteRealizationBuilding {
    // message fields
    id: ::std::option::Option<i32>,
    min_x: ::std::option::Option<i32>,
    min_y: ::std::option::Option<i32>,
    max_x: ::std::option::Option<i32>,
    max_y: ::std::option::Option<i32>,
    pub material: ::protobuf::SingularPtrField<MatPair>,
    pub wall_info: ::protobuf::SingularPtrField<SiteRealizationBuildingWall>,
    pub tower_info: ::protobuf::SingularPtrField<SiteRealizationBuildingTower>,
    pub trench_info: ::protobuf::SingularPtrField<SiteRealizationBuildingTrenches>,
    field_type: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuilding {
    fn default() -> &'a SiteRealizationBuilding {
        <SiteRealizationBuilding as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuilding {
    pub fn new() -> SiteRealizationBuilding {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 min_x = 3;


    pub fn get_min_x(&self) -> i32 {
        self.min_x.unwrap_or(0)
    }
    pub fn clear_min_x(&mut self) {
        self.min_x = ::std::option::Option::None;
    }

    pub fn has_min_x(&self) -> bool {
        self.min_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_x(&mut self, v: i32) {
        self.min_x = ::std::option::Option::Some(v);
    }

    // optional int32 min_y = 4;


    pub fn get_min_y(&self) -> i32 {
        self.min_y.unwrap_or(0)
    }
    pub fn clear_min_y(&mut self) {
        self.min_y = ::std::option::Option::None;
    }

    pub fn has_min_y(&self) -> bool {
        self.min_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_y(&mut self, v: i32) {
        self.min_y = ::std::option::Option::Some(v);
    }

    // optional int32 max_x = 5;


    pub fn get_max_x(&self) -> i32 {
        self.max_x.unwrap_or(0)
    }
    pub fn clear_max_x(&mut self) {
        self.max_x = ::std::option::Option::None;
    }

    pub fn has_max_x(&self) -> bool {
        self.max_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_x(&mut self, v: i32) {
        self.max_x = ::std::option::Option::Some(v);
    }

    // optional int32 max_y = 6;


    pub fn get_max_y(&self) -> i32 {
        self.max_y.unwrap_or(0)
    }
    pub fn clear_max_y(&mut self) {
        self.max_y = ::std::option::Option::None;
    }

    pub fn has_max_y(&self) -> bool {
        self.max_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_y(&mut self, v: i32) {
        self.max_y = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair material = 7;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional .RemoteFortressReader.SiteRealizationBuildingWall wall_info = 8;


    pub fn get_wall_info(&self) -> &SiteRealizationBuildingWall {
        self.wall_info.as_ref().unwrap_or_else(|| <SiteRealizationBuildingWall as ::protobuf::Message>::default_instance())
    }
    pub fn clear_wall_info(&mut self) {
        self.wall_info.clear();
    }

    pub fn has_wall_info(&self) -> bool {
        self.wall_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wall_info(&mut self, v: SiteRealizationBuildingWall) {
        self.wall_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wall_info(&mut self) -> &mut SiteRealizationBuildingWall {
        if self.wall_info.is_none() {
            self.wall_info.set_default();
        }
        self.wall_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_wall_info(&mut self) -> SiteRealizationBuildingWall {
        self.wall_info.take().unwrap_or_else(|| SiteRealizationBuildingWall::new())
    }

    // optional .RemoteFortressReader.SiteRealizationBuildingTower tower_info = 9;


    pub fn get_tower_info(&self) -> &SiteRealizationBuildingTower {
        self.tower_info.as_ref().unwrap_or_else(|| <SiteRealizationBuildingTower as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tower_info(&mut self) {
        self.tower_info.clear();
    }

    pub fn has_tower_info(&self) -> bool {
        self.tower_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_info(&mut self, v: SiteRealizationBuildingTower) {
        self.tower_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tower_info(&mut self) -> &mut SiteRealizationBuildingTower {
        if self.tower_info.is_none() {
            self.tower_info.set_default();
        }
        self.tower_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tower_info(&mut self) -> SiteRealizationBuildingTower {
        self.tower_info.take().unwrap_or_else(|| SiteRealizationBuildingTower::new())
    }

    // optional .RemoteFortressReader.SiteRealizationBuildingTrenches trench_info = 10;


    pub fn get_trench_info(&self) -> &SiteRealizationBuildingTrenches {
        self.trench_info.as_ref().unwrap_or_else(|| <SiteRealizationBuildingTrenches as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trench_info(&mut self) {
        self.trench_info.clear();
    }

    pub fn has_trench_info(&self) -> bool {
        self.trench_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trench_info(&mut self, v: SiteRealizationBuildingTrenches) {
        self.trench_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trench_info(&mut self) -> &mut SiteRealizationBuildingTrenches {
        if self.trench_info.is_none() {
            self.trench_info.set_default();
        }
        self.trench_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_trench_info(&mut self) -> SiteRealizationBuildingTrenches {
        self.trench_info.take().unwrap_or_else(|| SiteRealizationBuildingTrenches::new())
    }

    // optional int32 type = 11;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SiteRealizationBuilding {
    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wall_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tower_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trench_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_x = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_y = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wall_info)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tower_info)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trench_info)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_x {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_y {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.wall_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tower_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trench_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.min_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.max_x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.max_y {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.wall_info.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tower_info.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trench_info.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SiteRealizationBuilding {
        SiteRealizationBuilding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &SiteRealizationBuilding| { &m.id },
                |m: &mut SiteRealizationBuilding| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_x",
                |m: &SiteRealizationBuilding| { &m.min_x },
                |m: &mut SiteRealizationBuilding| { &mut m.min_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_y",
                |m: &SiteRealizationBuilding| { &m.min_y },
                |m: &mut SiteRealizationBuilding| { &mut m.min_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_x",
                |m: &SiteRealizationBuilding| { &m.max_x },
                |m: &mut SiteRealizationBuilding| { &mut m.max_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_y",
                |m: &SiteRealizationBuilding| { &m.max_y },
                |m: &mut SiteRealizationBuilding| { &mut m.max_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &SiteRealizationBuilding| { &m.material },
                |m: &mut SiteRealizationBuilding| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SiteRealizationBuildingWall>>(
                "wall_info",
                |m: &SiteRealizationBuilding| { &m.wall_info },
                |m: &mut SiteRealizationBuilding| { &mut m.wall_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SiteRealizationBuildingTower>>(
                "tower_info",
                |m: &SiteRealizationBuilding| { &m.tower_info },
                |m: &mut SiteRealizationBuilding| { &mut m.tower_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SiteRealizationBuildingTrenches>>(
                "trench_info",
                |m: &SiteRealizationBuilding| { &m.trench_info },
                |m: &mut SiteRealizationBuilding| { &mut m.trench_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &SiteRealizationBuilding| { &m.field_type },
                |m: &mut SiteRealizationBuilding| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SiteRealizationBuilding>(
                "SiteRealizationBuilding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SiteRealizationBuilding {
        static instance: ::protobuf::rt::LazyV2<SiteRealizationBuilding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SiteRealizationBuilding::new)
    }
}

impl ::protobuf::Clear for SiteRealizationBuilding {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.min_x = ::std::option::Option::None;
        self.min_y = ::std::option::Option::None;
        self.max_x = ::std::option::Option::None;
        self.max_y = ::std::option::Option::None;
        self.material.clear();
        self.wall_info.clear();
        self.tower_info.clear();
        self.trench_info.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SiteRealizationBuilding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuilding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegionTile {
    // message fields
    elevation: ::std::option::Option<i32>,
    rainfall: ::std::option::Option<i32>,
    vegetation: ::std::option::Option<i32>,
    temperature: ::std::option::Option<i32>,
    evilness: ::std::option::Option<i32>,
    drainage: ::std::option::Option<i32>,
    volcanism: ::std::option::Option<i32>,
    savagery: ::std::option::Option<i32>,
    salinity: ::std::option::Option<i32>,
    pub river_tiles: ::protobuf::SingularPtrField<RiverTile>,
    water_elevation: ::std::option::Option<i32>,
    pub surface_material: ::protobuf::SingularPtrField<MatPair>,
    pub plant_materials: ::protobuf::RepeatedField<MatPair>,
    pub buildings: ::protobuf::RepeatedField<SiteRealizationBuilding>,
    pub stone_materials: ::protobuf::RepeatedField<MatPair>,
    pub tree_materials: ::protobuf::RepeatedField<MatPair>,
    snow: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegionTile {
    fn default() -> &'a RegionTile {
        <RegionTile as ::protobuf::Message>::default_instance()
    }
}

impl RegionTile {
    pub fn new() -> RegionTile {
        ::std::default::Default::default()
    }

    // optional int32 elevation = 1;


    pub fn get_elevation(&self) -> i32 {
        self.elevation.unwrap_or(0)
    }
    pub fn clear_elevation(&mut self) {
        self.elevation = ::std::option::Option::None;
    }

    pub fn has_elevation(&self) -> bool {
        self.elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevation(&mut self, v: i32) {
        self.elevation = ::std::option::Option::Some(v);
    }

    // optional int32 rainfall = 2;


    pub fn get_rainfall(&self) -> i32 {
        self.rainfall.unwrap_or(0)
    }
    pub fn clear_rainfall(&mut self) {
        self.rainfall = ::std::option::Option::None;
    }

    pub fn has_rainfall(&self) -> bool {
        self.rainfall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rainfall(&mut self, v: i32) {
        self.rainfall = ::std::option::Option::Some(v);
    }

    // optional int32 vegetation = 3;


    pub fn get_vegetation(&self) -> i32 {
        self.vegetation.unwrap_or(0)
    }
    pub fn clear_vegetation(&mut self) {
        self.vegetation = ::std::option::Option::None;
    }

    pub fn has_vegetation(&self) -> bool {
        self.vegetation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vegetation(&mut self, v: i32) {
        self.vegetation = ::std::option::Option::Some(v);
    }

    // optional int32 temperature = 4;


    pub fn get_temperature(&self) -> i32 {
        self.temperature.unwrap_or(0)
    }
    pub fn clear_temperature(&mut self) {
        self.temperature = ::std::option::Option::None;
    }

    pub fn has_temperature(&self) -> bool {
        self.temperature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: i32) {
        self.temperature = ::std::option::Option::Some(v);
    }

    // optional int32 evilness = 5;


    pub fn get_evilness(&self) -> i32 {
        self.evilness.unwrap_or(0)
    }
    pub fn clear_evilness(&mut self) {
        self.evilness = ::std::option::Option::None;
    }

    pub fn has_evilness(&self) -> bool {
        self.evilness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evilness(&mut self, v: i32) {
        self.evilness = ::std::option::Option::Some(v);
    }

    // optional int32 drainage = 6;


    pub fn get_drainage(&self) -> i32 {
        self.drainage.unwrap_or(0)
    }
    pub fn clear_drainage(&mut self) {
        self.drainage = ::std::option::Option::None;
    }

    pub fn has_drainage(&self) -> bool {
        self.drainage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drainage(&mut self, v: i32) {
        self.drainage = ::std::option::Option::Some(v);
    }

    // optional int32 volcanism = 7;


    pub fn get_volcanism(&self) -> i32 {
        self.volcanism.unwrap_or(0)
    }
    pub fn clear_volcanism(&mut self) {
        self.volcanism = ::std::option::Option::None;
    }

    pub fn has_volcanism(&self) -> bool {
        self.volcanism.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volcanism(&mut self, v: i32) {
        self.volcanism = ::std::option::Option::Some(v);
    }

    // optional int32 savagery = 8;


    pub fn get_savagery(&self) -> i32 {
        self.savagery.unwrap_or(0)
    }
    pub fn clear_savagery(&mut self) {
        self.savagery = ::std::option::Option::None;
    }

    pub fn has_savagery(&self) -> bool {
        self.savagery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_savagery(&mut self, v: i32) {
        self.savagery = ::std::option::Option::Some(v);
    }

    // optional int32 salinity = 9;


    pub fn get_salinity(&self) -> i32 {
        self.salinity.unwrap_or(0)
    }
    pub fn clear_salinity(&mut self) {
        self.salinity = ::std::option::Option::None;
    }

    pub fn has_salinity(&self) -> bool {
        self.salinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salinity(&mut self, v: i32) {
        self.salinity = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.RiverTile river_tiles = 10;


    pub fn get_river_tiles(&self) -> &RiverTile {
        self.river_tiles.as_ref().unwrap_or_else(|| <RiverTile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_river_tiles(&mut self) {
        self.river_tiles.clear();
    }

    pub fn has_river_tiles(&self) -> bool {
        self.river_tiles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_river_tiles(&mut self, v: RiverTile) {
        self.river_tiles = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_river_tiles(&mut self) -> &mut RiverTile {
        if self.river_tiles.is_none() {
            self.river_tiles.set_default();
        }
        self.river_tiles.as_mut().unwrap()
    }

    // Take field
    pub fn take_river_tiles(&mut self) -> RiverTile {
        self.river_tiles.take().unwrap_or_else(|| RiverTile::new())
    }

    // optional int32 water_elevation = 11;


    pub fn get_water_elevation(&self) -> i32 {
        self.water_elevation.unwrap_or(0)
    }
    pub fn clear_water_elevation(&mut self) {
        self.water_elevation = ::std::option::Option::None;
    }

    pub fn has_water_elevation(&self) -> bool {
        self.water_elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_water_elevation(&mut self, v: i32) {
        self.water_elevation = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair surface_material = 12;


    pub fn get_surface_material(&self) -> &MatPair {
        self.surface_material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_surface_material(&mut self) {
        self.surface_material.clear();
    }

    pub fn has_surface_material(&self) -> bool {
        self.surface_material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface_material(&mut self, v: MatPair) {
        self.surface_material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_surface_material(&mut self) -> &mut MatPair {
        if self.surface_material.is_none() {
            self.surface_material.set_default();
        }
        self.surface_material.as_mut().unwrap()
    }

    // Take field
    pub fn take_surface_material(&mut self) -> MatPair {
        self.surface_material.take().unwrap_or_else(|| MatPair::new())
    }

    // repeated .RemoteFortressReader.MatPair plant_materials = 13;


    pub fn get_plant_materials(&self) -> &[MatPair] {
        &self.plant_materials
    }
    pub fn clear_plant_materials(&mut self) {
        self.plant_materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_plant_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.plant_materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plant_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.plant_materials
    }

    // Take field
    pub fn take_plant_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.plant_materials, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.SiteRealizationBuilding buildings = 14;


    pub fn get_buildings(&self) -> &[SiteRealizationBuilding] {
        &self.buildings
    }
    pub fn clear_buildings(&mut self) {
        self.buildings.clear();
    }

    // Param is passed by value, moved
    pub fn set_buildings(&mut self, v: ::protobuf::RepeatedField<SiteRealizationBuilding>) {
        self.buildings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buildings(&mut self) -> &mut ::protobuf::RepeatedField<SiteRealizationBuilding> {
        &mut self.buildings
    }

    // Take field
    pub fn take_buildings(&mut self) -> ::protobuf::RepeatedField<SiteRealizationBuilding> {
        ::std::mem::replace(&mut self.buildings, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.MatPair stone_materials = 15;


    pub fn get_stone_materials(&self) -> &[MatPair] {
        &self.stone_materials
    }
    pub fn clear_stone_materials(&mut self) {
        self.stone_materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_stone_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.stone_materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stone_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.stone_materials
    }

    // Take field
    pub fn take_stone_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.stone_materials, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.MatPair tree_materials = 16;


    pub fn get_tree_materials(&self) -> &[MatPair] {
        &self.tree_materials
    }
    pub fn clear_tree_materials(&mut self) {
        self.tree_materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_materials(&mut self, v: ::protobuf::RepeatedField<MatPair>) {
        self.tree_materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_materials(&mut self) -> &mut ::protobuf::RepeatedField<MatPair> {
        &mut self.tree_materials
    }

    // Take field
    pub fn take_tree_materials(&mut self) -> ::protobuf::RepeatedField<MatPair> {
        ::std::mem::replace(&mut self.tree_materials, ::protobuf::RepeatedField::new())
    }

    // optional int32 snow = 17;


    pub fn get_snow(&self) -> i32 {
        self.snow.unwrap_or(0)
    }
    pub fn clear_snow(&mut self) {
        self.snow = ::std::option::Option::None;
    }

    pub fn has_snow(&self) -> bool {
        self.snow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snow(&mut self, v: i32) {
        self.snow = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RegionTile {
    fn is_initialized(&self) -> bool {
        for v in &self.river_tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.surface_material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plant_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stone_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tree_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.elevation = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rainfall = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vegetation = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.temperature = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.evilness = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.drainage = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.volcanism = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.savagery = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.salinity = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.river_tiles)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.water_elevation = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.surface_material)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plant_materials)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buildings)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stone_materials)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tree_materials)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.snow = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.elevation {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rainfall {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vegetation {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.temperature {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.evilness {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.drainage {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.volcanism {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.savagery {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.salinity {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.river_tiles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.water_elevation {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.surface_material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.plant_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stone_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tree_materials {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.snow {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.elevation {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rainfall {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vegetation {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.temperature {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.evilness {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.drainage {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.volcanism {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.savagery {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.salinity {
            os.write_int32(9, v)?;
        }
        if let Some(ref v) = self.river_tiles.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.water_elevation {
            os.write_int32(11, v)?;
        }
        if let Some(ref v) = self.surface_material.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.plant_materials {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buildings {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stone_materials {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tree_materials {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.snow {
            os.write_int32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegionTile {
        RegionTile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "elevation",
                |m: &RegionTile| { &m.elevation },
                |m: &mut RegionTile| { &mut m.elevation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rainfall",
                |m: &RegionTile| { &m.rainfall },
                |m: &mut RegionTile| { &mut m.rainfall },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vegetation",
                |m: &RegionTile| { &m.vegetation },
                |m: &mut RegionTile| { &mut m.vegetation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "temperature",
                |m: &RegionTile| { &m.temperature },
                |m: &mut RegionTile| { &mut m.temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "evilness",
                |m: &RegionTile| { &m.evilness },
                |m: &mut RegionTile| { &mut m.evilness },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "drainage",
                |m: &RegionTile| { &m.drainage },
                |m: &mut RegionTile| { &mut m.drainage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "volcanism",
                |m: &RegionTile| { &m.volcanism },
                |m: &mut RegionTile| { &mut m.volcanism },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "savagery",
                |m: &RegionTile| { &m.savagery },
                |m: &mut RegionTile| { &mut m.savagery },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "salinity",
                |m: &RegionTile| { &m.salinity },
                |m: &mut RegionTile| { &mut m.salinity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiverTile>>(
                "river_tiles",
                |m: &RegionTile| { &m.river_tiles },
                |m: &mut RegionTile| { &mut m.river_tiles },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "water_elevation",
                |m: &RegionTile| { &m.water_elevation },
                |m: &mut RegionTile| { &mut m.water_elevation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "surface_material",
                |m: &RegionTile| { &m.surface_material },
                |m: &mut RegionTile| { &mut m.surface_material },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "plant_materials",
                |m: &RegionTile| { &m.plant_materials },
                |m: &mut RegionTile| { &mut m.plant_materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SiteRealizationBuilding>>(
                "buildings",
                |m: &RegionTile| { &m.buildings },
                |m: &mut RegionTile| { &mut m.buildings },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "stone_materials",
                |m: &RegionTile| { &m.stone_materials },
                |m: &mut RegionTile| { &mut m.stone_materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "tree_materials",
                |m: &RegionTile| { &m.tree_materials },
                |m: &mut RegionTile| { &mut m.tree_materials },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "snow",
                |m: &RegionTile| { &m.snow },
                |m: &mut RegionTile| { &mut m.snow },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegionTile>(
                "RegionTile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegionTile {
        static instance: ::protobuf::rt::LazyV2<RegionTile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegionTile::new)
    }
}

impl ::protobuf::Clear for RegionTile {
    fn clear(&mut self) {
        self.elevation = ::std::option::Option::None;
        self.rainfall = ::std::option::Option::None;
        self.vegetation = ::std::option::Option::None;
        self.temperature = ::std::option::Option::None;
        self.evilness = ::std::option::Option::None;
        self.drainage = ::std::option::Option::None;
        self.volcanism = ::std::option::Option::None;
        self.savagery = ::std::option::Option::None;
        self.salinity = ::std::option::Option::None;
        self.river_tiles.clear();
        self.water_elevation = ::std::option::Option::None;
        self.surface_material.clear();
        self.plant_materials.clear();
        self.buildings.clear();
        self.stone_materials.clear();
        self.tree_materials.clear();
        self.snow = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegionTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionTile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegionMap {
    // message fields
    map_x: ::std::option::Option<i32>,
    map_y: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    name_english: ::protobuf::SingularField<::std::string::String>,
    pub tiles: ::protobuf::RepeatedField<RegionTile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegionMap {
    fn default() -> &'a RegionMap {
        <RegionMap as ::protobuf::Message>::default_instance()
    }
}

impl RegionMap {
    pub fn new() -> RegionMap {
        ::std::default::Default::default()
    }

    // optional int32 map_x = 1;


    pub fn get_map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }
    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // optional int32 map_y = 2;


    pub fn get_map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }
    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_english = 4;


    pub fn get_name_english(&self) -> &str {
        match self.name_english.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name_english(&mut self) {
        self.name_english.clear();
    }

    pub fn has_name_english(&self) -> bool {
        self.name_english.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_english(&mut self, v: ::std::string::String) {
        self.name_english = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_english(&mut self) -> &mut ::std::string::String {
        if self.name_english.is_none() {
            self.name_english.set_default();
        }
        self.name_english.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_english(&mut self) -> ::std::string::String {
        self.name_english.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .RemoteFortressReader.RegionTile tiles = 5;


    pub fn get_tiles(&self) -> &[RegionTile] {
        &self.tiles
    }
    pub fn clear_tiles(&mut self) {
        self.tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiles(&mut self, v: ::protobuf::RepeatedField<RegionTile>) {
        self.tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiles(&mut self) -> &mut ::protobuf::RepeatedField<RegionTile> {
        &mut self.tiles
    }

    // Take field
    pub fn take_tiles(&mut self) -> ::protobuf::RepeatedField<RegionTile> {
        ::std::mem::replace(&mut self.tiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RegionMap {
    fn is_initialized(&self) -> bool {
        for v in &self.tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.map_y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_english)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.name_english.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.map_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.name_english.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.tiles {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegionMap {
        RegionMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_x",
                |m: &RegionMap| { &m.map_x },
                |m: &mut RegionMap| { &mut m.map_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "map_y",
                |m: &RegionMap| { &m.map_y },
                |m: &mut RegionMap| { &mut m.map_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RegionMap| { &m.name },
                |m: &mut RegionMap| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name_english",
                |m: &RegionMap| { &m.name_english },
                |m: &mut RegionMap| { &mut m.name_english },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegionTile>>(
                "tiles",
                |m: &RegionMap| { &m.tiles },
                |m: &mut RegionMap| { &mut m.tiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegionMap>(
                "RegionMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegionMap {
        static instance: ::protobuf::rt::LazyV2<RegionMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegionMap::new)
    }
}

impl ::protobuf::Clear for RegionMap {
    fn clear(&mut self) {
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.name.clear();
        self.name_english.clear();
        self.tiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegionMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegionMaps {
    // message fields
    pub world_maps: ::protobuf::RepeatedField<WorldMap>,
    pub region_maps: ::protobuf::RepeatedField<RegionMap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegionMaps {
    fn default() -> &'a RegionMaps {
        <RegionMaps as ::protobuf::Message>::default_instance()
    }
}

impl RegionMaps {
    pub fn new() -> RegionMaps {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.WorldMap world_maps = 1;


    pub fn get_world_maps(&self) -> &[WorldMap] {
        &self.world_maps
    }
    pub fn clear_world_maps(&mut self) {
        self.world_maps.clear();
    }

    // Param is passed by value, moved
    pub fn set_world_maps(&mut self, v: ::protobuf::RepeatedField<WorldMap>) {
        self.world_maps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_world_maps(&mut self) -> &mut ::protobuf::RepeatedField<WorldMap> {
        &mut self.world_maps
    }

    // Take field
    pub fn take_world_maps(&mut self) -> ::protobuf::RepeatedField<WorldMap> {
        ::std::mem::replace(&mut self.world_maps, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.RegionMap region_maps = 2;


    pub fn get_region_maps(&self) -> &[RegionMap] {
        &self.region_maps
    }
    pub fn clear_region_maps(&mut self) {
        self.region_maps.clear();
    }

    // Param is passed by value, moved
    pub fn set_region_maps(&mut self, v: ::protobuf::RepeatedField<RegionMap>) {
        self.region_maps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_region_maps(&mut self) -> &mut ::protobuf::RepeatedField<RegionMap> {
        &mut self.region_maps
    }

    // Take field
    pub fn take_region_maps(&mut self) -> ::protobuf::RepeatedField<RegionMap> {
        ::std::mem::replace(&mut self.region_maps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RegionMaps {
    fn is_initialized(&self) -> bool {
        for v in &self.world_maps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_maps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.world_maps)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.region_maps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.world_maps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.region_maps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.world_maps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.region_maps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegionMaps {
        RegionMaps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorldMap>>(
                "world_maps",
                |m: &RegionMaps| { &m.world_maps },
                |m: &mut RegionMaps| { &mut m.world_maps },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegionMap>>(
                "region_maps",
                |m: &RegionMaps| { &m.region_maps },
                |m: &mut RegionMaps| { &mut m.region_maps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegionMaps>(
                "RegionMaps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegionMaps {
        static instance: ::protobuf::rt::LazyV2<RegionMaps> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegionMaps::new)
    }
}

impl ::protobuf::Clear for RegionMaps {
    fn clear(&mut self) {
        self.world_maps.clear();
        self.region_maps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegionMaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionMaps {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatternDescriptor {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    pub colors: ::protobuf::RepeatedField<ColorDefinition>,
    pattern: ::std::option::Option<PatternType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatternDescriptor {
    fn default() -> &'a PatternDescriptor {
        <PatternDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl PatternDescriptor {
    pub fn new() -> PatternDescriptor {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .RemoteFortressReader.ColorDefinition colors = 2;


    pub fn get_colors(&self) -> &[ColorDefinition] {
        &self.colors
    }
    pub fn clear_colors(&mut self) {
        self.colors.clear();
    }

    // Param is passed by value, moved
    pub fn set_colors(&mut self, v: ::protobuf::RepeatedField<ColorDefinition>) {
        self.colors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colors(&mut self) -> &mut ::protobuf::RepeatedField<ColorDefinition> {
        &mut self.colors
    }

    // Take field
    pub fn take_colors(&mut self) -> ::protobuf::RepeatedField<ColorDefinition> {
        ::std::mem::replace(&mut self.colors, ::protobuf::RepeatedField::new())
    }

    // optional .RemoteFortressReader.PatternType pattern = 3;


    pub fn get_pattern(&self) -> PatternType {
        self.pattern.unwrap_or(PatternType::MONOTONE)
    }
    pub fn clear_pattern(&mut self) {
        self.pattern = ::std::option::Option::None;
    }

    pub fn has_pattern(&self) -> bool {
        self.pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: PatternType) {
        self.pattern = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PatternDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.colors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.colors)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.pattern, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.pattern {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.colors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.pattern {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatternDescriptor {
        PatternDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PatternDescriptor| { &m.id },
                |m: &mut PatternDescriptor| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "colors",
                |m: &PatternDescriptor| { &m.colors },
                |m: &mut PatternDescriptor| { &mut m.colors },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatternType>>(
                "pattern",
                |m: &PatternDescriptor| { &m.pattern },
                |m: &mut PatternDescriptor| { &mut m.pattern },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatternDescriptor>(
                "PatternDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatternDescriptor {
        static instance: ::protobuf::rt::LazyV2<PatternDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatternDescriptor::new)
    }
}

impl ::protobuf::Clear for PatternDescriptor {
    fn clear(&mut self) {
        self.id.clear();
        self.colors.clear();
        self.pattern = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatternDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatternDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColorModifierRaw {
    // message fields
    pub patterns: ::protobuf::RepeatedField<PatternDescriptor>,
    pub body_part_id: ::std::vec::Vec<i32>,
    pub tissue_layer_id: ::std::vec::Vec<i32>,
    start_date: ::std::option::Option<i32>,
    end_date: ::std::option::Option<i32>,
    part: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorModifierRaw {
    fn default() -> &'a ColorModifierRaw {
        <ColorModifierRaw as ::protobuf::Message>::default_instance()
    }
}

impl ColorModifierRaw {
    pub fn new() -> ColorModifierRaw {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.PatternDescriptor patterns = 1;


    pub fn get_patterns(&self) -> &[PatternDescriptor] {
        &self.patterns
    }
    pub fn clear_patterns(&mut self) {
        self.patterns.clear();
    }

    // Param is passed by value, moved
    pub fn set_patterns(&mut self, v: ::protobuf::RepeatedField<PatternDescriptor>) {
        self.patterns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patterns(&mut self) -> &mut ::protobuf::RepeatedField<PatternDescriptor> {
        &mut self.patterns
    }

    // Take field
    pub fn take_patterns(&mut self) -> ::protobuf::RepeatedField<PatternDescriptor> {
        ::std::mem::replace(&mut self.patterns, ::protobuf::RepeatedField::new())
    }

    // repeated int32 body_part_id = 2;


    pub fn get_body_part_id(&self) -> &[i32] {
        &self.body_part_id
    }
    pub fn clear_body_part_id(&mut self) {
        self.body_part_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_part_id(&mut self, v: ::std::vec::Vec<i32>) {
        self.body_part_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_part_id(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.body_part_id
    }

    // Take field
    pub fn take_body_part_id(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.body_part_id, ::std::vec::Vec::new())
    }

    // repeated int32 tissue_layer_id = 3;


    pub fn get_tissue_layer_id(&self) -> &[i32] {
        &self.tissue_layer_id
    }
    pub fn clear_tissue_layer_id(&mut self) {
        self.tissue_layer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tissue_layer_id(&mut self, v: ::std::vec::Vec<i32>) {
        self.tissue_layer_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tissue_layer_id(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tissue_layer_id
    }

    // Take field
    pub fn take_tissue_layer_id(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tissue_layer_id, ::std::vec::Vec::new())
    }

    // optional int32 start_date = 4;


    pub fn get_start_date(&self) -> i32 {
        self.start_date.unwrap_or(0)
    }
    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: i32) {
        self.start_date = ::std::option::Option::Some(v);
    }

    // optional int32 end_date = 5;


    pub fn get_end_date(&self) -> i32 {
        self.end_date.unwrap_or(0)
    }
    pub fn clear_end_date(&mut self) {
        self.end_date = ::std::option::Option::None;
    }

    pub fn has_end_date(&self) -> bool {
        self.end_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_date(&mut self, v: i32) {
        self.end_date = ::std::option::Option::Some(v);
    }

    // optional string part = 6;


    pub fn get_part(&self) -> &str {
        match self.part.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_part(&mut self) {
        self.part.clear();
    }

    pub fn has_part(&self) -> bool {
        self.part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_part(&mut self, v: ::std::string::String) {
        self.part = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_part(&mut self) -> &mut ::std::string::String {
        if self.part.is_none() {
            self.part.set_default();
        }
        self.part.as_mut().unwrap()
    }

    // Take field
    pub fn take_part(&mut self) -> ::std::string::String {
        self.part.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ColorModifierRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.patterns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patterns)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.body_part_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tissue_layer_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_date = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_date = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.part)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patterns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.body_part_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tissue_layer_id {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.start_date {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_date {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.part.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patterns {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.body_part_id {
            os.write_int32(2, *v)?;
        };
        for v in &self.tissue_layer_id {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.start_date {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.end_date {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.part.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorModifierRaw {
        ColorModifierRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatternDescriptor>>(
                "patterns",
                |m: &ColorModifierRaw| { &m.patterns },
                |m: &mut ColorModifierRaw| { &mut m.patterns },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "body_part_id",
                |m: &ColorModifierRaw| { &m.body_part_id },
                |m: &mut ColorModifierRaw| { &mut m.body_part_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tissue_layer_id",
                |m: &ColorModifierRaw| { &m.tissue_layer_id },
                |m: &mut ColorModifierRaw| { &mut m.tissue_layer_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start_date",
                |m: &ColorModifierRaw| { &m.start_date },
                |m: &mut ColorModifierRaw| { &mut m.start_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end_date",
                |m: &ColorModifierRaw| { &m.end_date },
                |m: &mut ColorModifierRaw| { &mut m.end_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "part",
                |m: &ColorModifierRaw| { &m.part },
                |m: &mut ColorModifierRaw| { &mut m.part },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColorModifierRaw>(
                "ColorModifierRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColorModifierRaw {
        static instance: ::protobuf::rt::LazyV2<ColorModifierRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColorModifierRaw::new)
    }
}

impl ::protobuf::Clear for ColorModifierRaw {
    fn clear(&mut self) {
        self.patterns.clear();
        self.body_part_id.clear();
        self.tissue_layer_id.clear();
        self.start_date = ::std::option::Option::None;
        self.end_date = ::std::option::Option::None;
        self.part.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorModifierRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorModifierRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BodyPartLayerRaw {
    // message fields
    layer_name: ::protobuf::SingularField<::std::string::String>,
    tissue_id: ::std::option::Option<i32>,
    layer_depth: ::std::option::Option<i32>,
    pub bp_modifiers: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BodyPartLayerRaw {
    fn default() -> &'a BodyPartLayerRaw {
        <BodyPartLayerRaw as ::protobuf::Message>::default_instance()
    }
}

impl BodyPartLayerRaw {
    pub fn new() -> BodyPartLayerRaw {
        ::std::default::Default::default()
    }

    // optional string layer_name = 1;


    pub fn get_layer_name(&self) -> &str {
        match self.layer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_layer_name(&mut self) {
        self.layer_name.clear();
    }

    pub fn has_layer_name(&self) -> bool {
        self.layer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_name(&mut self, v: ::std::string::String) {
        self.layer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layer_name(&mut self) -> &mut ::std::string::String {
        if self.layer_name.is_none() {
            self.layer_name.set_default();
        }
        self.layer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_layer_name(&mut self) -> ::std::string::String {
        self.layer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tissue_id = 2;


    pub fn get_tissue_id(&self) -> i32 {
        self.tissue_id.unwrap_or(0)
    }
    pub fn clear_tissue_id(&mut self) {
        self.tissue_id = ::std::option::Option::None;
    }

    pub fn has_tissue_id(&self) -> bool {
        self.tissue_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tissue_id(&mut self, v: i32) {
        self.tissue_id = ::std::option::Option::Some(v);
    }

    // optional int32 layer_depth = 3;


    pub fn get_layer_depth(&self) -> i32 {
        self.layer_depth.unwrap_or(0)
    }
    pub fn clear_layer_depth(&mut self) {
        self.layer_depth = ::std::option::Option::None;
    }

    pub fn has_layer_depth(&self) -> bool {
        self.layer_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_depth(&mut self, v: i32) {
        self.layer_depth = ::std::option::Option::Some(v);
    }

    // repeated int32 bp_modifiers = 4;


    pub fn get_bp_modifiers(&self) -> &[i32] {
        &self.bp_modifiers
    }
    pub fn clear_bp_modifiers(&mut self) {
        self.bp_modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_bp_modifiers(&mut self, v: ::std::vec::Vec<i32>) {
        self.bp_modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bp_modifiers(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.bp_modifiers
    }

    // Take field
    pub fn take_bp_modifiers(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.bp_modifiers, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BodyPartLayerRaw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.layer_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tissue_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.layer_depth = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.bp_modifiers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.layer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tissue_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.layer_depth {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.bp_modifiers {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.layer_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.tissue_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.layer_depth {
            os.write_int32(3, v)?;
        }
        for v in &self.bp_modifiers {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BodyPartLayerRaw {
        BodyPartLayerRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "layer_name",
                |m: &BodyPartLayerRaw| { &m.layer_name },
                |m: &mut BodyPartLayerRaw| { &mut m.layer_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tissue_id",
                |m: &BodyPartLayerRaw| { &m.tissue_id },
                |m: &mut BodyPartLayerRaw| { &mut m.tissue_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "layer_depth",
                |m: &BodyPartLayerRaw| { &m.layer_depth },
                |m: &mut BodyPartLayerRaw| { &mut m.layer_depth },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bp_modifiers",
                |m: &BodyPartLayerRaw| { &m.bp_modifiers },
                |m: &mut BodyPartLayerRaw| { &mut m.bp_modifiers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BodyPartLayerRaw>(
                "BodyPartLayerRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BodyPartLayerRaw {
        static instance: ::protobuf::rt::LazyV2<BodyPartLayerRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BodyPartLayerRaw::new)
    }
}

impl ::protobuf::Clear for BodyPartLayerRaw {
    fn clear(&mut self) {
        self.layer_name.clear();
        self.tissue_id = ::std::option::Option::None;
        self.layer_depth = ::std::option::Option::None;
        self.bp_modifiers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BodyPartLayerRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodyPartLayerRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BodyPartRaw {
    // message fields
    token: ::protobuf::SingularField<::std::string::String>,
    category: ::protobuf::SingularField<::std::string::String>,
    parent: ::std::option::Option<i32>,
    pub flags: ::std::vec::Vec<bool>,
    pub layers: ::protobuf::RepeatedField<BodyPartLayerRaw>,
    relsize: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BodyPartRaw {
    fn default() -> &'a BodyPartRaw {
        <BodyPartRaw as ::protobuf::Message>::default_instance()
    }
}

impl BodyPartRaw {
    pub fn new() -> BodyPartRaw {
        ::std::default::Default::default()
    }

    // optional string token = 1;


    pub fn get_token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string category = 2;


    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_category(&mut self) {
        self.category.clear();
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        if self.category.is_none() {
            self.category.set_default();
        }
        self.category.as_mut().unwrap()
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        self.category.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 parent = 3;


    pub fn get_parent(&self) -> i32 {
        self.parent.unwrap_or(0)
    }
    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: i32) {
        self.parent = ::std::option::Option::Some(v);
    }

    // repeated bool flags = 4;


    pub fn get_flags(&self) -> &[bool] {
        &self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: ::std::vec::Vec<bool>) {
        self.flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flags(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.flags
    }

    // Take field
    pub fn take_flags(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.flags, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.BodyPartLayerRaw layers = 5;


    pub fn get_layers(&self) -> &[BodyPartLayerRaw] {
        &self.layers
    }
    pub fn clear_layers(&mut self) {
        self.layers.clear();
    }

    // Param is passed by value, moved
    pub fn set_layers(&mut self, v: ::protobuf::RepeatedField<BodyPartLayerRaw>) {
        self.layers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_layers(&mut self) -> &mut ::protobuf::RepeatedField<BodyPartLayerRaw> {
        &mut self.layers
    }

    // Take field
    pub fn take_layers(&mut self) -> ::protobuf::RepeatedField<BodyPartLayerRaw> {
        ::std::mem::replace(&mut self.layers, ::protobuf::RepeatedField::new())
    }

    // optional int32 relsize = 6;


    pub fn get_relsize(&self) -> i32 {
        self.relsize.unwrap_or(0)
    }
    pub fn clear_relsize(&mut self) {
        self.relsize = ::std::option::Option::None;
    }

    pub fn has_relsize(&self) -> bool {
        self.relsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relsize(&mut self, v: i32) {
        self.relsize = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BodyPartRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.layers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.parent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.flags)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.layers)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.relsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 2 * self.flags.len() as u32;
        for value in &self.layers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.relsize {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.token.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.category.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.parent {
            os.write_int32(3, v)?;
        }
        for v in &self.flags {
            os.write_bool(4, *v)?;
        };
        for v in &self.layers {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.relsize {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BodyPartRaw {
        BodyPartRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &BodyPartRaw| { &m.token },
                |m: &mut BodyPartRaw| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "category",
                |m: &BodyPartRaw| { &m.category },
                |m: &mut BodyPartRaw| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "parent",
                |m: &BodyPartRaw| { &m.parent },
                |m: &mut BodyPartRaw| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flags",
                |m: &BodyPartRaw| { &m.flags },
                |m: &mut BodyPartRaw| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BodyPartLayerRaw>>(
                "layers",
                |m: &BodyPartRaw| { &m.layers },
                |m: &mut BodyPartRaw| { &mut m.layers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "relsize",
                |m: &BodyPartRaw| { &m.relsize },
                |m: &mut BodyPartRaw| { &mut m.relsize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BodyPartRaw>(
                "BodyPartRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BodyPartRaw {
        static instance: ::protobuf::rt::LazyV2<BodyPartRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BodyPartRaw::new)
    }
}

impl ::protobuf::Clear for BodyPartRaw {
    fn clear(&mut self) {
        self.token.clear();
        self.category.clear();
        self.parent = ::std::option::Option::None;
        self.flags.clear();
        self.layers.clear();
        self.relsize = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BodyPartRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodyPartRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BpAppearanceModifier {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    mod_min: ::std::option::Option<i32>,
    mod_max: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BpAppearanceModifier {
    fn default() -> &'a BpAppearanceModifier {
        <BpAppearanceModifier as ::protobuf::Message>::default_instance()
    }
}

impl BpAppearanceModifier {
    pub fn new() -> BpAppearanceModifier {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 mod_min = 2;


    pub fn get_mod_min(&self) -> i32 {
        self.mod_min.unwrap_or(0)
    }
    pub fn clear_mod_min(&mut self) {
        self.mod_min = ::std::option::Option::None;
    }

    pub fn has_mod_min(&self) -> bool {
        self.mod_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod_min(&mut self, v: i32) {
        self.mod_min = ::std::option::Option::Some(v);
    }

    // optional int32 mod_max = 3;


    pub fn get_mod_max(&self) -> i32 {
        self.mod_max.unwrap_or(0)
    }
    pub fn clear_mod_max(&mut self) {
        self.mod_max = ::std::option::Option::None;
    }

    pub fn has_mod_max(&self) -> bool {
        self.mod_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod_max(&mut self, v: i32) {
        self.mod_max = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BpAppearanceModifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mod_min = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mod_max = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mod_min {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mod_max {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mod_min {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mod_max {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BpAppearanceModifier {
        BpAppearanceModifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &BpAppearanceModifier| { &m.field_type },
                |m: &mut BpAppearanceModifier| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mod_min",
                |m: &BpAppearanceModifier| { &m.mod_min },
                |m: &mut BpAppearanceModifier| { &mut m.mod_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mod_max",
                |m: &BpAppearanceModifier| { &m.mod_max },
                |m: &mut BpAppearanceModifier| { &mut m.mod_max },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BpAppearanceModifier>(
                "BpAppearanceModifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BpAppearanceModifier {
        static instance: ::protobuf::rt::LazyV2<BpAppearanceModifier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BpAppearanceModifier::new)
    }
}

impl ::protobuf::Clear for BpAppearanceModifier {
    fn clear(&mut self) {
        self.field_type.clear();
        self.mod_min = ::std::option::Option::None;
        self.mod_max = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BpAppearanceModifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BpAppearanceModifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TissueRaw {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub material: ::protobuf::SingularPtrField<MatPair>,
    subordinate_to_tissue: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TissueRaw {
    fn default() -> &'a TissueRaw {
        <TissueRaw as ::protobuf::Message>::default_instance()
    }
}

impl TissueRaw {
    pub fn new() -> TissueRaw {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.MatPair material = 3;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional string subordinate_to_tissue = 4;


    pub fn get_subordinate_to_tissue(&self) -> &str {
        match self.subordinate_to_tissue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_subordinate_to_tissue(&mut self) {
        self.subordinate_to_tissue.clear();
    }

    pub fn has_subordinate_to_tissue(&self) -> bool {
        self.subordinate_to_tissue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subordinate_to_tissue(&mut self, v: ::std::string::String) {
        self.subordinate_to_tissue = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subordinate_to_tissue(&mut self) -> &mut ::std::string::String {
        if self.subordinate_to_tissue.is_none() {
            self.subordinate_to_tissue.set_default();
        }
        self.subordinate_to_tissue.as_mut().unwrap()
    }

    // Take field
    pub fn take_subordinate_to_tissue(&mut self) -> ::std::string::String {
        self.subordinate_to_tissue.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TissueRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subordinate_to_tissue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subordinate_to_tissue.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subordinate_to_tissue.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TissueRaw {
        TissueRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &TissueRaw| { &m.id },
                |m: &mut TissueRaw| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TissueRaw| { &m.name },
                |m: &mut TissueRaw| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &TissueRaw| { &m.material },
                |m: &mut TissueRaw| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subordinate_to_tissue",
                |m: &TissueRaw| { &m.subordinate_to_tissue },
                |m: &mut TissueRaw| { &mut m.subordinate_to_tissue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TissueRaw>(
                "TissueRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TissueRaw {
        static instance: ::protobuf::rt::LazyV2<TissueRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TissueRaw::new)
    }
}

impl ::protobuf::Clear for TissueRaw {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.material.clear();
        self.subordinate_to_tissue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TissueRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TissueRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CasteRaw {
    // message fields
    index: ::std::option::Option<i32>,
    caste_id: ::protobuf::SingularField<::std::string::String>,
    pub caste_name: ::protobuf::RepeatedField<::std::string::String>,
    pub baby_name: ::protobuf::RepeatedField<::std::string::String>,
    pub child_name: ::protobuf::RepeatedField<::std::string::String>,
    gender: ::std::option::Option<i32>,
    pub body_parts: ::protobuf::RepeatedField<BodyPartRaw>,
    total_relsize: ::std::option::Option<i32>,
    pub modifiers: ::protobuf::RepeatedField<BpAppearanceModifier>,
    pub modifier_idx: ::std::vec::Vec<i32>,
    pub part_idx: ::std::vec::Vec<i32>,
    pub layer_idx: ::std::vec::Vec<i32>,
    pub body_appearance_modifiers: ::protobuf::RepeatedField<BpAppearanceModifier>,
    pub color_modifiers: ::protobuf::RepeatedField<ColorModifierRaw>,
    description: ::protobuf::SingularField<::std::string::String>,
    adult_size: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CasteRaw {
    fn default() -> &'a CasteRaw {
        <CasteRaw as ::protobuf::Message>::default_instance()
    }
}

impl CasteRaw {
    pub fn new() -> CasteRaw {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string caste_id = 2;


    pub fn get_caste_id(&self) -> &str {
        match self.caste_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caste_id(&mut self) {
        self.caste_id.clear();
    }

    pub fn has_caste_id(&self) -> bool {
        self.caste_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caste_id(&mut self, v: ::std::string::String) {
        self.caste_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caste_id(&mut self) -> &mut ::std::string::String {
        if self.caste_id.is_none() {
            self.caste_id.set_default();
        }
        self.caste_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_caste_id(&mut self) -> ::std::string::String {
        self.caste_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string caste_name = 3;


    pub fn get_caste_name(&self) -> &[::std::string::String] {
        &self.caste_name
    }
    pub fn clear_caste_name(&mut self) {
        self.caste_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_caste_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.caste_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_caste_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.caste_name
    }

    // Take field
    pub fn take_caste_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.caste_name, ::protobuf::RepeatedField::new())
    }

    // repeated string baby_name = 4;


    pub fn get_baby_name(&self) -> &[::std::string::String] {
        &self.baby_name
    }
    pub fn clear_baby_name(&mut self) {
        self.baby_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_baby_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.baby_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_baby_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.baby_name
    }

    // Take field
    pub fn take_baby_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.baby_name, ::protobuf::RepeatedField::new())
    }

    // repeated string child_name = 5;


    pub fn get_child_name(&self) -> &[::std::string::String] {
        &self.child_name
    }
    pub fn clear_child_name(&mut self) {
        self.child_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_child_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.child_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_child_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.child_name
    }

    // Take field
    pub fn take_child_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.child_name, ::protobuf::RepeatedField::new())
    }

    // optional int32 gender = 6;


    pub fn get_gender(&self) -> i32 {
        self.gender.unwrap_or(0)
    }
    pub fn clear_gender(&mut self) {
        self.gender = ::std::option::Option::None;
    }

    pub fn has_gender(&self) -> bool {
        self.gender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: i32) {
        self.gender = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.BodyPartRaw body_parts = 7;


    pub fn get_body_parts(&self) -> &[BodyPartRaw] {
        &self.body_parts
    }
    pub fn clear_body_parts(&mut self) {
        self.body_parts.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_parts(&mut self, v: ::protobuf::RepeatedField<BodyPartRaw>) {
        self.body_parts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_parts(&mut self) -> &mut ::protobuf::RepeatedField<BodyPartRaw> {
        &mut self.body_parts
    }

    // Take field
    pub fn take_body_parts(&mut self) -> ::protobuf::RepeatedField<BodyPartRaw> {
        ::std::mem::replace(&mut self.body_parts, ::protobuf::RepeatedField::new())
    }

    // optional int32 total_relsize = 8;


    pub fn get_total_relsize(&self) -> i32 {
        self.total_relsize.unwrap_or(0)
    }
    pub fn clear_total_relsize(&mut self) {
        self.total_relsize = ::std::option::Option::None;
    }

    pub fn has_total_relsize(&self) -> bool {
        self.total_relsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_relsize(&mut self, v: i32) {
        self.total_relsize = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.BpAppearanceModifier modifiers = 9;


    pub fn get_modifiers(&self) -> &[BpAppearanceModifier] {
        &self.modifiers
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: ::protobuf::RepeatedField<BpAppearanceModifier>) {
        self.modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifiers(&mut self) -> &mut ::protobuf::RepeatedField<BpAppearanceModifier> {
        &mut self.modifiers
    }

    // Take field
    pub fn take_modifiers(&mut self) -> ::protobuf::RepeatedField<BpAppearanceModifier> {
        ::std::mem::replace(&mut self.modifiers, ::protobuf::RepeatedField::new())
    }

    // repeated int32 modifier_idx = 10;


    pub fn get_modifier_idx(&self) -> &[i32] {
        &self.modifier_idx
    }
    pub fn clear_modifier_idx(&mut self) {
        self.modifier_idx.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifier_idx(&mut self, v: ::std::vec::Vec<i32>) {
        self.modifier_idx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifier_idx(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.modifier_idx
    }

    // Take field
    pub fn take_modifier_idx(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.modifier_idx, ::std::vec::Vec::new())
    }

    // repeated int32 part_idx = 11;


    pub fn get_part_idx(&self) -> &[i32] {
        &self.part_idx
    }
    pub fn clear_part_idx(&mut self) {
        self.part_idx.clear();
    }

    // Param is passed by value, moved
    pub fn set_part_idx(&mut self, v: ::std::vec::Vec<i32>) {
        self.part_idx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_part_idx(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.part_idx
    }

    // Take field
    pub fn take_part_idx(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.part_idx, ::std::vec::Vec::new())
    }

    // repeated int32 layer_idx = 12;


    pub fn get_layer_idx(&self) -> &[i32] {
        &self.layer_idx
    }
    pub fn clear_layer_idx(&mut self) {
        self.layer_idx.clear();
    }

    // Param is passed by value, moved
    pub fn set_layer_idx(&mut self, v: ::std::vec::Vec<i32>) {
        self.layer_idx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_layer_idx(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.layer_idx
    }

    // Take field
    pub fn take_layer_idx(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.layer_idx, ::std::vec::Vec::new())
    }

    // repeated .RemoteFortressReader.BpAppearanceModifier body_appearance_modifiers = 13;


    pub fn get_body_appearance_modifiers(&self) -> &[BpAppearanceModifier] {
        &self.body_appearance_modifiers
    }
    pub fn clear_body_appearance_modifiers(&mut self) {
        self.body_appearance_modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_appearance_modifiers(&mut self, v: ::protobuf::RepeatedField<BpAppearanceModifier>) {
        self.body_appearance_modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_appearance_modifiers(&mut self) -> &mut ::protobuf::RepeatedField<BpAppearanceModifier> {
        &mut self.body_appearance_modifiers
    }

    // Take field
    pub fn take_body_appearance_modifiers(&mut self) -> ::protobuf::RepeatedField<BpAppearanceModifier> {
        ::std::mem::replace(&mut self.body_appearance_modifiers, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.ColorModifierRaw color_modifiers = 14;


    pub fn get_color_modifiers(&self) -> &[ColorModifierRaw] {
        &self.color_modifiers
    }
    pub fn clear_color_modifiers(&mut self) {
        self.color_modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_color_modifiers(&mut self, v: ::protobuf::RepeatedField<ColorModifierRaw>) {
        self.color_modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_color_modifiers(&mut self) -> &mut ::protobuf::RepeatedField<ColorModifierRaw> {
        &mut self.color_modifiers
    }

    // Take field
    pub fn take_color_modifiers(&mut self) -> ::protobuf::RepeatedField<ColorModifierRaw> {
        ::std::mem::replace(&mut self.color_modifiers, ::protobuf::RepeatedField::new())
    }

    // optional string description = 15;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 adult_size = 16;


    pub fn get_adult_size(&self) -> i32 {
        self.adult_size.unwrap_or(0)
    }
    pub fn clear_adult_size(&mut self) {
        self.adult_size = ::std::option::Option::None;
    }

    pub fn has_adult_size(&self) -> bool {
        self.adult_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_size(&mut self, v: i32) {
        self.adult_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CasteRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.body_parts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_appearance_modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.color_modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caste_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.caste_name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.baby_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.child_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gender = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.body_parts)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_relsize = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifiers)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.modifier_idx)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.part_idx)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.layer_idx)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.body_appearance_modifiers)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.color_modifiers)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.adult_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.caste_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.caste_name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.baby_name {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.child_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.gender {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.body_parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_relsize {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.modifier_idx {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.part_idx {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.layer_idx {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.body_appearance_modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.color_modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.adult_size {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.caste_id.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.caste_name {
            os.write_string(3, &v)?;
        };
        for v in &self.baby_name {
            os.write_string(4, &v)?;
        };
        for v in &self.child_name {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.gender {
            os.write_int32(6, v)?;
        }
        for v in &self.body_parts {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total_relsize {
            os.write_int32(8, v)?;
        }
        for v in &self.modifiers {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.modifier_idx {
            os.write_int32(10, *v)?;
        };
        for v in &self.part_idx {
            os.write_int32(11, *v)?;
        };
        for v in &self.layer_idx {
            os.write_int32(12, *v)?;
        };
        for v in &self.body_appearance_modifiers {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.color_modifiers {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.adult_size {
            os.write_int32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CasteRaw {
        CasteRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &CasteRaw| { &m.index },
                |m: &mut CasteRaw| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caste_id",
                |m: &CasteRaw| { &m.caste_id },
                |m: &mut CasteRaw| { &mut m.caste_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caste_name",
                |m: &CasteRaw| { &m.caste_name },
                |m: &mut CasteRaw| { &mut m.caste_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "baby_name",
                |m: &CasteRaw| { &m.baby_name },
                |m: &mut CasteRaw| { &mut m.baby_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "child_name",
                |m: &CasteRaw| { &m.child_name },
                |m: &mut CasteRaw| { &mut m.child_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gender",
                |m: &CasteRaw| { &m.gender },
                |m: &mut CasteRaw| { &mut m.gender },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BodyPartRaw>>(
                "body_parts",
                |m: &CasteRaw| { &m.body_parts },
                |m: &mut CasteRaw| { &mut m.body_parts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_relsize",
                |m: &CasteRaw| { &m.total_relsize },
                |m: &mut CasteRaw| { &mut m.total_relsize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BpAppearanceModifier>>(
                "modifiers",
                |m: &CasteRaw| { &m.modifiers },
                |m: &mut CasteRaw| { &mut m.modifiers },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "modifier_idx",
                |m: &CasteRaw| { &m.modifier_idx },
                |m: &mut CasteRaw| { &mut m.modifier_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "part_idx",
                |m: &CasteRaw| { &m.part_idx },
                |m: &mut CasteRaw| { &mut m.part_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "layer_idx",
                |m: &CasteRaw| { &m.layer_idx },
                |m: &mut CasteRaw| { &mut m.layer_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BpAppearanceModifier>>(
                "body_appearance_modifiers",
                |m: &CasteRaw| { &m.body_appearance_modifiers },
                |m: &mut CasteRaw| { &mut m.body_appearance_modifiers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorModifierRaw>>(
                "color_modifiers",
                |m: &CasteRaw| { &m.color_modifiers },
                |m: &mut CasteRaw| { &mut m.color_modifiers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CasteRaw| { &m.description },
                |m: &mut CasteRaw| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "adult_size",
                |m: &CasteRaw| { &m.adult_size },
                |m: &mut CasteRaw| { &mut m.adult_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CasteRaw>(
                "CasteRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CasteRaw {
        static instance: ::protobuf::rt::LazyV2<CasteRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CasteRaw::new)
    }
}

impl ::protobuf::Clear for CasteRaw {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.caste_id.clear();
        self.caste_name.clear();
        self.baby_name.clear();
        self.child_name.clear();
        self.gender = ::std::option::Option::None;
        self.body_parts.clear();
        self.total_relsize = ::std::option::Option::None;
        self.modifiers.clear();
        self.modifier_idx.clear();
        self.part_idx.clear();
        self.layer_idx.clear();
        self.body_appearance_modifiers.clear();
        self.color_modifiers.clear();
        self.description.clear();
        self.adult_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CasteRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CasteRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreatureRaw {
    // message fields
    index: ::std::option::Option<i32>,
    creature_id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::RepeatedField<::std::string::String>,
    pub general_baby_name: ::protobuf::RepeatedField<::std::string::String>,
    pub general_child_name: ::protobuf::RepeatedField<::std::string::String>,
    creature_tile: ::std::option::Option<i32>,
    creature_soldier_tile: ::std::option::Option<i32>,
    pub color: ::protobuf::SingularPtrField<ColorDefinition>,
    adultsize: ::std::option::Option<i32>,
    pub caste: ::protobuf::RepeatedField<CasteRaw>,
    pub tissues: ::protobuf::RepeatedField<TissueRaw>,
    pub flags: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatureRaw {
    fn default() -> &'a CreatureRaw {
        <CreatureRaw as ::protobuf::Message>::default_instance()
    }
}

impl CreatureRaw {
    pub fn new() -> CreatureRaw {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string creature_id = 2;


    pub fn get_creature_id(&self) -> &str {
        match self.creature_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_creature_id(&mut self) {
        self.creature_id.clear();
    }

    pub fn has_creature_id(&self) -> bool {
        self.creature_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_id(&mut self, v: ::std::string::String) {
        self.creature_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creature_id(&mut self) -> &mut ::std::string::String {
        if self.creature_id.is_none() {
            self.creature_id.set_default();
        }
        self.creature_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_creature_id(&mut self) -> ::std::string::String {
        self.creature_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string name = 3;


    pub fn get_name(&self) -> &[::std::string::String] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.name, ::protobuf::RepeatedField::new())
    }

    // repeated string general_baby_name = 4;


    pub fn get_general_baby_name(&self) -> &[::std::string::String] {
        &self.general_baby_name
    }
    pub fn clear_general_baby_name(&mut self) {
        self.general_baby_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_general_baby_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.general_baby_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_general_baby_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.general_baby_name
    }

    // Take field
    pub fn take_general_baby_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.general_baby_name, ::protobuf::RepeatedField::new())
    }

    // repeated string general_child_name = 5;


    pub fn get_general_child_name(&self) -> &[::std::string::String] {
        &self.general_child_name
    }
    pub fn clear_general_child_name(&mut self) {
        self.general_child_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_general_child_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.general_child_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_general_child_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.general_child_name
    }

    // Take field
    pub fn take_general_child_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.general_child_name, ::protobuf::RepeatedField::new())
    }

    // optional int32 creature_tile = 6;


    pub fn get_creature_tile(&self) -> i32 {
        self.creature_tile.unwrap_or(0)
    }
    pub fn clear_creature_tile(&mut self) {
        self.creature_tile = ::std::option::Option::None;
    }

    pub fn has_creature_tile(&self) -> bool {
        self.creature_tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_tile(&mut self, v: i32) {
        self.creature_tile = ::std::option::Option::Some(v);
    }

    // optional int32 creature_soldier_tile = 7;


    pub fn get_creature_soldier_tile(&self) -> i32 {
        self.creature_soldier_tile.unwrap_or(0)
    }
    pub fn clear_creature_soldier_tile(&mut self) {
        self.creature_soldier_tile = ::std::option::Option::None;
    }

    pub fn has_creature_soldier_tile(&self) -> bool {
        self.creature_soldier_tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_soldier_tile(&mut self, v: i32) {
        self.creature_soldier_tile = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ColorDefinition color = 8;


    pub fn get_color(&self) -> &ColorDefinition {
        self.color.as_ref().unwrap_or_else(|| <ColorDefinition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ColorDefinition) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ColorDefinition {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ColorDefinition {
        self.color.take().unwrap_or_else(|| ColorDefinition::new())
    }

    // optional int32 adultsize = 9;


    pub fn get_adultsize(&self) -> i32 {
        self.adultsize.unwrap_or(0)
    }
    pub fn clear_adultsize(&mut self) {
        self.adultsize = ::std::option::Option::None;
    }

    pub fn has_adultsize(&self) -> bool {
        self.adultsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adultsize(&mut self, v: i32) {
        self.adultsize = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.CasteRaw caste = 10;


    pub fn get_caste(&self) -> &[CasteRaw] {
        &self.caste
    }
    pub fn clear_caste(&mut self) {
        self.caste.clear();
    }

    // Param is passed by value, moved
    pub fn set_caste(&mut self, v: ::protobuf::RepeatedField<CasteRaw>) {
        self.caste = v;
    }

    // Mutable pointer to the field.
    pub fn mut_caste(&mut self) -> &mut ::protobuf::RepeatedField<CasteRaw> {
        &mut self.caste
    }

    // Take field
    pub fn take_caste(&mut self) -> ::protobuf::RepeatedField<CasteRaw> {
        ::std::mem::replace(&mut self.caste, ::protobuf::RepeatedField::new())
    }

    // repeated .RemoteFortressReader.TissueRaw tissues = 11;


    pub fn get_tissues(&self) -> &[TissueRaw] {
        &self.tissues
    }
    pub fn clear_tissues(&mut self) {
        self.tissues.clear();
    }

    // Param is passed by value, moved
    pub fn set_tissues(&mut self, v: ::protobuf::RepeatedField<TissueRaw>) {
        self.tissues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tissues(&mut self) -> &mut ::protobuf::RepeatedField<TissueRaw> {
        &mut self.tissues
    }

    // Take field
    pub fn take_tissues(&mut self) -> ::protobuf::RepeatedField<TissueRaw> {
        ::std::mem::replace(&mut self.tissues, ::protobuf::RepeatedField::new())
    }

    // repeated bool flags = 12;


    pub fn get_flags(&self) -> &[bool] {
        &self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: ::std::vec::Vec<bool>) {
        self.flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flags(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.flags
    }

    // Take field
    pub fn take_flags(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.flags, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreatureRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.caste {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tissues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creature_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.general_baby_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.general_child_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.creature_tile = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.creature_soldier_tile = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.adultsize = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.caste)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tissues)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.creature_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.general_baby_name {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.general_child_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.creature_tile {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creature_soldier_tile {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.adultsize {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.caste {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tissues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 2 * self.flags.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.creature_id.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.name {
            os.write_string(3, &v)?;
        };
        for v in &self.general_baby_name {
            os.write_string(4, &v)?;
        };
        for v in &self.general_child_name {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.creature_tile {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.creature_soldier_tile {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.adultsize {
            os.write_int32(9, v)?;
        }
        for v in &self.caste {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tissues {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.flags {
            os.write_bool(12, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatureRaw {
        CreatureRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &CreatureRaw| { &m.index },
                |m: &mut CreatureRaw| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creature_id",
                |m: &CreatureRaw| { &m.creature_id },
                |m: &mut CreatureRaw| { &mut m.creature_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreatureRaw| { &m.name },
                |m: &mut CreatureRaw| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "general_baby_name",
                |m: &CreatureRaw| { &m.general_baby_name },
                |m: &mut CreatureRaw| { &mut m.general_baby_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "general_child_name",
                |m: &CreatureRaw| { &m.general_child_name },
                |m: &mut CreatureRaw| { &mut m.general_child_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "creature_tile",
                |m: &CreatureRaw| { &m.creature_tile },
                |m: &mut CreatureRaw| { &mut m.creature_tile },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "creature_soldier_tile",
                |m: &CreatureRaw| { &m.creature_soldier_tile },
                |m: &mut CreatureRaw| { &mut m.creature_soldier_tile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "color",
                |m: &CreatureRaw| { &m.color },
                |m: &mut CreatureRaw| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "adultsize",
                |m: &CreatureRaw| { &m.adultsize },
                |m: &mut CreatureRaw| { &mut m.adultsize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CasteRaw>>(
                "caste",
                |m: &CreatureRaw| { &m.caste },
                |m: &mut CreatureRaw| { &mut m.caste },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TissueRaw>>(
                "tissues",
                |m: &CreatureRaw| { &m.tissues },
                |m: &mut CreatureRaw| { &mut m.tissues },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flags",
                |m: &CreatureRaw| { &m.flags },
                |m: &mut CreatureRaw| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreatureRaw>(
                "CreatureRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreatureRaw {
        static instance: ::protobuf::rt::LazyV2<CreatureRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatureRaw::new)
    }
}

impl ::protobuf::Clear for CreatureRaw {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.creature_id.clear();
        self.name.clear();
        self.general_baby_name.clear();
        self.general_child_name.clear();
        self.creature_tile = ::std::option::Option::None;
        self.creature_soldier_tile = ::std::option::Option::None;
        self.color.clear();
        self.adultsize = ::std::option::Option::None;
        self.caste.clear();
        self.tissues.clear();
        self.flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatureRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatureRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreatureRawList {
    // message fields
    pub creature_raws: ::protobuf::RepeatedField<CreatureRaw>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatureRawList {
    fn default() -> &'a CreatureRawList {
        <CreatureRawList as ::protobuf::Message>::default_instance()
    }
}

impl CreatureRawList {
    pub fn new() -> CreatureRawList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.CreatureRaw creature_raws = 1;


    pub fn get_creature_raws(&self) -> &[CreatureRaw] {
        &self.creature_raws
    }
    pub fn clear_creature_raws(&mut self) {
        self.creature_raws.clear();
    }

    // Param is passed by value, moved
    pub fn set_creature_raws(&mut self, v: ::protobuf::RepeatedField<CreatureRaw>) {
        self.creature_raws = v;
    }

    // Mutable pointer to the field.
    pub fn mut_creature_raws(&mut self) -> &mut ::protobuf::RepeatedField<CreatureRaw> {
        &mut self.creature_raws
    }

    // Take field
    pub fn take_creature_raws(&mut self) -> ::protobuf::RepeatedField<CreatureRaw> {
        ::std::mem::replace(&mut self.creature_raws, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreatureRawList {
    fn is_initialized(&self) -> bool {
        for v in &self.creature_raws {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.creature_raws)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.creature_raws {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.creature_raws {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatureRawList {
        CreatureRawList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreatureRaw>>(
                "creature_raws",
                |m: &CreatureRawList| { &m.creature_raws },
                |m: &mut CreatureRawList| { &mut m.creature_raws },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreatureRawList>(
                "CreatureRawList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreatureRawList {
        static instance: ::protobuf::rt::LazyV2<CreatureRawList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatureRawList::new)
    }
}

impl ::protobuf::Clear for CreatureRawList {
    fn clear(&mut self) {
        self.creature_raws.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatureRawList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatureRawList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Army {
    // message fields
    id: ::std::option::Option<i32>,
    pos_x: ::std::option::Option<i32>,
    pos_y: ::std::option::Option<i32>,
    pos_z: ::std::option::Option<i32>,
    pub leader: ::protobuf::SingularPtrField<UnitDefinition>,
    pub members: ::protobuf::RepeatedField<UnitDefinition>,
    flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Army {
    fn default() -> &'a Army {
        <Army as ::protobuf::Message>::default_instance()
    }
}

impl Army {
    pub fn new() -> Army {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x = 2;


    pub fn get_pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y = 3;


    pub fn get_pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z = 4;


    pub fn get_pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.UnitDefinition leader = 5;


    pub fn get_leader(&self) -> &UnitDefinition {
        self.leader.as_ref().unwrap_or_else(|| <UnitDefinition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leader(&mut self) {
        self.leader.clear();
    }

    pub fn has_leader(&self) -> bool {
        self.leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader(&mut self, v: UnitDefinition) {
        self.leader = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leader(&mut self) -> &mut UnitDefinition {
        if self.leader.is_none() {
            self.leader.set_default();
        }
        self.leader.as_mut().unwrap()
    }

    // Take field
    pub fn take_leader(&mut self) -> UnitDefinition {
        self.leader.take().unwrap_or_else(|| UnitDefinition::new())
    }

    // repeated .RemoteFortressReader.UnitDefinition members = 6;


    pub fn get_members(&self) -> &[UnitDefinition] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<UnitDefinition>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<UnitDefinition> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<UnitDefinition> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional uint32 flags = 7;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Army {
    fn is_initialized(&self) -> bool {
        for v in &self.leader {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leader)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.leader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.leader.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Army {
        Army::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Army| { &m.id },
                |m: &mut Army| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_x",
                |m: &Army| { &m.pos_x },
                |m: &mut Army| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_y",
                |m: &Army| { &m.pos_y },
                |m: &mut Army| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pos_z",
                |m: &Army| { &m.pos_z },
                |m: &mut Army| { &mut m.pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitDefinition>>(
                "leader",
                |m: &Army| { &m.leader },
                |m: &mut Army| { &mut m.leader },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitDefinition>>(
                "members",
                |m: &Army| { &m.members },
                |m: &mut Army| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &Army| { &m.flags },
                |m: &mut Army| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Army>(
                "Army",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Army {
        static instance: ::protobuf::rt::LazyV2<Army> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Army::new)
    }
}

impl ::protobuf::Clear for Army {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.leader.clear();
        self.members.clear();
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Army {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Army {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArmyList {
    // message fields
    pub armies: ::protobuf::RepeatedField<Army>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArmyList {
    fn default() -> &'a ArmyList {
        <ArmyList as ::protobuf::Message>::default_instance()
    }
}

impl ArmyList {
    pub fn new() -> ArmyList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.Army armies = 1;


    pub fn get_armies(&self) -> &[Army] {
        &self.armies
    }
    pub fn clear_armies(&mut self) {
        self.armies.clear();
    }

    // Param is passed by value, moved
    pub fn set_armies(&mut self, v: ::protobuf::RepeatedField<Army>) {
        self.armies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_armies(&mut self) -> &mut ::protobuf::RepeatedField<Army> {
        &mut self.armies
    }

    // Take field
    pub fn take_armies(&mut self) -> ::protobuf::RepeatedField<Army> {
        ::std::mem::replace(&mut self.armies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ArmyList {
    fn is_initialized(&self) -> bool {
        for v in &self.armies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.armies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.armies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.armies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArmyList {
        ArmyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Army>>(
                "armies",
                |m: &ArmyList| { &m.armies },
                |m: &mut ArmyList| { &mut m.armies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArmyList>(
                "ArmyList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArmyList {
        static instance: ::protobuf::rt::LazyV2<ArmyList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArmyList::new)
    }
}

impl ::protobuf::Clear for ArmyList {
    fn clear(&mut self) {
        self.armies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArmyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArmyList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GrowthPrint {
    // message fields
    priority: ::std::option::Option<i32>,
    color: ::std::option::Option<i32>,
    timing_start: ::std::option::Option<i32>,
    timing_end: ::std::option::Option<i32>,
    tile: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GrowthPrint {
    fn default() -> &'a GrowthPrint {
        <GrowthPrint as ::protobuf::Message>::default_instance()
    }
}

impl GrowthPrint {
    pub fn new() -> GrowthPrint {
        ::std::default::Default::default()
    }

    // optional int32 priority = 1;


    pub fn get_priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }
    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional int32 color = 2;


    pub fn get_color(&self) -> i32 {
        self.color.unwrap_or(0)
    }
    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional int32 timing_start = 3;


    pub fn get_timing_start(&self) -> i32 {
        self.timing_start.unwrap_or(0)
    }
    pub fn clear_timing_start(&mut self) {
        self.timing_start = ::std::option::Option::None;
    }

    pub fn has_timing_start(&self) -> bool {
        self.timing_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_start(&mut self, v: i32) {
        self.timing_start = ::std::option::Option::Some(v);
    }

    // optional int32 timing_end = 4;


    pub fn get_timing_end(&self) -> i32 {
        self.timing_end.unwrap_or(0)
    }
    pub fn clear_timing_end(&mut self) {
        self.timing_end = ::std::option::Option::None;
    }

    pub fn has_timing_end(&self) -> bool {
        self.timing_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_end(&mut self, v: i32) {
        self.timing_end = ::std::option::Option::Some(v);
    }

    // optional int32 tile = 5;


    pub fn get_tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }
    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GrowthPrint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.color = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timing_start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timing_end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timing_start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timing_end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.priority {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.timing_start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.timing_end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.tile {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GrowthPrint {
        GrowthPrint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "priority",
                |m: &GrowthPrint| { &m.priority },
                |m: &mut GrowthPrint| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "color",
                |m: &GrowthPrint| { &m.color },
                |m: &mut GrowthPrint| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timing_start",
                |m: &GrowthPrint| { &m.timing_start },
                |m: &mut GrowthPrint| { &mut m.timing_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timing_end",
                |m: &GrowthPrint| { &m.timing_end },
                |m: &mut GrowthPrint| { &mut m.timing_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tile",
                |m: &GrowthPrint| { &m.tile },
                |m: &mut GrowthPrint| { &mut m.tile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GrowthPrint>(
                "GrowthPrint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GrowthPrint {
        static instance: ::protobuf::rt::LazyV2<GrowthPrint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GrowthPrint::new)
    }
}

impl ::protobuf::Clear for GrowthPrint {
    fn clear(&mut self) {
        self.priority = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.timing_start = ::std::option::Option::None;
        self.timing_end = ::std::option::Option::None;
        self.tile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GrowthPrint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrowthPrint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TreeGrowth {
    // message fields
    index: ::std::option::Option<i32>,
    id: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub mat: ::protobuf::SingularPtrField<MatPair>,
    pub prints: ::protobuf::RepeatedField<GrowthPrint>,
    timing_start: ::std::option::Option<i32>,
    timing_end: ::std::option::Option<i32>,
    twigs: ::std::option::Option<bool>,
    light_branches: ::std::option::Option<bool>,
    heavy_branches: ::std::option::Option<bool>,
    trunk: ::std::option::Option<bool>,
    roots: ::std::option::Option<bool>,
    cap: ::std::option::Option<bool>,
    sapling: ::std::option::Option<bool>,
    trunk_height_start: ::std::option::Option<i32>,
    trunk_height_end: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TreeGrowth {
    fn default() -> &'a TreeGrowth {
        <TreeGrowth as ::protobuf::Message>::default_instance()
    }
}

impl TreeGrowth {
    pub fn new() -> TreeGrowth {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string id = 2;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.MatPair mat = 4;


    pub fn get_mat(&self) -> &MatPair {
        self.mat.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mat(&mut self) {
        self.mat.clear();
    }

    pub fn has_mat(&self) -> bool {
        self.mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mat(&mut self, v: MatPair) {
        self.mat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mat(&mut self) -> &mut MatPair {
        if self.mat.is_none() {
            self.mat.set_default();
        }
        self.mat.as_mut().unwrap()
    }

    // Take field
    pub fn take_mat(&mut self) -> MatPair {
        self.mat.take().unwrap_or_else(|| MatPair::new())
    }

    // repeated .RemoteFortressReader.GrowthPrint prints = 5;


    pub fn get_prints(&self) -> &[GrowthPrint] {
        &self.prints
    }
    pub fn clear_prints(&mut self) {
        self.prints.clear();
    }

    // Param is passed by value, moved
    pub fn set_prints(&mut self, v: ::protobuf::RepeatedField<GrowthPrint>) {
        self.prints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prints(&mut self) -> &mut ::protobuf::RepeatedField<GrowthPrint> {
        &mut self.prints
    }

    // Take field
    pub fn take_prints(&mut self) -> ::protobuf::RepeatedField<GrowthPrint> {
        ::std::mem::replace(&mut self.prints, ::protobuf::RepeatedField::new())
    }

    // optional int32 timing_start = 6;


    pub fn get_timing_start(&self) -> i32 {
        self.timing_start.unwrap_or(0)
    }
    pub fn clear_timing_start(&mut self) {
        self.timing_start = ::std::option::Option::None;
    }

    pub fn has_timing_start(&self) -> bool {
        self.timing_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_start(&mut self, v: i32) {
        self.timing_start = ::std::option::Option::Some(v);
    }

    // optional int32 timing_end = 7;


    pub fn get_timing_end(&self) -> i32 {
        self.timing_end.unwrap_or(0)
    }
    pub fn clear_timing_end(&mut self) {
        self.timing_end = ::std::option::Option::None;
    }

    pub fn has_timing_end(&self) -> bool {
        self.timing_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_end(&mut self, v: i32) {
        self.timing_end = ::std::option::Option::Some(v);
    }

    // optional bool twigs = 8;


    pub fn get_twigs(&self) -> bool {
        self.twigs.unwrap_or(false)
    }
    pub fn clear_twigs(&mut self) {
        self.twigs = ::std::option::Option::None;
    }

    pub fn has_twigs(&self) -> bool {
        self.twigs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twigs(&mut self, v: bool) {
        self.twigs = ::std::option::Option::Some(v);
    }

    // optional bool light_branches = 9;


    pub fn get_light_branches(&self) -> bool {
        self.light_branches.unwrap_or(false)
    }
    pub fn clear_light_branches(&mut self) {
        self.light_branches = ::std::option::Option::None;
    }

    pub fn has_light_branches(&self) -> bool {
        self.light_branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_light_branches(&mut self, v: bool) {
        self.light_branches = ::std::option::Option::Some(v);
    }

    // optional bool heavy_branches = 10;


    pub fn get_heavy_branches(&self) -> bool {
        self.heavy_branches.unwrap_or(false)
    }
    pub fn clear_heavy_branches(&mut self) {
        self.heavy_branches = ::std::option::Option::None;
    }

    pub fn has_heavy_branches(&self) -> bool {
        self.heavy_branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heavy_branches(&mut self, v: bool) {
        self.heavy_branches = ::std::option::Option::Some(v);
    }

    // optional bool trunk = 11;


    pub fn get_trunk(&self) -> bool {
        self.trunk.unwrap_or(false)
    }
    pub fn clear_trunk(&mut self) {
        self.trunk = ::std::option::Option::None;
    }

    pub fn has_trunk(&self) -> bool {
        self.trunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk(&mut self, v: bool) {
        self.trunk = ::std::option::Option::Some(v);
    }

    // optional bool roots = 12;


    pub fn get_roots(&self) -> bool {
        self.roots.unwrap_or(false)
    }
    pub fn clear_roots(&mut self) {
        self.roots = ::std::option::Option::None;
    }

    pub fn has_roots(&self) -> bool {
        self.roots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roots(&mut self, v: bool) {
        self.roots = ::std::option::Option::Some(v);
    }

    // optional bool cap = 13;


    pub fn get_cap(&self) -> bool {
        self.cap.unwrap_or(false)
    }
    pub fn clear_cap(&mut self) {
        self.cap = ::std::option::Option::None;
    }

    pub fn has_cap(&self) -> bool {
        self.cap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cap(&mut self, v: bool) {
        self.cap = ::std::option::Option::Some(v);
    }

    // optional bool sapling = 14;


    pub fn get_sapling(&self) -> bool {
        self.sapling.unwrap_or(false)
    }
    pub fn clear_sapling(&mut self) {
        self.sapling = ::std::option::Option::None;
    }

    pub fn has_sapling(&self) -> bool {
        self.sapling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sapling(&mut self, v: bool) {
        self.sapling = ::std::option::Option::Some(v);
    }

    // optional int32 trunk_height_start = 15;


    pub fn get_trunk_height_start(&self) -> i32 {
        self.trunk_height_start.unwrap_or(0)
    }
    pub fn clear_trunk_height_start(&mut self) {
        self.trunk_height_start = ::std::option::Option::None;
    }

    pub fn has_trunk_height_start(&self) -> bool {
        self.trunk_height_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk_height_start(&mut self, v: i32) {
        self.trunk_height_start = ::std::option::Option::Some(v);
    }

    // optional int32 trunk_height_end = 16;


    pub fn get_trunk_height_end(&self) -> i32 {
        self.trunk_height_end.unwrap_or(0)
    }
    pub fn clear_trunk_height_end(&mut self) {
        self.trunk_height_end = ::std::option::Option::None;
    }

    pub fn has_trunk_height_end(&self) -> bool {
        self.trunk_height_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk_height_end(&mut self, v: i32) {
        self.trunk_height_end = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TreeGrowth {
    fn is_initialized(&self) -> bool {
        for v in &self.mat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mat)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prints)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timing_start = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timing_end = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.twigs = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.light_branches = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.heavy_branches = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trunk = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.roots = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cap = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sapling = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trunk_height_start = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trunk_height_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.mat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.prints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.timing_start {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timing_end {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twigs {
            my_size += 2;
        }
        if let Some(v) = self.light_branches {
            my_size += 2;
        }
        if let Some(v) = self.heavy_branches {
            my_size += 2;
        }
        if let Some(v) = self.trunk {
            my_size += 2;
        }
        if let Some(v) = self.roots {
            my_size += 2;
        }
        if let Some(v) = self.cap {
            my_size += 2;
        }
        if let Some(v) = self.sapling {
            my_size += 2;
        }
        if let Some(v) = self.trunk_height_start {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trunk_height_end {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.mat.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.prints {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.timing_start {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.timing_end {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.twigs {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.light_branches {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.heavy_branches {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.trunk {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.roots {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.cap {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.sapling {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.trunk_height_start {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.trunk_height_end {
            os.write_int32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TreeGrowth {
        TreeGrowth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &TreeGrowth| { &m.index },
                |m: &mut TreeGrowth| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &TreeGrowth| { &m.id },
                |m: &mut TreeGrowth| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TreeGrowth| { &m.name },
                |m: &mut TreeGrowth| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "mat",
                |m: &TreeGrowth| { &m.mat },
                |m: &mut TreeGrowth| { &mut m.mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GrowthPrint>>(
                "prints",
                |m: &TreeGrowth| { &m.prints },
                |m: &mut TreeGrowth| { &mut m.prints },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timing_start",
                |m: &TreeGrowth| { &m.timing_start },
                |m: &mut TreeGrowth| { &mut m.timing_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timing_end",
                |m: &TreeGrowth| { &m.timing_end },
                |m: &mut TreeGrowth| { &mut m.timing_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "twigs",
                |m: &TreeGrowth| { &m.twigs },
                |m: &mut TreeGrowth| { &mut m.twigs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "light_branches",
                |m: &TreeGrowth| { &m.light_branches },
                |m: &mut TreeGrowth| { &mut m.light_branches },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "heavy_branches",
                |m: &TreeGrowth| { &m.heavy_branches },
                |m: &mut TreeGrowth| { &mut m.heavy_branches },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trunk",
                |m: &TreeGrowth| { &m.trunk },
                |m: &mut TreeGrowth| { &mut m.trunk },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "roots",
                |m: &TreeGrowth| { &m.roots },
                |m: &mut TreeGrowth| { &mut m.roots },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cap",
                |m: &TreeGrowth| { &m.cap },
                |m: &mut TreeGrowth| { &mut m.cap },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sapling",
                |m: &TreeGrowth| { &m.sapling },
                |m: &mut TreeGrowth| { &mut m.sapling },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trunk_height_start",
                |m: &TreeGrowth| { &m.trunk_height_start },
                |m: &mut TreeGrowth| { &mut m.trunk_height_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trunk_height_end",
                |m: &TreeGrowth| { &m.trunk_height_end },
                |m: &mut TreeGrowth| { &mut m.trunk_height_end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TreeGrowth>(
                "TreeGrowth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TreeGrowth {
        static instance: ::protobuf::rt::LazyV2<TreeGrowth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TreeGrowth::new)
    }
}

impl ::protobuf::Clear for TreeGrowth {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.id.clear();
        self.name.clear();
        self.mat.clear();
        self.prints.clear();
        self.timing_start = ::std::option::Option::None;
        self.timing_end = ::std::option::Option::None;
        self.twigs = ::std::option::Option::None;
        self.light_branches = ::std::option::Option::None;
        self.heavy_branches = ::std::option::Option::None;
        self.trunk = ::std::option::Option::None;
        self.roots = ::std::option::Option::None;
        self.cap = ::std::option::Option::None;
        self.sapling = ::std::option::Option::None;
        self.trunk_height_start = ::std::option::Option::None;
        self.trunk_height_end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TreeGrowth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeGrowth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlantRaw {
    // message fields
    index: ::std::option::Option<i32>,
    id: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub growths: ::protobuf::RepeatedField<TreeGrowth>,
    tile: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlantRaw {
    fn default() -> &'a PlantRaw {
        <PlantRaw as ::protobuf::Message>::default_instance()
    }
}

impl PlantRaw {
    pub fn new() -> PlantRaw {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string id = 2;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .RemoteFortressReader.TreeGrowth growths = 4;


    pub fn get_growths(&self) -> &[TreeGrowth] {
        &self.growths
    }
    pub fn clear_growths(&mut self) {
        self.growths.clear();
    }

    // Param is passed by value, moved
    pub fn set_growths(&mut self, v: ::protobuf::RepeatedField<TreeGrowth>) {
        self.growths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_growths(&mut self) -> &mut ::protobuf::RepeatedField<TreeGrowth> {
        &mut self.growths
    }

    // Take field
    pub fn take_growths(&mut self) -> ::protobuf::RepeatedField<TreeGrowth> {
        ::std::mem::replace(&mut self.growths, ::protobuf::RepeatedField::new())
    }

    // optional int32 tile = 5;


    pub fn get_tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }
    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlantRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.growths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.growths)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.growths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.growths {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.tile {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlantRaw {
        PlantRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &PlantRaw| { &m.index },
                |m: &mut PlantRaw| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PlantRaw| { &m.id },
                |m: &mut PlantRaw| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PlantRaw| { &m.name },
                |m: &mut PlantRaw| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TreeGrowth>>(
                "growths",
                |m: &PlantRaw| { &m.growths },
                |m: &mut PlantRaw| { &mut m.growths },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tile",
                |m: &PlantRaw| { &m.tile },
                |m: &mut PlantRaw| { &mut m.tile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlantRaw>(
                "PlantRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlantRaw {
        static instance: ::protobuf::rt::LazyV2<PlantRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlantRaw::new)
    }
}

impl ::protobuf::Clear for PlantRaw {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.id.clear();
        self.name.clear();
        self.growths.clear();
        self.tile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlantRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlantRawList {
    // message fields
    pub plant_raws: ::protobuf::RepeatedField<PlantRaw>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlantRawList {
    fn default() -> &'a PlantRawList {
        <PlantRawList as ::protobuf::Message>::default_instance()
    }
}

impl PlantRawList {
    pub fn new() -> PlantRawList {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.PlantRaw plant_raws = 1;


    pub fn get_plant_raws(&self) -> &[PlantRaw] {
        &self.plant_raws
    }
    pub fn clear_plant_raws(&mut self) {
        self.plant_raws.clear();
    }

    // Param is passed by value, moved
    pub fn set_plant_raws(&mut self, v: ::protobuf::RepeatedField<PlantRaw>) {
        self.plant_raws = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plant_raws(&mut self) -> &mut ::protobuf::RepeatedField<PlantRaw> {
        &mut self.plant_raws
    }

    // Take field
    pub fn take_plant_raws(&mut self) -> ::protobuf::RepeatedField<PlantRaw> {
        ::std::mem::replace(&mut self.plant_raws, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlantRawList {
    fn is_initialized(&self) -> bool {
        for v in &self.plant_raws {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plant_raws)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.plant_raws {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.plant_raws {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlantRawList {
        PlantRawList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlantRaw>>(
                "plant_raws",
                |m: &PlantRawList| { &m.plant_raws },
                |m: &mut PlantRawList| { &mut m.plant_raws },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlantRawList>(
                "PlantRawList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlantRawList {
        static instance: ::protobuf::rt::LazyV2<PlantRawList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlantRawList::new)
    }
}

impl ::protobuf::Clear for PlantRawList {
    fn clear(&mut self) {
        self.plant_raws.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlantRawList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantRawList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScreenTile {
    // message fields
    character: ::std::option::Option<u32>,
    foreground: ::std::option::Option<u32>,
    background: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScreenTile {
    fn default() -> &'a ScreenTile {
        <ScreenTile as ::protobuf::Message>::default_instance()
    }
}

impl ScreenTile {
    pub fn new() -> ScreenTile {
        ::std::default::Default::default()
    }

    // optional uint32 character = 1;


    pub fn get_character(&self) -> u32 {
        self.character.unwrap_or(0)
    }
    pub fn clear_character(&mut self) {
        self.character = ::std::option::Option::None;
    }

    pub fn has_character(&self) -> bool {
        self.character.is_some()
    }

    // Param is passed by value, moved
    pub fn set_character(&mut self, v: u32) {
        self.character = ::std::option::Option::Some(v);
    }

    // optional uint32 foreground = 2;


    pub fn get_foreground(&self) -> u32 {
        self.foreground.unwrap_or(0)
    }
    pub fn clear_foreground(&mut self) {
        self.foreground = ::std::option::Option::None;
    }

    pub fn has_foreground(&self) -> bool {
        self.foreground.is_some()
    }

    // Param is passed by value, moved
    pub fn set_foreground(&mut self, v: u32) {
        self.foreground = ::std::option::Option::Some(v);
    }

    // optional uint32 background = 3;


    pub fn get_background(&self) -> u32 {
        self.background.unwrap_or(0)
    }
    pub fn clear_background(&mut self) {
        self.background = ::std::option::Option::None;
    }

    pub fn has_background(&self) -> bool {
        self.background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background(&mut self, v: u32) {
        self.background = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScreenTile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.character = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.foreground = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.background = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.character {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.foreground {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.background {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.character {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.foreground {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.background {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScreenTile {
        ScreenTile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "character",
                |m: &ScreenTile| { &m.character },
                |m: &mut ScreenTile| { &mut m.character },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "foreground",
                |m: &ScreenTile| { &m.foreground },
                |m: &mut ScreenTile| { &mut m.foreground },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "background",
                |m: &ScreenTile| { &m.background },
                |m: &mut ScreenTile| { &mut m.background },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScreenTile>(
                "ScreenTile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScreenTile {
        static instance: ::protobuf::rt::LazyV2<ScreenTile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScreenTile::new)
    }
}

impl ::protobuf::Clear for ScreenTile {
    fn clear(&mut self) {
        self.character = ::std::option::Option::None;
        self.foreground = ::std::option::Option::None;
        self.background = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScreenTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenTile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScreenCapture {
    // message fields
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    pub tiles: ::protobuf::RepeatedField<ScreenTile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScreenCapture {
    fn default() -> &'a ScreenCapture {
        <ScreenCapture as ::protobuf::Message>::default_instance()
    }
}

impl ScreenCapture {
    pub fn new() -> ScreenCapture {
        ::std::default::Default::default()
    }

    // optional uint32 width = 1;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 2;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.ScreenTile tiles = 3;


    pub fn get_tiles(&self) -> &[ScreenTile] {
        &self.tiles
    }
    pub fn clear_tiles(&mut self) {
        self.tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiles(&mut self, v: ::protobuf::RepeatedField<ScreenTile>) {
        self.tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiles(&mut self) -> &mut ::protobuf::RepeatedField<ScreenTile> {
        &mut self.tiles
    }

    // Take field
    pub fn take_tiles(&mut self) -> ::protobuf::RepeatedField<ScreenTile> {
        ::std::mem::replace(&mut self.tiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScreenCapture {
    fn is_initialized(&self) -> bool {
        for v in &self.tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        }
        for v in &self.tiles {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScreenCapture {
        ScreenCapture::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &ScreenCapture| { &m.width },
                |m: &mut ScreenCapture| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &ScreenCapture| { &m.height },
                |m: &mut ScreenCapture| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScreenTile>>(
                "tiles",
                |m: &ScreenCapture| { &m.tiles },
                |m: &mut ScreenCapture| { &mut m.tiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScreenCapture>(
                "ScreenCapture",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScreenCapture {
        static instance: ::protobuf::rt::LazyV2<ScreenCapture> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScreenCapture::new)
    }
}

impl ::protobuf::Clear for ScreenCapture {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.tiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScreenCapture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenCapture {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyboardEvent {
    // message fields
    field_type: ::std::option::Option<u32>,
    which: ::std::option::Option<u32>,
    state: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    sym: ::std::option::Option<u32>,
    field_mod: ::std::option::Option<u32>,
    unicode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyboardEvent {
    fn default() -> &'a KeyboardEvent {
        <KeyboardEvent as ::protobuf::Message>::default_instance()
    }
}

impl KeyboardEvent {
    pub fn new() -> KeyboardEvent {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 which = 2;


    pub fn get_which(&self) -> u32 {
        self.which.unwrap_or(0)
    }
    pub fn clear_which(&mut self) {
        self.which = ::std::option::Option::None;
    }

    pub fn has_which(&self) -> bool {
        self.which.is_some()
    }

    // Param is passed by value, moved
    pub fn set_which(&mut self, v: u32) {
        self.which = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 3;


    pub fn get_state(&self) -> u32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional uint32 scancode = 4;


    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }
    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    // optional uint32 sym = 5;


    pub fn get_sym(&self) -> u32 {
        self.sym.unwrap_or(0)
    }
    pub fn clear_sym(&mut self) {
        self.sym = ::std::option::Option::None;
    }

    pub fn has_sym(&self) -> bool {
        self.sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sym(&mut self, v: u32) {
        self.sym = ::std::option::Option::Some(v);
    }

    // optional uint32 mod = 6;


    pub fn get_field_mod(&self) -> u32 {
        self.field_mod.unwrap_or(0)
    }
    pub fn clear_field_mod(&mut self) {
        self.field_mod = ::std::option::Option::None;
    }

    pub fn has_field_mod(&self) -> bool {
        self.field_mod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_mod(&mut self, v: u32) {
        self.field_mod = ::std::option::Option::Some(v);
    }

    // optional uint32 unicode = 7;


    pub fn get_unicode(&self) -> u32 {
        self.unicode.unwrap_or(0)
    }
    pub fn clear_unicode(&mut self) {
        self.unicode = ::std::option::Option::None;
    }

    pub fn has_unicode(&self) -> bool {
        self.unicode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unicode(&mut self, v: u32) {
        self.unicode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for KeyboardEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.which = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scancode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sym = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_mod = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unicode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.which {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sym {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_mod {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unicode {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.which {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sym {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.field_mod {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unicode {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyboardEvent {
        KeyboardEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &KeyboardEvent| { &m.field_type },
                |m: &mut KeyboardEvent| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "which",
                |m: &KeyboardEvent| { &m.which },
                |m: &mut KeyboardEvent| { &mut m.which },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "state",
                |m: &KeyboardEvent| { &m.state },
                |m: &mut KeyboardEvent| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scancode",
                |m: &KeyboardEvent| { &m.scancode },
                |m: &mut KeyboardEvent| { &mut m.scancode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sym",
                |m: &KeyboardEvent| { &m.sym },
                |m: &mut KeyboardEvent| { &mut m.sym },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mod",
                |m: &KeyboardEvent| { &m.field_mod },
                |m: &mut KeyboardEvent| { &mut m.field_mod },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unicode",
                |m: &KeyboardEvent| { &m.unicode },
                |m: &mut KeyboardEvent| { &mut m.unicode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyboardEvent>(
                "KeyboardEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyboardEvent {
        static instance: ::protobuf::rt::LazyV2<KeyboardEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyboardEvent::new)
    }
}

impl ::protobuf::Clear for KeyboardEvent {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.which = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.sym = ::std::option::Option::None;
        self.field_mod = ::std::option::Option::None;
        self.unicode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyboardEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyboardEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigCommand {
    // message fields
    designation: ::std::option::Option<TileDigDesignation>,
    pub locations: ::protobuf::RepeatedField<Coord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DigCommand {
    fn default() -> &'a DigCommand {
        <DigCommand as ::protobuf::Message>::default_instance()
    }
}

impl DigCommand {
    pub fn new() -> DigCommand {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.TileDigDesignation designation = 1;


    pub fn get_designation(&self) -> TileDigDesignation {
        self.designation.unwrap_or(TileDigDesignation::NO_DIG)
    }
    pub fn clear_designation(&mut self) {
        self.designation = ::std::option::Option::None;
    }

    pub fn has_designation(&self) -> bool {
        self.designation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_designation(&mut self, v: TileDigDesignation) {
        self.designation = ::std::option::Option::Some(v);
    }

    // repeated .RemoteFortressReader.Coord locations = 2;


    pub fn get_locations(&self) -> &[Coord] {
        &self.locations
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: ::protobuf::RepeatedField<Coord>) {
        self.locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locations(&mut self) -> &mut ::protobuf::RepeatedField<Coord> {
        &mut self.locations
    }

    // Take field
    pub fn take_locations(&mut self) -> ::protobuf::RepeatedField<Coord> {
        ::std::mem::replace(&mut self.locations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DigCommand {
    fn is_initialized(&self) -> bool {
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.designation, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.designation {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.designation {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.locations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigCommand {
        DigCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TileDigDesignation>>(
                "designation",
                |m: &DigCommand| { &m.designation },
                |m: &mut DigCommand| { &mut m.designation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "locations",
                |m: &DigCommand| { &m.locations },
                |m: &mut DigCommand| { &mut m.locations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DigCommand>(
                "DigCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DigCommand {
        static instance: ::protobuf::rt::LazyV2<DigCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DigCommand::new)
    }
}

impl ::protobuf::Clear for DigCommand {
    fn clear(&mut self) {
        self.designation = ::std::option::Option::None;
        self.locations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleBool {
    // message fields
    Value: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleBool {
    fn default() -> &'a SingleBool {
        <SingleBool as ::protobuf::Message>::default_instance()
    }
}

impl SingleBool {
    pub fn new() -> SingleBool {
        ::std::default::Default::default()
    }

    // optional bool Value = 1;


    pub fn get_Value(&self) -> bool {
        self.Value.unwrap_or(false)
    }
    pub fn clear_Value(&mut self) {
        self.Value = ::std::option::Option::None;
    }

    pub fn has_Value(&self) -> bool {
        self.Value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Value(&mut self, v: bool) {
        self.Value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SingleBool {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Value {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Value {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleBool {
        SingleBool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "Value",
                |m: &SingleBool| { &m.Value },
                |m: &mut SingleBool| { &mut m.Value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleBool>(
                "SingleBool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleBool {
        static instance: ::protobuf::rt::LazyV2<SingleBool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleBool::new)
    }
}

impl ::protobuf::Clear for SingleBool {
    fn clear(&mut self) {
        self.Value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleBool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleBool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionInfo {
    // message fields
    dwarf_fortress_version: ::protobuf::SingularField<::std::string::String>,
    dfhack_version: ::protobuf::SingularField<::std::string::String>,
    remote_fortress_reader_version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionInfo {
    fn default() -> &'a VersionInfo {
        <VersionInfo as ::protobuf::Message>::default_instance()
    }
}

impl VersionInfo {
    pub fn new() -> VersionInfo {
        ::std::default::Default::default()
    }

    // optional string dwarf_fortress_version = 1;


    pub fn get_dwarf_fortress_version(&self) -> &str {
        match self.dwarf_fortress_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dwarf_fortress_version(&mut self) {
        self.dwarf_fortress_version.clear();
    }

    pub fn has_dwarf_fortress_version(&self) -> bool {
        self.dwarf_fortress_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dwarf_fortress_version(&mut self, v: ::std::string::String) {
        self.dwarf_fortress_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dwarf_fortress_version(&mut self) -> &mut ::std::string::String {
        if self.dwarf_fortress_version.is_none() {
            self.dwarf_fortress_version.set_default();
        }
        self.dwarf_fortress_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_dwarf_fortress_version(&mut self) -> ::std::string::String {
        self.dwarf_fortress_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dfhack_version = 2;


    pub fn get_dfhack_version(&self) -> &str {
        match self.dfhack_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dfhack_version(&mut self) {
        self.dfhack_version.clear();
    }

    pub fn has_dfhack_version(&self) -> bool {
        self.dfhack_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dfhack_version(&mut self, v: ::std::string::String) {
        self.dfhack_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dfhack_version(&mut self) -> &mut ::std::string::String {
        if self.dfhack_version.is_none() {
            self.dfhack_version.set_default();
        }
        self.dfhack_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_dfhack_version(&mut self) -> ::std::string::String {
        self.dfhack_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_fortress_reader_version = 3;


    pub fn get_remote_fortress_reader_version(&self) -> &str {
        match self.remote_fortress_reader_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_remote_fortress_reader_version(&mut self) {
        self.remote_fortress_reader_version.clear();
    }

    pub fn has_remote_fortress_reader_version(&self) -> bool {
        self.remote_fortress_reader_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_fortress_reader_version(&mut self, v: ::std::string::String) {
        self.remote_fortress_reader_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_fortress_reader_version(&mut self) -> &mut ::std::string::String {
        if self.remote_fortress_reader_version.is_none() {
            self.remote_fortress_reader_version.set_default();
        }
        self.remote_fortress_reader_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_fortress_reader_version(&mut self) -> ::std::string::String {
        self.remote_fortress_reader_version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dwarf_fortress_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dfhack_version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.remote_fortress_reader_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dwarf_fortress_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dfhack_version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.remote_fortress_reader_version.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dwarf_fortress_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dfhack_version.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.remote_fortress_reader_version.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionInfo {
        VersionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dwarf_fortress_version",
                |m: &VersionInfo| { &m.dwarf_fortress_version },
                |m: &mut VersionInfo| { &mut m.dwarf_fortress_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dfhack_version",
                |m: &VersionInfo| { &m.dfhack_version },
                |m: &mut VersionInfo| { &mut m.dfhack_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_fortress_reader_version",
                |m: &VersionInfo| { &m.remote_fortress_reader_version },
                |m: &mut VersionInfo| { &mut m.remote_fortress_reader_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VersionInfo>(
                "VersionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VersionInfo {
        static instance: ::protobuf::rt::LazyV2<VersionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VersionInfo::new)
    }
}

impl ::protobuf::Clear for VersionInfo {
    fn clear(&mut self) {
        self.dwarf_fortress_version.clear();
        self.dfhack_version.clear();
        self.remote_fortress_reader_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRequest {
    // message fields
    list_start: ::std::option::Option<i32>,
    list_end: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    // optional int32 list_start = 1;


    pub fn get_list_start(&self) -> i32 {
        self.list_start.unwrap_or(0)
    }
    pub fn clear_list_start(&mut self) {
        self.list_start = ::std::option::Option::None;
    }

    pub fn has_list_start(&self) -> bool {
        self.list_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_start(&mut self, v: i32) {
        self.list_start = ::std::option::Option::Some(v);
    }

    // optional int32 list_end = 2;


    pub fn get_list_end(&self) -> i32 {
        self.list_end.unwrap_or(0)
    }
    pub fn clear_list_end(&mut self) {
        self.list_end = ::std::option::Option::None;
    }

    pub fn has_list_end(&self) -> bool {
        self.list_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_end(&mut self, v: i32) {
        self.list_end = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.list_start = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.list_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.list_start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.list_start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.list_end {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "list_start",
                |m: &ListRequest| { &m.list_start },
                |m: &mut ListRequest| { &mut m.list_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "list_end",
                |m: &ListRequest| { &m.list_end },
                |m: &mut ListRequest| { &mut m.list_end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListRequest>(
                "ListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListRequest {
        static instance: ::protobuf::rt::LazyV2<ListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListRequest::new)
    }
}

impl ::protobuf::Clear for ListRequest {
    fn clear(&mut self) {
        self.list_start = ::std::option::Option::None;
        self.list_end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Report {
    // message fields
    field_type: ::std::option::Option<i32>,
    text: ::protobuf::SingularField<::std::string::String>,
    pub color: ::protobuf::SingularPtrField<ColorDefinition>,
    duration: ::std::option::Option<i32>,
    continuation: ::std::option::Option<bool>,
    unconscious: ::std::option::Option<bool>,
    announcement: ::std::option::Option<bool>,
    repeat_count: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<Coord>,
    id: ::std::option::Option<i32>,
    year: ::std::option::Option<i32>,
    time: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Report {
    fn default() -> &'a Report {
        <Report as ::protobuf::Message>::default_instance()
    }
}

impl Report {
    pub fn new() -> Report {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.ColorDefinition color = 3;


    pub fn get_color(&self) -> &ColorDefinition {
        self.color.as_ref().unwrap_or_else(|| <ColorDefinition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ColorDefinition) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ColorDefinition {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ColorDefinition {
        self.color.take().unwrap_or_else(|| ColorDefinition::new())
    }

    // optional int32 duration = 4;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool continuation = 5;


    pub fn get_continuation(&self) -> bool {
        self.continuation.unwrap_or(false)
    }
    pub fn clear_continuation(&mut self) {
        self.continuation = ::std::option::Option::None;
    }

    pub fn has_continuation(&self) -> bool {
        self.continuation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continuation(&mut self, v: bool) {
        self.continuation = ::std::option::Option::Some(v);
    }

    // optional bool unconscious = 6;


    pub fn get_unconscious(&self) -> bool {
        self.unconscious.unwrap_or(false)
    }
    pub fn clear_unconscious(&mut self) {
        self.unconscious = ::std::option::Option::None;
    }

    pub fn has_unconscious(&self) -> bool {
        self.unconscious.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unconscious(&mut self, v: bool) {
        self.unconscious = ::std::option::Option::Some(v);
    }

    // optional bool announcement = 7;


    pub fn get_announcement(&self) -> bool {
        self.announcement.unwrap_or(false)
    }
    pub fn clear_announcement(&mut self) {
        self.announcement = ::std::option::Option::None;
    }

    pub fn has_announcement(&self) -> bool {
        self.announcement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement(&mut self, v: bool) {
        self.announcement = ::std::option::Option::Some(v);
    }

    // optional int32 repeat_count = 8;


    pub fn get_repeat_count(&self) -> i32 {
        self.repeat_count.unwrap_or(0)
    }
    pub fn clear_repeat_count(&mut self) {
        self.repeat_count = ::std::option::Option::None;
    }

    pub fn has_repeat_count(&self) -> bool {
        self.repeat_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat_count(&mut self, v: i32) {
        self.repeat_count = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord pos = 9;


    pub fn get_pos(&self) -> &Coord {
        self.pos.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Coord) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Coord {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Coord {
        self.pos.take().unwrap_or_else(|| Coord::new())
    }

    // optional int32 id = 10;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 year = 11;


    pub fn get_year(&self) -> i32 {
        self.year.unwrap_or(0)
    }
    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: i32) {
        self.year = ::std::option::Option::Some(v);
    }

    // optional int32 time = 12;


    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or(0)
    }
    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Report {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.continuation = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unconscious = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.announcement = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.repeat_count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.year = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.continuation {
            my_size += 2;
        }
        if let Some(v) = self.unconscious {
            my_size += 2;
        }
        if let Some(v) = self.announcement {
            my_size += 2;
        }
        if let Some(v) = self.repeat_count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.continuation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.unconscious {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.announcement {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.repeat_count {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.year {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Report {
        Report::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &Report| { &m.field_type },
                |m: &mut Report| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &Report| { &m.text },
                |m: &mut Report| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorDefinition>>(
                "color",
                |m: &Report| { &m.color },
                |m: &mut Report| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &Report| { &m.duration },
                |m: &mut Report| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "continuation",
                |m: &Report| { &m.continuation },
                |m: &mut Report| { &mut m.continuation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unconscious",
                |m: &Report| { &m.unconscious },
                |m: &mut Report| { &mut m.unconscious },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "announcement",
                |m: &Report| { &m.announcement },
                |m: &mut Report| { &mut m.announcement },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "repeat_count",
                |m: &Report| { &m.repeat_count },
                |m: &mut Report| { &mut m.repeat_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "pos",
                |m: &Report| { &m.pos },
                |m: &mut Report| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Report| { &m.id },
                |m: &mut Report| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "year",
                |m: &Report| { &m.year },
                |m: &mut Report| { &mut m.year },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "time",
                |m: &Report| { &m.time },
                |m: &mut Report| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Report>(
                "Report",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Report {
        static instance: ::protobuf::rt::LazyV2<Report> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Report::new)
    }
}

impl ::protobuf::Clear for Report {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.text.clear();
        self.color.clear();
        self.duration = ::std::option::Option::None;
        self.continuation = ::std::option::Option::None;
        self.unconscious = ::std::option::Option::None;
        self.announcement = ::std::option::Option::None;
        self.repeat_count = ::std::option::Option::None;
        self.pos.clear();
        self.id = ::std::option::Option::None;
        self.year = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Report {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Report {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub reports: ::protobuf::RepeatedField<Report>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.Report reports = 1;


    pub fn get_reports(&self) -> &[Report] {
        &self.reports
    }
    pub fn clear_reports(&mut self) {
        self.reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: ::protobuf::RepeatedField<Report>) {
        self.reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reports(&mut self) -> &mut ::protobuf::RepeatedField<Report> {
        &mut self.reports
    }

    // Take field
    pub fn take_reports(&mut self) -> ::protobuf::RepeatedField<Report> {
        ::std::mem::replace(&mut self.reports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        for v in &self.reports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Report>>(
                "reports",
                |m: &Status| { &m.reports },
                |m: &mut Status| { &mut m.reports },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Status>(
                "Status",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Status {
        static instance: ::protobuf::rt::LazyV2<Status> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Status::new)
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.reports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShapeDescriptior {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    tile: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShapeDescriptior {
    fn default() -> &'a ShapeDescriptior {
        <ShapeDescriptior as ::protobuf::Message>::default_instance()
    }
}

impl ShapeDescriptior {
    pub fn new() -> ShapeDescriptior {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tile = 2;


    pub fn get_tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }
    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ShapeDescriptior {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.tile {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShapeDescriptior {
        ShapeDescriptior::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ShapeDescriptior| { &m.id },
                |m: &mut ShapeDescriptior| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tile",
                |m: &ShapeDescriptior| { &m.tile },
                |m: &mut ShapeDescriptior| { &mut m.tile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShapeDescriptior>(
                "ShapeDescriptior",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShapeDescriptior {
        static instance: ::protobuf::rt::LazyV2<ShapeDescriptior> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShapeDescriptior::new)
    }
}

impl ::protobuf::Clear for ShapeDescriptior {
    fn clear(&mut self) {
        self.id.clear();
        self.tile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShapeDescriptior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShapeDescriptior {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Language {
    // message fields
    pub shapes: ::protobuf::RepeatedField<ShapeDescriptior>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Language {
    fn default() -> &'a Language {
        <Language as ::protobuf::Message>::default_instance()
    }
}

impl Language {
    pub fn new() -> Language {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.ShapeDescriptior shapes = 1;


    pub fn get_shapes(&self) -> &[ShapeDescriptior] {
        &self.shapes
    }
    pub fn clear_shapes(&mut self) {
        self.shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_shapes(&mut self, v: ::protobuf::RepeatedField<ShapeDescriptior>) {
        self.shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shapes(&mut self) -> &mut ::protobuf::RepeatedField<ShapeDescriptior> {
        &mut self.shapes
    }

    // Take field
    pub fn take_shapes(&mut self) -> ::protobuf::RepeatedField<ShapeDescriptior> {
        ::std::mem::replace(&mut self.shapes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Language {
    fn is_initialized(&self) -> bool {
        for v in &self.shapes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shapes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shapes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Language {
        Language::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeDescriptior>>(
                "shapes",
                |m: &Language| { &m.shapes },
                |m: &mut Language| { &mut m.shapes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Language>(
                "Language",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Language {
        static instance: ::protobuf::rt::LazyV2<Language> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Language::new)
    }
}

impl ::protobuf::Clear for Language {
    fn clear(&mut self) {
        self.shapes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Language {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Language {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ItemImprovement {
    // message fields
    pub material: ::protobuf::SingularPtrField<MatPair>,
    shape: ::std::option::Option<i32>,
    specific_type: ::std::option::Option<i32>,
    pub image: ::protobuf::SingularPtrField<ArtImage>,
    field_type: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ItemImprovement {
    fn default() -> &'a ItemImprovement {
        <ItemImprovement as ::protobuf::Message>::default_instance()
    }
}

impl ItemImprovement {
    pub fn new() -> ItemImprovement {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.MatPair material = 1;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional int32 shape = 3;


    pub fn get_shape(&self) -> i32 {
        self.shape.unwrap_or(0)
    }
    pub fn clear_shape(&mut self) {
        self.shape = ::std::option::Option::None;
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: i32) {
        self.shape = ::std::option::Option::Some(v);
    }

    // optional int32 specific_type = 4;


    pub fn get_specific_type(&self) -> i32 {
        self.specific_type.unwrap_or(0)
    }
    pub fn clear_specific_type(&mut self) {
        self.specific_type = ::std::option::Option::None;
    }

    pub fn has_specific_type(&self) -> bool {
        self.specific_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specific_type(&mut self, v: i32) {
        self.specific_type = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImage image = 5;


    pub fn get_image(&self) -> &ArtImage {
        self.image.as_ref().unwrap_or_else(|| <ArtImage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ArtImage) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ArtImage {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ArtImage {
        self.image.take().unwrap_or_else(|| ArtImage::new())
    }

    // optional int32 type = 6;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ItemImprovement {
    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shape = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.specific_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.shape {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.specific_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.shape {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.specific_type {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ItemImprovement {
        ItemImprovement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &ItemImprovement| { &m.material },
                |m: &mut ItemImprovement| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shape",
                |m: &ItemImprovement| { &m.shape },
                |m: &mut ItemImprovement| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "specific_type",
                |m: &ItemImprovement| { &m.specific_type },
                |m: &mut ItemImprovement| { &mut m.specific_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtImage>>(
                "image",
                |m: &ItemImprovement| { &m.image },
                |m: &mut ItemImprovement| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &ItemImprovement| { &m.field_type },
                |m: &mut ItemImprovement| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ItemImprovement>(
                "ItemImprovement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ItemImprovement {
        static instance: ::protobuf::rt::LazyV2<ItemImprovement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ItemImprovement::new)
    }
}

impl ::protobuf::Clear for ItemImprovement {
    fn clear(&mut self) {
        self.material.clear();
        self.shape = ::std::option::Option::None;
        self.specific_type = ::std::option::Option::None;
        self.image.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ItemImprovement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemImprovement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtImageElement {
    // message fields
    count: ::std::option::Option<i32>,
    field_type: ::std::option::Option<ArtImageElementType>,
    pub creature_item: ::protobuf::SingularPtrField<MatPair>,
    pub material: ::protobuf::SingularPtrField<MatPair>,
    id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtImageElement {
    fn default() -> &'a ArtImageElement {
        <ArtImageElement as ::protobuf::Message>::default_instance()
    }
}

impl ArtImageElement {
    pub fn new() -> ArtImageElement {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImageElementType type = 2;


    pub fn get_field_type(&self) -> ArtImageElementType {
        self.field_type.unwrap_or(ArtImageElementType::IMAGE_CREATURE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ArtImageElementType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair creature_item = 3;


    pub fn get_creature_item(&self) -> &MatPair {
        self.creature_item.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creature_item(&mut self) {
        self.creature_item.clear();
    }

    pub fn has_creature_item(&self) -> bool {
        self.creature_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_item(&mut self, v: MatPair) {
        self.creature_item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creature_item(&mut self) -> &mut MatPair {
        if self.creature_item.is_none() {
            self.creature_item.set_default();
        }
        self.creature_item.as_mut().unwrap()
    }

    // Take field
    pub fn take_creature_item(&mut self) -> MatPair {
        self.creature_item.take().unwrap_or_else(|| MatPair::new())
    }

    // optional .RemoteFortressReader.MatPair material = 5;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional int32 id = 6;


    pub fn get_id(&self) -> i32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ArtImageElement {
    fn is_initialized(&self) -> bool {
        for v in &self.creature_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creature_item)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.creature_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.creature_item.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtImageElement {
        ArtImageElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &ArtImageElement| { &m.count },
                |m: &mut ArtImageElement| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ArtImageElementType>>(
                "type",
                |m: &ArtImageElement| { &m.field_type },
                |m: &mut ArtImageElement| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "creature_item",
                |m: &ArtImageElement| { &m.creature_item },
                |m: &mut ArtImageElement| { &mut m.creature_item },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &ArtImageElement| { &m.material },
                |m: &mut ArtImageElement| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &ArtImageElement| { &m.id },
                |m: &mut ArtImageElement| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtImageElement>(
                "ArtImageElement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtImageElement {
        static instance: ::protobuf::rt::LazyV2<ArtImageElement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtImageElement::new)
    }
}

impl ::protobuf::Clear for ArtImageElement {
    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.creature_item.clear();
        self.material.clear();
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtImageElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImageElement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtImageProperty {
    // message fields
    subject: ::std::option::Option<i32>,
    object: ::std::option::Option<i32>,
    verb: ::std::option::Option<ArtImageVerb>,
    field_type: ::std::option::Option<ArtImagePropertyType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtImageProperty {
    fn default() -> &'a ArtImageProperty {
        <ArtImageProperty as ::protobuf::Message>::default_instance()
    }
}

impl ArtImageProperty {
    pub fn new() -> ArtImageProperty {
        ::std::default::Default::default()
    }

    // optional int32 subject = 1;


    pub fn get_subject(&self) -> i32 {
        self.subject.unwrap_or(0)
    }
    pub fn clear_subject(&mut self) {
        self.subject = ::std::option::Option::None;
    }

    pub fn has_subject(&self) -> bool {
        self.subject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: i32) {
        self.subject = ::std::option::Option::Some(v);
    }

    // optional int32 object = 2;


    pub fn get_object(&self) -> i32 {
        self.object.unwrap_or(0)
    }
    pub fn clear_object(&mut self) {
        self.object = ::std::option::Option::None;
    }

    pub fn has_object(&self) -> bool {
        self.object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: i32) {
        self.object = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImageVerb verb = 3;


    pub fn get_verb(&self) -> ArtImageVerb {
        self.verb.unwrap_or(ArtImageVerb::VERB_WITHERING)
    }
    pub fn clear_verb(&mut self) {
        self.verb = ::std::option::Option::None;
    }

    pub fn has_verb(&self) -> bool {
        self.verb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verb(&mut self, v: ArtImageVerb) {
        self.verb = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImagePropertyType type = 4;


    pub fn get_field_type(&self) -> ArtImagePropertyType {
        self.field_type.unwrap_or(ArtImagePropertyType::TRANSITIVE_VERB)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ArtImagePropertyType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ArtImageProperty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subject = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.object = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.verb, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subject {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.object {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.verb {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subject {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.object {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.verb {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtImageProperty {
        ArtImageProperty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "subject",
                |m: &ArtImageProperty| { &m.subject },
                |m: &mut ArtImageProperty| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "object",
                |m: &ArtImageProperty| { &m.object },
                |m: &mut ArtImageProperty| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ArtImageVerb>>(
                "verb",
                |m: &ArtImageProperty| { &m.verb },
                |m: &mut ArtImageProperty| { &mut m.verb },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ArtImagePropertyType>>(
                "type",
                |m: &ArtImageProperty| { &m.field_type },
                |m: &mut ArtImageProperty| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtImageProperty>(
                "ArtImageProperty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtImageProperty {
        static instance: ::protobuf::rt::LazyV2<ArtImageProperty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtImageProperty::new)
    }
}

impl ::protobuf::Clear for ArtImageProperty {
    fn clear(&mut self) {
        self.subject = ::std::option::Option::None;
        self.object = ::std::option::Option::None;
        self.verb = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtImageProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImageProperty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArtImage {
    // message fields
    pub elements: ::protobuf::RepeatedField<ArtImageElement>,
    pub id: ::protobuf::SingularPtrField<MatPair>,
    pub properties: ::protobuf::RepeatedField<ArtImageProperty>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtImage {
    fn default() -> &'a ArtImage {
        <ArtImage as ::protobuf::Message>::default_instance()
    }
}

impl ArtImage {
    pub fn new() -> ArtImage {
        ::std::default::Default::default()
    }

    // repeated .RemoteFortressReader.ArtImageElement elements = 1;


    pub fn get_elements(&self) -> &[ArtImageElement] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<ArtImageElement>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<ArtImageElement> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<ArtImageElement> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    // optional .RemoteFortressReader.MatPair id = 2;


    pub fn get_id(&self) -> &MatPair {
        self.id.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: MatPair) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut MatPair {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> MatPair {
        self.id.take().unwrap_or_else(|| MatPair::new())
    }

    // repeated .RemoteFortressReader.ArtImageProperty properties = 3;


    pub fn get_properties(&self) -> &[ArtImageProperty] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<ArtImageProperty>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<ArtImageProperty> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<ArtImageProperty> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ArtImage {
    fn is_initialized(&self) -> bool {
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtImage {
        ArtImage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtImageElement>>(
                "elements",
                |m: &ArtImage| { &m.elements },
                |m: &mut ArtImage| { &mut m.elements },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "id",
                |m: &ArtImage| { &m.id },
                |m: &mut ArtImage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtImageProperty>>(
                "properties",
                |m: &ArtImage| { &m.properties },
                |m: &mut ArtImage| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtImage>(
                "ArtImage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtImage {
        static instance: ::protobuf::rt::LazyV2<ArtImage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtImage::new)
    }
}

impl ::protobuf::Clear for ArtImage {
    fn clear(&mut self) {
        self.elements.clear();
        self.id.clear();
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Engraving {
    // message fields
    pub pos: ::protobuf::SingularPtrField<Coord>,
    quality: ::std::option::Option<i32>,
    tile: ::std::option::Option<i32>,
    pub image: ::protobuf::SingularPtrField<ArtImage>,
    floor: ::std::option::Option<bool>,
    west: ::std::option::Option<bool>,
    east: ::std::option::Option<bool>,
    north: ::std::option::Option<bool>,
    south: ::std::option::Option<bool>,
    hidden: ::std::option::Option<bool>,
    northwest: ::std::option::Option<bool>,
    northeast: ::std::option::Option<bool>,
    southwest: ::std::option::Option<bool>,
    southeast: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Engraving {
    fn default() -> &'a Engraving {
        <Engraving as ::protobuf::Message>::default_instance()
    }
}

impl Engraving {
    pub fn new() -> Engraving {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.Coord pos = 1;


    pub fn get_pos(&self) -> &Coord {
        self.pos.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Coord) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Coord {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Coord {
        self.pos.take().unwrap_or_else(|| Coord::new())
    }

    // optional int32 quality = 2;


    pub fn get_quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional int32 tile = 3;


    pub fn get_tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }
    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImage image = 4;


    pub fn get_image(&self) -> &ArtImage {
        self.image.as_ref().unwrap_or_else(|| <ArtImage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ArtImage) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ArtImage {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ArtImage {
        self.image.take().unwrap_or_else(|| ArtImage::new())
    }

    // optional bool floor = 5;


    pub fn get_floor(&self) -> bool {
        self.floor.unwrap_or(false)
    }
    pub fn clear_floor(&mut self) {
        self.floor = ::std::option::Option::None;
    }

    pub fn has_floor(&self) -> bool {
        self.floor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_floor(&mut self, v: bool) {
        self.floor = ::std::option::Option::Some(v);
    }

    // optional bool west = 6;


    pub fn get_west(&self) -> bool {
        self.west.unwrap_or(false)
    }
    pub fn clear_west(&mut self) {
        self.west = ::std::option::Option::None;
    }

    pub fn has_west(&self) -> bool {
        self.west.is_some()
    }

    // Param is passed by value, moved
    pub fn set_west(&mut self, v: bool) {
        self.west = ::std::option::Option::Some(v);
    }

    // optional bool east = 7;


    pub fn get_east(&self) -> bool {
        self.east.unwrap_or(false)
    }
    pub fn clear_east(&mut self) {
        self.east = ::std::option::Option::None;
    }

    pub fn has_east(&self) -> bool {
        self.east.is_some()
    }

    // Param is passed by value, moved
    pub fn set_east(&mut self, v: bool) {
        self.east = ::std::option::Option::Some(v);
    }

    // optional bool north = 8;


    pub fn get_north(&self) -> bool {
        self.north.unwrap_or(false)
    }
    pub fn clear_north(&mut self) {
        self.north = ::std::option::Option::None;
    }

    pub fn has_north(&self) -> bool {
        self.north.is_some()
    }

    // Param is passed by value, moved
    pub fn set_north(&mut self, v: bool) {
        self.north = ::std::option::Option::Some(v);
    }

    // optional bool south = 9;


    pub fn get_south(&self) -> bool {
        self.south.unwrap_or(false)
    }
    pub fn clear_south(&mut self) {
        self.south = ::std::option::Option::None;
    }

    pub fn has_south(&self) -> bool {
        self.south.is_some()
    }

    // Param is passed by value, moved
    pub fn set_south(&mut self, v: bool) {
        self.south = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 10;


    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }
    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional bool northwest = 11;


    pub fn get_northwest(&self) -> bool {
        self.northwest.unwrap_or(false)
    }
    pub fn clear_northwest(&mut self) {
        self.northwest = ::std::option::Option::None;
    }

    pub fn has_northwest(&self) -> bool {
        self.northwest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_northwest(&mut self, v: bool) {
        self.northwest = ::std::option::Option::Some(v);
    }

    // optional bool northeast = 12;


    pub fn get_northeast(&self) -> bool {
        self.northeast.unwrap_or(false)
    }
    pub fn clear_northeast(&mut self) {
        self.northeast = ::std::option::Option::None;
    }

    pub fn has_northeast(&self) -> bool {
        self.northeast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_northeast(&mut self, v: bool) {
        self.northeast = ::std::option::Option::Some(v);
    }

    // optional bool southwest = 13;


    pub fn get_southwest(&self) -> bool {
        self.southwest.unwrap_or(false)
    }
    pub fn clear_southwest(&mut self) {
        self.southwest = ::std::option::Option::None;
    }

    pub fn has_southwest(&self) -> bool {
        self.southwest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_southwest(&mut self, v: bool) {
        self.southwest = ::std::option::Option::Some(v);
    }

    // optional bool southeast = 14;


    pub fn get_southeast(&self) -> bool {
        self.southeast.unwrap_or(false)
    }
    pub fn clear_southeast(&mut self) {
        self.southeast = ::std::option::Option::None;
    }

    pub fn has_southeast(&self) -> bool {
        self.southeast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_southeast(&mut self, v: bool) {
        self.southeast = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Engraving {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tile = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.floor = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.west = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.east = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.north = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.south = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.northwest = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.northeast = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.southwest = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.southeast = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.floor {
            my_size += 2;
        }
        if let Some(v) = self.west {
            my_size += 2;
        }
        if let Some(v) = self.east {
            my_size += 2;
        }
        if let Some(v) = self.north {
            my_size += 2;
        }
        if let Some(v) = self.south {
            my_size += 2;
        }
        if let Some(v) = self.hidden {
            my_size += 2;
        }
        if let Some(v) = self.northwest {
            my_size += 2;
        }
        if let Some(v) = self.northeast {
            my_size += 2;
        }
        if let Some(v) = self.southwest {
            my_size += 2;
        }
        if let Some(v) = self.southeast {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.tile {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.floor {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.west {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.east {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.north {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.south {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.northwest {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.northeast {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.southwest {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.southeast {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Engraving {
        Engraving::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "pos",
                |m: &Engraving| { &m.pos },
                |m: &mut Engraving| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "quality",
                |m: &Engraving| { &m.quality },
                |m: &mut Engraving| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tile",
                |m: &Engraving| { &m.tile },
                |m: &mut Engraving| { &mut m.tile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtImage>>(
                "image",
                |m: &Engraving| { &m.image },
                |m: &mut Engraving| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "floor",
                |m: &Engraving| { &m.floor },
                |m: &mut Engraving| { &mut m.floor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "west",
                |m: &Engraving| { &m.west },
                |m: &mut Engraving| { &mut m.west },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "east",
                |m: &Engraving| { &m.east },
                |m: &mut Engraving| { &mut m.east },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "north",
                |m: &Engraving| { &m.north },
                |m: &mut Engraving| { &mut m.north },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "south",
                |m: &Engraving| { &m.south },
                |m: &mut Engraving| { &mut m.south },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hidden",
                |m: &Engraving| { &m.hidden },
                |m: &mut Engraving| { &mut m.hidden },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "northwest",
                |m: &Engraving| { &m.northwest },
                |m: &mut Engraving| { &mut m.northwest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "northeast",
                |m: &Engraving| { &m.northeast },
                |m: &mut Engraving| { &mut m.northeast },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "southwest",
                |m: &Engraving| { &m.southwest },
                |m: &mut Engraving| { &mut m.southwest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "southeast",
                |m: &Engraving| { &m.southeast },
                |m: &mut Engraving| { &mut m.southeast },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Engraving>(
                "Engraving",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Engraving {
        static instance: ::protobuf::rt::LazyV2<Engraving> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Engraving::new)
    }
}

impl ::protobuf::Clear for Engraving {
    fn clear(&mut self) {
        self.pos.clear();
        self.quality = ::std::option::Option::None;
        self.tile = ::std::option::Option::None;
        self.image.clear();
        self.floor = ::std::option::Option::None;
        self.west = ::std::option::Option::None;
        self.east = ::std::option::Option::None;
        self.north = ::std::option::Option::None;
        self.south = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.northwest = ::std::option::Option::None;
        self.northeast = ::std::option::Option::None;
        self.southwest = ::std::option::Option::None;
        self.southeast = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Engraving {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Engraving {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlowInfo {
    // message fields
    index: ::std::option::Option<i32>,
    field_type: ::std::option::Option<FlowType>,
    density: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<Coord>,
    pub dest: ::protobuf::SingularPtrField<Coord>,
    expanding: ::std::option::Option<bool>,
    reuse: ::std::option::Option<bool>,
    guide_id: ::std::option::Option<i32>,
    pub material: ::protobuf::SingularPtrField<MatPair>,
    pub item: ::protobuf::SingularPtrField<MatPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowInfo {
    fn default() -> &'a FlowInfo {
        <FlowInfo as ::protobuf::Message>::default_instance()
    }
}

impl FlowInfo {
    pub fn new() -> FlowInfo {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.FlowType type = 2;


    pub fn get_field_type(&self) -> FlowType {
        self.field_type.unwrap_or(FlowType::Miasma)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FlowType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 density = 3;


    pub fn get_density(&self) -> i32 {
        self.density.unwrap_or(0)
    }
    pub fn clear_density(&mut self) {
        self.density = ::std::option::Option::None;
    }

    pub fn has_density(&self) -> bool {
        self.density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_density(&mut self, v: i32) {
        self.density = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord pos = 4;


    pub fn get_pos(&self) -> &Coord {
        self.pos.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Coord) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Coord {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Coord {
        self.pos.take().unwrap_or_else(|| Coord::new())
    }

    // optional .RemoteFortressReader.Coord dest = 5;


    pub fn get_dest(&self) -> &Coord {
        self.dest.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: Coord) {
        self.dest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut Coord {
        if self.dest.is_none() {
            self.dest.set_default();
        }
        self.dest.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest(&mut self) -> Coord {
        self.dest.take().unwrap_or_else(|| Coord::new())
    }

    // optional bool expanding = 6;


    pub fn get_expanding(&self) -> bool {
        self.expanding.unwrap_or(false)
    }
    pub fn clear_expanding(&mut self) {
        self.expanding = ::std::option::Option::None;
    }

    pub fn has_expanding(&self) -> bool {
        self.expanding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expanding(&mut self, v: bool) {
        self.expanding = ::std::option::Option::Some(v);
    }

    // optional bool reuse = 7;


    pub fn get_reuse(&self) -> bool {
        self.reuse.unwrap_or(false)
    }
    pub fn clear_reuse(&mut self) {
        self.reuse = ::std::option::Option::None;
    }

    pub fn has_reuse(&self) -> bool {
        self.reuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reuse(&mut self, v: bool) {
        self.reuse = ::std::option::Option::Some(v);
    }

    // optional int32 guide_id = 8;


    pub fn get_guide_id(&self) -> i32 {
        self.guide_id.unwrap_or(0)
    }
    pub fn clear_guide_id(&mut self) {
        self.guide_id = ::std::option::Option::None;
    }

    pub fn has_guide_id(&self) -> bool {
        self.guide_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guide_id(&mut self, v: i32) {
        self.guide_id = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatPair material = 9;


    pub fn get_material(&self) -> &MatPair {
        self.material.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_material(&mut self) {
        self.material.clear();
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: MatPair) {
        self.material = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material(&mut self) -> &mut MatPair {
        if self.material.is_none() {
            self.material.set_default();
        }
        self.material.as_mut().unwrap()
    }

    // Take field
    pub fn take_material(&mut self) -> MatPair {
        self.material.take().unwrap_or_else(|| MatPair::new())
    }

    // optional .RemoteFortressReader.MatPair item = 10;


    pub fn get_item(&self) -> &MatPair {
        self.item.as_ref().unwrap_or_else(|| <MatPair as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: MatPair) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut MatPair {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> MatPair {
        self.item.take().unwrap_or_else(|| MatPair::new())
    }
}

impl ::protobuf::Message for FlowInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.density = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dest)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expanding = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reuse = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guide_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.material)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.density {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.expanding {
            my_size += 2;
        }
        if let Some(v) = self.reuse {
            my_size += 2;
        }
        if let Some(v) = self.guide_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.density {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dest.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.expanding {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.reuse {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.guide_id {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.material.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowInfo {
        FlowInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &FlowInfo| { &m.index },
                |m: &mut FlowInfo| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowType>>(
                "type",
                |m: &FlowInfo| { &m.field_type },
                |m: &mut FlowInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "density",
                |m: &FlowInfo| { &m.density },
                |m: &mut FlowInfo| { &mut m.density },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "pos",
                |m: &FlowInfo| { &m.pos },
                |m: &mut FlowInfo| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "dest",
                |m: &FlowInfo| { &m.dest },
                |m: &mut FlowInfo| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expanding",
                |m: &FlowInfo| { &m.expanding },
                |m: &mut FlowInfo| { &mut m.expanding },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reuse",
                |m: &FlowInfo| { &m.reuse },
                |m: &mut FlowInfo| { &mut m.reuse },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guide_id",
                |m: &FlowInfo| { &m.guide_id },
                |m: &mut FlowInfo| { &mut m.guide_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "material",
                |m: &FlowInfo| { &m.material },
                |m: &mut FlowInfo| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatPair>>(
                "item",
                |m: &FlowInfo| { &m.item },
                |m: &mut FlowInfo| { &mut m.item },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlowInfo>(
                "FlowInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlowInfo {
        static instance: ::protobuf::rt::LazyV2<FlowInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlowInfo::new)
    }
}

impl ::protobuf::Clear for FlowInfo {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.density = ::std::option::Option::None;
        self.pos.clear();
        self.dest.clear();
        self.expanding = ::std::option::Option::None;
        self.reuse = ::std::option::Option::None;
        self.guide_id = ::std::option::Option::None;
        self.material.clear();
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Wave {
    // message fields
    pub dest: ::protobuf::SingularPtrField<Coord>,
    pub pos: ::protobuf::SingularPtrField<Coord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Wave {
    fn default() -> &'a Wave {
        <Wave as ::protobuf::Message>::default_instance()
    }
}

impl Wave {
    pub fn new() -> Wave {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.Coord dest = 1;


    pub fn get_dest(&self) -> &Coord {
        self.dest.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: Coord) {
        self.dest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut Coord {
        if self.dest.is_none() {
            self.dest.set_default();
        }
        self.dest.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest(&mut self) -> Coord {
        self.dest.take().unwrap_or_else(|| Coord::new())
    }

    // optional .RemoteFortressReader.Coord pos = 2;


    pub fn get_pos(&self) -> &Coord {
        self.pos.as_ref().unwrap_or_else(|| <Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Coord) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Coord {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Coord {
        self.pos.take().unwrap_or_else(|| Coord::new())
    }
}

impl ::protobuf::Message for Wave {
    fn is_initialized(&self) -> bool {
        for v in &self.dest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dest.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Wave {
        Wave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "dest",
                |m: &Wave| { &m.dest },
                |m: &mut Wave| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coord>>(
                "pos",
                |m: &Wave| { &m.pos },
                |m: &mut Wave| { &mut m.pos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Wave>(
                "Wave",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Wave {
        static instance: ::protobuf::rt::LazyV2<Wave> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Wave::new)
    }
}

impl ::protobuf::Clear for Wave {
    fn clear(&mut self) {
        self.dest.clear();
        self.pos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Wave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Wave {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TiletypeShape {
    NO_SHAPE = -1,
    EMPTY = 0,
    FLOOR = 1,
    BOULDER = 2,
    PEBBLES = 3,
    WALL = 4,
    FORTIFICATION = 5,
    STAIR_UP = 6,
    STAIR_DOWN = 7,
    STAIR_UPDOWN = 8,
    RAMP = 9,
    RAMP_TOP = 10,
    BROOK_BED = 11,
    BROOK_TOP = 12,
    TREE_SHAPE = 13,
    SAPLING = 14,
    SHRUB = 15,
    ENDLESS_PIT = 16,
    BRANCH = 17,
    TRUNK_BRANCH = 18,
    TWIG = 19,
}

impl ::protobuf::ProtobufEnum for TiletypeShape {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeShape> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeShape::NO_SHAPE),
            0 => ::std::option::Option::Some(TiletypeShape::EMPTY),
            1 => ::std::option::Option::Some(TiletypeShape::FLOOR),
            2 => ::std::option::Option::Some(TiletypeShape::BOULDER),
            3 => ::std::option::Option::Some(TiletypeShape::PEBBLES),
            4 => ::std::option::Option::Some(TiletypeShape::WALL),
            5 => ::std::option::Option::Some(TiletypeShape::FORTIFICATION),
            6 => ::std::option::Option::Some(TiletypeShape::STAIR_UP),
            7 => ::std::option::Option::Some(TiletypeShape::STAIR_DOWN),
            8 => ::std::option::Option::Some(TiletypeShape::STAIR_UPDOWN),
            9 => ::std::option::Option::Some(TiletypeShape::RAMP),
            10 => ::std::option::Option::Some(TiletypeShape::RAMP_TOP),
            11 => ::std::option::Option::Some(TiletypeShape::BROOK_BED),
            12 => ::std::option::Option::Some(TiletypeShape::BROOK_TOP),
            13 => ::std::option::Option::Some(TiletypeShape::TREE_SHAPE),
            14 => ::std::option::Option::Some(TiletypeShape::SAPLING),
            15 => ::std::option::Option::Some(TiletypeShape::SHRUB),
            16 => ::std::option::Option::Some(TiletypeShape::ENDLESS_PIT),
            17 => ::std::option::Option::Some(TiletypeShape::BRANCH),
            18 => ::std::option::Option::Some(TiletypeShape::TRUNK_BRANCH),
            19 => ::std::option::Option::Some(TiletypeShape::TWIG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TiletypeShape] = &[
            TiletypeShape::NO_SHAPE,
            TiletypeShape::EMPTY,
            TiletypeShape::FLOOR,
            TiletypeShape::BOULDER,
            TiletypeShape::PEBBLES,
            TiletypeShape::WALL,
            TiletypeShape::FORTIFICATION,
            TiletypeShape::STAIR_UP,
            TiletypeShape::STAIR_DOWN,
            TiletypeShape::STAIR_UPDOWN,
            TiletypeShape::RAMP,
            TiletypeShape::RAMP_TOP,
            TiletypeShape::BROOK_BED,
            TiletypeShape::BROOK_TOP,
            TiletypeShape::TREE_SHAPE,
            TiletypeShape::SAPLING,
            TiletypeShape::SHRUB,
            TiletypeShape::ENDLESS_PIT,
            TiletypeShape::BRANCH,
            TiletypeShape::TRUNK_BRANCH,
            TiletypeShape::TWIG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TiletypeShape>("TiletypeShape", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TiletypeShape {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeShape {
    fn default() -> Self {
        TiletypeShape::NO_SHAPE
    }
}

impl ::protobuf::reflect::ProtobufValue for TiletypeShape {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TiletypeSpecial {
    NO_SPECIAL = -1,
    NORMAL = 0,
    RIVER_SOURCE = 1,
    WATERFALL = 2,
    SMOOTH = 3,
    FURROWED = 4,
    WET = 5,
    DEAD = 6,
    WORN_1 = 7,
    WORN_2 = 8,
    WORN_3 = 9,
    TRACK = 10,
    SMOOTH_DEAD = 11,
}

impl ::protobuf::ProtobufEnum for TiletypeSpecial {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeSpecial> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeSpecial::NO_SPECIAL),
            0 => ::std::option::Option::Some(TiletypeSpecial::NORMAL),
            1 => ::std::option::Option::Some(TiletypeSpecial::RIVER_SOURCE),
            2 => ::std::option::Option::Some(TiletypeSpecial::WATERFALL),
            3 => ::std::option::Option::Some(TiletypeSpecial::SMOOTH),
            4 => ::std::option::Option::Some(TiletypeSpecial::FURROWED),
            5 => ::std::option::Option::Some(TiletypeSpecial::WET),
            6 => ::std::option::Option::Some(TiletypeSpecial::DEAD),
            7 => ::std::option::Option::Some(TiletypeSpecial::WORN_1),
            8 => ::std::option::Option::Some(TiletypeSpecial::WORN_2),
            9 => ::std::option::Option::Some(TiletypeSpecial::WORN_3),
            10 => ::std::option::Option::Some(TiletypeSpecial::TRACK),
            11 => ::std::option::Option::Some(TiletypeSpecial::SMOOTH_DEAD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TiletypeSpecial] = &[
            TiletypeSpecial::NO_SPECIAL,
            TiletypeSpecial::NORMAL,
            TiletypeSpecial::RIVER_SOURCE,
            TiletypeSpecial::WATERFALL,
            TiletypeSpecial::SMOOTH,
            TiletypeSpecial::FURROWED,
            TiletypeSpecial::WET,
            TiletypeSpecial::DEAD,
            TiletypeSpecial::WORN_1,
            TiletypeSpecial::WORN_2,
            TiletypeSpecial::WORN_3,
            TiletypeSpecial::TRACK,
            TiletypeSpecial::SMOOTH_DEAD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TiletypeSpecial>("TiletypeSpecial", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TiletypeSpecial {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeSpecial {
    fn default() -> Self {
        TiletypeSpecial::NO_SPECIAL
    }
}

impl ::protobuf::reflect::ProtobufValue for TiletypeSpecial {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TiletypeMaterial {
    NO_MATERIAL = -1,
    AIR = 0,
    SOIL = 1,
    STONE = 2,
    FEATURE = 3,
    LAVA_STONE = 4,
    MINERAL = 5,
    FROZEN_LIQUID = 6,
    CONSTRUCTION = 7,
    GRASS_LIGHT = 8,
    GRASS_DARK = 9,
    GRASS_DRY = 10,
    GRASS_DEAD = 11,
    PLANT = 12,
    HFS = 13,
    CAMPFIRE = 14,
    FIRE = 15,
    ASHES = 16,
    MAGMA = 17,
    DRIFTWOOD = 18,
    POOL = 19,
    BROOK = 20,
    RIVER = 21,
    ROOT = 22,
    TREE_MATERIAL = 23,
    MUSHROOM = 24,
    UNDERWORLD_GATE = 25,
}

impl ::protobuf::ProtobufEnum for TiletypeMaterial {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeMaterial> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeMaterial::NO_MATERIAL),
            0 => ::std::option::Option::Some(TiletypeMaterial::AIR),
            1 => ::std::option::Option::Some(TiletypeMaterial::SOIL),
            2 => ::std::option::Option::Some(TiletypeMaterial::STONE),
            3 => ::std::option::Option::Some(TiletypeMaterial::FEATURE),
            4 => ::std::option::Option::Some(TiletypeMaterial::LAVA_STONE),
            5 => ::std::option::Option::Some(TiletypeMaterial::MINERAL),
            6 => ::std::option::Option::Some(TiletypeMaterial::FROZEN_LIQUID),
            7 => ::std::option::Option::Some(TiletypeMaterial::CONSTRUCTION),
            8 => ::std::option::Option::Some(TiletypeMaterial::GRASS_LIGHT),
            9 => ::std::option::Option::Some(TiletypeMaterial::GRASS_DARK),
            10 => ::std::option::Option::Some(TiletypeMaterial::GRASS_DRY),
            11 => ::std::option::Option::Some(TiletypeMaterial::GRASS_DEAD),
            12 => ::std::option::Option::Some(TiletypeMaterial::PLANT),
            13 => ::std::option::Option::Some(TiletypeMaterial::HFS),
            14 => ::std::option::Option::Some(TiletypeMaterial::CAMPFIRE),
            15 => ::std::option::Option::Some(TiletypeMaterial::FIRE),
            16 => ::std::option::Option::Some(TiletypeMaterial::ASHES),
            17 => ::std::option::Option::Some(TiletypeMaterial::MAGMA),
            18 => ::std::option::Option::Some(TiletypeMaterial::DRIFTWOOD),
            19 => ::std::option::Option::Some(TiletypeMaterial::POOL),
            20 => ::std::option::Option::Some(TiletypeMaterial::BROOK),
            21 => ::std::option::Option::Some(TiletypeMaterial::RIVER),
            22 => ::std::option::Option::Some(TiletypeMaterial::ROOT),
            23 => ::std::option::Option::Some(TiletypeMaterial::TREE_MATERIAL),
            24 => ::std::option::Option::Some(TiletypeMaterial::MUSHROOM),
            25 => ::std::option::Option::Some(TiletypeMaterial::UNDERWORLD_GATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TiletypeMaterial] = &[
            TiletypeMaterial::NO_MATERIAL,
            TiletypeMaterial::AIR,
            TiletypeMaterial::SOIL,
            TiletypeMaterial::STONE,
            TiletypeMaterial::FEATURE,
            TiletypeMaterial::LAVA_STONE,
            TiletypeMaterial::MINERAL,
            TiletypeMaterial::FROZEN_LIQUID,
            TiletypeMaterial::CONSTRUCTION,
            TiletypeMaterial::GRASS_LIGHT,
            TiletypeMaterial::GRASS_DARK,
            TiletypeMaterial::GRASS_DRY,
            TiletypeMaterial::GRASS_DEAD,
            TiletypeMaterial::PLANT,
            TiletypeMaterial::HFS,
            TiletypeMaterial::CAMPFIRE,
            TiletypeMaterial::FIRE,
            TiletypeMaterial::ASHES,
            TiletypeMaterial::MAGMA,
            TiletypeMaterial::DRIFTWOOD,
            TiletypeMaterial::POOL,
            TiletypeMaterial::BROOK,
            TiletypeMaterial::RIVER,
            TiletypeMaterial::ROOT,
            TiletypeMaterial::TREE_MATERIAL,
            TiletypeMaterial::MUSHROOM,
            TiletypeMaterial::UNDERWORLD_GATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TiletypeMaterial>("TiletypeMaterial", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TiletypeMaterial {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeMaterial {
    fn default() -> Self {
        TiletypeMaterial::NO_MATERIAL
    }
}

impl ::protobuf::reflect::ProtobufValue for TiletypeMaterial {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TiletypeVariant {
    NO_VARIANT = -1,
    VAR_1 = 0,
    VAR_2 = 1,
    VAR_3 = 2,
    VAR_4 = 3,
}

impl ::protobuf::ProtobufEnum for TiletypeVariant {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeVariant> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeVariant::NO_VARIANT),
            0 => ::std::option::Option::Some(TiletypeVariant::VAR_1),
            1 => ::std::option::Option::Some(TiletypeVariant::VAR_2),
            2 => ::std::option::Option::Some(TiletypeVariant::VAR_3),
            3 => ::std::option::Option::Some(TiletypeVariant::VAR_4),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TiletypeVariant] = &[
            TiletypeVariant::NO_VARIANT,
            TiletypeVariant::VAR_1,
            TiletypeVariant::VAR_2,
            TiletypeVariant::VAR_3,
            TiletypeVariant::VAR_4,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TiletypeVariant>("TiletypeVariant", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TiletypeVariant {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeVariant {
    fn default() -> Self {
        TiletypeVariant::NO_VARIANT
    }
}

impl ::protobuf::reflect::ProtobufValue for TiletypeVariant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorldPoles {
    NO_POLES = 0,
    NORTH_POLE = 1,
    SOUTH_POLE = 2,
    BOTH_POLES = 3,
}

impl ::protobuf::ProtobufEnum for WorldPoles {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorldPoles> {
        match value {
            0 => ::std::option::Option::Some(WorldPoles::NO_POLES),
            1 => ::std::option::Option::Some(WorldPoles::NORTH_POLE),
            2 => ::std::option::Option::Some(WorldPoles::SOUTH_POLE),
            3 => ::std::option::Option::Some(WorldPoles::BOTH_POLES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorldPoles] = &[
            WorldPoles::NO_POLES,
            WorldPoles::NORTH_POLE,
            WorldPoles::SOUTH_POLE,
            WorldPoles::BOTH_POLES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WorldPoles>("WorldPoles", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WorldPoles {
}

impl ::std::default::Default for WorldPoles {
    fn default() -> Self {
        WorldPoles::NO_POLES
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldPoles {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuildingDirection {
    NORTH = 0,
    EAST = 1,
    SOUTH = 2,
    WEST = 3,
    NONE = 4,
}

impl ::protobuf::ProtobufEnum for BuildingDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuildingDirection> {
        match value {
            0 => ::std::option::Option::Some(BuildingDirection::NORTH),
            1 => ::std::option::Option::Some(BuildingDirection::EAST),
            2 => ::std::option::Option::Some(BuildingDirection::SOUTH),
            3 => ::std::option::Option::Some(BuildingDirection::WEST),
            4 => ::std::option::Option::Some(BuildingDirection::NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuildingDirection] = &[
            BuildingDirection::NORTH,
            BuildingDirection::EAST,
            BuildingDirection::SOUTH,
            BuildingDirection::WEST,
            BuildingDirection::NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BuildingDirection>("BuildingDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BuildingDirection {
}

impl ::std::default::Default for BuildingDirection {
    fn default() -> Self {
        BuildingDirection::NORTH
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TileDigDesignation {
    NO_DIG = 0,
    DEFAULT_DIG = 1,
    UP_DOWN_STAIR_DIG = 2,
    CHANNEL_DIG = 3,
    RAMP_DIG = 4,
    DOWN_STAIR_DIG = 5,
    UP_STAIR_DIG = 6,
}

impl ::protobuf::ProtobufEnum for TileDigDesignation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TileDigDesignation> {
        match value {
            0 => ::std::option::Option::Some(TileDigDesignation::NO_DIG),
            1 => ::std::option::Option::Some(TileDigDesignation::DEFAULT_DIG),
            2 => ::std::option::Option::Some(TileDigDesignation::UP_DOWN_STAIR_DIG),
            3 => ::std::option::Option::Some(TileDigDesignation::CHANNEL_DIG),
            4 => ::std::option::Option::Some(TileDigDesignation::RAMP_DIG),
            5 => ::std::option::Option::Some(TileDigDesignation::DOWN_STAIR_DIG),
            6 => ::std::option::Option::Some(TileDigDesignation::UP_STAIR_DIG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TileDigDesignation] = &[
            TileDigDesignation::NO_DIG,
            TileDigDesignation::DEFAULT_DIG,
            TileDigDesignation::UP_DOWN_STAIR_DIG,
            TileDigDesignation::CHANNEL_DIG,
            TileDigDesignation::RAMP_DIG,
            TileDigDesignation::DOWN_STAIR_DIG,
            TileDigDesignation::UP_STAIR_DIG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TileDigDesignation>("TileDigDesignation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TileDigDesignation {
}

impl ::std::default::Default for TileDigDesignation {
    fn default() -> Self {
        TileDigDesignation::NO_DIG
    }
}

impl ::protobuf::reflect::ProtobufValue for TileDigDesignation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HairStyle {
    UNKEMPT = -1,
    NEATLY_COMBED = 0,
    BRAIDED = 1,
    DOUBLE_BRAID = 2,
    PONY_TAILS = 3,
    CLEAN_SHAVEN = 4,
}

impl ::protobuf::ProtobufEnum for HairStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HairStyle> {
        match value {
            -1 => ::std::option::Option::Some(HairStyle::UNKEMPT),
            0 => ::std::option::Option::Some(HairStyle::NEATLY_COMBED),
            1 => ::std::option::Option::Some(HairStyle::BRAIDED),
            2 => ::std::option::Option::Some(HairStyle::DOUBLE_BRAID),
            3 => ::std::option::Option::Some(HairStyle::PONY_TAILS),
            4 => ::std::option::Option::Some(HairStyle::CLEAN_SHAVEN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HairStyle] = &[
            HairStyle::UNKEMPT,
            HairStyle::NEATLY_COMBED,
            HairStyle::BRAIDED,
            HairStyle::DOUBLE_BRAID,
            HairStyle::PONY_TAILS,
            HairStyle::CLEAN_SHAVEN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HairStyle>("HairStyle", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HairStyle {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HairStyle {
    fn default() -> Self {
        HairStyle::UNKEMPT
    }
}

impl ::protobuf::reflect::ProtobufValue for HairStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InventoryMode {
    Hauled = 0,
    Weapon = 1,
    Worn = 2,
    Piercing = 3,
    Flask = 4,
    WrappedAround = 5,
    StuckIn = 6,
    InMouth = 7,
    Pet = 8,
    SewnInto = 9,
    Strapped = 10,
}

impl ::protobuf::ProtobufEnum for InventoryMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InventoryMode> {
        match value {
            0 => ::std::option::Option::Some(InventoryMode::Hauled),
            1 => ::std::option::Option::Some(InventoryMode::Weapon),
            2 => ::std::option::Option::Some(InventoryMode::Worn),
            3 => ::std::option::Option::Some(InventoryMode::Piercing),
            4 => ::std::option::Option::Some(InventoryMode::Flask),
            5 => ::std::option::Option::Some(InventoryMode::WrappedAround),
            6 => ::std::option::Option::Some(InventoryMode::StuckIn),
            7 => ::std::option::Option::Some(InventoryMode::InMouth),
            8 => ::std::option::Option::Some(InventoryMode::Pet),
            9 => ::std::option::Option::Some(InventoryMode::SewnInto),
            10 => ::std::option::Option::Some(InventoryMode::Strapped),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InventoryMode] = &[
            InventoryMode::Hauled,
            InventoryMode::Weapon,
            InventoryMode::Worn,
            InventoryMode::Piercing,
            InventoryMode::Flask,
            InventoryMode::WrappedAround,
            InventoryMode::StuckIn,
            InventoryMode::InMouth,
            InventoryMode::Pet,
            InventoryMode::SewnInto,
            InventoryMode::Strapped,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<InventoryMode>("InventoryMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for InventoryMode {
}

impl ::std::default::Default for InventoryMode {
    fn default() -> Self {
        InventoryMode::Hauled
    }
}

impl ::protobuf::reflect::ProtobufValue for InventoryMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArmorLayer {
    LAYER_UNDER = 0,
    LAYER_OVER = 1,
    LAYER_ARMOR = 2,
    LAYER_COVER = 3,
}

impl ::protobuf::ProtobufEnum for ArmorLayer {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArmorLayer> {
        match value {
            0 => ::std::option::Option::Some(ArmorLayer::LAYER_UNDER),
            1 => ::std::option::Option::Some(ArmorLayer::LAYER_OVER),
            2 => ::std::option::Option::Some(ArmorLayer::LAYER_ARMOR),
            3 => ::std::option::Option::Some(ArmorLayer::LAYER_COVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArmorLayer] = &[
            ArmorLayer::LAYER_UNDER,
            ArmorLayer::LAYER_OVER,
            ArmorLayer::LAYER_ARMOR,
            ArmorLayer::LAYER_COVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ArmorLayer>("ArmorLayer", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ArmorLayer {
}

impl ::std::default::Default for ArmorLayer {
    fn default() -> Self {
        ArmorLayer::LAYER_UNDER
    }
}

impl ::protobuf::reflect::ProtobufValue for ArmorLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MatterState {
    Solid = 0,
    Liquid = 1,
    Gas = 2,
    Powder = 3,
    Paste = 4,
    Pressed = 5,
}

impl ::protobuf::ProtobufEnum for MatterState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatterState> {
        match value {
            0 => ::std::option::Option::Some(MatterState::Solid),
            1 => ::std::option::Option::Some(MatterState::Liquid),
            2 => ::std::option::Option::Some(MatterState::Gas),
            3 => ::std::option::Option::Some(MatterState::Powder),
            4 => ::std::option::Option::Some(MatterState::Paste),
            5 => ::std::option::Option::Some(MatterState::Pressed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MatterState] = &[
            MatterState::Solid,
            MatterState::Liquid,
            MatterState::Gas,
            MatterState::Powder,
            MatterState::Paste,
            MatterState::Pressed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MatterState>("MatterState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MatterState {
}

impl ::std::default::Default for MatterState {
    fn default() -> Self {
        MatterState::Solid
    }
}

impl ::protobuf::reflect::ProtobufValue for MatterState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FrontType {
    FRONT_NONE = 0,
    FRONT_WARM = 1,
    FRONT_COLD = 2,
    FRONT_OCCLUDED = 3,
}

impl ::protobuf::ProtobufEnum for FrontType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FrontType> {
        match value {
            0 => ::std::option::Option::Some(FrontType::FRONT_NONE),
            1 => ::std::option::Option::Some(FrontType::FRONT_WARM),
            2 => ::std::option::Option::Some(FrontType::FRONT_COLD),
            3 => ::std::option::Option::Some(FrontType::FRONT_OCCLUDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FrontType] = &[
            FrontType::FRONT_NONE,
            FrontType::FRONT_WARM,
            FrontType::FRONT_COLD,
            FrontType::FRONT_OCCLUDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FrontType>("FrontType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FrontType {
}

impl ::std::default::Default for FrontType {
    fn default() -> Self {
        FrontType::FRONT_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for FrontType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CumulusType {
    CUMULUS_NONE = 0,
    CUMULUS_MEDIUM = 1,
    CUMULUS_MULTI = 2,
    CUMULUS_NIMBUS = 3,
}

impl ::protobuf::ProtobufEnum for CumulusType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CumulusType> {
        match value {
            0 => ::std::option::Option::Some(CumulusType::CUMULUS_NONE),
            1 => ::std::option::Option::Some(CumulusType::CUMULUS_MEDIUM),
            2 => ::std::option::Option::Some(CumulusType::CUMULUS_MULTI),
            3 => ::std::option::Option::Some(CumulusType::CUMULUS_NIMBUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CumulusType] = &[
            CumulusType::CUMULUS_NONE,
            CumulusType::CUMULUS_MEDIUM,
            CumulusType::CUMULUS_MULTI,
            CumulusType::CUMULUS_NIMBUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CumulusType>("CumulusType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CumulusType {
}

impl ::std::default::Default for CumulusType {
    fn default() -> Self {
        CumulusType::CUMULUS_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CumulusType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StratusType {
    STRATUS_NONE = 0,
    STRATUS_ALTO = 1,
    STRATUS_PROPER = 2,
    STRATUS_NIMBUS = 3,
}

impl ::protobuf::ProtobufEnum for StratusType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StratusType> {
        match value {
            0 => ::std::option::Option::Some(StratusType::STRATUS_NONE),
            1 => ::std::option::Option::Some(StratusType::STRATUS_ALTO),
            2 => ::std::option::Option::Some(StratusType::STRATUS_PROPER),
            3 => ::std::option::Option::Some(StratusType::STRATUS_NIMBUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StratusType] = &[
            StratusType::STRATUS_NONE,
            StratusType::STRATUS_ALTO,
            StratusType::STRATUS_PROPER,
            StratusType::STRATUS_NIMBUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StratusType>("StratusType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StratusType {
}

impl ::std::default::Default for StratusType {
    fn default() -> Self {
        StratusType::STRATUS_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for StratusType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FogType {
    FOG_NONE = 0,
    FOG_MIST = 1,
    FOG_NORMAL = 2,
    F0G_THICK = 3,
}

impl ::protobuf::ProtobufEnum for FogType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FogType> {
        match value {
            0 => ::std::option::Option::Some(FogType::FOG_NONE),
            1 => ::std::option::Option::Some(FogType::FOG_MIST),
            2 => ::std::option::Option::Some(FogType::FOG_NORMAL),
            3 => ::std::option::Option::Some(FogType::F0G_THICK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FogType] = &[
            FogType::FOG_NONE,
            FogType::FOG_MIST,
            FogType::FOG_NORMAL,
            FogType::F0G_THICK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FogType>("FogType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FogType {
}

impl ::std::default::Default for FogType {
    fn default() -> Self {
        FogType::FOG_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for FogType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PatternType {
    MONOTONE = 0,
    STRIPES = 1,
    IRIS_EYE = 2,
    SPOTS = 3,
    PUPIL_EYE = 4,
    MOTTLED = 5,
}

impl ::protobuf::ProtobufEnum for PatternType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatternType> {
        match value {
            0 => ::std::option::Option::Some(PatternType::MONOTONE),
            1 => ::std::option::Option::Some(PatternType::STRIPES),
            2 => ::std::option::Option::Some(PatternType::IRIS_EYE),
            3 => ::std::option::Option::Some(PatternType::SPOTS),
            4 => ::std::option::Option::Some(PatternType::PUPIL_EYE),
            5 => ::std::option::Option::Some(PatternType::MOTTLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatternType] = &[
            PatternType::MONOTONE,
            PatternType::STRIPES,
            PatternType::IRIS_EYE,
            PatternType::SPOTS,
            PatternType::PUPIL_EYE,
            PatternType::MOTTLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatternType>("PatternType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatternType {
}

impl ::std::default::Default for PatternType {
    fn default() -> Self {
        PatternType::MONOTONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PatternType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArtImageElementType {
    IMAGE_CREATURE = 0,
    IMAGE_PLANT = 1,
    IMAGE_TREE = 2,
    IMAGE_SHAPE = 3,
    IMAGE_ITEM = 4,
}

impl ::protobuf::ProtobufEnum for ArtImageElementType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtImageElementType> {
        match value {
            0 => ::std::option::Option::Some(ArtImageElementType::IMAGE_CREATURE),
            1 => ::std::option::Option::Some(ArtImageElementType::IMAGE_PLANT),
            2 => ::std::option::Option::Some(ArtImageElementType::IMAGE_TREE),
            3 => ::std::option::Option::Some(ArtImageElementType::IMAGE_SHAPE),
            4 => ::std::option::Option::Some(ArtImageElementType::IMAGE_ITEM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArtImageElementType] = &[
            ArtImageElementType::IMAGE_CREATURE,
            ArtImageElementType::IMAGE_PLANT,
            ArtImageElementType::IMAGE_TREE,
            ArtImageElementType::IMAGE_SHAPE,
            ArtImageElementType::IMAGE_ITEM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ArtImageElementType>("ArtImageElementType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ArtImageElementType {
}

impl ::std::default::Default for ArtImageElementType {
    fn default() -> Self {
        ArtImageElementType::IMAGE_CREATURE
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImageElementType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArtImagePropertyType {
    TRANSITIVE_VERB = 0,
    INTRANSITIVE_VERB = 1,
}

impl ::protobuf::ProtobufEnum for ArtImagePropertyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtImagePropertyType> {
        match value {
            0 => ::std::option::Option::Some(ArtImagePropertyType::TRANSITIVE_VERB),
            1 => ::std::option::Option::Some(ArtImagePropertyType::INTRANSITIVE_VERB),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArtImagePropertyType] = &[
            ArtImagePropertyType::TRANSITIVE_VERB,
            ArtImagePropertyType::INTRANSITIVE_VERB,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ArtImagePropertyType>("ArtImagePropertyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ArtImagePropertyType {
}

impl ::std::default::Default for ArtImagePropertyType {
    fn default() -> Self {
        ArtImagePropertyType::TRANSITIVE_VERB
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImagePropertyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArtImageVerb {
    VERB_WITHERING = 0,
    VERB_SURROUNDEDBY = 1,
    VERB_MASSACRING = 2,
    VERB_FIGHTING = 3,
    VERB_LABORING = 4,
    VERB_GREETING = 5,
    VERB_REFUSING = 6,
    VERB_SPEAKING = 7,
    VERB_EMBRACING = 8,
    VERB_STRIKINGDOWN = 9,
    VERB_MENACINGPOSE = 10,
    VERB_TRAVELING = 11,
    VERB_RAISING = 12,
    VERB_HIDING = 13,
    VERB_LOOKINGCONFUSED = 14,
    VERB_LOOKINGTERRIFIED = 15,
    VERB_DEVOURING = 16,
    VERB_ADMIRING = 17,
    VERB_BURNING = 18,
    VERB_WEEPING = 19,
    VERB_LOOKINGDEJECTED = 20,
    VERB_CRINGING = 21,
    VERB_SCREAMING = 22,
    VERB_SUBMISSIVEGESTURE = 23,
    VERB_FETALPOSITION = 24,
    VERB_SMEAREDINTOSPIRAL = 25,
    VERB_FALLING = 26,
    VERB_DEAD = 27,
    VERB_LAUGHING = 28,
    VERB_LOOKINGOFFENDED = 29,
    VERB_BEINGSHOT = 30,
    VERB_PLAINTIVEGESTURE = 31,
    VERB_MELTING = 32,
    VERB_SHOOTING = 33,
    VERB_TORTURING = 34,
    VERB_COMMITTINGDEPRAVEDACT = 35,
    VERB_PRAYING = 36,
    VERB_CONTEMPLATING = 37,
    VERB_COOKING = 38,
    VERB_ENGRAVING = 39,
    VERB_PROSTRATING = 40,
    VERB_SUFFERING = 41,
    VERB_BEINGIMPALED = 42,
    VERB_BEINGCONTORTED = 43,
    VERB_BEINGFLAYED = 44,
    VERB_HANGINGFROM = 45,
    VERB_BEINGMUTILATED = 46,
    VERB_TRIUMPHANTPOSE = 47,
}

impl ::protobuf::ProtobufEnum for ArtImageVerb {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtImageVerb> {
        match value {
            0 => ::std::option::Option::Some(ArtImageVerb::VERB_WITHERING),
            1 => ::std::option::Option::Some(ArtImageVerb::VERB_SURROUNDEDBY),
            2 => ::std::option::Option::Some(ArtImageVerb::VERB_MASSACRING),
            3 => ::std::option::Option::Some(ArtImageVerb::VERB_FIGHTING),
            4 => ::std::option::Option::Some(ArtImageVerb::VERB_LABORING),
            5 => ::std::option::Option::Some(ArtImageVerb::VERB_GREETING),
            6 => ::std::option::Option::Some(ArtImageVerb::VERB_REFUSING),
            7 => ::std::option::Option::Some(ArtImageVerb::VERB_SPEAKING),
            8 => ::std::option::Option::Some(ArtImageVerb::VERB_EMBRACING),
            9 => ::std::option::Option::Some(ArtImageVerb::VERB_STRIKINGDOWN),
            10 => ::std::option::Option::Some(ArtImageVerb::VERB_MENACINGPOSE),
            11 => ::std::option::Option::Some(ArtImageVerb::VERB_TRAVELING),
            12 => ::std::option::Option::Some(ArtImageVerb::VERB_RAISING),
            13 => ::std::option::Option::Some(ArtImageVerb::VERB_HIDING),
            14 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGCONFUSED),
            15 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGTERRIFIED),
            16 => ::std::option::Option::Some(ArtImageVerb::VERB_DEVOURING),
            17 => ::std::option::Option::Some(ArtImageVerb::VERB_ADMIRING),
            18 => ::std::option::Option::Some(ArtImageVerb::VERB_BURNING),
            19 => ::std::option::Option::Some(ArtImageVerb::VERB_WEEPING),
            20 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGDEJECTED),
            21 => ::std::option::Option::Some(ArtImageVerb::VERB_CRINGING),
            22 => ::std::option::Option::Some(ArtImageVerb::VERB_SCREAMING),
            23 => ::std::option::Option::Some(ArtImageVerb::VERB_SUBMISSIVEGESTURE),
            24 => ::std::option::Option::Some(ArtImageVerb::VERB_FETALPOSITION),
            25 => ::std::option::Option::Some(ArtImageVerb::VERB_SMEAREDINTOSPIRAL),
            26 => ::std::option::Option::Some(ArtImageVerb::VERB_FALLING),
            27 => ::std::option::Option::Some(ArtImageVerb::VERB_DEAD),
            28 => ::std::option::Option::Some(ArtImageVerb::VERB_LAUGHING),
            29 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGOFFENDED),
            30 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGSHOT),
            31 => ::std::option::Option::Some(ArtImageVerb::VERB_PLAINTIVEGESTURE),
            32 => ::std::option::Option::Some(ArtImageVerb::VERB_MELTING),
            33 => ::std::option::Option::Some(ArtImageVerb::VERB_SHOOTING),
            34 => ::std::option::Option::Some(ArtImageVerb::VERB_TORTURING),
            35 => ::std::option::Option::Some(ArtImageVerb::VERB_COMMITTINGDEPRAVEDACT),
            36 => ::std::option::Option::Some(ArtImageVerb::VERB_PRAYING),
            37 => ::std::option::Option::Some(ArtImageVerb::VERB_CONTEMPLATING),
            38 => ::std::option::Option::Some(ArtImageVerb::VERB_COOKING),
            39 => ::std::option::Option::Some(ArtImageVerb::VERB_ENGRAVING),
            40 => ::std::option::Option::Some(ArtImageVerb::VERB_PROSTRATING),
            41 => ::std::option::Option::Some(ArtImageVerb::VERB_SUFFERING),
            42 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGIMPALED),
            43 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGCONTORTED),
            44 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGFLAYED),
            45 => ::std::option::Option::Some(ArtImageVerb::VERB_HANGINGFROM),
            46 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGMUTILATED),
            47 => ::std::option::Option::Some(ArtImageVerb::VERB_TRIUMPHANTPOSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArtImageVerb] = &[
            ArtImageVerb::VERB_WITHERING,
            ArtImageVerb::VERB_SURROUNDEDBY,
            ArtImageVerb::VERB_MASSACRING,
            ArtImageVerb::VERB_FIGHTING,
            ArtImageVerb::VERB_LABORING,
            ArtImageVerb::VERB_GREETING,
            ArtImageVerb::VERB_REFUSING,
            ArtImageVerb::VERB_SPEAKING,
            ArtImageVerb::VERB_EMBRACING,
            ArtImageVerb::VERB_STRIKINGDOWN,
            ArtImageVerb::VERB_MENACINGPOSE,
            ArtImageVerb::VERB_TRAVELING,
            ArtImageVerb::VERB_RAISING,
            ArtImageVerb::VERB_HIDING,
            ArtImageVerb::VERB_LOOKINGCONFUSED,
            ArtImageVerb::VERB_LOOKINGTERRIFIED,
            ArtImageVerb::VERB_DEVOURING,
            ArtImageVerb::VERB_ADMIRING,
            ArtImageVerb::VERB_BURNING,
            ArtImageVerb::VERB_WEEPING,
            ArtImageVerb::VERB_LOOKINGDEJECTED,
            ArtImageVerb::VERB_CRINGING,
            ArtImageVerb::VERB_SCREAMING,
            ArtImageVerb::VERB_SUBMISSIVEGESTURE,
            ArtImageVerb::VERB_FETALPOSITION,
            ArtImageVerb::VERB_SMEAREDINTOSPIRAL,
            ArtImageVerb::VERB_FALLING,
            ArtImageVerb::VERB_DEAD,
            ArtImageVerb::VERB_LAUGHING,
            ArtImageVerb::VERB_LOOKINGOFFENDED,
            ArtImageVerb::VERB_BEINGSHOT,
            ArtImageVerb::VERB_PLAINTIVEGESTURE,
            ArtImageVerb::VERB_MELTING,
            ArtImageVerb::VERB_SHOOTING,
            ArtImageVerb::VERB_TORTURING,
            ArtImageVerb::VERB_COMMITTINGDEPRAVEDACT,
            ArtImageVerb::VERB_PRAYING,
            ArtImageVerb::VERB_CONTEMPLATING,
            ArtImageVerb::VERB_COOKING,
            ArtImageVerb::VERB_ENGRAVING,
            ArtImageVerb::VERB_PROSTRATING,
            ArtImageVerb::VERB_SUFFERING,
            ArtImageVerb::VERB_BEINGIMPALED,
            ArtImageVerb::VERB_BEINGCONTORTED,
            ArtImageVerb::VERB_BEINGFLAYED,
            ArtImageVerb::VERB_HANGINGFROM,
            ArtImageVerb::VERB_BEINGMUTILATED,
            ArtImageVerb::VERB_TRIUMPHANTPOSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ArtImageVerb>("ArtImageVerb", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ArtImageVerb {
}

impl ::std::default::Default for ArtImageVerb {
    fn default() -> Self {
        ArtImageVerb::VERB_WITHERING
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImageVerb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowType {
    Miasma = 0,
    Steam = 1,
    Mist = 2,
    MaterialDust = 3,
    MagmaMist = 4,
    Smoke = 5,
    Dragonfire = 6,
    Fire = 7,
    Web = 8,
    MaterialGas = 9,
    MaterialVapor = 10,
    OceanWave = 11,
    SeaFoam = 12,
    ItemCloud = 13,
    CampFire = -1,
}

impl ::protobuf::ProtobufEnum for FlowType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowType> {
        match value {
            0 => ::std::option::Option::Some(FlowType::Miasma),
            1 => ::std::option::Option::Some(FlowType::Steam),
            2 => ::std::option::Option::Some(FlowType::Mist),
            3 => ::std::option::Option::Some(FlowType::MaterialDust),
            4 => ::std::option::Option::Some(FlowType::MagmaMist),
            5 => ::std::option::Option::Some(FlowType::Smoke),
            6 => ::std::option::Option::Some(FlowType::Dragonfire),
            7 => ::std::option::Option::Some(FlowType::Fire),
            8 => ::std::option::Option::Some(FlowType::Web),
            9 => ::std::option::Option::Some(FlowType::MaterialGas),
            10 => ::std::option::Option::Some(FlowType::MaterialVapor),
            11 => ::std::option::Option::Some(FlowType::OceanWave),
            12 => ::std::option::Option::Some(FlowType::SeaFoam),
            13 => ::std::option::Option::Some(FlowType::ItemCloud),
            -1 => ::std::option::Option::Some(FlowType::CampFire),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowType] = &[
            FlowType::Miasma,
            FlowType::Steam,
            FlowType::Mist,
            FlowType::MaterialDust,
            FlowType::MagmaMist,
            FlowType::Smoke,
            FlowType::Dragonfire,
            FlowType::Fire,
            FlowType::Web,
            FlowType::MaterialGas,
            FlowType::MaterialVapor,
            FlowType::OceanWave,
            FlowType::SeaFoam,
            FlowType::ItemCloud,
            FlowType::CampFire,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FlowType>("FlowType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FlowType {
}

impl ::std::default::Default for FlowType {
    fn default() -> Self {
        FlowType::Miasma
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1aRemoteFortressReader.proto\x12\x14RemoteFortressReader\x1a\x17Item\
    defInstrument.proto\"9\n\x05Coord\x12\x0e\n\x01x\x18\x01\x20\x01(\x05R\
    \x01xB\0\x12\x0e\n\x01y\x18\x02\x20\x01(\x05R\x01yB\0\x12\x0e\n\x01z\x18\
    \x03\x20\x01(\x05R\x01zB\0:\0\"\xf9\x02\n\x08Tiletype\x12\x10\n\x02id\
    \x18\x01\x20\x02(\x05R\x02idB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\
    \x04nameB\0\x12\x1a\n\x07caption\x18\x03\x20\x01(\tR\x07captionB\0\x12;\
    \n\x05shape\x18\x04\x20\x01(\x0e2#.RemoteFortressReader.TiletypeShapeR\
    \x05shapeB\0\x12A\n\x07special\x18\x05\x20\x01(\x0e2%.RemoteFortressRead\
    er.TiletypeSpecialR\x07specialB\0\x12D\n\x08material\x18\x06\x20\x01(\
    \x0e2&.RemoteFortressReader.TiletypeMaterialR\x08materialB\0\x12A\n\x07v\
    ariant\x18\x07\x20\x01(\x0e2%.RemoteFortressReader.TiletypeVariantR\x07v\
    ariantB\0\x12\x1e\n\tdirection\x18\x08\x20\x01(\tR\tdirectionB\0:\0\"W\n\
    \x0cTiletypeList\x12E\n\rtiletype_list\x18\x01\x20\x03(\x0b2\x1e.RemoteF\
    ortressReader.TiletypeR\x0ctiletypeListB\0:\0\"\x8f\x01\n\x0fBuildingExt\
    ents\x12\x15\n\x05pos_x\x18\x01\x20\x02(\x05R\x04posXB\0\x12\x15\n\x05po\
    s_y\x18\x02\x20\x02(\x05R\x04posYB\0\x12\x16\n\x05width\x18\x03\x20\x02(\
    \x05R\x05widthB\0\x12\x18\n\x06height\x18\x04\x20\x02(\x05R\x06heightB\0\
    \x12\x1a\n\x07extents\x18\x05\x20\x03(\x05R\x07extentsB\0:\0\"X\n\x0cBui\
    ldingItem\x120\n\x04item\x18\x01\x20\x01(\x0b2\x1a.RemoteFortressReader.\
    ItemR\x04itemB\0\x12\x14\n\x04mode\x18\x02\x20\x01(\x05R\x04modeB\0:\0\"\
    \x88\x05\n\x10BuildingInstance\x12\x16\n\x05index\x18\x01\x20\x02(\x05R\
    \x05indexB\0\x12\x1c\n\tpos_x_min\x18\x02\x20\x01(\x05R\x07posXMinB\0\
    \x12\x1c\n\tpos_y_min\x18\x03\x20\x01(\x05R\x07posYMinB\0\x12\x1c\n\tpos\
    _z_min\x18\x04\x20\x01(\x05R\x07posZMinB\0\x12\x1c\n\tpos_x_max\x18\x05\
    \x20\x01(\x05R\x07posXMaxB\0\x12\x1c\n\tpos_y_max\x18\x06\x20\x01(\x05R\
    \x07posYMaxB\0\x12\x1c\n\tpos_z_max\x18\x07\x20\x01(\x05R\x07posZMaxB\0\
    \x12I\n\rbuilding_type\x18\x08\x20\x01(\x0b2\".RemoteFortressReader.Buil\
    dingTypeR\x0cbuildingTypeB\0\x12;\n\x08material\x18\t\x20\x01(\x0b2\x1d.\
    RemoteFortressReader.MatPairR\x08materialB\0\x12'\n\x0ebuilding_flags\
    \x18\n\x20\x01(\rR\rbuildingFlagsB\0\x12\x19\n\x07is_room\x18\x0b\x20\
    \x01(\x08R\x06isRoomB\0\x12;\n\x04room\x18\x0c\x20\x01(\x0b2%.RemoteFort\
    ressReader.BuildingExtentsR\x04roomB\0\x12G\n\tdirection\x18\r\x20\x01(\
    \x0e2'.RemoteFortressReader.BuildingDirectionR\tdirectionB\0\x12:\n\x05i\
    tems\x18\x0e\x20\x03(\x0b2\".RemoteFortressReader.BuildingItemR\x05items\
    B\0\x12\x18\n\x06active\x18\x0f\x20\x01(\x05R\x06activeB\0:\0\"}\n\tRive\
    rEdge\x12\x19\n\x07min_pos\x18\x01\x20\x01(\x05R\x06minPosB\0\x12\x19\n\
    \x07max_pos\x18\x02\x20\x01(\x05R\x06maxPosB\0\x12\x18\n\x06active\x18\
    \x03\x20\x01(\x05R\x06activeB\0\x12\x1e\n\televation\x18\x04\x20\x01(\
    \x05R\televationB\0:\0\"\xed\x01\n\tRiverTile\x127\n\x05north\x18\x01\
    \x20\x01(\x0b2\x1f.RemoteFortressReader.RiverEdgeR\x05northB\0\x127\n\
    \x05south\x18\x02\x20\x01(\x0b2\x1f.RemoteFortressReader.RiverEdgeR\x05s\
    outhB\0\x125\n\x04east\x18\x03\x20\x01(\x0b2\x1f.RemoteFortressReader.Ri\
    verEdgeR\x04eastB\0\x125\n\x04west\x18\x04\x20\x01(\x0b2\x1f.RemoteFortr\
    essReader.RiverEdgeR\x04westB\0:\0\"\xd2\x01\n\x07Spatter\x12;\n\x08mate\
    rial\x18\x01\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08material\
    B\0\x12\x18\n\x06amount\x18\x02\x20\x01(\x05R\x06amountB\0\x129\n\x05sta\
    te\x18\x03\x20\x01(\x0e2!.RemoteFortressReader.MatterStateR\x05stateB\0\
    \x123\n\x04item\x18\x04\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\
    \x04itemB\0:\0\"L\n\x0bSpatterPile\x12;\n\x08spatters\x18\x01\x20\x03(\
    \x0b2\x1d.RemoteFortressReader.SpatterR\x08spattersB\0:\0\"\xc8\x05\n\
    \x04Item\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12/\n\x03pos\
    \x18\x02\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03posB\0\x12\x18\
    \n\x06flags1\x18\x03\x20\x01(\rR\x06flags1B\0\x12\x18\n\x06flags2\x18\
    \x04\x20\x01(\rR\x06flags2B\0\x123\n\x04type\x18\x05\x20\x01(\x0b2\x1d.R\
    emoteFortressReader.MatPairR\x04typeB\0\x12;\n\x08material\x18\x06\x20\
    \x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08materialB\0\x129\n\x03dy\
    e\x18\x07\x20\x01(\x0b2%.RemoteFortressReader.ColorDefinitionR\x03dyeB\0\
    \x12\x1f\n\nstack_size\x18\x08\x20\x01(\x05R\tstackSizeB\0\x12\x1b\n\x08\
    subpos_x\x18\t\x20\x01(\x02R\x07subposXB\0\x12\x1b\n\x08subpos_y\x18\n\
    \x20\x01(\x02R\x07subposYB\0\x12\x1b\n\x08subpos_z\x18\x0b\x20\x01(\x02R\
    \x07subposZB\0\x12\x20\n\nprojectile\x18\x0c\x20\x01(\x08R\nprojectileB\
    \0\x12\x1f\n\nvelocity_x\x18\r\x20\x01(\x02R\tvelocityXB\0\x12\x1f\n\nve\
    locity_y\x18\x0e\x20\x01(\x02R\tvelocityYB\0\x12\x1f\n\nvelocity_z\x18\
    \x0f\x20\x01(\x02R\tvelocityZB\0\x12\x18\n\x06volume\x18\x10\x20\x01(\
    \x05R\x06volumeB\0\x12K\n\x0cimprovements\x18\x11\x20\x03(\x0b2%.RemoteF\
    ortressReader.ItemImprovementR\x0cimprovementsB\0\x126\n\x05image\x18\
    \x12\x20\x01(\x0b2\x1e.RemoteFortressReader.ArtImageR\x05imageB\0:\0\"\
    \xd1\x02\n\tPlantTile\x12\x16\n\x05trunk\x18\x01\x20\x01(\x08R\x05trunkB\
    \0\x12)\n\x0fconnection_east\x18\x02\x20\x01(\x08R\x0econnectionEastB\0\
    \x12+\n\x10connection_south\x18\x03\x20\x01(\x08R\x0fconnectionSouthB\0\
    \x12)\n\x0fconnection_west\x18\x04\x20\x01(\x08R\x0econnectionWestB\0\
    \x12+\n\x10connection_north\x18\x05\x20\x01(\x08R\x0fconnectionNorthB\0\
    \x12\x1c\n\x08branches\x18\x06\x20\x01(\x08R\x08branchesB\0\x12\x16\n\
    \x05twigs\x18\x07\x20\x01(\x08R\x05twigsB\0\x12D\n\ttile_type\x18\x08\
    \x20\x01(\x0e2%.RemoteFortressReader.TiletypeSpecialR\x08tileTypeB\0:\0\
    \"x\n\x08TreeInfo\x121\n\x04size\x18\x01\x20\x01(\x0b2\x1b.RemoteFortres\
    sReader.CoordR\x04sizeB\0\x127\n\x05tiles\x18\x02\x20\x03(\x0b2\x1f.Remo\
    teFortressReader.PlantTileR\x05tilesB\0:\0\"\xa2\x01\n\rPlantInstance\
    \x12\x1f\n\nplant_type\x18\x01\x20\x01(\x05R\tplantTypeB\0\x12/\n\x03pos\
    \x18\x02\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03posB\0\x12=\n\
    \ttree_info\x18\x03\x20\x01(\x0b2\x1e.RemoteFortressReader.TreeInfoR\x08\
    treeInfoB\0:\0\"\xca\n\n\x08MapBlock\x12\x15\n\x05map_x\x18\x01\x20\x02(\
    \x05R\x04mapXB\0\x12\x15\n\x05map_y\x18\x02\x20\x02(\x05R\x04mapYB\0\x12\
    \x15\n\x05map_z\x18\x03\x20\x02(\x05R\x04mapZB\0\x12\x16\n\x05tiles\x18\
    \x04\x20\x03(\x05R\x05tilesB\0\x12=\n\tmaterials\x18\x05\x20\x03(\x0b2\
    \x1d.RemoteFortressReader.MatPairR\tmaterialsB\0\x12H\n\x0flayer_materia\
    ls\x18\x06\x20\x03(\x0b2\x1d.RemoteFortressReader.MatPairR\x0elayerMater\
    ialsB\0\x12F\n\x0evein_materials\x18\x07\x20\x03(\x0b2\x1d.RemoteFortres\
    sReader.MatPairR\rveinMaterialsB\0\x12F\n\x0ebase_materials\x18\x08\x20\
    \x03(\x0b2\x1d.RemoteFortressReader.MatPairR\rbaseMaterialsB\0\x12\x16\n\
    \x05magma\x18\t\x20\x03(\x05R\x05magmaB\0\x12\x16\n\x05water\x18\n\x20\
    \x03(\x05R\x05waterB\0\x12\x18\n\x06hidden\x18\x0b\x20\x03(\x08R\x06hidd\
    enB\0\x12\x16\n\x05light\x18\x0c\x20\x03(\x08R\x05lightB\0\x12$\n\x0csub\
    terranean\x18\r\x20\x03(\x08R\x0csubterraneanB\0\x12\x1a\n\x07outside\
    \x18\x0e\x20\x03(\x08R\x07outsideB\0\x12\x1a\n\x07aquifer\x18\x0f\x20\
    \x03(\x08R\x07aquiferB\0\x12'\n\x0ewater_stagnant\x18\x10\x20\x03(\x08R\
    \rwaterStagnantB\0\x12\x1f\n\nwater_salt\x18\x11\x20\x03(\x08R\twaterSal\
    tB\0\x12N\n\x12construction_items\x18\x12\x20\x03(\x0b2\x1d.RemoteFortre\
    ssReader.MatPairR\x11constructionItemsB\0\x12F\n\tbuildings\x18\x13\x20\
    \x03(\x0b2&.RemoteFortressReader.BuildingInstanceR\tbuildingsB\0\x12#\n\
    \x0ctree_percent\x18\x14\x20\x03(\x05R\x0btreePercentB\0\x12\x17\n\x06tr\
    ee_x\x18\x15\x20\x03(\x05R\x05treeXB\0\x12\x17\n\x06tree_y\x18\x16\x20\
    \x03(\x05R\x05treeYB\0\x12\x17\n\x06tree_z\x18\x17\x20\x03(\x05R\x05tree\
    ZB\0\x12\\\n\x14tile_dig_designation\x18\x18\x20\x03(\x0e2(.RemoteFortre\
    ssReader.TileDigDesignationR\x12tileDigDesignationB\0\x12E\n\x0bspatterP\
    ile\x18\x19\x20\x03(\x0b2!.RemoteFortressReader.SpatterPileR\x0bspatterP\
    ileB\0\x122\n\x05items\x18\x1a\x20\x03(\x0b2\x1a.RemoteFortressReader.It\
    emR\x05itemsB\0\x12?\n\x1btile_dig_designation_marker\x18\x1b\x20\x03(\
    \x08R\x18tileDigDesignationMarkerB\0\x12;\n\x19tile_dig_designation_auto\
    \x18\x1c\x20\x03(\x08R\x16tileDigDesignationAutoB\0\x12%\n\rgrass_percen\
    t\x18\x1d\x20\x03(\x05R\x0cgrassPercentB\0\x126\n\x05flows\x18\x1e\x20\
    \x03(\x0b2\x1e.RemoteFortressReader.FlowInfoR\x05flowsB\0:\0\"G\n\x07Mat\
    Pair\x12\x1b\n\x08mat_type\x18\x01\x20\x02(\x05R\x07matTypeB\0\x12\x1d\n\
    \tmat_index\x18\x02\x20\x02(\x05R\x08matIndexB\0:\0\"U\n\x0fColorDefinit\
    ion\x12\x12\n\x03red\x18\x01\x20\x02(\x05R\x03redB\0\x12\x16\n\x05green\
    \x18\x02\x20\x02(\x05R\x05greenB\0\x12\x14\n\x04blue\x18\x03\x20\x02(\
    \x05R\x04blueB\0:\0\"\xfc\x02\n\x12MaterialDefinition\x12:\n\x08mat_pair\
    \x18\x01\x20\x02(\x0b2\x1d.RemoteFortressReader.MatPairR\x07matPairB\0\
    \x12\x10\n\x02id\x18\x02\x20\x01(\tR\x02idB\0\x12\x14\n\x04name\x18\x03\
    \x20\x01(\tR\x04nameB\0\x12H\n\x0bstate_color\x18\x04\x20\x01(\x0b2%.Rem\
    oteFortressReader.ColorDefinitionR\nstateColorB\0\x12B\n\ninstrument\x18\
    \x05\x20\x01(\x0b2\x20.ItemdefInstrument.InstrumentDefR\ninstrumentB\0\
    \x12\x19\n\x07up_step\x18\x06\x20\x01(\x05R\x06upStepB\0\x12\x1d\n\tdown\
    _step\x18\x07\x20\x01(\x05R\x08downStepB\0\x128\n\x05layer\x18\x08\x20\
    \x01(\x0e2\x20.RemoteFortressReader.ArmorLayerR\x05layerB\0:\0\"\x8f\x01\
    \n\x0cBuildingType\x12%\n\rbuilding_type\x18\x01\x20\x02(\x05R\x0cbuildi\
    ngTypeB\0\x12+\n\x10building_subtype\x18\x02\x20\x02(\x05R\x0fbuildingSu\
    btypeB\0\x12)\n\x0fbuilding_custom\x18\x03\x20\x02(\x05R\x0ebuildingCust\
    omB\0:\0\"\x89\x01\n\x12BuildingDefinition\x12I\n\rbuilding_type\x18\x01\
    \x20\x02(\x0b2\".RemoteFortressReader.BuildingTypeR\x0cbuildingTypeB\0\
    \x12\x10\n\x02id\x18\x02\x20\x01(\tR\x02idB\0\x12\x14\n\x04name\x18\x03\
    \x20\x01(\tR\x04nameB\0:\0\"a\n\x0cBuildingList\x12O\n\rbuilding_list\
    \x18\x01\x20\x03(\x0b2(.RemoteFortressReader.BuildingDefinitionR\x0cbuil\
    dingListB\0:\0\"a\n\x0cMaterialList\x12O\n\rmaterial_list\x18\x01\x20\
    \x03(\x0b2(.RemoteFortressReader.MaterialDefinitionR\x0cmaterialListB\0:\
    \0\"[\n\x04Hair\x12\x18\n\x06length\x18\x01\x20\x01(\x05R\x06lengthB\0\
    \x127\n\x05style\x18\x02\x20\x01(\x0e2\x1f.RemoteFortressReader.HairStyl\
    eR\x05styleB\0:\0\"\xcc\x01\n\x0cBodySizeInfo\x12\x1b\n\x08size_cur\x18\
    \x01\x20\x01(\x05R\x07sizeCurB\0\x12\x1d\n\tsize_base\x18\x02\x20\x01(\
    \x05R\x08sizeBaseB\0\x12\x1b\n\x08area_cur\x18\x03\x20\x01(\x05R\x07area\
    CurB\0\x12\x1d\n\tarea_base\x18\x04\x20\x01(\x05R\x08areaBaseB\0\x12\x1f\
    \n\nlength_cur\x18\x05\x20\x01(\x05R\tlengthCurB\0\x12!\n\x0blength_base\
    \x18\x06\x20\x01(\x05R\nlengthBaseB\0:\0\"\xb4\x03\n\x0eUnitAppearance\
    \x12'\n\x0ebody_modifiers\x18\x01\x20\x03(\x05R\rbodyModifiersB\0\x12#\n\
    \x0cbp_modifiers\x18\x02\x20\x03(\x05R\x0bbpModifiersB\0\x12%\n\rsize_mo\
    difier\x18\x03\x20\x01(\x05R\x0csizeModifierB\0\x12\x18\n\x06colors\x18\
    \x04\x20\x03(\x05R\x06colorsB\0\x120\n\x04hair\x18\x05\x20\x01(\x0b2\x1a\
    .RemoteFortressReader.HairR\x04hairB\0\x122\n\x05beard\x18\x06\x20\x01(\
    \x0b2\x1a.RemoteFortressReader.HairR\x05beardB\0\x12:\n\tmoustache\x18\
    \x07\x20\x01(\x0b2\x1a.RemoteFortressReader.HairR\tmoustacheB\0\x12:\n\t\
    sideburns\x18\x08\x20\x01(\x0b2\x1a.RemoteFortressReader.HairR\tsideburn\
    sB\0\x123\n\x14physical_description\x18\t\x20\x01(\tR\x13physicalDescrip\
    tionB\0:\0\"\xa2\x01\n\rInventoryItem\x129\n\x04mode\x18\x01\x20\x01(\
    \x0e2#.RemoteFortressReader.InventoryModeR\x04modeB\0\x120\n\x04item\x18\
    \x02\x20\x01(\x0b2\x1a.RemoteFortressReader.ItemR\x04itemB\0\x12\"\n\x0c\
    body_part_id\x18\x03\x20\x01(\x05R\nbodyPartIdB\0:\0\"|\n\tWoundPart\x12\
    *\n\x10global_layer_idx\x18\x01\x20\x01(\x05R\x0eglobalLayerIdxB\0\x12\"\
    \n\x0cbody_part_id\x18\x02\x20\x01(\x05R\nbodyPartIdB\0\x12\x1d\n\tlayer\
    _idx\x18\x03\x20\x01(\x05R\x08layerIdxB\0:\0\"k\n\tUnitWound\x127\n\x05p\
    arts\x18\x01\x20\x03(\x0b2\x1f.RemoteFortressReader.WoundPartR\x05partsB\
    \0\x12#\n\x0csevered_part\x18\x02\x20\x01(\x08R\x0bseveredPartB\0:\0\"\
    \xf1\x07\n\x0eUnitDefinition\x12\x10\n\x02id\x18\x01\x20\x02(\x05R\x02id\
    B\0\x12\x1a\n\x07isValid\x18\x02\x20\x01(\x08R\x07isValidB\0\x12\x15\n\
    \x05pos_x\x18\x03\x20\x01(\x05R\x04posXB\0\x12\x15\n\x05pos_y\x18\x04\
    \x20\x01(\x05R\x04posYB\0\x12\x15\n\x05pos_z\x18\x05\x20\x01(\x05R\x04po\
    sZB\0\x123\n\x04race\x18\x06\x20\x01(\x0b2\x1d.RemoteFortressReader.MatP\
    airR\x04raceB\0\x12R\n\x10profession_color\x18\x07\x20\x01(\x0b2%.Remote\
    FortressReader.ColorDefinitionR\x0fprofessionColorB\0\x12\x18\n\x06flags\
    1\x18\x08\x20\x01(\rR\x06flags1B\0\x12\x18\n\x06flags2\x18\t\x20\x01(\rR\
    \x06flags2B\0\x12\x18\n\x06flags3\x18\n\x20\x01(\rR\x06flags3B\0\x12\x1f\
    \n\nis_soldier\x18\x0b\x20\x01(\x08R\tisSoldierB\0\x12A\n\tsize_info\x18\
    \x0c\x20\x01(\x0b2\".RemoteFortressReader.BodySizeInfoR\x08sizeInfoB\0\
    \x12\x14\n\x04name\x18\r\x20\x01(\tR\x04nameB\0\x12\x1d\n\tblood_max\x18\
    \x0e\x20\x01(\x05R\x08bloodMaxB\0\x12!\n\x0bblood_count\x18\x0f\x20\x01(\
    \x05R\nbloodCountB\0\x12F\n\nappearance\x18\x10\x20\x01(\x0b2$.RemoteFor\
    tressReader.UnitAppearanceR\nappearanceB\0\x12%\n\rprofession_id\x18\x11\
    \x20\x01(\x05R\x0cprofessionIdB\0\x12)\n\x0fnoble_positions\x18\x12\x20\
    \x03(\tR\x0enoblePositionsB\0\x12\x1b\n\x08rider_id\x18\x13\x20\x01(\x05\
    R\x07riderIdB\0\x12C\n\tinventory\x18\x14\x20\x03(\x0b2#.RemoteFortressR\
    eader.InventoryItemR\tinventoryB\0\x12\x1b\n\x08subpos_x\x18\x15\x20\x01\
    (\x02R\x07subposXB\0\x12\x1b\n\x08subpos_y\x18\x16\x20\x01(\x02R\x07subp\
    osYB\0\x12\x1b\n\x08subpos_z\x18\x17\x20\x01(\x02R\x07subposZB\0\x125\n\
    \x06facing\x18\x18\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x06faci\
    ngB\0\x12\x12\n\x03age\x18\x19\x20\x01(\x05R\x03ageB\0\x129\n\x06wounds\
    \x18\x1a\x20\x03(\x0b2\x1f.RemoteFortressReader.UnitWoundR\x06woundsB\0:\
    \0\"Y\n\x08UnitList\x12K\n\rcreature_list\x18\x01\x20\x03(\x0b2$.RemoteF\
    ortressReader.UnitDefinitionR\x0ccreatureListB\0:\0\"\xc1\x01\n\x0cBlock\
    Request\x12%\n\rblocks_needed\x18\x01\x20\x01(\x05R\x0cblocksNeededB\0\
    \x12\x15\n\x05min_x\x18\x02\x20\x01(\x05R\x04minXB\0\x12\x15\n\x05max_x\
    \x18\x03\x20\x01(\x05R\x04maxXB\0\x12\x15\n\x05min_y\x18\x04\x20\x01(\
    \x05R\x04minYB\0\x12\x15\n\x05max_y\x18\x05\x20\x01(\x05R\x04maxYB\0\x12\
    \x15\n\x05min_z\x18\x06\x20\x01(\x05R\x04minZB\0\x12\x15\n\x05max_z\x18\
    \x07\x20\x01(\x05R\x04maxZB\0:\0\"\xfe\x01\n\tBlockList\x12?\n\nmap_bloc\
    ks\x18\x01\x20\x03(\x0b2\x1e.RemoteFortressReader.MapBlockR\tmapBlocksB\
    \0\x12\x15\n\x05map_x\x18\x02\x20\x01(\x05R\x04mapXB\0\x12\x15\n\x05map_\
    y\x18\x03\x20\x01(\x05R\x04mapYB\0\x12A\n\nengravings\x18\x04\x20\x03(\
    \x0b2\x1f.RemoteFortressReader.EngravingR\nengravingsB\0\x12=\n\x0bocean\
    _waves\x18\x05\x20\x03(\x0b2\x1a.RemoteFortressReader.WaveR\noceanWavesB\
    \0:\0\"i\n\x08PlantDef\x12\x15\n\x05pos_x\x18\x01\x20\x02(\x05R\x04posXB\
    \0\x12\x15\n\x05pos_y\x18\x02\x20\x02(\x05R\x04posYB\0\x12\x15\n\x05pos_\
    z\x18\x03\x20\x02(\x05R\x04posZB\0\x12\x16\n\x05index\x18\x04\x20\x02(\
    \x05R\x05indexB\0:\0\"N\n\tPlantList\x12?\n\nplant_list\x18\x01\x20\x03(\
    \x0b2\x1e.RemoteFortressReader.PlantDefR\tplantListB\0:\0\"\xf4\x02\n\
    \x08ViewInfo\x12\x1e\n\nview_pos_x\x18\x01\x20\x01(\x05R\x08viewPosXB\0\
    \x12\x1e\n\nview_pos_y\x18\x02\x20\x01(\x05R\x08viewPosYB\0\x12\x1e\n\nv\
    iew_pos_z\x18\x03\x20\x01(\x05R\x08viewPosZB\0\x12\x20\n\x0bview_size_x\
    \x18\x04\x20\x01(\x05R\tviewSizeXB\0\x12\x20\n\x0bview_size_y\x18\x05\
    \x20\x01(\x05R\tviewSizeYB\0\x12\"\n\x0ccursor_pos_x\x18\x06\x20\x01(\
    \x05R\ncursorPosXB\0\x12\"\n\x0ccursor_pos_y\x18\x07\x20\x01(\x05R\ncurs\
    orPosYB\0\x12\"\n\x0ccursor_pos_z\x18\x08\x20\x01(\x05R\ncursorPosZB\0\
    \x12*\n\x0efollow_unit_id\x18\t\x20\x01(\x05:\x02-1R\x0cfollowUnitIdB\0\
    \x12*\n\x0efollow_item_id\x18\n\x20\x01(\x05:\x02-1R\x0cfollowItemIdB\0:\
    \0\"\xcd\x02\n\x07MapInfo\x12\"\n\x0cblock_size_x\x18\x01\x20\x01(\x05R\
    \nblockSizeXB\0\x12\"\n\x0cblock_size_y\x18\x02\x20\x01(\x05R\nblockSize\
    YB\0\x12\"\n\x0cblock_size_z\x18\x03\x20\x01(\x05R\nblockSizeZB\0\x12\
    \x20\n\x0bblock_pos_x\x18\x04\x20\x01(\x05R\tblockPosXB\0\x12\x20\n\x0bb\
    lock_pos_y\x18\x05\x20\x01(\x05R\tblockPosYB\0\x12\x20\n\x0bblock_pos_z\
    \x18\x06\x20\x01(\x05R\tblockPosZB\0\x12\x1f\n\nworld_name\x18\x07\x20\
    \x01(\tR\tworldNameB\0\x12.\n\x12world_name_english\x18\x08\x20\x01(\tR\
    \x10worldNameEnglishB\0\x12\x1d\n\tsave_name\x18\t\x20\x01(\tR\x08saveNa\
    meB\0:\0\"\x8d\x02\n\x05Cloud\x127\n\x05front\x18\x01\x20\x01(\x0e2\x1f.\
    RemoteFortressReader.FrontTypeR\x05frontB\0\x12=\n\x07cumulus\x18\x02\
    \x20\x01(\x0e2!.RemoteFortressReader.CumulusTypeR\x07cumulusB\0\x12\x18\
    \n\x06cirrus\x18\x03\x20\x01(\x08R\x06cirrusB\0\x12=\n\x07stratus\x18\
    \x04\x20\x01(\x0e2!.RemoteFortressReader.StratusTypeR\x07stratusB\0\x121\
    \n\x03fog\x18\x05\x20\x01(\x0e2\x1d.RemoteFortressReader.FogTypeR\x03fog\
    B\0:\0\"\xa5\x07\n\x08WorldMap\x12!\n\x0bworld_width\x18\x01\x20\x02(\
    \x05R\nworldWidthB\0\x12#\n\x0cworld_height\x18\x02\x20\x02(\x05R\x0bwor\
    ldHeightB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12#\n\x0cn\
    ame_english\x18\x04\x20\x01(\tR\x0bnameEnglishB\0\x12\x1e\n\televation\
    \x18\x05\x20\x03(\x05R\televationB\0\x12\x1c\n\x08rainfall\x18\x06\x20\
    \x03(\x05R\x08rainfallB\0\x12\x20\n\nvegetation\x18\x07\x20\x03(\x05R\nv\
    egetationB\0\x12\"\n\x0btemperature\x18\x08\x20\x03(\x05R\x0btemperature\
    B\0\x12\x1c\n\x08evilness\x18\t\x20\x03(\x05R\x08evilnessB\0\x12\x1c\n\
    \x08drainage\x18\n\x20\x03(\x05R\x08drainageB\0\x12\x1e\n\tvolcanism\x18\
    \x0b\x20\x03(\x05R\tvolcanismB\0\x12\x1c\n\x08savagery\x18\x0c\x20\x03(\
    \x05R\x08savageryB\0\x125\n\x06clouds\x18\r\x20\x03(\x0b2\x1b.RemoteFort\
    ressReader.CloudR\x06cloudsB\0\x12\x1c\n\x08salinity\x18\x0e\x20\x03(\
    \x05R\x08salinityB\0\x12\x15\n\x05map_x\x18\x0f\x20\x01(\x05R\x04mapXB\0\
    \x12\x15\n\x05map_y\x18\x10\x20\x01(\x05R\x04mapYB\0\x12\x1b\n\x08center\
    _x\x18\x11\x20\x01(\x05R\x07centerXB\0\x12\x1b\n\x08center_y\x18\x12\x20\
    \x01(\x05R\x07centerYB\0\x12\x1b\n\x08center_z\x18\x13\x20\x01(\x05R\x07\
    centerZB\0\x12\x1b\n\x08cur_year\x18\x14\x20\x01(\x05R\x07curYearB\0\x12\
    $\n\rcur_year_tick\x18\x15\x20\x01(\x05R\x0bcurYearTickB\0\x12C\n\x0bwor\
    ld_poles\x18\x16\x20\x01(\x0e2\x20.RemoteFortressReader.WorldPolesR\nwor\
    ldPolesB\0\x12B\n\x0briver_tiles\x18\x17\x20\x03(\x0b2\x1f.RemoteFortres\
    sReader.RiverTileR\nriverTilesB\0\x12)\n\x0fwater_elevation\x18\x18\x20\
    \x03(\x05R\x0ewaterElevationB\0\x12E\n\x0cregion_tiles\x18\x19\x20\x03(\
    \x0b2\x20.RemoteFortressReader.RegionTileR\x0bregionTilesB\0:\0\"\xb5\
    \x01\n\x1bSiteRealizationBuildingWall\x12\x19\n\x07start_x\x18\x01\x20\
    \x01(\x05R\x06startXB\0\x12\x19\n\x07start_y\x18\x02\x20\x01(\x05R\x06st\
    artYB\0\x12\x19\n\x07start_z\x18\x03\x20\x01(\x05R\x06startZB\0\x12\x15\
    \n\x05end_x\x18\x04\x20\x01(\x05R\x04endXB\0\x12\x15\n\x05end_y\x18\x05\
    \x20\x01(\x05R\x04endYB\0\x12\x15\n\x05end_z\x18\x06\x20\x01(\x05R\x04en\
    dZB\0:\0\"k\n\x1cSiteRealizationBuildingTower\x12\x17\n\x06roof_z\x18\
    \x01\x20\x01(\x05R\x05roofZB\0\x12\x16\n\x05round\x18\x02\x20\x01(\x08R\
    \x05roundB\0\x12\x18\n\x06goblin\x18\x03\x20\x01(\x08R\x06goblinB\0:\0\"\
    \x97\x01\n\x0bTrenchSpoke\x12!\n\x0bmound_start\x18\x01\x20\x01(\x05R\nm\
    oundStartB\0\x12#\n\x0ctrench_start\x18\x02\x20\x01(\x05R\x0btrenchStart\
    B\0\x12\x1f\n\ntrench_end\x18\x03\x20\x01(\x05R\ttrenchEndB\0\x12\x1d\n\
    \tmound_end\x18\x04\x20\x01(\x05R\x08moundEndB\0:\0\"`\n\x1fSiteRealizat\
    ionBuildingTrenches\x12;\n\x06spokes\x18\x01\x20\x03(\x0b2!.RemoteFortre\
    ssReader.TrenchSpokeR\x06spokesB\0:\0\"\xdd\x03\n\x17SiteRealizationBuil\
    ding\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x15\n\x05min_x\
    \x18\x03\x20\x01(\x05R\x04minXB\0\x12\x15\n\x05min_y\x18\x04\x20\x01(\
    \x05R\x04minYB\0\x12\x15\n\x05max_x\x18\x05\x20\x01(\x05R\x04maxXB\0\x12\
    \x15\n\x05max_y\x18\x06\x20\x01(\x05R\x04maxYB\0\x12;\n\x08material\x18\
    \x07\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08materialB\0\x12P\
    \n\twall_info\x18\x08\x20\x01(\x0b21.RemoteFortressReader.SiteRealizatio\
    nBuildingWallR\x08wallInfoB\0\x12S\n\ntower_info\x18\t\x20\x01(\x0b22.Re\
    moteFortressReader.SiteRealizationBuildingTowerR\ttowerInfoB\0\x12X\n\
    \x0btrench_info\x18\n\x20\x01(\x0b25.RemoteFortressReader.SiteRealizatio\
    nBuildingTrenchesR\ntrenchInfoB\0\x12\x14\n\x04type\x18\x0b\x20\x01(\x05\
    R\x04typeB\0:\0\"\xa6\x06\n\nRegionTile\x12\x1e\n\televation\x18\x01\x20\
    \x01(\x05R\televationB\0\x12\x1c\n\x08rainfall\x18\x02\x20\x01(\x05R\x08\
    rainfallB\0\x12\x20\n\nvegetation\x18\x03\x20\x01(\x05R\nvegetationB\0\
    \x12\"\n\x0btemperature\x18\x04\x20\x01(\x05R\x0btemperatureB\0\x12\x1c\
    \n\x08evilness\x18\x05\x20\x01(\x05R\x08evilnessB\0\x12\x1c\n\x08drainag\
    e\x18\x06\x20\x01(\x05R\x08drainageB\0\x12\x1e\n\tvolcanism\x18\x07\x20\
    \x01(\x05R\tvolcanismB\0\x12\x1c\n\x08savagery\x18\x08\x20\x01(\x05R\x08\
    savageryB\0\x12\x1c\n\x08salinity\x18\t\x20\x01(\x05R\x08salinityB\0\x12\
    B\n\x0briver_tiles\x18\n\x20\x01(\x0b2\x1f.RemoteFortressReader.RiverTil\
    eR\nriverTilesB\0\x12)\n\x0fwater_elevation\x18\x0b\x20\x01(\x05R\x0ewat\
    erElevationB\0\x12J\n\x10surface_material\x18\x0c\x20\x01(\x0b2\x1d.Remo\
    teFortressReader.MatPairR\x0fsurfaceMaterialB\0\x12H\n\x0fplant_material\
    s\x18\r\x20\x03(\x0b2\x1d.RemoteFortressReader.MatPairR\x0eplantMaterial\
    sB\0\x12M\n\tbuildings\x18\x0e\x20\x03(\x0b2-.RemoteFortressReader.SiteR\
    ealizationBuildingR\tbuildingsB\0\x12H\n\x0fstone_materials\x18\x0f\x20\
    \x03(\x0b2\x1d.RemoteFortressReader.MatPairR\x0estoneMaterialsB\0\x12F\n\
    \x0etree_materials\x18\x10\x20\x03(\x0b2\x1d.RemoteFortressReader.MatPai\
    rR\rtreeMaterialsB\0\x12\x14\n\x04snow\x18\x11\x20\x01(\x05R\x04snowB\0:\
    \0\"\xb0\x01\n\tRegionMap\x12\x15\n\x05map_x\x18\x01\x20\x01(\x05R\x04ma\
    pXB\0\x12\x15\n\x05map_y\x18\x02\x20\x01(\x05R\x04mapYB\0\x12\x14\n\x04n\
    ame\x18\x03\x20\x01(\tR\x04nameB\0\x12#\n\x0cname_english\x18\x04\x20\
    \x01(\tR\x0bnameEnglishB\0\x128\n\x05tiles\x18\x05\x20\x03(\x0b2\x20.Rem\
    oteFortressReader.RegionTileR\x05tilesB\0:\0\"\x93\x01\n\nRegionMaps\x12\
    ?\n\nworld_maps\x18\x01\x20\x03(\x0b2\x1e.RemoteFortressReader.WorldMapR\
    \tworldMapsB\0\x12B\n\x0bregion_maps\x18\x02\x20\x03(\x0b2\x1f.RemoteFor\
    tressReader.RegionMapR\nregionMapsB\0:\0\"\xa7\x01\n\x11PatternDescripto\
    r\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12?\n\x06colors\x18\x02\
    \x20\x03(\x0b2%.RemoteFortressReader.ColorDefinitionR\x06colorsB\0\x12=\
    \n\x07pattern\x18\x03\x20\x01(\x0e2!.RemoteFortressReader.PatternTypeR\
    \x07patternB\0:\0\"\xfd\x01\n\x10ColorModifierRaw\x12E\n\x08patterns\x18\
    \x01\x20\x03(\x0b2'.RemoteFortressReader.PatternDescriptorR\x08patternsB\
    \0\x12\"\n\x0cbody_part_id\x18\x02\x20\x03(\x05R\nbodyPartIdB\0\x12(\n\
    \x0ftissue_layer_id\x18\x03\x20\x03(\x05R\rtissueLayerIdB\0\x12\x1f\n\ns\
    tart_date\x18\x04\x20\x01(\x05R\tstartDateB\0\x12\x1b\n\x08end_date\x18\
    \x05\x20\x01(\x05R\x07endDateB\0\x12\x14\n\x04part\x18\x06\x20\x01(\tR\
    \x04partB\0:\0\"\x9c\x01\n\x10BodyPartLayerRaw\x12\x1f\n\nlayer_name\x18\
    \x01\x20\x01(\tR\tlayerNameB\0\x12\x1d\n\ttissue_id\x18\x02\x20\x01(\x05\
    R\x08tissueIdB\0\x12!\n\x0blayer_depth\x18\x03\x20\x01(\x05R\nlayerDepth\
    B\0\x12#\n\x0cbp_modifiers\x18\x04\x20\x03(\x05R\x0bbpModifiersB\0:\0\"\
    \xd5\x01\n\x0bBodyPartRaw\x12\x16\n\x05token\x18\x01\x20\x01(\tR\x05toke\
    nB\0\x12\x1c\n\x08category\x18\x02\x20\x01(\tR\x08categoryB\0\x12\x18\n\
    \x06parent\x18\x03\x20\x01(\x05R\x06parentB\0\x12\x16\n\x05flags\x18\x04\
    \x20\x03(\x08R\x05flagsB\0\x12@\n\x06layers\x18\x05\x20\x03(\x0b2&.Remot\
    eFortressReader.BodyPartLayerRawR\x06layersB\0\x12\x1a\n\x07relsize\x18\
    \x06\x20\x01(\x05R\x07relsizeB\0:\0\"d\n\x14BpAppearanceModifier\x12\x14\
    \n\x04type\x18\x01\x20\x01(\tR\x04typeB\0\x12\x19\n\x07mod_min\x18\x02\
    \x20\x01(\x05R\x06modMinB\0\x12\x19\n\x07mod_max\x18\x03\x20\x01(\x05R\
    \x06modMaxB\0:\0\"\xa8\x01\n\tTissueRaw\x12\x10\n\x02id\x18\x01\x20\x01(\
    \tR\x02idB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12;\n\x08\
    material\x18\x03\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08mate\
    rialB\0\x124\n\x15subordinate_to_tissue\x18\x04\x20\x01(\tR\x13subordina\
    teToTissueB\0:\0\"\xd6\x05\n\x08CasteRaw\x12\x16\n\x05index\x18\x01\x20\
    \x01(\x05R\x05indexB\0\x12\x1b\n\x08caste_id\x18\x02\x20\x01(\tR\x07cast\
    eIdB\0\x12\x1f\n\ncaste_name\x18\x03\x20\x03(\tR\tcasteNameB\0\x12\x1d\n\
    \tbaby_name\x18\x04\x20\x03(\tR\x08babyNameB\0\x12\x1f\n\nchild_name\x18\
    \x05\x20\x03(\tR\tchildNameB\0\x12\x18\n\x06gender\x18\x06\x20\x01(\x05R\
    \x06genderB\0\x12B\n\nbody_parts\x18\x07\x20\x03(\x0b2!.RemoteFortressRe\
    ader.BodyPartRawR\tbodyPartsB\0\x12%\n\rtotal_relsize\x18\x08\x20\x01(\
    \x05R\x0ctotalRelsizeB\0\x12J\n\tmodifiers\x18\t\x20\x03(\x0b2*.RemoteFo\
    rtressReader.BpAppearanceModifierR\tmodifiersB\0\x12#\n\x0cmodifier_idx\
    \x18\n\x20\x03(\x05R\x0bmodifierIdxB\0\x12\x1b\n\x08part_idx\x18\x0b\x20\
    \x03(\x05R\x07partIdxB\0\x12\x1d\n\tlayer_idx\x18\x0c\x20\x03(\x05R\x08l\
    ayerIdxB\0\x12h\n\x19body_appearance_modifiers\x18\r\x20\x03(\x0b2*.Remo\
    teFortressReader.BpAppearanceModifierR\x17bodyAppearanceModifiersB\0\x12\
    Q\n\x0fcolor_modifiers\x18\x0e\x20\x03(\x0b2&.RemoteFortressReader.Color\
    ModifierRawR\x0ecolorModifiersB\0\x12\"\n\x0bdescription\x18\x0f\x20\x01\
    (\tR\x0bdescriptionB\0\x12\x1f\n\nadult_size\x18\x10\x20\x01(\x05R\tadul\
    tSizeB\0:\0\"\x87\x04\n\x0bCreatureRaw\x12\x16\n\x05index\x18\x01\x20\
    \x01(\x05R\x05indexB\0\x12!\n\x0bcreature_id\x18\x02\x20\x01(\tR\ncreatu\
    reIdB\0\x12\x14\n\x04name\x18\x03\x20\x03(\tR\x04nameB\0\x12,\n\x11gener\
    al_baby_name\x18\x04\x20\x03(\tR\x0fgeneralBabyNameB\0\x12.\n\x12general\
    _child_name\x18\x05\x20\x03(\tR\x10generalChildNameB\0\x12%\n\rcreature_\
    tile\x18\x06\x20\x01(\x05R\x0ccreatureTileB\0\x124\n\x15creature_soldier\
    _tile\x18\x07\x20\x01(\x05R\x13creatureSoldierTileB\0\x12=\n\x05color\
    \x18\x08\x20\x01(\x0b2%.RemoteFortressReader.ColorDefinitionR\x05colorB\
    \0\x12\x1e\n\tadultsize\x18\t\x20\x01(\x05R\tadultsizeB\0\x126\n\x05cast\
    e\x18\n\x20\x03(\x0b2\x1e.RemoteFortressReader.CasteRawR\x05casteB\0\x12\
    ;\n\x07tissues\x18\x0b\x20\x03(\x0b2\x1f.RemoteFortressReader.TissueRawR\
    \x07tissuesB\0\x12\x16\n\x05flags\x18\x0c\x20\x03(\x08R\x05flagsB\0:\0\"\
    ]\n\x0fCreatureRawList\x12H\n\rcreature_raws\x18\x01\x20\x03(\x0b2!.Remo\
    teFortressReader.CreatureRawR\x0ccreatureRawsB\0:\0\"\xf9\x01\n\x04Army\
    \x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x15\n\x05pos_x\x18\
    \x02\x20\x01(\x05R\x04posXB\0\x12\x15\n\x05pos_y\x18\x03\x20\x01(\x05R\
    \x04posYB\0\x12\x15\n\x05pos_z\x18\x04\x20\x01(\x05R\x04posZB\0\x12>\n\
    \x06leader\x18\x05\x20\x01(\x0b2$.RemoteFortressReader.UnitDefinitionR\
    \x06leaderB\0\x12@\n\x07members\x18\x06\x20\x03(\x0b2$.RemoteFortressRea\
    der.UnitDefinitionR\x07membersB\0\x12\x16\n\x05flags\x18\x07\x20\x01(\rR\
    \x05flagsB\0:\0\"B\n\x08ArmyList\x124\n\x06armies\x18\x01\x20\x03(\x0b2\
    \x1a.RemoteFortressReader.ArmyR\x06armiesB\0:\0\"\xa1\x01\n\x0bGrowthPri\
    nt\x12\x1c\n\x08priority\x18\x01\x20\x01(\x05R\x08priorityB\0\x12\x16\n\
    \x05color\x18\x02\x20\x01(\x05R\x05colorB\0\x12#\n\x0ctiming_start\x18\
    \x03\x20\x01(\x05R\x0btimingStartB\0\x12\x1f\n\ntiming_end\x18\x04\x20\
    \x01(\x05R\ttimingEndB\0\x12\x14\n\x04tile\x18\x05\x20\x01(\x05R\x04tile\
    B\0:\0\"\xaa\x04\n\nTreeGrowth\x12\x16\n\x05index\x18\x01\x20\x01(\x05R\
    \x05indexB\0\x12\x10\n\x02id\x18\x02\x20\x01(\tR\x02idB\0\x12\x14\n\x04n\
    ame\x18\x03\x20\x01(\tR\x04nameB\0\x121\n\x03mat\x18\x04\x20\x01(\x0b2\
    \x1d.RemoteFortressReader.MatPairR\x03matB\0\x12;\n\x06prints\x18\x05\
    \x20\x03(\x0b2!.RemoteFortressReader.GrowthPrintR\x06printsB\0\x12#\n\
    \x0ctiming_start\x18\x06\x20\x01(\x05R\x0btimingStartB\0\x12\x1f\n\ntimi\
    ng_end\x18\x07\x20\x01(\x05R\ttimingEndB\0\x12\x16\n\x05twigs\x18\x08\
    \x20\x01(\x08R\x05twigsB\0\x12'\n\x0elight_branches\x18\t\x20\x01(\x08R\
    \rlightBranchesB\0\x12'\n\x0eheavy_branches\x18\n\x20\x01(\x08R\rheavyBr\
    anchesB\0\x12\x16\n\x05trunk\x18\x0b\x20\x01(\x08R\x05trunkB\0\x12\x16\n\
    \x05roots\x18\x0c\x20\x01(\x08R\x05rootsB\0\x12\x12\n\x03cap\x18\r\x20\
    \x01(\x08R\x03capB\0\x12\x1a\n\x07sapling\x18\x0e\x20\x01(\x08R\x07sapli\
    ngB\0\x12.\n\x12trunk_height_start\x18\x0f\x20\x01(\x05R\x10trunkHeightS\
    tartB\0\x12*\n\x10trunk_height_end\x18\x10\x20\x01(\x05R\x0etrunkHeightE\
    ndB\0:\0\"\xa0\x01\n\x08PlantRaw\x12\x16\n\x05index\x18\x01\x20\x01(\x05\
    R\x05indexB\0\x12\x10\n\x02id\x18\x02\x20\x01(\tR\x02idB\0\x12\x14\n\x04\
    name\x18\x03\x20\x01(\tR\x04nameB\0\x12<\n\x07growths\x18\x04\x20\x03(\
    \x0b2\x20.RemoteFortressReader.TreeGrowthR\x07growthsB\0\x12\x14\n\x04ti\
    le\x18\x05\x20\x01(\x05R\x04tileB\0:\0\"Q\n\x0cPlantRawList\x12?\n\nplan\
    t_raws\x18\x01\x20\x03(\x0b2\x1e.RemoteFortressReader.PlantRawR\tplantRa\
    wsB\0:\0\"r\n\nScreenTile\x12\x1e\n\tcharacter\x18\x01\x20\x01(\rR\tchar\
    acterB\0\x12\x20\n\nforeground\x18\x02\x20\x01(\rR\nforegroundB\0\x12\
    \x20\n\nbackground\x18\x03\x20\x01(\rR\nbackgroundB\0:\0\"}\n\rScreenCap\
    ture\x12\x16\n\x05width\x18\x01\x20\x01(\rR\x05widthB\0\x12\x18\n\x06hei\
    ght\x18\x02\x20\x01(\rR\x06heightB\0\x128\n\x05tiles\x18\x03\x20\x03(\
    \x0b2\x20.RemoteFortressReader.ScreenTileR\x05tilesB\0:\0\"\xb9\x01\n\rK\
    eyboardEvent\x12\x14\n\x04type\x18\x01\x20\x01(\rR\x04typeB\0\x12\x16\n\
    \x05which\x18\x02\x20\x01(\rR\x05whichB\0\x12\x16\n\x05state\x18\x03\x20\
    \x01(\rR\x05stateB\0\x12\x1c\n\x08scancode\x18\x04\x20\x01(\rR\x08scanco\
    deB\0\x12\x12\n\x03sym\x18\x05\x20\x01(\rR\x03symB\0\x12\x12\n\x03mod\
    \x18\x06\x20\x01(\rR\x03modB\0\x12\x1a\n\x07unicode\x18\x07\x20\x01(\rR\
    \x07unicodeB\0:\0\"\x99\x01\n\nDigCommand\x12L\n\x0bdesignation\x18\x01\
    \x20\x01(\x0e2(.RemoteFortressReader.TileDigDesignationR\x0bdesignationB\
    \0\x12;\n\tlocations\x18\x02\x20\x03(\x0b2\x1b.RemoteFortressReader.Coor\
    dR\tlocationsB\0:\0\"&\n\nSingleBool\x12\x16\n\x05Value\x18\x01\x20\x01(\
    \x08R\x05ValueB\0:\0\"\xb7\x01\n\x0bVersionInfo\x126\n\x16dwarf_fortress\
    _version\x18\x01\x20\x01(\tR\x14dwarfFortressVersionB\0\x12'\n\x0edfhack\
    _version\x18\x02\x20\x01(\tR\rdfhackVersionB\0\x12E\n\x1eremote_fortress\
    _reader_version\x18\x03\x20\x01(\tR\x1bremoteFortressReaderVersionB\0:\0\
    \"M\n\x0bListRequest\x12\x1f\n\nlist_start\x18\x01\x20\x01(\x05R\tlistSt\
    artB\0\x12\x1b\n\x08list_end\x18\x02\x20\x01(\x05R\x07listEndB\0:\0\"\
    \x97\x03\n\x06Report\x12\x14\n\x04type\x18\x01\x20\x01(\x05R\x04typeB\0\
    \x12\x14\n\x04text\x18\x02\x20\x01(\tR\x04textB\0\x12=\n\x05color\x18\
    \x03\x20\x01(\x0b2%.RemoteFortressReader.ColorDefinitionR\x05colorB\0\
    \x12\x1c\n\x08duration\x18\x04\x20\x01(\x05R\x08durationB\0\x12$\n\x0cco\
    ntinuation\x18\x05\x20\x01(\x08R\x0ccontinuationB\0\x12\"\n\x0bunconscio\
    us\x18\x06\x20\x01(\x08R\x0bunconsciousB\0\x12$\n\x0cannouncement\x18\
    \x07\x20\x01(\x08R\x0cannouncementB\0\x12#\n\x0crepeat_count\x18\x08\x20\
    \x01(\x05R\x0brepeatCountB\0\x12/\n\x03pos\x18\t\x20\x01(\x0b2\x1b.Remot\
    eFortressReader.CoordR\x03posB\0\x12\x10\n\x02id\x18\n\x20\x01(\x05R\x02\
    idB\0\x12\x14\n\x04year\x18\x0b\x20\x01(\x05R\x04yearB\0\x12\x14\n\x04ti\
    me\x18\x0c\x20\x01(\x05R\x04timeB\0:\0\"D\n\x06Status\x128\n\x07reports\
    \x18\x01\x20\x03(\x0b2\x1c.RemoteFortressReader.ReportR\x07reportsB\0:\0\
    \"<\n\x10ShapeDescriptior\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\
    \x12\x14\n\x04tile\x18\x02\x20\x01(\x05R\x04tileB\0:\0\"N\n\x08Language\
    \x12@\n\x06shapes\x18\x01\x20\x03(\x0b2&.RemoteFortressReader.ShapeDescr\
    iptiorR\x06shapesB\0:\0\"\xdd\x01\n\x0fItemImprovement\x12;\n\x08materia\
    l\x18\x01\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08materialB\0\
    \x12\x16\n\x05shape\x18\x03\x20\x01(\x05R\x05shapeB\0\x12%\n\rspecific_t\
    ype\x18\x04\x20\x01(\x05R\x0cspecificTypeB\0\x126\n\x05image\x18\x05\x20\
    \x01(\x0b2\x1e.RemoteFortressReader.ArtImageR\x05imageB\0\x12\x14\n\x04t\
    ype\x18\x06\x20\x01(\x05R\x04typeB\0:\0\"\x81\x02\n\x0fArtImageElement\
    \x12\x16\n\x05count\x18\x01\x20\x01(\x05R\x05countB\0\x12?\n\x04type\x18\
    \x02\x20\x01(\x0e2).RemoteFortressReader.ArtImageElementTypeR\x04typeB\0\
    \x12D\n\rcreature_item\x18\x03\x20\x01(\x0b2\x1d.RemoteFortressReader.Ma\
    tPairR\x0ccreatureItemB\0\x12;\n\x08material\x18\x05\x20\x01(\x0b2\x1d.R\
    emoteFortressReader.MatPairR\x08materialB\0\x12\x10\n\x02id\x18\x06\x20\
    \x01(\x05R\x02idB\0:\0\"\xc6\x01\n\x10ArtImageProperty\x12\x1a\n\x07subj\
    ect\x18\x01\x20\x01(\x05R\x07subjectB\0\x12\x18\n\x06object\x18\x02\x20\
    \x01(\x05R\x06objectB\0\x128\n\x04verb\x18\x03\x20\x01(\x0e2\".RemoteFor\
    tressReader.ArtImageVerbR\x04verbB\0\x12@\n\x04type\x18\x04\x20\x01(\x0e\
    2*.RemoteFortressReader.ArtImagePropertyTypeR\x04typeB\0:\0\"\xcc\x01\n\
    \x08ArtImage\x12C\n\x08elements\x18\x01\x20\x03(\x0b2%.RemoteFortressRea\
    der.ArtImageElementR\x08elementsB\0\x12/\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1d.RemoteFortressReader.MatPairR\x02idB\0\x12H\n\nproperties\x18\x03\
    \x20\x03(\x0b2&.RemoteFortressReader.ArtImagePropertyR\npropertiesB\0:\0\
    \"\xb6\x03\n\tEngraving\x12/\n\x03pos\x18\x01\x20\x01(\x0b2\x1b.RemoteFo\
    rtressReader.CoordR\x03posB\0\x12\x1a\n\x07quality\x18\x02\x20\x01(\x05R\
    \x07qualityB\0\x12\x14\n\x04tile\x18\x03\x20\x01(\x05R\x04tileB\0\x126\n\
    \x05image\x18\x04\x20\x01(\x0b2\x1e.RemoteFortressReader.ArtImageR\x05im\
    ageB\0\x12\x16\n\x05floor\x18\x05\x20\x01(\x08R\x05floorB\0\x12\x14\n\
    \x04west\x18\x06\x20\x01(\x08R\x04westB\0\x12\x14\n\x04east\x18\x07\x20\
    \x01(\x08R\x04eastB\0\x12\x16\n\x05north\x18\x08\x20\x01(\x08R\x05northB\
    \0\x12\x16\n\x05south\x18\t\x20\x01(\x08R\x05southB\0\x12\x18\n\x06hidde\
    n\x18\n\x20\x01(\x08R\x06hiddenB\0\x12\x1e\n\tnorthwest\x18\x0b\x20\x01(\
    \x08R\tnorthwestB\0\x12\x1e\n\tnortheast\x18\x0c\x20\x01(\x08R\tnortheas\
    tB\0\x12\x1e\n\tsouthwest\x18\r\x20\x01(\x08R\tsouthwestB\0\x12\x1e\n\ts\
    outheast\x18\x0e\x20\x01(\x08R\tsoutheastB\0:\0\"\xa1\x03\n\x08FlowInfo\
    \x12\x16\n\x05index\x18\x01\x20\x01(\x05R\x05indexB\0\x124\n\x04type\x18\
    \x02\x20\x01(\x0e2\x1e.RemoteFortressReader.FlowTypeR\x04typeB\0\x12\x1a\
    \n\x07density\x18\x03\x20\x01(\x05R\x07densityB\0\x12/\n\x03pos\x18\x04\
    \x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03posB\0\x121\n\x04dest\
    \x18\x05\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x04destB\0\x12\
    \x1e\n\texpanding\x18\x06\x20\x01(\x08R\texpandingB\0\x12\x16\n\x05reuse\
    \x18\x07\x20\x01(\x08R\x05reuseB\0\x12\x1b\n\x08guide_id\x18\x08\x20\x01\
    (\x05R\x07guideIdB\0\x12;\n\x08material\x18\t\x20\x01(\x0b2\x1d.RemoteFo\
    rtressReader.MatPairR\x08materialB\0\x123\n\x04item\x18\n\x20\x01(\x0b2\
    \x1d.RemoteFortressReader.MatPairR\x04itemB\0:\0\"l\n\x04Wave\x121\n\x04\
    dest\x18\x01\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x04destB\0\
    \x12/\n\x03pos\x18\x02\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03\
    posB\0:\0*\xbc\x02\n\rTiletypeShape\x12\x15\n\x08NO_SHAPE\x10\xff\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12\t\n\x05EMPTY\x10\0\x12\t\n\x05FLOOR\
    \x10\x01\x12\x0b\n\x07BOULDER\x10\x02\x12\x0b\n\x07PEBBLES\x10\x03\x12\
    \x08\n\x04WALL\x10\x04\x12\x11\n\rFORTIFICATION\x10\x05\x12\x0c\n\x08STA\
    IR_UP\x10\x06\x12\x0e\n\nSTAIR_DOWN\x10\x07\x12\x10\n\x0cSTAIR_UPDOWN\
    \x10\x08\x12\x08\n\x04RAMP\x10\t\x12\x0c\n\x08RAMP_TOP\x10\n\x12\r\n\tBR\
    OOK_BED\x10\x0b\x12\r\n\tBROOK_TOP\x10\x0c\x12\x0e\n\nTREE_SHAPE\x10\r\
    \x12\x0b\n\x07SAPLING\x10\x0e\x12\t\n\x05SHRUB\x10\x0f\x12\x0f\n\x0bENDL\
    ESS_PIT\x10\x10\x12\n\n\x06BRANCH\x10\x11\x12\x10\n\x0cTRUNK_BRANCH\x10\
    \x12\x12\x08\n\x04TWIG\x10\x13\x1a\0*\xc6\x01\n\x0fTiletypeSpecial\x12\
    \x17\n\nNO_SPECIAL\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\n\n\
    \x06NORMAL\x10\0\x12\x10\n\x0cRIVER_SOURCE\x10\x01\x12\r\n\tWATERFALL\
    \x10\x02\x12\n\n\x06SMOOTH\x10\x03\x12\x0c\n\x08FURROWED\x10\x04\x12\x07\
    \n\x03WET\x10\x05\x12\x08\n\x04DEAD\x10\x06\x12\n\n\x06WORN_1\x10\x07\
    \x12\n\n\x06WORN_2\x10\x08\x12\n\n\x06WORN_3\x10\t\x12\t\n\x05TRACK\x10\
    \n\x12\x0f\n\x0bSMOOTH_DEAD\x10\x0b\x1a\0*\x8c\x03\n\x10TiletypeMaterial\
    \x12\x18\n\x0bNO_MATERIAL\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\
    \x12\x07\n\x03AIR\x10\0\x12\x08\n\x04SOIL\x10\x01\x12\t\n\x05STONE\x10\
    \x02\x12\x0b\n\x07FEATURE\x10\x03\x12\x0e\n\nLAVA_STONE\x10\x04\x12\x0b\
    \n\x07MINERAL\x10\x05\x12\x11\n\rFROZEN_LIQUID\x10\x06\x12\x10\n\x0cCONS\
    TRUCTION\x10\x07\x12\x0f\n\x0bGRASS_LIGHT\x10\x08\x12\x0e\n\nGRASS_DARK\
    \x10\t\x12\r\n\tGRASS_DRY\x10\n\x12\x0e\n\nGRASS_DEAD\x10\x0b\x12\t\n\
    \x05PLANT\x10\x0c\x12\x07\n\x03HFS\x10\r\x12\x0c\n\x08CAMPFIRE\x10\x0e\
    \x12\x08\n\x04FIRE\x10\x0f\x12\t\n\x05ASHES\x10\x10\x12\t\n\x05MAGMA\x10\
    \x11\x12\r\n\tDRIFTWOOD\x10\x12\x12\x08\n\x04POOL\x10\x13\x12\t\n\x05BRO\
    OK\x10\x14\x12\t\n\x05RIVER\x10\x15\x12\x08\n\x04ROOT\x10\x16\x12\x11\n\
    \rTREE_MATERIAL\x10\x17\x12\x0c\n\x08MUSHROOM\x10\x18\x12\x13\n\x0fUNDER\
    WORLD_GATE\x10\x19\x1a\0*X\n\x0fTiletypeVariant\x12\x17\n\nNO_VARIANT\
    \x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\t\n\x05VAR_1\x10\0\x12\
    \t\n\x05VAR_2\x10\x01\x12\t\n\x05VAR_3\x10\x02\x12\t\n\x05VAR_4\x10\x03\
    \x1a\0*L\n\nWorldPoles\x12\x0c\n\x08NO_POLES\x10\0\x12\x0e\n\nNORTH_POLE\
    \x10\x01\x12\x0e\n\nSOUTH_POLE\x10\x02\x12\x0e\n\nBOTH_POLES\x10\x03\x1a\
    \0*I\n\x11BuildingDirection\x12\t\n\x05NORTH\x10\0\x12\x08\n\x04EAST\x10\
    \x01\x12\t\n\x05SOUTH\x10\x02\x12\x08\n\x04WEST\x10\x03\x12\x08\n\x04NON\
    E\x10\x04\x1a\0*\x8f\x01\n\x12TileDigDesignation\x12\n\n\x06NO_DIG\x10\0\
    \x12\x0f\n\x0bDEFAULT_DIG\x10\x01\x12\x15\n\x11UP_DOWN_STAIR_DIG\x10\x02\
    \x12\x0f\n\x0bCHANNEL_DIG\x10\x03\x12\x0c\n\x08RAMP_DIG\x10\x04\x12\x12\
    \n\x0eDOWN_STAIR_DIG\x10\x05\x12\x10\n\x0cUP_STAIR_DIG\x10\x06\x1a\0*w\n\
    \tHairStyle\x12\x14\n\x07UNKEMPT\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\
    \x01\x12\x11\n\rNEATLY_COMBED\x10\0\x12\x0b\n\x07BRAIDED\x10\x01\x12\x10\
    \n\x0cDOUBLE_BRAID\x10\x02\x12\x0e\n\nPONY_TAILS\x10\x03\x12\x10\n\x0cCL\
    EAN_SHAVEN\x10\x04\x1a\0*\x9e\x01\n\rInventoryMode\x12\n\n\x06Hauled\x10\
    \0\x12\n\n\x06Weapon\x10\x01\x12\x08\n\x04Worn\x10\x02\x12\x0c\n\x08Pier\
    cing\x10\x03\x12\t\n\x05Flask\x10\x04\x12\x11\n\rWrappedAround\x10\x05\
    \x12\x0b\n\x07StuckIn\x10\x06\x12\x0b\n\x07InMouth\x10\x07\x12\x07\n\x03\
    Pet\x10\x08\x12\x0c\n\x08SewnInto\x10\t\x12\x0c\n\x08Strapped\x10\n\x1a\
    \0*Q\n\nArmorLayer\x12\x0f\n\x0bLAYER_UNDER\x10\0\x12\x0e\n\nLAYER_OVER\
    \x10\x01\x12\x0f\n\x0bLAYER_ARMOR\x10\x02\x12\x0f\n\x0bLAYER_COVER\x10\
    \x03\x1a\0*S\n\x0bMatterState\x12\t\n\x05Solid\x10\0\x12\n\n\x06Liquid\
    \x10\x01\x12\x07\n\x03Gas\x10\x02\x12\n\n\x06Powder\x10\x03\x12\t\n\x05P\
    aste\x10\x04\x12\x0b\n\x07Pressed\x10\x05\x1a\0*Q\n\tFrontType\x12\x0e\n\
    \nFRONT_NONE\x10\0\x12\x0e\n\nFRONT_WARM\x10\x01\x12\x0e\n\nFRONT_COLD\
    \x10\x02\x12\x12\n\x0eFRONT_OCCLUDED\x10\x03\x1a\0*\\\n\x0bCumulusType\
    \x12\x10\n\x0cCUMULUS_NONE\x10\0\x12\x12\n\x0eCUMULUS_MEDIUM\x10\x01\x12\
    \x11\n\rCUMULUS_MULTI\x10\x02\x12\x12\n\x0eCUMULUS_NIMBUS\x10\x03\x1a\0*\
    [\n\x0bStratusType\x12\x10\n\x0cSTRATUS_NONE\x10\0\x12\x10\n\x0cSTRATUS_\
    ALTO\x10\x01\x12\x12\n\x0eSTRATUS_PROPER\x10\x02\x12\x12\n\x0eSTRATUS_NI\
    MBUS\x10\x03\x1a\0*F\n\x07FogType\x12\x0c\n\x08FOG_NONE\x10\0\x12\x0c\n\
    \x08FOG_MIST\x10\x01\x12\x0e\n\nFOG_NORMAL\x10\x02\x12\r\n\tF0G_THICK\
    \x10\x03\x1a\0*_\n\x0bPatternType\x12\x0c\n\x08MONOTONE\x10\0\x12\x0b\n\
    \x07STRIPES\x10\x01\x12\x0c\n\x08IRIS_EYE\x10\x02\x12\t\n\x05SPOTS\x10\
    \x03\x12\r\n\tPUPIL_EYE\x10\x04\x12\x0b\n\x07MOTTLED\x10\x05\x1a\0*m\n\
    \x13ArtImageElementType\x12\x12\n\x0eIMAGE_CREATURE\x10\0\x12\x0f\n\x0bI\
    MAGE_PLANT\x10\x01\x12\x0e\n\nIMAGE_TREE\x10\x02\x12\x0f\n\x0bIMAGE_SHAP\
    E\x10\x03\x12\x0e\n\nIMAGE_ITEM\x10\x04\x1a\0*D\n\x14ArtImagePropertyTyp\
    e\x12\x13\n\x0fTRANSITIVE_VERB\x10\0\x12\x15\n\x11INTRANSITIVE_VERB\x10\
    \x01\x1a\0*\x97\x08\n\x0cArtImageVerb\x12\x12\n\x0eVERB_WITHERING\x10\0\
    \x12\x15\n\x11VERB_SURROUNDEDBY\x10\x01\x12\x13\n\x0fVERB_MASSACRING\x10\
    \x02\x12\x11\n\rVERB_FIGHTING\x10\x03\x12\x11\n\rVERB_LABORING\x10\x04\
    \x12\x11\n\rVERB_GREETING\x10\x05\x12\x11\n\rVERB_REFUSING\x10\x06\x12\
    \x11\n\rVERB_SPEAKING\x10\x07\x12\x12\n\x0eVERB_EMBRACING\x10\x08\x12\
    \x15\n\x11VERB_STRIKINGDOWN\x10\t\x12\x15\n\x11VERB_MENACINGPOSE\x10\n\
    \x12\x12\n\x0eVERB_TRAVELING\x10\x0b\x12\x10\n\x0cVERB_RAISING\x10\x0c\
    \x12\x0f\n\x0bVERB_HIDING\x10\r\x12\x18\n\x14VERB_LOOKINGCONFUSED\x10\
    \x0e\x12\x19\n\x15VERB_LOOKINGTERRIFIED\x10\x0f\x12\x12\n\x0eVERB_DEVOUR\
    ING\x10\x10\x12\x11\n\rVERB_ADMIRING\x10\x11\x12\x10\n\x0cVERB_BURNING\
    \x10\x12\x12\x10\n\x0cVERB_WEEPING\x10\x13\x12\x18\n\x14VERB_LOOKINGDEJE\
    CTED\x10\x14\x12\x11\n\rVERB_CRINGING\x10\x15\x12\x12\n\x0eVERB_SCREAMIN\
    G\x10\x16\x12\x1a\n\x16VERB_SUBMISSIVEGESTURE\x10\x17\x12\x16\n\x12VERB_\
    FETALPOSITION\x10\x18\x12\x1a\n\x16VERB_SMEAREDINTOSPIRAL\x10\x19\x12\
    \x10\n\x0cVERB_FALLING\x10\x1a\x12\r\n\tVERB_DEAD\x10\x1b\x12\x11\n\rVER\
    B_LAUGHING\x10\x1c\x12\x18\n\x14VERB_LOOKINGOFFENDED\x10\x1d\x12\x12\n\
    \x0eVERB_BEINGSHOT\x10\x1e\x12\x19\n\x15VERB_PLAINTIVEGESTURE\x10\x1f\
    \x12\x10\n\x0cVERB_MELTING\x10\x20\x12\x11\n\rVERB_SHOOTING\x10!\x12\x12\
    \n\x0eVERB_TORTURING\x10\"\x12\x1e\n\x1aVERB_COMMITTINGDEPRAVEDACT\x10#\
    \x12\x10\n\x0cVERB_PRAYING\x10$\x12\x16\n\x12VERB_CONTEMPLATING\x10%\x12\
    \x10\n\x0cVERB_COOKING\x10&\x12\x12\n\x0eVERB_ENGRAVING\x10'\x12\x14\n\
    \x10VERB_PROSTRATING\x10(\x12\x12\n\x0eVERB_SUFFERING\x10)\x12\x15\n\x11\
    VERB_BEINGIMPALED\x10*\x12\x17\n\x13VERB_BEINGCONTORTED\x10+\x12\x14\n\
    \x10VERB_BEINGFLAYED\x10,\x12\x14\n\x10VERB_HANGINGFROM\x10-\x12\x17\n\
    \x13VERB_BEINGMUTILATED\x10.\x12\x17\n\x13VERB_TRIUMPHANTPOSE\x10/\x1a\0\
    *\xe2\x01\n\x08FlowType\x12\n\n\x06Miasma\x10\0\x12\t\n\x05Steam\x10\x01\
    \x12\x08\n\x04Mist\x10\x02\x12\x10\n\x0cMaterialDust\x10\x03\x12\r\n\tMa\
    gmaMist\x10\x04\x12\t\n\x05Smoke\x10\x05\x12\x0e\n\nDragonfire\x10\x06\
    \x12\x08\n\x04Fire\x10\x07\x12\x07\n\x03Web\x10\x08\x12\x0f\n\x0bMateria\
    lGas\x10\t\x12\x11\n\rMaterialVapor\x10\n\x12\r\n\tOceanWave\x10\x0b\x12\
    \x0b\n\x07SeaFoam\x10\x0c\x12\r\n\tItemCloud\x10\r\x12\x15\n\x08CampFire\
    \x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x1a\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
