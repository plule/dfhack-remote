// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `RemoteFortressReader.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
#[derive(Hash, Eq)]
// @@protoc_insertion_point(message:RemoteFortressReader.Coord)
pub struct Coord {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Coord.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Coord.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Coord.z)
    pub z: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Coord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Coord {
    fn default() -> &'a Coord {
        <Coord as ::protobuf::Message>::default_instance()
    }
}

impl Coord {
    pub fn new() -> Coord {
        ::std::default::Default::default()
    }

    // optional int32 x = 1;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 2;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 z = 3;

    pub fn z(&self) -> i32 {
        self.z.unwrap_or(0)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: i32) {
        self.z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &Coord| { &m.x },
            |m: &mut Coord| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &Coord| { &m.y },
            |m: &mut Coord| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &Coord| { &m.z },
            |m: &mut Coord| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Coord>(
            "Coord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Coord {
    const NAME: &'static str = "Coord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.z = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.z {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Coord {
        Coord::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Coord {
        static instance: Coord = Coord {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Coord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Coord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Coord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Coord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Tiletype)
pub struct Tiletype {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.shape)
    pub shape: ::std::option::Option<::protobuf::EnumOrUnknown<TiletypeShape>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.special)
    pub special: ::std::option::Option<::protobuf::EnumOrUnknown<TiletypeSpecial>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.material)
    pub material: ::std::option::Option<::protobuf::EnumOrUnknown<TiletypeMaterial>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.variant)
    pub variant: ::std::option::Option<::protobuf::EnumOrUnknown<TiletypeVariant>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Tiletype.direction)
    pub direction: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Tiletype.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tiletype {
    fn default() -> &'a Tiletype {
        <Tiletype as ::protobuf::Message>::default_instance()
    }
}

impl Tiletype {
    pub fn new() -> Tiletype {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.TiletypeShape shape = 4;

    pub fn shape(&self) -> TiletypeShape {
        match self.shape {
            Some(e) => e.enum_value_or(TiletypeShape::NO_SHAPE),
            None => TiletypeShape::NO_SHAPE,
        }
    }

    pub fn clear_shape(&mut self) {
        self.shape = ::std::option::Option::None;
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: TiletypeShape) {
        self.shape = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RemoteFortressReader.TiletypeSpecial special = 5;

    pub fn special(&self) -> TiletypeSpecial {
        match self.special {
            Some(e) => e.enum_value_or(TiletypeSpecial::NO_SPECIAL),
            None => TiletypeSpecial::NO_SPECIAL,
        }
    }

    pub fn clear_special(&mut self) {
        self.special = ::std::option::Option::None;
    }

    pub fn has_special(&self) -> bool {
        self.special.is_some()
    }

    // Param is passed by value, moved
    pub fn set_special(&mut self, v: TiletypeSpecial) {
        self.special = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RemoteFortressReader.TiletypeMaterial material = 6;

    pub fn material(&self) -> TiletypeMaterial {
        match self.material {
            Some(e) => e.enum_value_or(TiletypeMaterial::NO_MATERIAL),
            None => TiletypeMaterial::NO_MATERIAL,
        }
    }

    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: TiletypeMaterial) {
        self.material = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RemoteFortressReader.TiletypeVariant variant = 7;

    pub fn variant(&self) -> TiletypeVariant {
        match self.variant {
            Some(e) => e.enum_value_or(TiletypeVariant::NO_VARIANT),
            None => TiletypeVariant::NO_VARIANT,
        }
    }

    pub fn clear_variant(&mut self) {
        self.variant = ::std::option::Option::None;
    }

    pub fn has_variant(&self) -> bool {
        self.variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: TiletypeVariant) {
        self.variant = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string direction = 8;

    pub fn direction(&self) -> &str {
        match self.direction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        if self.direction.is_none() {
            self.direction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.direction.as_mut().unwrap()
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        self.direction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Tiletype| { &m.id },
            |m: &mut Tiletype| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Tiletype| { &m.name },
            |m: &mut Tiletype| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &Tiletype| { &m.caption },
            |m: &mut Tiletype| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shape",
            |m: &Tiletype| { &m.shape },
            |m: &mut Tiletype| { &mut m.shape },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "special",
            |m: &Tiletype| { &m.special },
            |m: &mut Tiletype| { &mut m.special },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "material",
            |m: &Tiletype| { &m.material },
            |m: &mut Tiletype| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "variant",
            |m: &Tiletype| { &m.variant },
            |m: &mut Tiletype| { &mut m.variant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction",
            |m: &Tiletype| { &m.direction },
            |m: &mut Tiletype| { &mut m.direction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tiletype>(
            "Tiletype",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tiletype {
    const NAME: &'static str = "Tiletype";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.shape = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.special = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.material = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.variant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                66 => {
                    self.direction = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.shape {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.special {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.variant {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.direction.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.shape {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.special {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.material {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.variant {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.direction.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tiletype {
        Tiletype::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.shape = ::std::option::Option::None;
        self.special = ::std::option::Option::None;
        self.material = ::std::option::Option::None;
        self.variant = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tiletype {
        static instance: Tiletype = Tiletype {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            shape: ::std::option::Option::None,
            special: ::std::option::Option::None,
            material: ::std::option::Option::None,
            variant: ::std::option::Option::None,
            direction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tiletype {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tiletype").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tiletype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tiletype {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.TiletypeList)
pub struct TiletypeList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.TiletypeList.tiletype_list)
    pub tiletype_list: ::std::vec::Vec<Tiletype>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.TiletypeList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TiletypeList {
    fn default() -> &'a TiletypeList {
        <TiletypeList as ::protobuf::Message>::default_instance()
    }
}

impl TiletypeList {
    pub fn new() -> TiletypeList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tiletype_list",
            |m: &TiletypeList| { &m.tiletype_list },
            |m: &mut TiletypeList| { &mut m.tiletype_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TiletypeList>(
            "TiletypeList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TiletypeList {
    const NAME: &'static str = "TiletypeList";

    fn is_initialized(&self) -> bool {
        for v in &self.tiletype_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tiletype_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tiletype_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tiletype_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TiletypeList {
        TiletypeList::new()
    }

    fn clear(&mut self) {
        self.tiletype_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TiletypeList {
        static instance: TiletypeList = TiletypeList {
            tiletype_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TiletypeList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TiletypeList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TiletypeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TiletypeList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BuildingExtents)
pub struct BuildingExtents {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingExtents.pos_x)
    pub pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingExtents.pos_y)
    pub pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingExtents.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingExtents.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingExtents.extents)
    pub extents: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BuildingExtents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildingExtents {
    fn default() -> &'a BuildingExtents {
        <BuildingExtents as ::protobuf::Message>::default_instance()
    }
}

impl BuildingExtents {
    pub fn new() -> BuildingExtents {
        ::std::default::Default::default()
    }

    // required int32 pos_x = 1;

    pub fn pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // required int32 pos_y = 2;

    pub fn pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // required int32 width = 3;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required int32 height = 4;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &BuildingExtents| { &m.pos_x },
            |m: &mut BuildingExtents| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &BuildingExtents| { &m.pos_y },
            |m: &mut BuildingExtents| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &BuildingExtents| { &m.width },
            |m: &mut BuildingExtents| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &BuildingExtents| { &m.height },
            |m: &mut BuildingExtents| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extents",
            |m: &BuildingExtents| { &m.extents },
            |m: &mut BuildingExtents| { &mut m.extents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingExtents>(
            "BuildingExtents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildingExtents {
    const NAME: &'static str = "BuildingExtents";

    fn is_initialized(&self) -> bool {
        if self.pos_x.is_none() {
            return false;
        }
        if self.pos_y.is_none() {
            return false;
        }
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.extents)?;
                },
                40 => {
                    self.extents.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.extents {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        for v in &self.extents {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildingExtents {
        BuildingExtents::new()
    }

    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.extents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildingExtents {
        static instance: BuildingExtents = BuildingExtents {
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            extents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildingExtents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildingExtents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildingExtents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingExtents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BuildingItem)
pub struct BuildingItem {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingItem.item)
    pub item: ::protobuf::MessageField<Item>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingItem.mode)
    pub mode: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BuildingItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildingItem {
    fn default() -> &'a BuildingItem {
        <BuildingItem as ::protobuf::Message>::default_instance()
    }
}

impl BuildingItem {
    pub fn new() -> BuildingItem {
        ::std::default::Default::default()
    }

    // optional int32 mode = 2;

    pub fn mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "item",
            |m: &BuildingItem| { &m.item },
            |m: &mut BuildingItem| { &mut m.item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &BuildingItem| { &m.mode },
            |m: &mut BuildingItem| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingItem>(
            "BuildingItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildingItem {
    const NAME: &'static str = "BuildingItem";

    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                16 => {
                    self.mode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildingItem {
        BuildingItem::new()
    }

    fn clear(&mut self) {
        self.item.clear();
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildingItem {
        static instance: BuildingItem = BuildingItem {
            item: ::protobuf::MessageField::none(),
            mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildingItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildingItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildingItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BuildingInstance)
pub struct BuildingInstance {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.pos_x_min)
    pub pos_x_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.pos_y_min)
    pub pos_y_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.pos_z_min)
    pub pos_z_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.pos_x_max)
    pub pos_x_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.pos_y_max)
    pub pos_y_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.pos_z_max)
    pub pos_z_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.building_type)
    pub building_type: ::protobuf::MessageField<BuildingType>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.building_flags)
    pub building_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.is_room)
    pub is_room: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.room)
    pub room: ::protobuf::MessageField<BuildingExtents>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.direction)
    pub direction: ::std::option::Option<::protobuf::EnumOrUnknown<BuildingDirection>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.items)
    pub items: ::std::vec::Vec<BuildingItem>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingInstance.active)
    pub active: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BuildingInstance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildingInstance {
    fn default() -> &'a BuildingInstance {
        <BuildingInstance as ::protobuf::Message>::default_instance()
    }
}

impl BuildingInstance {
    pub fn new() -> BuildingInstance {
        ::std::default::Default::default()
    }

    // required int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x_min = 2;

    pub fn pos_x_min(&self) -> i32 {
        self.pos_x_min.unwrap_or(0)
    }

    pub fn clear_pos_x_min(&mut self) {
        self.pos_x_min = ::std::option::Option::None;
    }

    pub fn has_pos_x_min(&self) -> bool {
        self.pos_x_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x_min(&mut self, v: i32) {
        self.pos_x_min = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y_min = 3;

    pub fn pos_y_min(&self) -> i32 {
        self.pos_y_min.unwrap_or(0)
    }

    pub fn clear_pos_y_min(&mut self) {
        self.pos_y_min = ::std::option::Option::None;
    }

    pub fn has_pos_y_min(&self) -> bool {
        self.pos_y_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y_min(&mut self, v: i32) {
        self.pos_y_min = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z_min = 4;

    pub fn pos_z_min(&self) -> i32 {
        self.pos_z_min.unwrap_or(0)
    }

    pub fn clear_pos_z_min(&mut self) {
        self.pos_z_min = ::std::option::Option::None;
    }

    pub fn has_pos_z_min(&self) -> bool {
        self.pos_z_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z_min(&mut self, v: i32) {
        self.pos_z_min = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x_max = 5;

    pub fn pos_x_max(&self) -> i32 {
        self.pos_x_max.unwrap_or(0)
    }

    pub fn clear_pos_x_max(&mut self) {
        self.pos_x_max = ::std::option::Option::None;
    }

    pub fn has_pos_x_max(&self) -> bool {
        self.pos_x_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x_max(&mut self, v: i32) {
        self.pos_x_max = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y_max = 6;

    pub fn pos_y_max(&self) -> i32 {
        self.pos_y_max.unwrap_or(0)
    }

    pub fn clear_pos_y_max(&mut self) {
        self.pos_y_max = ::std::option::Option::None;
    }

    pub fn has_pos_y_max(&self) -> bool {
        self.pos_y_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y_max(&mut self, v: i32) {
        self.pos_y_max = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z_max = 7;

    pub fn pos_z_max(&self) -> i32 {
        self.pos_z_max.unwrap_or(0)
    }

    pub fn clear_pos_z_max(&mut self) {
        self.pos_z_max = ::std::option::Option::None;
    }

    pub fn has_pos_z_max(&self) -> bool {
        self.pos_z_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z_max(&mut self, v: i32) {
        self.pos_z_max = ::std::option::Option::Some(v);
    }

    // optional uint32 building_flags = 10;

    pub fn building_flags(&self) -> u32 {
        self.building_flags.unwrap_or(0)
    }

    pub fn clear_building_flags(&mut self) {
        self.building_flags = ::std::option::Option::None;
    }

    pub fn has_building_flags(&self) -> bool {
        self.building_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_flags(&mut self, v: u32) {
        self.building_flags = ::std::option::Option::Some(v);
    }

    // optional bool is_room = 11;

    pub fn is_room(&self) -> bool {
        self.is_room.unwrap_or(false)
    }

    pub fn clear_is_room(&mut self) {
        self.is_room = ::std::option::Option::None;
    }

    pub fn has_is_room(&self) -> bool {
        self.is_room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_room(&mut self, v: bool) {
        self.is_room = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.BuildingDirection direction = 13;

    pub fn direction(&self) -> BuildingDirection {
        match self.direction {
            Some(e) => e.enum_value_or(BuildingDirection::NORTH),
            None => BuildingDirection::NORTH,
        }
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: BuildingDirection) {
        self.direction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 active = 15;

    pub fn active(&self) -> i32 {
        self.active.unwrap_or(0)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: i32) {
        self.active = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &BuildingInstance| { &m.index },
            |m: &mut BuildingInstance| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x_min",
            |m: &BuildingInstance| { &m.pos_x_min },
            |m: &mut BuildingInstance| { &mut m.pos_x_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y_min",
            |m: &BuildingInstance| { &m.pos_y_min },
            |m: &mut BuildingInstance| { &mut m.pos_y_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z_min",
            |m: &BuildingInstance| { &m.pos_z_min },
            |m: &mut BuildingInstance| { &mut m.pos_z_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x_max",
            |m: &BuildingInstance| { &m.pos_x_max },
            |m: &mut BuildingInstance| { &mut m.pos_x_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y_max",
            |m: &BuildingInstance| { &m.pos_y_max },
            |m: &mut BuildingInstance| { &mut m.pos_y_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z_max",
            |m: &BuildingInstance| { &m.pos_z_max },
            |m: &mut BuildingInstance| { &mut m.pos_z_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildingType>(
            "building_type",
            |m: &BuildingInstance| { &m.building_type },
            |m: &mut BuildingInstance| { &mut m.building_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &BuildingInstance| { &m.material },
            |m: &mut BuildingInstance| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_flags",
            |m: &BuildingInstance| { &m.building_flags },
            |m: &mut BuildingInstance| { &mut m.building_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_room",
            |m: &BuildingInstance| { &m.is_room },
            |m: &mut BuildingInstance| { &mut m.is_room },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildingExtents>(
            "room",
            |m: &BuildingInstance| { &m.room },
            |m: &mut BuildingInstance| { &mut m.room },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction",
            |m: &BuildingInstance| { &m.direction },
            |m: &mut BuildingInstance| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &BuildingInstance| { &m.items },
            |m: &mut BuildingInstance| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active",
            |m: &BuildingInstance| { &m.active },
            |m: &mut BuildingInstance| { &mut m.active },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingInstance>(
            "BuildingInstance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildingInstance {
    const NAME: &'static str = "BuildingInstance";

    fn is_initialized(&self) -> bool {
        if self.index.is_none() {
            return false;
        }
        for v in &self.building_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.room {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pos_x_min = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.pos_y_min = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.pos_z_min = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.pos_x_max = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.pos_y_max = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.pos_z_max = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.building_type)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                80 => {
                    self.building_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.is_room = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.room)?;
                },
                104 => {
                    self.direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                114 => {
                    self.items.push(is.read_message()?);
                },
                120 => {
                    self.active = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_x_min {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.pos_y_min {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.pos_z_min {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.pos_x_max {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.pos_y_max {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.pos_z_max {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.building_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.building_flags {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.is_room {
            my_size += 1 + 1;
        }
        if let Some(v) = self.room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.active {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x_min {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos_y_min {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos_z_min {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.pos_x_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.pos_y_max {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pos_z_max {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.building_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.building_flags {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.is_room {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.room.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.active {
            os.write_int32(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildingInstance {
        BuildingInstance::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.pos_x_min = ::std::option::Option::None;
        self.pos_y_min = ::std::option::Option::None;
        self.pos_z_min = ::std::option::Option::None;
        self.pos_x_max = ::std::option::Option::None;
        self.pos_y_max = ::std::option::Option::None;
        self.pos_z_max = ::std::option::Option::None;
        self.building_type.clear();
        self.material.clear();
        self.building_flags = ::std::option::Option::None;
        self.is_room = ::std::option::Option::None;
        self.room.clear();
        self.direction = ::std::option::Option::None;
        self.items.clear();
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildingInstance {
        static instance: BuildingInstance = BuildingInstance {
            index: ::std::option::Option::None,
            pos_x_min: ::std::option::Option::None,
            pos_y_min: ::std::option::Option::None,
            pos_z_min: ::std::option::Option::None,
            pos_x_max: ::std::option::Option::None,
            pos_y_max: ::std::option::Option::None,
            pos_z_max: ::std::option::Option::None,
            building_type: ::protobuf::MessageField::none(),
            material: ::protobuf::MessageField::none(),
            building_flags: ::std::option::Option::None,
            is_room: ::std::option::Option::None,
            room: ::protobuf::MessageField::none(),
            direction: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            active: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildingInstance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildingInstance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildingInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingInstance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.RiverEdge)
pub struct RiverEdge {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverEdge.min_pos)
    pub min_pos: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverEdge.max_pos)
    pub max_pos: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverEdge.active)
    pub active: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverEdge.elevation)
    pub elevation: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.RiverEdge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RiverEdge {
    fn default() -> &'a RiverEdge {
        <RiverEdge as ::protobuf::Message>::default_instance()
    }
}

impl RiverEdge {
    pub fn new() -> RiverEdge {
        ::std::default::Default::default()
    }

    // optional int32 min_pos = 1;

    pub fn min_pos(&self) -> i32 {
        self.min_pos.unwrap_or(0)
    }

    pub fn clear_min_pos(&mut self) {
        self.min_pos = ::std::option::Option::None;
    }

    pub fn has_min_pos(&self) -> bool {
        self.min_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_pos(&mut self, v: i32) {
        self.min_pos = ::std::option::Option::Some(v);
    }

    // optional int32 max_pos = 2;

    pub fn max_pos(&self) -> i32 {
        self.max_pos.unwrap_or(0)
    }

    pub fn clear_max_pos(&mut self) {
        self.max_pos = ::std::option::Option::None;
    }

    pub fn has_max_pos(&self) -> bool {
        self.max_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_pos(&mut self, v: i32) {
        self.max_pos = ::std::option::Option::Some(v);
    }

    // optional int32 active = 3;

    pub fn active(&self) -> i32 {
        self.active.unwrap_or(0)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: i32) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional int32 elevation = 4;

    pub fn elevation(&self) -> i32 {
        self.elevation.unwrap_or(0)
    }

    pub fn clear_elevation(&mut self) {
        self.elevation = ::std::option::Option::None;
    }

    pub fn has_elevation(&self) -> bool {
        self.elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevation(&mut self, v: i32) {
        self.elevation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_pos",
            |m: &RiverEdge| { &m.min_pos },
            |m: &mut RiverEdge| { &mut m.min_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_pos",
            |m: &RiverEdge| { &m.max_pos },
            |m: &mut RiverEdge| { &mut m.max_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active",
            |m: &RiverEdge| { &m.active },
            |m: &mut RiverEdge| { &mut m.active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevation",
            |m: &RiverEdge| { &m.elevation },
            |m: &mut RiverEdge| { &mut m.elevation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RiverEdge>(
            "RiverEdge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RiverEdge {
    const NAME: &'static str = "RiverEdge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.min_pos = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.max_pos = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.active = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.elevation = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.min_pos {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.max_pos {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.active {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.elevation {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.min_pos {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.max_pos {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.active {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.elevation {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RiverEdge {
        RiverEdge::new()
    }

    fn clear(&mut self) {
        self.min_pos = ::std::option::Option::None;
        self.max_pos = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.elevation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RiverEdge {
        static instance: RiverEdge = RiverEdge {
            min_pos: ::std::option::Option::None,
            max_pos: ::std::option::Option::None,
            active: ::std::option::Option::None,
            elevation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RiverEdge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RiverEdge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RiverEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiverEdge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.RiverTile)
pub struct RiverTile {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverTile.north)
    pub north: ::protobuf::MessageField<RiverEdge>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverTile.south)
    pub south: ::protobuf::MessageField<RiverEdge>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverTile.east)
    pub east: ::protobuf::MessageField<RiverEdge>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RiverTile.west)
    pub west: ::protobuf::MessageField<RiverEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.RiverTile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RiverTile {
    fn default() -> &'a RiverTile {
        <RiverTile as ::protobuf::Message>::default_instance()
    }
}

impl RiverTile {
    pub fn new() -> RiverTile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RiverEdge>(
            "north",
            |m: &RiverTile| { &m.north },
            |m: &mut RiverTile| { &mut m.north },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RiverEdge>(
            "south",
            |m: &RiverTile| { &m.south },
            |m: &mut RiverTile| { &mut m.south },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RiverEdge>(
            "east",
            |m: &RiverTile| { &m.east },
            |m: &mut RiverTile| { &mut m.east },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RiverEdge>(
            "west",
            |m: &RiverTile| { &m.west },
            |m: &mut RiverTile| { &mut m.west },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RiverTile>(
            "RiverTile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RiverTile {
    const NAME: &'static str = "RiverTile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.north)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.south)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.east)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.west)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.north.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.south.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.east.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.west.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.north.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.south.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.east.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.west.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RiverTile {
        RiverTile::new()
    }

    fn clear(&mut self) {
        self.north.clear();
        self.south.clear();
        self.east.clear();
        self.west.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RiverTile {
        static instance: RiverTile = RiverTile {
            north: ::protobuf::MessageField::none(),
            south: ::protobuf::MessageField::none(),
            east: ::protobuf::MessageField::none(),
            west: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RiverTile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RiverTile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RiverTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiverTile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Spatter)
pub struct Spatter {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Spatter.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Spatter.amount)
    pub amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Spatter.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<MatterState>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Spatter.item)
    pub item: ::protobuf::MessageField<MatPair>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Spatter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Spatter {
    fn default() -> &'a Spatter {
        <Spatter as ::protobuf::Message>::default_instance()
    }
}

impl Spatter {
    pub fn new() -> Spatter {
        ::std::default::Default::default()
    }

    // optional int32 amount = 2;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.MatterState state = 3;

    pub fn state(&self) -> MatterState {
        match self.state {
            Some(e) => e.enum_value_or(MatterState::Solid),
            None => MatterState::Solid,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: MatterState) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &Spatter| { &m.material },
            |m: &mut Spatter| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &Spatter| { &m.amount },
            |m: &mut Spatter| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &Spatter| { &m.state },
            |m: &mut Spatter| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "item",
            |m: &Spatter| { &m.item },
            |m: &mut Spatter| { &mut m.item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Spatter>(
            "Spatter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Spatter {
    const NAME: &'static str = "Spatter";

    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                16 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.amount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Spatter {
        Spatter::new()
    }

    fn clear(&mut self) {
        self.material.clear();
        self.amount = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.item.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Spatter {
        static instance: Spatter = Spatter {
            material: ::protobuf::MessageField::none(),
            amount: ::std::option::Option::None,
            state: ::std::option::Option::None,
            item: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Spatter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Spatter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Spatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Spatter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.SpatterPile)
pub struct SpatterPile {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.SpatterPile.spatters)
    pub spatters: ::std::vec::Vec<Spatter>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.SpatterPile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SpatterPile {
    fn default() -> &'a SpatterPile {
        <SpatterPile as ::protobuf::Message>::default_instance()
    }
}

impl SpatterPile {
    pub fn new() -> SpatterPile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "spatters",
            |m: &SpatterPile| { &m.spatters },
            |m: &mut SpatterPile| { &mut m.spatters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpatterPile>(
            "SpatterPile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SpatterPile {
    const NAME: &'static str = "SpatterPile";

    fn is_initialized(&self) -> bool {
        for v in &self.spatters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.spatters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.spatters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.spatters {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SpatterPile {
        SpatterPile::new()
    }

    fn clear(&mut self) {
        self.spatters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SpatterPile {
        static instance: SpatterPile = SpatterPile {
            spatters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SpatterPile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SpatterPile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SpatterPile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatterPile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Item)
pub struct Item {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.pos)
    pub pos: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.flags1)
    pub flags1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.flags2)
    pub flags2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.type)
    pub type_: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.dye)
    pub dye: ::protobuf::MessageField<ColorDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.stack_size)
    pub stack_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.subpos_x)
    pub subpos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.subpos_y)
    pub subpos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.subpos_z)
    pub subpos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.projectile)
    pub projectile: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.velocity_x)
    pub velocity_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.velocity_y)
    pub velocity_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.velocity_z)
    pub velocity_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.volume)
    pub volume: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.improvements)
    pub improvements: ::std::vec::Vec<ItemImprovement>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Item.image)
    pub image: ::protobuf::MessageField<ArtImage>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Item.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Item {
    fn default() -> &'a Item {
        <Item as ::protobuf::Message>::default_instance()
    }
}

impl Item {
    pub fn new() -> Item {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 flags1 = 3;

    pub fn flags1(&self) -> u32 {
        self.flags1.unwrap_or(0)
    }

    pub fn clear_flags1(&mut self) {
        self.flags1 = ::std::option::Option::None;
    }

    pub fn has_flags1(&self) -> bool {
        self.flags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags1(&mut self, v: u32) {
        self.flags1 = ::std::option::Option::Some(v);
    }

    // optional uint32 flags2 = 4;

    pub fn flags2(&self) -> u32 {
        self.flags2.unwrap_or(0)
    }

    pub fn clear_flags2(&mut self) {
        self.flags2 = ::std::option::Option::None;
    }

    pub fn has_flags2(&self) -> bool {
        self.flags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags2(&mut self, v: u32) {
        self.flags2 = ::std::option::Option::Some(v);
    }

    // optional int32 stack_size = 8;

    pub fn stack_size(&self) -> i32 {
        self.stack_size.unwrap_or(0)
    }

    pub fn clear_stack_size(&mut self) {
        self.stack_size = ::std::option::Option::None;
    }

    pub fn has_stack_size(&self) -> bool {
        self.stack_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_size(&mut self, v: i32) {
        self.stack_size = ::std::option::Option::Some(v);
    }

    // optional float subpos_x = 9;

    pub fn subpos_x(&self) -> f32 {
        self.subpos_x.unwrap_or(0.)
    }

    pub fn clear_subpos_x(&mut self) {
        self.subpos_x = ::std::option::Option::None;
    }

    pub fn has_subpos_x(&self) -> bool {
        self.subpos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_x(&mut self, v: f32) {
        self.subpos_x = ::std::option::Option::Some(v);
    }

    // optional float subpos_y = 10;

    pub fn subpos_y(&self) -> f32 {
        self.subpos_y.unwrap_or(0.)
    }

    pub fn clear_subpos_y(&mut self) {
        self.subpos_y = ::std::option::Option::None;
    }

    pub fn has_subpos_y(&self) -> bool {
        self.subpos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_y(&mut self, v: f32) {
        self.subpos_y = ::std::option::Option::Some(v);
    }

    // optional float subpos_z = 11;

    pub fn subpos_z(&self) -> f32 {
        self.subpos_z.unwrap_or(0.)
    }

    pub fn clear_subpos_z(&mut self) {
        self.subpos_z = ::std::option::Option::None;
    }

    pub fn has_subpos_z(&self) -> bool {
        self.subpos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_z(&mut self, v: f32) {
        self.subpos_z = ::std::option::Option::Some(v);
    }

    // optional bool projectile = 12;

    pub fn projectile(&self) -> bool {
        self.projectile.unwrap_or(false)
    }

    pub fn clear_projectile(&mut self) {
        self.projectile = ::std::option::Option::None;
    }

    pub fn has_projectile(&self) -> bool {
        self.projectile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectile(&mut self, v: bool) {
        self.projectile = ::std::option::Option::Some(v);
    }

    // optional float velocity_x = 13;

    pub fn velocity_x(&self) -> f32 {
        self.velocity_x.unwrap_or(0.)
    }

    pub fn clear_velocity_x(&mut self) {
        self.velocity_x = ::std::option::Option::None;
    }

    pub fn has_velocity_x(&self) -> bool {
        self.velocity_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_x(&mut self, v: f32) {
        self.velocity_x = ::std::option::Option::Some(v);
    }

    // optional float velocity_y = 14;

    pub fn velocity_y(&self) -> f32 {
        self.velocity_y.unwrap_or(0.)
    }

    pub fn clear_velocity_y(&mut self) {
        self.velocity_y = ::std::option::Option::None;
    }

    pub fn has_velocity_y(&self) -> bool {
        self.velocity_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_y(&mut self, v: f32) {
        self.velocity_y = ::std::option::Option::Some(v);
    }

    // optional float velocity_z = 15;

    pub fn velocity_z(&self) -> f32 {
        self.velocity_z.unwrap_or(0.)
    }

    pub fn clear_velocity_z(&mut self) {
        self.velocity_z = ::std::option::Option::None;
    }

    pub fn has_velocity_z(&self) -> bool {
        self.velocity_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_z(&mut self, v: f32) {
        self.velocity_z = ::std::option::Option::Some(v);
    }

    // optional int32 volume = 16;

    pub fn volume(&self) -> i32 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i32) {
        self.volume = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Item| { &m.id },
            |m: &mut Item| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "pos",
            |m: &Item| { &m.pos },
            |m: &mut Item| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags1",
            |m: &Item| { &m.flags1 },
            |m: &mut Item| { &mut m.flags1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags2",
            |m: &Item| { &m.flags2 },
            |m: &mut Item| { &mut m.flags2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "type",
            |m: &Item| { &m.type_ },
            |m: &mut Item| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &Item| { &m.material },
            |m: &mut Item| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ColorDefinition>(
            "dye",
            |m: &Item| { &m.dye },
            |m: &mut Item| { &mut m.dye },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_size",
            |m: &Item| { &m.stack_size },
            |m: &mut Item| { &mut m.stack_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subpos_x",
            |m: &Item| { &m.subpos_x },
            |m: &mut Item| { &mut m.subpos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subpos_y",
            |m: &Item| { &m.subpos_y },
            |m: &mut Item| { &mut m.subpos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subpos_z",
            |m: &Item| { &m.subpos_z },
            |m: &mut Item| { &mut m.subpos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "projectile",
            |m: &Item| { &m.projectile },
            |m: &mut Item| { &mut m.projectile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "velocity_x",
            |m: &Item| { &m.velocity_x },
            |m: &mut Item| { &mut m.velocity_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "velocity_y",
            |m: &Item| { &m.velocity_y },
            |m: &mut Item| { &mut m.velocity_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "velocity_z",
            |m: &Item| { &m.velocity_z },
            |m: &mut Item| { &mut m.velocity_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &Item| { &m.volume },
            |m: &mut Item| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "improvements",
            |m: &Item| { &m.improvements },
            |m: &mut Item| { &mut m.improvements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArtImage>(
            "image",
            |m: &Item| { &m.image },
            |m: &mut Item| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
            "Item",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Item {
    const NAME: &'static str = "Item";

    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dye {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.improvements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                24 => {
                    self.flags1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.flags2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dye)?;
                },
                64 => {
                    self.stack_size = ::std::option::Option::Some(is.read_int32()?);
                },
                77 => {
                    self.subpos_x = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.subpos_y = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.subpos_z = ::std::option::Option::Some(is.read_float()?);
                },
                96 => {
                    self.projectile = ::std::option::Option::Some(is.read_bool()?);
                },
                109 => {
                    self.velocity_x = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.velocity_y = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.velocity_z = ::std::option::Option::Some(is.read_float()?);
                },
                128 => {
                    self.volume = ::std::option::Option::Some(is.read_int32()?);
                },
                138 => {
                    self.improvements.push(is.read_message()?);
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flags1 {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.flags2 {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dye.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stack_size {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.subpos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.subpos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.subpos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.projectile {
            my_size += 1 + 1;
        }
        if let Some(v) = self.velocity_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.velocity_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.velocity_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        for value in &self.improvements {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.flags1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.flags2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.dye.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.stack_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.subpos_x {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.subpos_y {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.subpos_z {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.projectile {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.velocity_x {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.velocity_y {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.velocity_z {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int32(16, v)?;
        }
        for v in &self.improvements {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Item {
        Item::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.pos.clear();
        self.flags1 = ::std::option::Option::None;
        self.flags2 = ::std::option::Option::None;
        self.type_.clear();
        self.material.clear();
        self.dye.clear();
        self.stack_size = ::std::option::Option::None;
        self.subpos_x = ::std::option::Option::None;
        self.subpos_y = ::std::option::Option::None;
        self.subpos_z = ::std::option::Option::None;
        self.projectile = ::std::option::Option::None;
        self.velocity_x = ::std::option::Option::None;
        self.velocity_y = ::std::option::Option::None;
        self.velocity_z = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.improvements.clear();
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Item {
        static instance: Item = Item {
            id: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            flags1: ::std::option::Option::None,
            flags2: ::std::option::Option::None,
            type_: ::protobuf::MessageField::none(),
            material: ::protobuf::MessageField::none(),
            dye: ::protobuf::MessageField::none(),
            stack_size: ::std::option::Option::None,
            subpos_x: ::std::option::Option::None,
            subpos_y: ::std::option::Option::None,
            subpos_z: ::std::option::Option::None,
            projectile: ::std::option::Option::None,
            velocity_x: ::std::option::Option::None,
            velocity_y: ::std::option::Option::None,
            velocity_z: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            improvements: ::std::vec::Vec::new(),
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Item {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Item").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Item {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PlantTile)
pub struct PlantTile {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.trunk)
    pub trunk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.connection_east)
    pub connection_east: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.connection_south)
    pub connection_south: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.connection_west)
    pub connection_west: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.connection_north)
    pub connection_north: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.branches)
    pub branches: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.twigs)
    pub twigs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantTile.tile_type)
    pub tile_type: ::std::option::Option<::protobuf::EnumOrUnknown<TiletypeSpecial>>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PlantTile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlantTile {
    fn default() -> &'a PlantTile {
        <PlantTile as ::protobuf::Message>::default_instance()
    }
}

impl PlantTile {
    pub fn new() -> PlantTile {
        ::std::default::Default::default()
    }

    // optional bool trunk = 1;

    pub fn trunk(&self) -> bool {
        self.trunk.unwrap_or(false)
    }

    pub fn clear_trunk(&mut self) {
        self.trunk = ::std::option::Option::None;
    }

    pub fn has_trunk(&self) -> bool {
        self.trunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk(&mut self, v: bool) {
        self.trunk = ::std::option::Option::Some(v);
    }

    // optional bool connection_east = 2;

    pub fn connection_east(&self) -> bool {
        self.connection_east.unwrap_or(false)
    }

    pub fn clear_connection_east(&mut self) {
        self.connection_east = ::std::option::Option::None;
    }

    pub fn has_connection_east(&self) -> bool {
        self.connection_east.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_east(&mut self, v: bool) {
        self.connection_east = ::std::option::Option::Some(v);
    }

    // optional bool connection_south = 3;

    pub fn connection_south(&self) -> bool {
        self.connection_south.unwrap_or(false)
    }

    pub fn clear_connection_south(&mut self) {
        self.connection_south = ::std::option::Option::None;
    }

    pub fn has_connection_south(&self) -> bool {
        self.connection_south.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_south(&mut self, v: bool) {
        self.connection_south = ::std::option::Option::Some(v);
    }

    // optional bool connection_west = 4;

    pub fn connection_west(&self) -> bool {
        self.connection_west.unwrap_or(false)
    }

    pub fn clear_connection_west(&mut self) {
        self.connection_west = ::std::option::Option::None;
    }

    pub fn has_connection_west(&self) -> bool {
        self.connection_west.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_west(&mut self, v: bool) {
        self.connection_west = ::std::option::Option::Some(v);
    }

    // optional bool connection_north = 5;

    pub fn connection_north(&self) -> bool {
        self.connection_north.unwrap_or(false)
    }

    pub fn clear_connection_north(&mut self) {
        self.connection_north = ::std::option::Option::None;
    }

    pub fn has_connection_north(&self) -> bool {
        self.connection_north.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_north(&mut self, v: bool) {
        self.connection_north = ::std::option::Option::Some(v);
    }

    // optional bool branches = 6;

    pub fn branches(&self) -> bool {
        self.branches.unwrap_or(false)
    }

    pub fn clear_branches(&mut self) {
        self.branches = ::std::option::Option::None;
    }

    pub fn has_branches(&self) -> bool {
        self.branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branches(&mut self, v: bool) {
        self.branches = ::std::option::Option::Some(v);
    }

    // optional bool twigs = 7;

    pub fn twigs(&self) -> bool {
        self.twigs.unwrap_or(false)
    }

    pub fn clear_twigs(&mut self) {
        self.twigs = ::std::option::Option::None;
    }

    pub fn has_twigs(&self) -> bool {
        self.twigs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twigs(&mut self, v: bool) {
        self.twigs = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.TiletypeSpecial tile_type = 8;

    pub fn tile_type(&self) -> TiletypeSpecial {
        match self.tile_type {
            Some(e) => e.enum_value_or(TiletypeSpecial::NO_SPECIAL),
            None => TiletypeSpecial::NO_SPECIAL,
        }
    }

    pub fn clear_tile_type(&mut self) {
        self.tile_type = ::std::option::Option::None;
    }

    pub fn has_tile_type(&self) -> bool {
        self.tile_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile_type(&mut self, v: TiletypeSpecial) {
        self.tile_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trunk",
            |m: &PlantTile| { &m.trunk },
            |m: &mut PlantTile| { &mut m.trunk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_east",
            |m: &PlantTile| { &m.connection_east },
            |m: &mut PlantTile| { &mut m.connection_east },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_south",
            |m: &PlantTile| { &m.connection_south },
            |m: &mut PlantTile| { &mut m.connection_south },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_west",
            |m: &PlantTile| { &m.connection_west },
            |m: &mut PlantTile| { &mut m.connection_west },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_north",
            |m: &PlantTile| { &m.connection_north },
            |m: &mut PlantTile| { &mut m.connection_north },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "branches",
            |m: &PlantTile| { &m.branches },
            |m: &mut PlantTile| { &mut m.branches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "twigs",
            |m: &PlantTile| { &m.twigs },
            |m: &mut PlantTile| { &mut m.twigs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tile_type",
            |m: &PlantTile| { &m.tile_type },
            |m: &mut PlantTile| { &mut m.tile_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlantTile>(
            "PlantTile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlantTile {
    const NAME: &'static str = "PlantTile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trunk = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.connection_east = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.connection_south = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.connection_west = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.connection_north = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.branches = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.twigs = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.tile_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trunk {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connection_east {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connection_south {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connection_west {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connection_north {
            my_size += 1 + 1;
        }
        if let Some(v) = self.branches {
            my_size += 1 + 1;
        }
        if let Some(v) = self.twigs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tile_type {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trunk {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.connection_east {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.connection_south {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.connection_west {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.connection_north {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.branches {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.twigs {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.tile_type {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlantTile {
        PlantTile::new()
    }

    fn clear(&mut self) {
        self.trunk = ::std::option::Option::None;
        self.connection_east = ::std::option::Option::None;
        self.connection_south = ::std::option::Option::None;
        self.connection_west = ::std::option::Option::None;
        self.connection_north = ::std::option::Option::None;
        self.branches = ::std::option::Option::None;
        self.twigs = ::std::option::Option::None;
        self.tile_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlantTile {
        static instance: PlantTile = PlantTile {
            trunk: ::std::option::Option::None,
            connection_east: ::std::option::Option::None,
            connection_south: ::std::option::Option::None,
            connection_west: ::std::option::Option::None,
            connection_north: ::std::option::Option::None,
            branches: ::std::option::Option::None,
            twigs: ::std::option::Option::None,
            tile_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlantTile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlantTile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlantTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantTile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.TreeInfo)
pub struct TreeInfo {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeInfo.size)
    pub size: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeInfo.tiles)
    pub tiles: ::std::vec::Vec<PlantTile>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.TreeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TreeInfo {
    fn default() -> &'a TreeInfo {
        <TreeInfo as ::protobuf::Message>::default_instance()
    }
}

impl TreeInfo {
    pub fn new() -> TreeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "size",
            |m: &TreeInfo| { &m.size },
            |m: &mut TreeInfo| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tiles",
            |m: &TreeInfo| { &m.tiles },
            |m: &mut TreeInfo| { &mut m.tiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TreeInfo>(
            "TreeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TreeInfo {
    const NAME: &'static str = "TreeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.size)?;
                },
                18 => {
                    self.tiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tiles {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TreeInfo {
        TreeInfo::new()
    }

    fn clear(&mut self) {
        self.size.clear();
        self.tiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TreeInfo {
        static instance: TreeInfo = TreeInfo {
            size: ::protobuf::MessageField::none(),
            tiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TreeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TreeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TreeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PlantInstance)
pub struct PlantInstance {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantInstance.plant_type)
    pub plant_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantInstance.pos)
    pub pos: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantInstance.tree_info)
    pub tree_info: ::protobuf::MessageField<TreeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PlantInstance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlantInstance {
    fn default() -> &'a PlantInstance {
        <PlantInstance as ::protobuf::Message>::default_instance()
    }
}

impl PlantInstance {
    pub fn new() -> PlantInstance {
        ::std::default::Default::default()
    }

    // optional int32 plant_type = 1;

    pub fn plant_type(&self) -> i32 {
        self.plant_type.unwrap_or(0)
    }

    pub fn clear_plant_type(&mut self) {
        self.plant_type = ::std::option::Option::None;
    }

    pub fn has_plant_type(&self) -> bool {
        self.plant_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plant_type(&mut self, v: i32) {
        self.plant_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plant_type",
            |m: &PlantInstance| { &m.plant_type },
            |m: &mut PlantInstance| { &mut m.plant_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "pos",
            |m: &PlantInstance| { &m.pos },
            |m: &mut PlantInstance| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TreeInfo>(
            "tree_info",
            |m: &PlantInstance| { &m.tree_info },
            |m: &mut PlantInstance| { &mut m.tree_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlantInstance>(
            "PlantInstance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlantInstance {
    const NAME: &'static str = "PlantInstance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.plant_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tree_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.plant_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tree_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.plant_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.tree_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlantInstance {
        PlantInstance::new()
    }

    fn clear(&mut self) {
        self.plant_type = ::std::option::Option::None;
        self.pos.clear();
        self.tree_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlantInstance {
        static instance: PlantInstance = PlantInstance {
            plant_type: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            tree_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlantInstance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlantInstance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlantInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantInstance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.MapBlock)
pub struct MapBlock {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.map_x)
    pub map_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.map_y)
    pub map_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.map_z)
    pub map_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tiles)
    pub tiles: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.materials)
    pub materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.layer_materials)
    pub layer_materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.vein_materials)
    pub vein_materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.base_materials)
    pub base_materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.magma)
    pub magma: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.water)
    pub water: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.hidden)
    pub hidden: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.light)
    pub light: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.subterranean)
    pub subterranean: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.outside)
    pub outside: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.aquifer)
    pub aquifer: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.water_stagnant)
    pub water_stagnant: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.water_salt)
    pub water_salt: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.construction_items)
    pub construction_items: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.buildings)
    pub buildings: ::std::vec::Vec<BuildingInstance>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tree_percent)
    pub tree_percent: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tree_x)
    pub tree_x: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tree_y)
    pub tree_y: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tree_z)
    pub tree_z: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tile_dig_designation)
    pub tile_dig_designation: ::std::vec::Vec<::protobuf::EnumOrUnknown<TileDigDesignation>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.spatterPile)
    pub spatterPile: ::std::vec::Vec<SpatterPile>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.items)
    pub items: ::std::vec::Vec<Item>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tile_dig_designation_marker)
    pub tile_dig_designation_marker: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.tile_dig_designation_auto)
    pub tile_dig_designation_auto: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.grass_percent)
    pub grass_percent: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapBlock.flows)
    pub flows: ::std::vec::Vec<FlowInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.MapBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapBlock {
    fn default() -> &'a MapBlock {
        <MapBlock as ::protobuf::Message>::default_instance()
    }
}

impl MapBlock {
    pub fn new() -> MapBlock {
        ::std::default::Default::default()
    }

    // required int32 map_x = 1;

    pub fn map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }

    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // required int32 map_y = 2;

    pub fn map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }

    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // required int32 map_z = 3;

    pub fn map_z(&self) -> i32 {
        self.map_z.unwrap_or(0)
    }

    pub fn clear_map_z(&mut self) {
        self.map_z = ::std::option::Option::None;
    }

    pub fn has_map_z(&self) -> bool {
        self.map_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_z(&mut self, v: i32) {
        self.map_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_x",
            |m: &MapBlock| { &m.map_x },
            |m: &mut MapBlock| { &mut m.map_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_y",
            |m: &MapBlock| { &m.map_y },
            |m: &mut MapBlock| { &mut m.map_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_z",
            |m: &MapBlock| { &m.map_z },
            |m: &mut MapBlock| { &mut m.map_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tiles",
            |m: &MapBlock| { &m.tiles },
            |m: &mut MapBlock| { &mut m.tiles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "materials",
            |m: &MapBlock| { &m.materials },
            |m: &mut MapBlock| { &mut m.materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "layer_materials",
            |m: &MapBlock| { &m.layer_materials },
            |m: &mut MapBlock| { &mut m.layer_materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vein_materials",
            |m: &MapBlock| { &m.vein_materials },
            |m: &mut MapBlock| { &mut m.vein_materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "base_materials",
            |m: &MapBlock| { &m.base_materials },
            |m: &mut MapBlock| { &mut m.base_materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "magma",
            |m: &MapBlock| { &m.magma },
            |m: &mut MapBlock| { &mut m.magma },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "water",
            |m: &MapBlock| { &m.water },
            |m: &mut MapBlock| { &mut m.water },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hidden",
            |m: &MapBlock| { &m.hidden },
            |m: &mut MapBlock| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "light",
            |m: &MapBlock| { &m.light },
            |m: &mut MapBlock| { &mut m.light },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subterranean",
            |m: &MapBlock| { &m.subterranean },
            |m: &mut MapBlock| { &mut m.subterranean },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outside",
            |m: &MapBlock| { &m.outside },
            |m: &mut MapBlock| { &mut m.outside },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "aquifer",
            |m: &MapBlock| { &m.aquifer },
            |m: &mut MapBlock| { &mut m.aquifer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "water_stagnant",
            |m: &MapBlock| { &m.water_stagnant },
            |m: &mut MapBlock| { &mut m.water_stagnant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "water_salt",
            |m: &MapBlock| { &m.water_salt },
            |m: &mut MapBlock| { &mut m.water_salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "construction_items",
            |m: &MapBlock| { &m.construction_items },
            |m: &mut MapBlock| { &mut m.construction_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buildings",
            |m: &MapBlock| { &m.buildings },
            |m: &mut MapBlock| { &mut m.buildings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tree_percent",
            |m: &MapBlock| { &m.tree_percent },
            |m: &mut MapBlock| { &mut m.tree_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tree_x",
            |m: &MapBlock| { &m.tree_x },
            |m: &mut MapBlock| { &mut m.tree_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tree_y",
            |m: &MapBlock| { &m.tree_y },
            |m: &mut MapBlock| { &mut m.tree_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tree_z",
            |m: &MapBlock| { &m.tree_z },
            |m: &mut MapBlock| { &mut m.tree_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tile_dig_designation",
            |m: &MapBlock| { &m.tile_dig_designation },
            |m: &mut MapBlock| { &mut m.tile_dig_designation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "spatterPile",
            |m: &MapBlock| { &m.spatterPile },
            |m: &mut MapBlock| { &mut m.spatterPile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &MapBlock| { &m.items },
            |m: &mut MapBlock| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tile_dig_designation_marker",
            |m: &MapBlock| { &m.tile_dig_designation_marker },
            |m: &mut MapBlock| { &mut m.tile_dig_designation_marker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tile_dig_designation_auto",
            |m: &MapBlock| { &m.tile_dig_designation_auto },
            |m: &mut MapBlock| { &mut m.tile_dig_designation_auto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grass_percent",
            |m: &MapBlock| { &m.grass_percent },
            |m: &mut MapBlock| { &mut m.grass_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flows",
            |m: &MapBlock| { &m.flows },
            |m: &mut MapBlock| { &mut m.flows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapBlock>(
            "MapBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapBlock {
    const NAME: &'static str = "MapBlock";

    fn is_initialized(&self) -> bool {
        if self.map_x.is_none() {
            return false;
        }
        if self.map_y.is_none() {
            return false;
        }
        if self.map_z.is_none() {
            return false;
        }
        for v in &self.materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.layer_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vein_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.base_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.construction_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spatterPile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.map_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.map_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.map_z = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.tiles)?;
                },
                32 => {
                    self.tiles.push(is.read_int32()?);
                },
                42 => {
                    self.materials.push(is.read_message()?);
                },
                50 => {
                    self.layer_materials.push(is.read_message()?);
                },
                58 => {
                    self.vein_materials.push(is.read_message()?);
                },
                66 => {
                    self.base_materials.push(is.read_message()?);
                },
                74 => {
                    is.read_repeated_packed_int32_into(&mut self.magma)?;
                },
                72 => {
                    self.magma.push(is.read_int32()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.water)?;
                },
                80 => {
                    self.water.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_bool_into(&mut self.hidden)?;
                },
                88 => {
                    self.hidden.push(is.read_bool()?);
                },
                98 => {
                    is.read_repeated_packed_bool_into(&mut self.light)?;
                },
                96 => {
                    self.light.push(is.read_bool()?);
                },
                106 => {
                    is.read_repeated_packed_bool_into(&mut self.subterranean)?;
                },
                104 => {
                    self.subterranean.push(is.read_bool()?);
                },
                114 => {
                    is.read_repeated_packed_bool_into(&mut self.outside)?;
                },
                112 => {
                    self.outside.push(is.read_bool()?);
                },
                122 => {
                    is.read_repeated_packed_bool_into(&mut self.aquifer)?;
                },
                120 => {
                    self.aquifer.push(is.read_bool()?);
                },
                130 => {
                    is.read_repeated_packed_bool_into(&mut self.water_stagnant)?;
                },
                128 => {
                    self.water_stagnant.push(is.read_bool()?);
                },
                138 => {
                    is.read_repeated_packed_bool_into(&mut self.water_salt)?;
                },
                136 => {
                    self.water_salt.push(is.read_bool()?);
                },
                146 => {
                    self.construction_items.push(is.read_message()?);
                },
                154 => {
                    self.buildings.push(is.read_message()?);
                },
                162 => {
                    is.read_repeated_packed_int32_into(&mut self.tree_percent)?;
                },
                160 => {
                    self.tree_percent.push(is.read_int32()?);
                },
                170 => {
                    is.read_repeated_packed_int32_into(&mut self.tree_x)?;
                },
                168 => {
                    self.tree_x.push(is.read_int32()?);
                },
                178 => {
                    is.read_repeated_packed_int32_into(&mut self.tree_y)?;
                },
                176 => {
                    self.tree_y.push(is.read_int32()?);
                },
                186 => {
                    is.read_repeated_packed_int32_into(&mut self.tree_z)?;
                },
                184 => {
                    self.tree_z.push(is.read_int32()?);
                },
                192 => {
                    self.tile_dig_designation.push(is.read_enum_or_unknown()?);
                },
                194 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.tile_dig_designation)?
                },
                202 => {
                    self.spatterPile.push(is.read_message()?);
                },
                210 => {
                    self.items.push(is.read_message()?);
                },
                218 => {
                    is.read_repeated_packed_bool_into(&mut self.tile_dig_designation_marker)?;
                },
                216 => {
                    self.tile_dig_designation_marker.push(is.read_bool()?);
                },
                226 => {
                    is.read_repeated_packed_bool_into(&mut self.tile_dig_designation_auto)?;
                },
                224 => {
                    self.tile_dig_designation_auto.push(is.read_bool()?);
                },
                234 => {
                    is.read_repeated_packed_int32_into(&mut self.grass_percent)?;
                },
                232 => {
                    self.grass_percent.push(is.read_int32()?);
                },
                242 => {
                    self.flows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.map_z {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.tiles {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        for value in &self.materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.layer_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.vein_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.base_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.magma {
            my_size += ::protobuf::rt::int32_size(9, *value);
        };
        for value in &self.water {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        my_size += 2 * self.hidden.len() as u64;
        my_size += 2 * self.light.len() as u64;
        my_size += 2 * self.subterranean.len() as u64;
        my_size += 2 * self.outside.len() as u64;
        my_size += 2 * self.aquifer.len() as u64;
        my_size += 3 * self.water_stagnant.len() as u64;
        my_size += 3 * self.water_salt.len() as u64;
        for value in &self.construction_items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tree_percent {
            my_size += ::protobuf::rt::int32_size(20, *value);
        };
        for value in &self.tree_x {
            my_size += ::protobuf::rt::int32_size(21, *value);
        };
        for value in &self.tree_y {
            my_size += ::protobuf::rt::int32_size(22, *value);
        };
        for value in &self.tree_z {
            my_size += ::protobuf::rt::int32_size(23, *value);
        };
        for value in &self.tile_dig_designation {
            my_size += ::protobuf::rt::int32_size(24, value.value());
        };
        for value in &self.spatterPile {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 3 * self.tile_dig_designation_marker.len() as u64;
        my_size += 3 * self.tile_dig_designation_auto.len() as u64;
        for value in &self.grass_percent {
            my_size += ::protobuf::rt::int32_size(29, *value);
        };
        for value in &self.flows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.map_z {
            os.write_int32(3, v)?;
        }
        for v in &self.tiles {
            os.write_int32(4, *v)?;
        };
        for v in &self.materials {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.layer_materials {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.vein_materials {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.base_materials {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.magma {
            os.write_int32(9, *v)?;
        };
        for v in &self.water {
            os.write_int32(10, *v)?;
        };
        for v in &self.hidden {
            os.write_bool(11, *v)?;
        };
        for v in &self.light {
            os.write_bool(12, *v)?;
        };
        for v in &self.subterranean {
            os.write_bool(13, *v)?;
        };
        for v in &self.outside {
            os.write_bool(14, *v)?;
        };
        for v in &self.aquifer {
            os.write_bool(15, *v)?;
        };
        for v in &self.water_stagnant {
            os.write_bool(16, *v)?;
        };
        for v in &self.water_salt {
            os.write_bool(17, *v)?;
        };
        for v in &self.construction_items {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.buildings {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        for v in &self.tree_percent {
            os.write_int32(20, *v)?;
        };
        for v in &self.tree_x {
            os.write_int32(21, *v)?;
        };
        for v in &self.tree_y {
            os.write_int32(22, *v)?;
        };
        for v in &self.tree_z {
            os.write_int32(23, *v)?;
        };
        for v in &self.tile_dig_designation {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.spatterPile {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        for v in &self.tile_dig_designation_marker {
            os.write_bool(27, *v)?;
        };
        for v in &self.tile_dig_designation_auto {
            os.write_bool(28, *v)?;
        };
        for v in &self.grass_percent {
            os.write_int32(29, *v)?;
        };
        for v in &self.flows {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapBlock {
        MapBlock::new()
    }

    fn clear(&mut self) {
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.map_z = ::std::option::Option::None;
        self.tiles.clear();
        self.materials.clear();
        self.layer_materials.clear();
        self.vein_materials.clear();
        self.base_materials.clear();
        self.magma.clear();
        self.water.clear();
        self.hidden.clear();
        self.light.clear();
        self.subterranean.clear();
        self.outside.clear();
        self.aquifer.clear();
        self.water_stagnant.clear();
        self.water_salt.clear();
        self.construction_items.clear();
        self.buildings.clear();
        self.tree_percent.clear();
        self.tree_x.clear();
        self.tree_y.clear();
        self.tree_z.clear();
        self.tile_dig_designation.clear();
        self.spatterPile.clear();
        self.items.clear();
        self.tile_dig_designation_marker.clear();
        self.tile_dig_designation_auto.clear();
        self.grass_percent.clear();
        self.flows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapBlock {
        static instance: MapBlock = MapBlock {
            map_x: ::std::option::Option::None,
            map_y: ::std::option::Option::None,
            map_z: ::std::option::Option::None,
            tiles: ::std::vec::Vec::new(),
            materials: ::std::vec::Vec::new(),
            layer_materials: ::std::vec::Vec::new(),
            vein_materials: ::std::vec::Vec::new(),
            base_materials: ::std::vec::Vec::new(),
            magma: ::std::vec::Vec::new(),
            water: ::std::vec::Vec::new(),
            hidden: ::std::vec::Vec::new(),
            light: ::std::vec::Vec::new(),
            subterranean: ::std::vec::Vec::new(),
            outside: ::std::vec::Vec::new(),
            aquifer: ::std::vec::Vec::new(),
            water_stagnant: ::std::vec::Vec::new(),
            water_salt: ::std::vec::Vec::new(),
            construction_items: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            tree_percent: ::std::vec::Vec::new(),
            tree_x: ::std::vec::Vec::new(),
            tree_y: ::std::vec::Vec::new(),
            tree_z: ::std::vec::Vec::new(),
            tile_dig_designation: ::std::vec::Vec::new(),
            spatterPile: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            tile_dig_designation_marker: ::std::vec::Vec::new(),
            tile_dig_designation_auto: ::std::vec::Vec::new(),
            grass_percent: ::std::vec::Vec::new(),
            flows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
#[derive(Hash, Eq)]
// @@protoc_insertion_point(message:RemoteFortressReader.MatPair)
pub struct MatPair {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.MatPair.mat_type)
    pub mat_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MatPair.mat_index)
    pub mat_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.MatPair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatPair {
    fn default() -> &'a MatPair {
        <MatPair as ::protobuf::Message>::default_instance()
    }
}

impl MatPair {
    pub fn new() -> MatPair {
        ::std::default::Default::default()
    }

    // required int32 mat_type = 1;

    pub fn mat_type(&self) -> i32 {
        self.mat_type.unwrap_or(0)
    }

    pub fn clear_mat_type(&mut self) {
        self.mat_type = ::std::option::Option::None;
    }

    pub fn has_mat_type(&self) -> bool {
        self.mat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mat_type(&mut self, v: i32) {
        self.mat_type = ::std::option::Option::Some(v);
    }

    // required int32 mat_index = 2;

    pub fn mat_index(&self) -> i32 {
        self.mat_index.unwrap_or(0)
    }

    pub fn clear_mat_index(&mut self) {
        self.mat_index = ::std::option::Option::None;
    }

    pub fn has_mat_index(&self) -> bool {
        self.mat_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mat_index(&mut self, v: i32) {
        self.mat_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mat_type",
            |m: &MatPair| { &m.mat_type },
            |m: &mut MatPair| { &mut m.mat_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mat_index",
            |m: &MatPair| { &m.mat_index },
            |m: &mut MatPair| { &mut m.mat_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatPair>(
            "MatPair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatPair {
    const NAME: &'static str = "MatPair";

    fn is_initialized(&self) -> bool {
        if self.mat_type.is_none() {
            return false;
        }
        if self.mat_index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mat_type = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mat_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mat_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mat_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mat_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mat_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatPair {
        MatPair::new()
    }

    fn clear(&mut self) {
        self.mat_type = ::std::option::Option::None;
        self.mat_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatPair {
        static instance: MatPair = MatPair {
            mat_type: ::std::option::Option::None,
            mat_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatPair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatPair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatPair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ColorDefinition)
pub struct ColorDefinition {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorDefinition.red)
    pub red: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorDefinition.green)
    pub green: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorDefinition.blue)
    pub blue: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ColorDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorDefinition {
    fn default() -> &'a ColorDefinition {
        <ColorDefinition as ::protobuf::Message>::default_instance()
    }
}

impl ColorDefinition {
    pub fn new() -> ColorDefinition {
        ::std::default::Default::default()
    }

    // required int32 red = 1;

    pub fn red(&self) -> i32 {
        self.red.unwrap_or(0)
    }

    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: i32) {
        self.red = ::std::option::Option::Some(v);
    }

    // required int32 green = 2;

    pub fn green(&self) -> i32 {
        self.green.unwrap_or(0)
    }

    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: i32) {
        self.green = ::std::option::Option::Some(v);
    }

    // required int32 blue = 3;

    pub fn blue(&self) -> i32 {
        self.blue.unwrap_or(0)
    }

    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: i32) {
        self.blue = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "red",
            |m: &ColorDefinition| { &m.red },
            |m: &mut ColorDefinition| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "green",
            |m: &ColorDefinition| { &m.green },
            |m: &mut ColorDefinition| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blue",
            |m: &ColorDefinition| { &m.blue },
            |m: &mut ColorDefinition| { &mut m.blue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorDefinition>(
            "ColorDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorDefinition {
    const NAME: &'static str = "ColorDefinition";

    fn is_initialized(&self) -> bool {
        if self.red.is_none() {
            return false;
        }
        if self.green.is_none() {
            return false;
        }
        if self.blue.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.red = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.green = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.blue = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.red {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.green {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.blue {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorDefinition {
        ColorDefinition::new()
    }

    fn clear(&mut self) {
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorDefinition {
        static instance: ColorDefinition = ColorDefinition {
            red: ::std::option::Option::None,
            green: ::std::option::Option::None,
            blue: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.MaterialDefinition)
pub struct MaterialDefinition {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.mat_pair)
    pub mat_pair: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.name)
    pub name: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.state_color)
    pub state_color: ::protobuf::MessageField<ColorDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.instrument)
    pub instrument: ::protobuf::MessageField<super::ItemdefInstrument::InstrumentDef>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.up_step)
    pub up_step: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.down_step)
    pub down_step: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialDefinition.layer)
    pub layer: ::std::option::Option<::protobuf::EnumOrUnknown<ArmorLayer>>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.MaterialDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MaterialDefinition {
    fn default() -> &'a MaterialDefinition {
        <MaterialDefinition as ::protobuf::Message>::default_instance()
    }
}

impl MaterialDefinition {
    pub fn new() -> MaterialDefinition {
        ::std::default::Default::default()
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes name = 3;

    pub fn name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 up_step = 6;

    pub fn up_step(&self) -> i32 {
        self.up_step.unwrap_or(0)
    }

    pub fn clear_up_step(&mut self) {
        self.up_step = ::std::option::Option::None;
    }

    pub fn has_up_step(&self) -> bool {
        self.up_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up_step(&mut self, v: i32) {
        self.up_step = ::std::option::Option::Some(v);
    }

    // optional int32 down_step = 7;

    pub fn down_step(&self) -> i32 {
        self.down_step.unwrap_or(0)
    }

    pub fn clear_down_step(&mut self) {
        self.down_step = ::std::option::Option::None;
    }

    pub fn has_down_step(&self) -> bool {
        self.down_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_down_step(&mut self, v: i32) {
        self.down_step = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArmorLayer layer = 8;

    pub fn layer(&self) -> ArmorLayer {
        match self.layer {
            Some(e) => e.enum_value_or(ArmorLayer::LAYER_UNDER),
            None => ArmorLayer::LAYER_UNDER,
        }
    }

    pub fn clear_layer(&mut self) {
        self.layer = ::std::option::Option::None;
    }

    pub fn has_layer(&self) -> bool {
        self.layer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer(&mut self, v: ArmorLayer) {
        self.layer = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "mat_pair",
            |m: &MaterialDefinition| { &m.mat_pair },
            |m: &mut MaterialDefinition| { &mut m.mat_pair },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &MaterialDefinition| { &m.id },
            |m: &mut MaterialDefinition| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MaterialDefinition| { &m.name },
            |m: &mut MaterialDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ColorDefinition>(
            "state_color",
            |m: &MaterialDefinition| { &m.state_color },
            |m: &mut MaterialDefinition| { &mut m.state_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ItemdefInstrument::InstrumentDef>(
            "instrument",
            |m: &MaterialDefinition| { &m.instrument },
            |m: &mut MaterialDefinition| { &mut m.instrument },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "up_step",
            |m: &MaterialDefinition| { &m.up_step },
            |m: &mut MaterialDefinition| { &mut m.up_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "down_step",
            |m: &MaterialDefinition| { &m.down_step },
            |m: &mut MaterialDefinition| { &mut m.down_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer",
            |m: &MaterialDefinition| { &m.layer },
            |m: &mut MaterialDefinition| { &mut m.layer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MaterialDefinition>(
            "MaterialDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MaterialDefinition {
    const NAME: &'static str = "MaterialDefinition";

    fn is_initialized(&self) -> bool {
        if self.mat_pair.is_none() {
            return false;
        }
        for v in &self.mat_pair {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mat_pair)?;
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state_color)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.instrument)?;
                },
                48 => {
                    self.up_step = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.down_step = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.layer = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mat_pair.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.state_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.up_step {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.down_step {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.layer {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mat_pair.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.state_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.instrument.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.up_step {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.down_step {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.layer {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MaterialDefinition {
        MaterialDefinition::new()
    }

    fn clear(&mut self) {
        self.mat_pair.clear();
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.state_color.clear();
        self.instrument.clear();
        self.up_step = ::std::option::Option::None;
        self.down_step = ::std::option::Option::None;
        self.layer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MaterialDefinition {
        static instance: MaterialDefinition = MaterialDefinition {
            mat_pair: ::protobuf::MessageField::none(),
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            state_color: ::protobuf::MessageField::none(),
            instrument: ::protobuf::MessageField::none(),
            up_step: ::std::option::Option::None,
            down_step: ::std::option::Option::None,
            layer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MaterialDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MaterialDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MaterialDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BuildingType)
pub struct BuildingType {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingType.building_type)
    pub building_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingType.building_subtype)
    pub building_subtype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingType.building_custom)
    pub building_custom: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BuildingType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildingType {
    fn default() -> &'a BuildingType {
        <BuildingType as ::protobuf::Message>::default_instance()
    }
}

impl BuildingType {
    pub fn new() -> BuildingType {
        ::std::default::Default::default()
    }

    // required int32 building_type = 1;

    pub fn building_type(&self) -> i32 {
        self.building_type.unwrap_or(0)
    }

    pub fn clear_building_type(&mut self) {
        self.building_type = ::std::option::Option::None;
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: i32) {
        self.building_type = ::std::option::Option::Some(v);
    }

    // required int32 building_subtype = 2;

    pub fn building_subtype(&self) -> i32 {
        self.building_subtype.unwrap_or(0)
    }

    pub fn clear_building_subtype(&mut self) {
        self.building_subtype = ::std::option::Option::None;
    }

    pub fn has_building_subtype(&self) -> bool {
        self.building_subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_subtype(&mut self, v: i32) {
        self.building_subtype = ::std::option::Option::Some(v);
    }

    // required int32 building_custom = 3;

    pub fn building_custom(&self) -> i32 {
        self.building_custom.unwrap_or(0)
    }

    pub fn clear_building_custom(&mut self) {
        self.building_custom = ::std::option::Option::None;
    }

    pub fn has_building_custom(&self) -> bool {
        self.building_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_custom(&mut self, v: i32) {
        self.building_custom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_type",
            |m: &BuildingType| { &m.building_type },
            |m: &mut BuildingType| { &mut m.building_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_subtype",
            |m: &BuildingType| { &m.building_subtype },
            |m: &mut BuildingType| { &mut m.building_subtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "building_custom",
            |m: &BuildingType| { &m.building_custom },
            |m: &mut BuildingType| { &mut m.building_custom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingType>(
            "BuildingType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildingType {
    const NAME: &'static str = "BuildingType";

    fn is_initialized(&self) -> bool {
        if self.building_type.is_none() {
            return false;
        }
        if self.building_subtype.is_none() {
            return false;
        }
        if self.building_custom.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.building_type = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.building_subtype = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.building_custom = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.building_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.building_subtype {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.building_custom {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.building_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.building_subtype {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.building_custom {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildingType {
        BuildingType::new()
    }

    fn clear(&mut self) {
        self.building_type = ::std::option::Option::None;
        self.building_subtype = ::std::option::Option::None;
        self.building_custom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildingType {
        static instance: BuildingType = BuildingType {
            building_type: ::std::option::Option::None,
            building_subtype: ::std::option::Option::None,
            building_custom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildingType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildingType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BuildingDefinition)
pub struct BuildingDefinition {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingDefinition.building_type)
    pub building_type: ::protobuf::MessageField<BuildingType>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingDefinition.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BuildingDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildingDefinition {
    fn default() -> &'a BuildingDefinition {
        <BuildingDefinition as ::protobuf::Message>::default_instance()
    }
}

impl BuildingDefinition {
    pub fn new() -> BuildingDefinition {
        ::std::default::Default::default()
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildingType>(
            "building_type",
            |m: &BuildingDefinition| { &m.building_type },
            |m: &mut BuildingDefinition| { &mut m.building_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &BuildingDefinition| { &m.id },
            |m: &mut BuildingDefinition| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &BuildingDefinition| { &m.name },
            |m: &mut BuildingDefinition| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingDefinition>(
            "BuildingDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildingDefinition {
    const NAME: &'static str = "BuildingDefinition";

    fn is_initialized(&self) -> bool {
        if self.building_type.is_none() {
            return false;
        }
        for v in &self.building_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.building_type)?;
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.building_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.building_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildingDefinition {
        BuildingDefinition::new()
    }

    fn clear(&mut self) {
        self.building_type.clear();
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildingDefinition {
        static instance: BuildingDefinition = BuildingDefinition {
            building_type: ::protobuf::MessageField::none(),
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildingDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildingDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildingDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BuildingList)
pub struct BuildingList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BuildingList.building_list)
    pub building_list: ::std::vec::Vec<BuildingDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BuildingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildingList {
    fn default() -> &'a BuildingList {
        <BuildingList as ::protobuf::Message>::default_instance()
    }
}

impl BuildingList {
    pub fn new() -> BuildingList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "building_list",
            |m: &BuildingList| { &m.building_list },
            |m: &mut BuildingList| { &mut m.building_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildingList>(
            "BuildingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildingList {
    const NAME: &'static str = "BuildingList";

    fn is_initialized(&self) -> bool {
        for v in &self.building_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.building_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.building_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.building_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildingList {
        BuildingList::new()
    }

    fn clear(&mut self) {
        self.building_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildingList {
        static instance: BuildingList = BuildingList {
            building_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.MaterialList)
pub struct MaterialList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.MaterialList.material_list)
    pub material_list: ::std::vec::Vec<MaterialDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.MaterialList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MaterialList {
    fn default() -> &'a MaterialList {
        <MaterialList as ::protobuf::Message>::default_instance()
    }
}

impl MaterialList {
    pub fn new() -> MaterialList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "material_list",
            |m: &MaterialList| { &m.material_list },
            |m: &mut MaterialList| { &mut m.material_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MaterialList>(
            "MaterialList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MaterialList {
    const NAME: &'static str = "MaterialList";

    fn is_initialized(&self) -> bool {
        for v in &self.material_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.material_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.material_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.material_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MaterialList {
        MaterialList::new()
    }

    fn clear(&mut self) {
        self.material_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MaterialList {
        static instance: MaterialList = MaterialList {
            material_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MaterialList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MaterialList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MaterialList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Hair)
pub struct Hair {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Hair.length)
    pub length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Hair.style)
    pub style: ::std::option::Option<::protobuf::EnumOrUnknown<HairStyle>>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Hair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hair {
    fn default() -> &'a Hair {
        <Hair as ::protobuf::Message>::default_instance()
    }
}

impl Hair {
    pub fn new() -> Hair {
        ::std::default::Default::default()
    }

    // optional int32 length = 1;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.HairStyle style = 2;

    pub fn style(&self) -> HairStyle {
        match self.style {
            Some(e) => e.enum_value_or(HairStyle::UNKEMPT),
            None => HairStyle::UNKEMPT,
        }
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: HairStyle) {
        self.style = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &Hair| { &m.length },
            |m: &mut Hair| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &Hair| { &m.style },
            |m: &mut Hair| { &mut m.style },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hair>(
            "Hair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hair {
    const NAME: &'static str = "Hair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.style = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.length {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.style {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hair {
        Hair::new()
    }

    fn clear(&mut self) {
        self.length = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hair {
        static instance: Hair = Hair {
            length: ::std::option::Option::None,
            style: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BodySizeInfo)
pub struct BodySizeInfo {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BodySizeInfo.size_cur)
    pub size_cur: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodySizeInfo.size_base)
    pub size_base: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodySizeInfo.area_cur)
    pub area_cur: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodySizeInfo.area_base)
    pub area_base: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodySizeInfo.length_cur)
    pub length_cur: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodySizeInfo.length_base)
    pub length_base: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BodySizeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BodySizeInfo {
    fn default() -> &'a BodySizeInfo {
        <BodySizeInfo as ::protobuf::Message>::default_instance()
    }
}

impl BodySizeInfo {
    pub fn new() -> BodySizeInfo {
        ::std::default::Default::default()
    }

    // optional int32 size_cur = 1;

    pub fn size_cur(&self) -> i32 {
        self.size_cur.unwrap_or(0)
    }

    pub fn clear_size_cur(&mut self) {
        self.size_cur = ::std::option::Option::None;
    }

    pub fn has_size_cur(&self) -> bool {
        self.size_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_cur(&mut self, v: i32) {
        self.size_cur = ::std::option::Option::Some(v);
    }

    // optional int32 size_base = 2;

    pub fn size_base(&self) -> i32 {
        self.size_base.unwrap_or(0)
    }

    pub fn clear_size_base(&mut self) {
        self.size_base = ::std::option::Option::None;
    }

    pub fn has_size_base(&self) -> bool {
        self.size_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_base(&mut self, v: i32) {
        self.size_base = ::std::option::Option::Some(v);
    }

    // optional int32 area_cur = 3;

    pub fn area_cur(&self) -> i32 {
        self.area_cur.unwrap_or(0)
    }

    pub fn clear_area_cur(&mut self) {
        self.area_cur = ::std::option::Option::None;
    }

    pub fn has_area_cur(&self) -> bool {
        self.area_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_area_cur(&mut self, v: i32) {
        self.area_cur = ::std::option::Option::Some(v);
    }

    // optional int32 area_base = 4;

    pub fn area_base(&self) -> i32 {
        self.area_base.unwrap_or(0)
    }

    pub fn clear_area_base(&mut self) {
        self.area_base = ::std::option::Option::None;
    }

    pub fn has_area_base(&self) -> bool {
        self.area_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_area_base(&mut self, v: i32) {
        self.area_base = ::std::option::Option::Some(v);
    }

    // optional int32 length_cur = 5;

    pub fn length_cur(&self) -> i32 {
        self.length_cur.unwrap_or(0)
    }

    pub fn clear_length_cur(&mut self) {
        self.length_cur = ::std::option::Option::None;
    }

    pub fn has_length_cur(&self) -> bool {
        self.length_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_cur(&mut self, v: i32) {
        self.length_cur = ::std::option::Option::Some(v);
    }

    // optional int32 length_base = 6;

    pub fn length_base(&self) -> i32 {
        self.length_base.unwrap_or(0)
    }

    pub fn clear_length_base(&mut self) {
        self.length_base = ::std::option::Option::None;
    }

    pub fn has_length_base(&self) -> bool {
        self.length_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_base(&mut self, v: i32) {
        self.length_base = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_cur",
            |m: &BodySizeInfo| { &m.size_cur },
            |m: &mut BodySizeInfo| { &mut m.size_cur },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_base",
            |m: &BodySizeInfo| { &m.size_base },
            |m: &mut BodySizeInfo| { &mut m.size_base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "area_cur",
            |m: &BodySizeInfo| { &m.area_cur },
            |m: &mut BodySizeInfo| { &mut m.area_cur },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "area_base",
            |m: &BodySizeInfo| { &m.area_base },
            |m: &mut BodySizeInfo| { &mut m.area_base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length_cur",
            |m: &BodySizeInfo| { &m.length_cur },
            |m: &mut BodySizeInfo| { &mut m.length_cur },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length_base",
            |m: &BodySizeInfo| { &m.length_base },
            |m: &mut BodySizeInfo| { &mut m.length_base },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BodySizeInfo>(
            "BodySizeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BodySizeInfo {
    const NAME: &'static str = "BodySizeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size_cur = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.size_base = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.area_cur = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.area_base = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.length_cur = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.length_base = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size_cur {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.size_base {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.area_cur {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.area_base {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.length_cur {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.length_base {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size_cur {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.size_base {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.area_cur {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.area_base {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.length_cur {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.length_base {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BodySizeInfo {
        BodySizeInfo::new()
    }

    fn clear(&mut self) {
        self.size_cur = ::std::option::Option::None;
        self.size_base = ::std::option::Option::None;
        self.area_cur = ::std::option::Option::None;
        self.area_base = ::std::option::Option::None;
        self.length_cur = ::std::option::Option::None;
        self.length_base = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BodySizeInfo {
        static instance: BodySizeInfo = BodySizeInfo {
            size_cur: ::std::option::Option::None,
            size_base: ::std::option::Option::None,
            area_cur: ::std::option::Option::None,
            area_base: ::std::option::Option::None,
            length_cur: ::std::option::Option::None,
            length_base: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BodySizeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BodySizeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BodySizeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodySizeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.UnitAppearance)
pub struct UnitAppearance {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.body_modifiers)
    pub body_modifiers: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.bp_modifiers)
    pub bp_modifiers: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.size_modifier)
    pub size_modifier: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.colors)
    pub colors: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.hair)
    pub hair: ::protobuf::MessageField<Hair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.beard)
    pub beard: ::protobuf::MessageField<Hair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.moustache)
    pub moustache: ::protobuf::MessageField<Hair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.sideburns)
    pub sideburns: ::protobuf::MessageField<Hair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitAppearance.physical_description)
    pub physical_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.UnitAppearance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitAppearance {
    fn default() -> &'a UnitAppearance {
        <UnitAppearance as ::protobuf::Message>::default_instance()
    }
}

impl UnitAppearance {
    pub fn new() -> UnitAppearance {
        ::std::default::Default::default()
    }

    // optional int32 size_modifier = 3;

    pub fn size_modifier(&self) -> i32 {
        self.size_modifier.unwrap_or(0)
    }

    pub fn clear_size_modifier(&mut self) {
        self.size_modifier = ::std::option::Option::None;
    }

    pub fn has_size_modifier(&self) -> bool {
        self.size_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_modifier(&mut self, v: i32) {
        self.size_modifier = ::std::option::Option::Some(v);
    }

    // optional string physical_description = 9;

    pub fn physical_description(&self) -> &str {
        match self.physical_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_physical_description(&mut self) {
        self.physical_description = ::std::option::Option::None;
    }

    pub fn has_physical_description(&self) -> bool {
        self.physical_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_physical_description(&mut self, v: ::std::string::String) {
        self.physical_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_physical_description(&mut self) -> &mut ::std::string::String {
        if self.physical_description.is_none() {
            self.physical_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.physical_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_physical_description(&mut self) -> ::std::string::String {
        self.physical_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_modifiers",
            |m: &UnitAppearance| { &m.body_modifiers },
            |m: &mut UnitAppearance| { &mut m.body_modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bp_modifiers",
            |m: &UnitAppearance| { &m.bp_modifiers },
            |m: &mut UnitAppearance| { &mut m.bp_modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_modifier",
            |m: &UnitAppearance| { &m.size_modifier },
            |m: &mut UnitAppearance| { &mut m.size_modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &UnitAppearance| { &m.colors },
            |m: &mut UnitAppearance| { &mut m.colors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Hair>(
            "hair",
            |m: &UnitAppearance| { &m.hair },
            |m: &mut UnitAppearance| { &mut m.hair },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Hair>(
            "beard",
            |m: &UnitAppearance| { &m.beard },
            |m: &mut UnitAppearance| { &mut m.beard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Hair>(
            "moustache",
            |m: &UnitAppearance| { &m.moustache },
            |m: &mut UnitAppearance| { &mut m.moustache },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Hair>(
            "sideburns",
            |m: &UnitAppearance| { &m.sideburns },
            |m: &mut UnitAppearance| { &mut m.sideburns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "physical_description",
            |m: &UnitAppearance| { &m.physical_description },
            |m: &mut UnitAppearance| { &mut m.physical_description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitAppearance>(
            "UnitAppearance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitAppearance {
    const NAME: &'static str = "UnitAppearance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.body_modifiers)?;
                },
                8 => {
                    self.body_modifiers.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.bp_modifiers)?;
                },
                16 => {
                    self.bp_modifiers.push(is.read_int32()?);
                },
                24 => {
                    self.size_modifier = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.colors)?;
                },
                32 => {
                    self.colors.push(is.read_int32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hair)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.beard)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.moustache)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sideburns)?;
                },
                74 => {
                    self.physical_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.body_modifiers {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.bp_modifiers {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.size_modifier {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.colors {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        if let Some(v) = self.hair.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.beard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.moustache.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sideburns.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.physical_description.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.body_modifiers {
            os.write_int32(1, *v)?;
        };
        for v in &self.bp_modifiers {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.size_modifier {
            os.write_int32(3, v)?;
        }
        for v in &self.colors {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.hair.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.beard.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.moustache.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.sideburns.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.physical_description.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitAppearance {
        UnitAppearance::new()
    }

    fn clear(&mut self) {
        self.body_modifiers.clear();
        self.bp_modifiers.clear();
        self.size_modifier = ::std::option::Option::None;
        self.colors.clear();
        self.hair.clear();
        self.beard.clear();
        self.moustache.clear();
        self.sideburns.clear();
        self.physical_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitAppearance {
        static instance: UnitAppearance = UnitAppearance {
            body_modifiers: ::std::vec::Vec::new(),
            bp_modifiers: ::std::vec::Vec::new(),
            size_modifier: ::std::option::Option::None,
            colors: ::std::vec::Vec::new(),
            hair: ::protobuf::MessageField::none(),
            beard: ::protobuf::MessageField::none(),
            moustache: ::protobuf::MessageField::none(),
            sideburns: ::protobuf::MessageField::none(),
            physical_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitAppearance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitAppearance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitAppearance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitAppearance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.InventoryItem)
pub struct InventoryItem {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.InventoryItem.mode)
    pub mode: ::std::option::Option<::protobuf::EnumOrUnknown<InventoryMode>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.InventoryItem.item)
    pub item: ::protobuf::MessageField<Item>,
    // @@protoc_insertion_point(field:RemoteFortressReader.InventoryItem.body_part_id)
    pub body_part_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.InventoryItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InventoryItem {
    fn default() -> &'a InventoryItem {
        <InventoryItem as ::protobuf::Message>::default_instance()
    }
}

impl InventoryItem {
    pub fn new() -> InventoryItem {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.InventoryMode mode = 1;

    pub fn mode(&self) -> InventoryMode {
        match self.mode {
            Some(e) => e.enum_value_or(InventoryMode::Hauled),
            None => InventoryMode::Hauled,
        }
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: InventoryMode) {
        self.mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 body_part_id = 3;

    pub fn body_part_id(&self) -> i32 {
        self.body_part_id.unwrap_or(0)
    }

    pub fn clear_body_part_id(&mut self) {
        self.body_part_id = ::std::option::Option::None;
    }

    pub fn has_body_part_id(&self) -> bool {
        self.body_part_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_part_id(&mut self, v: i32) {
        self.body_part_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &InventoryItem| { &m.mode },
            |m: &mut InventoryItem| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "item",
            |m: &InventoryItem| { &m.item },
            |m: &mut InventoryItem| { &mut m.item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body_part_id",
            |m: &InventoryItem| { &m.body_part_id },
            |m: &mut InventoryItem| { &mut m.body_part_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InventoryItem>(
            "InventoryItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InventoryItem {
    const NAME: &'static str = "InventoryItem";

    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                24 => {
                    self.body_part_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body_part_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.body_part_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InventoryItem {
        InventoryItem::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.item.clear();
        self.body_part_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InventoryItem {
        static instance: InventoryItem = InventoryItem {
            mode: ::std::option::Option::None,
            item: ::protobuf::MessageField::none(),
            body_part_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InventoryItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InventoryItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InventoryItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InventoryItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.WoundPart)
pub struct WoundPart {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.WoundPart.global_layer_idx)
    pub global_layer_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WoundPart.body_part_id)
    pub body_part_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WoundPart.layer_idx)
    pub layer_idx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.WoundPart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WoundPart {
    fn default() -> &'a WoundPart {
        <WoundPart as ::protobuf::Message>::default_instance()
    }
}

impl WoundPart {
    pub fn new() -> WoundPart {
        ::std::default::Default::default()
    }

    // optional int32 global_layer_idx = 1;

    pub fn global_layer_idx(&self) -> i32 {
        self.global_layer_idx.unwrap_or(0)
    }

    pub fn clear_global_layer_idx(&mut self) {
        self.global_layer_idx = ::std::option::Option::None;
    }

    pub fn has_global_layer_idx(&self) -> bool {
        self.global_layer_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_layer_idx(&mut self, v: i32) {
        self.global_layer_idx = ::std::option::Option::Some(v);
    }

    // optional int32 body_part_id = 2;

    pub fn body_part_id(&self) -> i32 {
        self.body_part_id.unwrap_or(0)
    }

    pub fn clear_body_part_id(&mut self) {
        self.body_part_id = ::std::option::Option::None;
    }

    pub fn has_body_part_id(&self) -> bool {
        self.body_part_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_part_id(&mut self, v: i32) {
        self.body_part_id = ::std::option::Option::Some(v);
    }

    // optional int32 layer_idx = 3;

    pub fn layer_idx(&self) -> i32 {
        self.layer_idx.unwrap_or(0)
    }

    pub fn clear_layer_idx(&mut self) {
        self.layer_idx = ::std::option::Option::None;
    }

    pub fn has_layer_idx(&self) -> bool {
        self.layer_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_idx(&mut self, v: i32) {
        self.layer_idx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "global_layer_idx",
            |m: &WoundPart| { &m.global_layer_idx },
            |m: &mut WoundPart| { &mut m.global_layer_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body_part_id",
            |m: &WoundPart| { &m.body_part_id },
            |m: &mut WoundPart| { &mut m.body_part_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_idx",
            |m: &WoundPart| { &m.layer_idx },
            |m: &mut WoundPart| { &mut m.layer_idx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WoundPart>(
            "WoundPart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WoundPart {
    const NAME: &'static str = "WoundPart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.global_layer_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.body_part_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.layer_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.global_layer_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.body_part_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.layer_idx {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.global_layer_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.body_part_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.layer_idx {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WoundPart {
        WoundPart::new()
    }

    fn clear(&mut self) {
        self.global_layer_idx = ::std::option::Option::None;
        self.body_part_id = ::std::option::Option::None;
        self.layer_idx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WoundPart {
        static instance: WoundPart = WoundPart {
            global_layer_idx: ::std::option::Option::None,
            body_part_id: ::std::option::Option::None,
            layer_idx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WoundPart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WoundPart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WoundPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WoundPart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.UnitWound)
pub struct UnitWound {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitWound.parts)
    pub parts: ::std::vec::Vec<WoundPart>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitWound.severed_part)
    pub severed_part: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.UnitWound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitWound {
    fn default() -> &'a UnitWound {
        <UnitWound as ::protobuf::Message>::default_instance()
    }
}

impl UnitWound {
    pub fn new() -> UnitWound {
        ::std::default::Default::default()
    }

    // optional bool severed_part = 2;

    pub fn severed_part(&self) -> bool {
        self.severed_part.unwrap_or(false)
    }

    pub fn clear_severed_part(&mut self) {
        self.severed_part = ::std::option::Option::None;
    }

    pub fn has_severed_part(&self) -> bool {
        self.severed_part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severed_part(&mut self, v: bool) {
        self.severed_part = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parts",
            |m: &UnitWound| { &m.parts },
            |m: &mut UnitWound| { &mut m.parts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "severed_part",
            |m: &UnitWound| { &m.severed_part },
            |m: &mut UnitWound| { &mut m.severed_part },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitWound>(
            "UnitWound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitWound {
    const NAME: &'static str = "UnitWound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parts.push(is.read_message()?);
                },
                16 => {
                    self.severed_part = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.severed_part {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.parts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.severed_part {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitWound {
        UnitWound::new()
    }

    fn clear(&mut self) {
        self.parts.clear();
        self.severed_part = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitWound {
        static instance: UnitWound = UnitWound {
            parts: ::std::vec::Vec::new(),
            severed_part: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitWound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitWound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitWound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitWound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.UnitDefinition)
pub struct UnitDefinition {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.isValid)
    pub isValid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.pos_x)
    pub pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.pos_y)
    pub pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.pos_z)
    pub pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.race)
    pub race: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.profession_color)
    pub profession_color: ::protobuf::MessageField<ColorDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.flags1)
    pub flags1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.flags2)
    pub flags2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.flags3)
    pub flags3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.is_soldier)
    pub is_soldier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.size_info)
    pub size_info: ::protobuf::MessageField<BodySizeInfo>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.blood_max)
    pub blood_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.blood_count)
    pub blood_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.appearance)
    pub appearance: ::protobuf::MessageField<UnitAppearance>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.profession_id)
    pub profession_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.noble_positions)
    pub noble_positions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.rider_id)
    pub rider_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.inventory)
    pub inventory: ::std::vec::Vec<InventoryItem>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.subpos_x)
    pub subpos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.subpos_y)
    pub subpos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.subpos_z)
    pub subpos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.facing)
    pub facing: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.age)
    pub age: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitDefinition.wounds)
    pub wounds: ::std::vec::Vec<UnitWound>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.UnitDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitDefinition {
    fn default() -> &'a UnitDefinition {
        <UnitDefinition as ::protobuf::Message>::default_instance()
    }
}

impl UnitDefinition {
    pub fn new() -> UnitDefinition {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bool isValid = 2;

    pub fn isValid(&self) -> bool {
        self.isValid.unwrap_or(false)
    }

    pub fn clear_isValid(&mut self) {
        self.isValid = ::std::option::Option::None;
    }

    pub fn has_isValid(&self) -> bool {
        self.isValid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isValid(&mut self, v: bool) {
        self.isValid = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x = 3;

    pub fn pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y = 4;

    pub fn pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z = 5;

    pub fn pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional uint32 flags1 = 8;

    pub fn flags1(&self) -> u32 {
        self.flags1.unwrap_or(0)
    }

    pub fn clear_flags1(&mut self) {
        self.flags1 = ::std::option::Option::None;
    }

    pub fn has_flags1(&self) -> bool {
        self.flags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags1(&mut self, v: u32) {
        self.flags1 = ::std::option::Option::Some(v);
    }

    // optional uint32 flags2 = 9;

    pub fn flags2(&self) -> u32 {
        self.flags2.unwrap_or(0)
    }

    pub fn clear_flags2(&mut self) {
        self.flags2 = ::std::option::Option::None;
    }

    pub fn has_flags2(&self) -> bool {
        self.flags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags2(&mut self, v: u32) {
        self.flags2 = ::std::option::Option::Some(v);
    }

    // optional uint32 flags3 = 10;

    pub fn flags3(&self) -> u32 {
        self.flags3.unwrap_or(0)
    }

    pub fn clear_flags3(&mut self) {
        self.flags3 = ::std::option::Option::None;
    }

    pub fn has_flags3(&self) -> bool {
        self.flags3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags3(&mut self, v: u32) {
        self.flags3 = ::std::option::Option::Some(v);
    }

    // optional bool is_soldier = 11;

    pub fn is_soldier(&self) -> bool {
        self.is_soldier.unwrap_or(false)
    }

    pub fn clear_is_soldier(&mut self) {
        self.is_soldier = ::std::option::Option::None;
    }

    pub fn has_is_soldier(&self) -> bool {
        self.is_soldier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_soldier(&mut self, v: bool) {
        self.is_soldier = ::std::option::Option::Some(v);
    }

    // optional string name = 13;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 blood_max = 14;

    pub fn blood_max(&self) -> i32 {
        self.blood_max.unwrap_or(0)
    }

    pub fn clear_blood_max(&mut self) {
        self.blood_max = ::std::option::Option::None;
    }

    pub fn has_blood_max(&self) -> bool {
        self.blood_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blood_max(&mut self, v: i32) {
        self.blood_max = ::std::option::Option::Some(v);
    }

    // optional int32 blood_count = 15;

    pub fn blood_count(&self) -> i32 {
        self.blood_count.unwrap_or(0)
    }

    pub fn clear_blood_count(&mut self) {
        self.blood_count = ::std::option::Option::None;
    }

    pub fn has_blood_count(&self) -> bool {
        self.blood_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blood_count(&mut self, v: i32) {
        self.blood_count = ::std::option::Option::Some(v);
    }

    // optional int32 profession_id = 17;

    pub fn profession_id(&self) -> i32 {
        self.profession_id.unwrap_or(0)
    }

    pub fn clear_profession_id(&mut self) {
        self.profession_id = ::std::option::Option::None;
    }

    pub fn has_profession_id(&self) -> bool {
        self.profession_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession_id(&mut self, v: i32) {
        self.profession_id = ::std::option::Option::Some(v);
    }

    // optional int32 rider_id = 19;

    pub fn rider_id(&self) -> i32 {
        self.rider_id.unwrap_or(0)
    }

    pub fn clear_rider_id(&mut self) {
        self.rider_id = ::std::option::Option::None;
    }

    pub fn has_rider_id(&self) -> bool {
        self.rider_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = ::std::option::Option::Some(v);
    }

    // optional float subpos_x = 21;

    pub fn subpos_x(&self) -> f32 {
        self.subpos_x.unwrap_or(0.)
    }

    pub fn clear_subpos_x(&mut self) {
        self.subpos_x = ::std::option::Option::None;
    }

    pub fn has_subpos_x(&self) -> bool {
        self.subpos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_x(&mut self, v: f32) {
        self.subpos_x = ::std::option::Option::Some(v);
    }

    // optional float subpos_y = 22;

    pub fn subpos_y(&self) -> f32 {
        self.subpos_y.unwrap_or(0.)
    }

    pub fn clear_subpos_y(&mut self) {
        self.subpos_y = ::std::option::Option::None;
    }

    pub fn has_subpos_y(&self) -> bool {
        self.subpos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_y(&mut self, v: f32) {
        self.subpos_y = ::std::option::Option::Some(v);
    }

    // optional float subpos_z = 23;

    pub fn subpos_z(&self) -> f32 {
        self.subpos_z.unwrap_or(0.)
    }

    pub fn clear_subpos_z(&mut self) {
        self.subpos_z = ::std::option::Option::None;
    }

    pub fn has_subpos_z(&self) -> bool {
        self.subpos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subpos_z(&mut self, v: f32) {
        self.subpos_z = ::std::option::Option::Some(v);
    }

    // optional int32 age = 25;

    pub fn age(&self) -> i32 {
        self.age.unwrap_or(0)
    }

    pub fn clear_age(&mut self) {
        self.age = ::std::option::Option::None;
    }

    pub fn has_age(&self) -> bool {
        self.age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_age(&mut self, v: i32) {
        self.age = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &UnitDefinition| { &m.id },
            |m: &mut UnitDefinition| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isValid",
            |m: &UnitDefinition| { &m.isValid },
            |m: &mut UnitDefinition| { &mut m.isValid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &UnitDefinition| { &m.pos_x },
            |m: &mut UnitDefinition| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &UnitDefinition| { &m.pos_y },
            |m: &mut UnitDefinition| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &UnitDefinition| { &m.pos_z },
            |m: &mut UnitDefinition| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "race",
            |m: &UnitDefinition| { &m.race },
            |m: &mut UnitDefinition| { &mut m.race },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ColorDefinition>(
            "profession_color",
            |m: &UnitDefinition| { &m.profession_color },
            |m: &mut UnitDefinition| { &mut m.profession_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags1",
            |m: &UnitDefinition| { &m.flags1 },
            |m: &mut UnitDefinition| { &mut m.flags1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags2",
            |m: &UnitDefinition| { &m.flags2 },
            |m: &mut UnitDefinition| { &mut m.flags2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags3",
            |m: &UnitDefinition| { &m.flags3 },
            |m: &mut UnitDefinition| { &mut m.flags3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_soldier",
            |m: &UnitDefinition| { &m.is_soldier },
            |m: &mut UnitDefinition| { &mut m.is_soldier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BodySizeInfo>(
            "size_info",
            |m: &UnitDefinition| { &m.size_info },
            |m: &mut UnitDefinition| { &mut m.size_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &UnitDefinition| { &m.name },
            |m: &mut UnitDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blood_max",
            |m: &UnitDefinition| { &m.blood_max },
            |m: &mut UnitDefinition| { &mut m.blood_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blood_count",
            |m: &UnitDefinition| { &m.blood_count },
            |m: &mut UnitDefinition| { &mut m.blood_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitAppearance>(
            "appearance",
            |m: &UnitDefinition| { &m.appearance },
            |m: &mut UnitDefinition| { &mut m.appearance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "profession_id",
            |m: &UnitDefinition| { &m.profession_id },
            |m: &mut UnitDefinition| { &mut m.profession_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "noble_positions",
            |m: &UnitDefinition| { &m.noble_positions },
            |m: &mut UnitDefinition| { &mut m.noble_positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rider_id",
            |m: &UnitDefinition| { &m.rider_id },
            |m: &mut UnitDefinition| { &mut m.rider_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inventory",
            |m: &UnitDefinition| { &m.inventory },
            |m: &mut UnitDefinition| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subpos_x",
            |m: &UnitDefinition| { &m.subpos_x },
            |m: &mut UnitDefinition| { &mut m.subpos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subpos_y",
            |m: &UnitDefinition| { &m.subpos_y },
            |m: &mut UnitDefinition| { &mut m.subpos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subpos_z",
            |m: &UnitDefinition| { &m.subpos_z },
            |m: &mut UnitDefinition| { &mut m.subpos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "facing",
            |m: &UnitDefinition| { &m.facing },
            |m: &mut UnitDefinition| { &mut m.facing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "age",
            |m: &UnitDefinition| { &m.age },
            |m: &mut UnitDefinition| { &mut m.age },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wounds",
            |m: &UnitDefinition| { &m.wounds },
            |m: &mut UnitDefinition| { &mut m.wounds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitDefinition>(
            "UnitDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitDefinition {
    const NAME: &'static str = "UnitDefinition";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.race {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profession_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.size_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appearance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.facing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wounds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.isValid = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.race)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.profession_color)?;
                },
                64 => {
                    self.flags1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.flags2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.flags3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.is_soldier = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.size_info)?;
                },
                106 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.blood_max = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.blood_count = ::std::option::Option::Some(is.read_int32()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appearance)?;
                },
                136 => {
                    self.profession_id = ::std::option::Option::Some(is.read_int32()?);
                },
                146 => {
                    self.noble_positions.push(is.read_string()?);
                },
                152 => {
                    self.rider_id = ::std::option::Option::Some(is.read_int32()?);
                },
                162 => {
                    self.inventory.push(is.read_message()?);
                },
                173 => {
                    self.subpos_x = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.subpos_y = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.subpos_z = ::std::option::Option::Some(is.read_float()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.facing)?;
                },
                200 => {
                    self.age = ::std::option::Option::Some(is.read_int32()?);
                },
                210 => {
                    self.wounds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.isValid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.race.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.profession_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flags1 {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.flags2 {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.flags3 {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.is_soldier {
            my_size += 1 + 1;
        }
        if let Some(v) = self.size_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.blood_max {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.blood_count {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.appearance.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.profession_id {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        for value in &self.noble_positions {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        if let Some(v) = self.rider_id {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        for value in &self.inventory {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.subpos_x {
            my_size += 2 + 4;
        }
        if let Some(v) = self.subpos_y {
            my_size += 2 + 4;
        }
        if let Some(v) = self.subpos_z {
            my_size += 2 + 4;
        }
        if let Some(v) = self.facing.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.age {
            my_size += ::protobuf::rt::int32_size(25, v);
        }
        for value in &self.wounds {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.isValid {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.race.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.profession_color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.flags1 {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.flags2 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.flags3 {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.is_soldier {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.size_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.blood_max {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.blood_count {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.appearance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.profession_id {
            os.write_int32(17, v)?;
        }
        for v in &self.noble_positions {
            os.write_string(18, &v)?;
        };
        if let Some(v) = self.rider_id {
            os.write_int32(19, v)?;
        }
        for v in &self.inventory {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if let Some(v) = self.subpos_x {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.subpos_y {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.subpos_z {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.facing.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.age {
            os.write_int32(25, v)?;
        }
        for v in &self.wounds {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitDefinition {
        UnitDefinition::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.isValid = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.race.clear();
        self.profession_color.clear();
        self.flags1 = ::std::option::Option::None;
        self.flags2 = ::std::option::Option::None;
        self.flags3 = ::std::option::Option::None;
        self.is_soldier = ::std::option::Option::None;
        self.size_info.clear();
        self.name = ::std::option::Option::None;
        self.blood_max = ::std::option::Option::None;
        self.blood_count = ::std::option::Option::None;
        self.appearance.clear();
        self.profession_id = ::std::option::Option::None;
        self.noble_positions.clear();
        self.rider_id = ::std::option::Option::None;
        self.inventory.clear();
        self.subpos_x = ::std::option::Option::None;
        self.subpos_y = ::std::option::Option::None;
        self.subpos_z = ::std::option::Option::None;
        self.facing.clear();
        self.age = ::std::option::Option::None;
        self.wounds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitDefinition {
        static instance: UnitDefinition = UnitDefinition {
            id: ::std::option::Option::None,
            isValid: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            race: ::protobuf::MessageField::none(),
            profession_color: ::protobuf::MessageField::none(),
            flags1: ::std::option::Option::None,
            flags2: ::std::option::Option::None,
            flags3: ::std::option::Option::None,
            is_soldier: ::std::option::Option::None,
            size_info: ::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            blood_max: ::std::option::Option::None,
            blood_count: ::std::option::Option::None,
            appearance: ::protobuf::MessageField::none(),
            profession_id: ::std::option::Option::None,
            noble_positions: ::std::vec::Vec::new(),
            rider_id: ::std::option::Option::None,
            inventory: ::std::vec::Vec::new(),
            subpos_x: ::std::option::Option::None,
            subpos_y: ::std::option::Option::None,
            subpos_z: ::std::option::Option::None,
            facing: ::protobuf::MessageField::none(),
            age: ::std::option::Option::None,
            wounds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.UnitList)
pub struct UnitList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.UnitList.creature_list)
    pub creature_list: ::std::vec::Vec<UnitDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.UnitList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitList {
    fn default() -> &'a UnitList {
        <UnitList as ::protobuf::Message>::default_instance()
    }
}

impl UnitList {
    pub fn new() -> UnitList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "creature_list",
            |m: &UnitList| { &m.creature_list },
            |m: &mut UnitList| { &mut m.creature_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitList>(
            "UnitList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitList {
    const NAME: &'static str = "UnitList";

    fn is_initialized(&self) -> bool {
        for v in &self.creature_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creature_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.creature_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.creature_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitList {
        UnitList::new()
    }

    fn clear(&mut self) {
        self.creature_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitList {
        static instance: UnitList = UnitList {
            creature_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BlockRequest)
pub struct BlockRequest {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.blocks_needed)
    pub blocks_needed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.min_x)
    pub min_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.max_x)
    pub max_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.min_y)
    pub min_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.max_y)
    pub max_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.min_z)
    pub min_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockRequest.max_z)
    pub max_z: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRequest {
    fn default() -> &'a BlockRequest {
        <BlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockRequest {
    pub fn new() -> BlockRequest {
        ::std::default::Default::default()
    }

    // optional int32 blocks_needed = 1;

    pub fn blocks_needed(&self) -> i32 {
        self.blocks_needed.unwrap_or(0)
    }

    pub fn clear_blocks_needed(&mut self) {
        self.blocks_needed = ::std::option::Option::None;
    }

    pub fn has_blocks_needed(&self) -> bool {
        self.blocks_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_needed(&mut self, v: i32) {
        self.blocks_needed = ::std::option::Option::Some(v);
    }

    // optional int32 min_x = 2;

    pub fn min_x(&self) -> i32 {
        self.min_x.unwrap_or(0)
    }

    pub fn clear_min_x(&mut self) {
        self.min_x = ::std::option::Option::None;
    }

    pub fn has_min_x(&self) -> bool {
        self.min_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_x(&mut self, v: i32) {
        self.min_x = ::std::option::Option::Some(v);
    }

    // optional int32 max_x = 3;

    pub fn max_x(&self) -> i32 {
        self.max_x.unwrap_or(0)
    }

    pub fn clear_max_x(&mut self) {
        self.max_x = ::std::option::Option::None;
    }

    pub fn has_max_x(&self) -> bool {
        self.max_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_x(&mut self, v: i32) {
        self.max_x = ::std::option::Option::Some(v);
    }

    // optional int32 min_y = 4;

    pub fn min_y(&self) -> i32 {
        self.min_y.unwrap_or(0)
    }

    pub fn clear_min_y(&mut self) {
        self.min_y = ::std::option::Option::None;
    }

    pub fn has_min_y(&self) -> bool {
        self.min_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_y(&mut self, v: i32) {
        self.min_y = ::std::option::Option::Some(v);
    }

    // optional int32 max_y = 5;

    pub fn max_y(&self) -> i32 {
        self.max_y.unwrap_or(0)
    }

    pub fn clear_max_y(&mut self) {
        self.max_y = ::std::option::Option::None;
    }

    pub fn has_max_y(&self) -> bool {
        self.max_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_y(&mut self, v: i32) {
        self.max_y = ::std::option::Option::Some(v);
    }

    // optional int32 min_z = 6;

    pub fn min_z(&self) -> i32 {
        self.min_z.unwrap_or(0)
    }

    pub fn clear_min_z(&mut self) {
        self.min_z = ::std::option::Option::None;
    }

    pub fn has_min_z(&self) -> bool {
        self.min_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_z(&mut self, v: i32) {
        self.min_z = ::std::option::Option::Some(v);
    }

    // optional int32 max_z = 7;

    pub fn max_z(&self) -> i32 {
        self.max_z.unwrap_or(0)
    }

    pub fn clear_max_z(&mut self) {
        self.max_z = ::std::option::Option::None;
    }

    pub fn has_max_z(&self) -> bool {
        self.max_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_z(&mut self, v: i32) {
        self.max_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blocks_needed",
            |m: &BlockRequest| { &m.blocks_needed },
            |m: &mut BlockRequest| { &mut m.blocks_needed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_x",
            |m: &BlockRequest| { &m.min_x },
            |m: &mut BlockRequest| { &mut m.min_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_x",
            |m: &BlockRequest| { &m.max_x },
            |m: &mut BlockRequest| { &mut m.max_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_y",
            |m: &BlockRequest| { &m.min_y },
            |m: &mut BlockRequest| { &mut m.min_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_y",
            |m: &BlockRequest| { &m.max_y },
            |m: &mut BlockRequest| { &mut m.max_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_z",
            |m: &BlockRequest| { &m.min_z },
            |m: &mut BlockRequest| { &mut m.min_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_z",
            |m: &BlockRequest| { &m.max_z },
            |m: &mut BlockRequest| { &mut m.max_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRequest>(
            "BlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRequest {
    const NAME: &'static str = "BlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.blocks_needed = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.min_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.max_x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.min_y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.max_y = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.min_z = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.max_z = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.blocks_needed {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.min_x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.max_x {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.min_y {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.max_y {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.min_z {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.max_z {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.blocks_needed {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.max_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.min_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.max_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.min_z {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.max_z {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRequest {
        BlockRequest::new()
    }

    fn clear(&mut self) {
        self.blocks_needed = ::std::option::Option::None;
        self.min_x = ::std::option::Option::None;
        self.max_x = ::std::option::Option::None;
        self.min_y = ::std::option::Option::None;
        self.max_y = ::std::option::Option::None;
        self.min_z = ::std::option::Option::None;
        self.max_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRequest {
        static instance: BlockRequest = BlockRequest {
            blocks_needed: ::std::option::Option::None,
            min_x: ::std::option::Option::None,
            max_x: ::std::option::Option::None,
            min_y: ::std::option::Option::None,
            max_y: ::std::option::Option::None,
            min_z: ::std::option::Option::None,
            max_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BlockList)
pub struct BlockList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockList.map_blocks)
    pub map_blocks: ::std::vec::Vec<MapBlock>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockList.map_x)
    pub map_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockList.map_y)
    pub map_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockList.engravings)
    pub engravings: ::std::vec::Vec<Engraving>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BlockList.ocean_waves)
    pub ocean_waves: ::std::vec::Vec<Wave>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BlockList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockList {
    fn default() -> &'a BlockList {
        <BlockList as ::protobuf::Message>::default_instance()
    }
}

impl BlockList {
    pub fn new() -> BlockList {
        ::std::default::Default::default()
    }

    // optional int32 map_x = 2;

    pub fn map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }

    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // optional int32 map_y = 3;

    pub fn map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }

    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "map_blocks",
            |m: &BlockList| { &m.map_blocks },
            |m: &mut BlockList| { &mut m.map_blocks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_x",
            |m: &BlockList| { &m.map_x },
            |m: &mut BlockList| { &mut m.map_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_y",
            |m: &BlockList| { &m.map_y },
            |m: &mut BlockList| { &mut m.map_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "engravings",
            |m: &BlockList| { &m.engravings },
            |m: &mut BlockList| { &mut m.engravings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ocean_waves",
            |m: &BlockList| { &m.ocean_waves },
            |m: &mut BlockList| { &mut m.ocean_waves },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockList>(
            "BlockList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockList {
    const NAME: &'static str = "BlockList";

    fn is_initialized(&self) -> bool {
        for v in &self.map_blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.engravings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ocean_waves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_blocks.push(is.read_message()?);
                },
                16 => {
                    self.map_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.map_y = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.engravings.push(is.read_message()?);
                },
                42 => {
                    self.ocean_waves.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.map_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.engravings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ocean_waves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.map_blocks {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.map_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(3, v)?;
        }
        for v in &self.engravings {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.ocean_waves {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockList {
        BlockList::new()
    }

    fn clear(&mut self) {
        self.map_blocks.clear();
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.engravings.clear();
        self.ocean_waves.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockList {
        static instance: BlockList = BlockList {
            map_blocks: ::std::vec::Vec::new(),
            map_x: ::std::option::Option::None,
            map_y: ::std::option::Option::None,
            engravings: ::std::vec::Vec::new(),
            ocean_waves: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PlantDef)
pub struct PlantDef {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantDef.pos_x)
    pub pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantDef.pos_y)
    pub pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantDef.pos_z)
    pub pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantDef.index)
    pub index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PlantDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlantDef {
    fn default() -> &'a PlantDef {
        <PlantDef as ::protobuf::Message>::default_instance()
    }
}

impl PlantDef {
    pub fn new() -> PlantDef {
        ::std::default::Default::default()
    }

    // required int32 pos_x = 1;

    pub fn pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // required int32 pos_y = 2;

    pub fn pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // required int32 pos_z = 3;

    pub fn pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // required int32 index = 4;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &PlantDef| { &m.pos_x },
            |m: &mut PlantDef| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &PlantDef| { &m.pos_y },
            |m: &mut PlantDef| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &PlantDef| { &m.pos_z },
            |m: &mut PlantDef| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &PlantDef| { &m.index },
            |m: &mut PlantDef| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlantDef>(
            "PlantDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlantDef {
    const NAME: &'static str = "PlantDef";

    fn is_initialized(&self) -> bool {
        if self.pos_x.is_none() {
            return false;
        }
        if self.pos_y.is_none() {
            return false;
        }
        if self.pos_z.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlantDef {
        PlantDef::new()
    }

    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlantDef {
        static instance: PlantDef = PlantDef {
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlantDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlantDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlantDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PlantList)
pub struct PlantList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantList.plant_list)
    pub plant_list: ::std::vec::Vec<PlantDef>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PlantList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlantList {
    fn default() -> &'a PlantList {
        <PlantList as ::protobuf::Message>::default_instance()
    }
}

impl PlantList {
    pub fn new() -> PlantList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "plant_list",
            |m: &PlantList| { &m.plant_list },
            |m: &mut PlantList| { &mut m.plant_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlantList>(
            "PlantList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlantList {
    const NAME: &'static str = "PlantList";

    fn is_initialized(&self) -> bool {
        for v in &self.plant_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plant_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.plant_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.plant_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlantList {
        PlantList::new()
    }

    fn clear(&mut self) {
        self.plant_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlantList {
        static instance: PlantList = PlantList {
            plant_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlantList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlantList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlantList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ViewInfo)
pub struct ViewInfo {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.view_pos_x)
    pub view_pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.view_pos_y)
    pub view_pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.view_pos_z)
    pub view_pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.view_size_x)
    pub view_size_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.view_size_y)
    pub view_size_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.cursor_pos_x)
    pub cursor_pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.cursor_pos_y)
    pub cursor_pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.cursor_pos_z)
    pub cursor_pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.follow_unit_id)
    pub follow_unit_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ViewInfo.follow_item_id)
    pub follow_item_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ViewInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ViewInfo {
    fn default() -> &'a ViewInfo {
        <ViewInfo as ::protobuf::Message>::default_instance()
    }
}

impl ViewInfo {
    pub fn new() -> ViewInfo {
        ::std::default::Default::default()
    }

    // optional int32 view_pos_x = 1;

    pub fn view_pos_x(&self) -> i32 {
        self.view_pos_x.unwrap_or(0)
    }

    pub fn clear_view_pos_x(&mut self) {
        self.view_pos_x = ::std::option::Option::None;
    }

    pub fn has_view_pos_x(&self) -> bool {
        self.view_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_pos_x(&mut self, v: i32) {
        self.view_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 view_pos_y = 2;

    pub fn view_pos_y(&self) -> i32 {
        self.view_pos_y.unwrap_or(0)
    }

    pub fn clear_view_pos_y(&mut self) {
        self.view_pos_y = ::std::option::Option::None;
    }

    pub fn has_view_pos_y(&self) -> bool {
        self.view_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_pos_y(&mut self, v: i32) {
        self.view_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 view_pos_z = 3;

    pub fn view_pos_z(&self) -> i32 {
        self.view_pos_z.unwrap_or(0)
    }

    pub fn clear_view_pos_z(&mut self) {
        self.view_pos_z = ::std::option::Option::None;
    }

    pub fn has_view_pos_z(&self) -> bool {
        self.view_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_pos_z(&mut self, v: i32) {
        self.view_pos_z = ::std::option::Option::Some(v);
    }

    // optional int32 view_size_x = 4;

    pub fn view_size_x(&self) -> i32 {
        self.view_size_x.unwrap_or(0)
    }

    pub fn clear_view_size_x(&mut self) {
        self.view_size_x = ::std::option::Option::None;
    }

    pub fn has_view_size_x(&self) -> bool {
        self.view_size_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_size_x(&mut self, v: i32) {
        self.view_size_x = ::std::option::Option::Some(v);
    }

    // optional int32 view_size_y = 5;

    pub fn view_size_y(&self) -> i32 {
        self.view_size_y.unwrap_or(0)
    }

    pub fn clear_view_size_y(&mut self) {
        self.view_size_y = ::std::option::Option::None;
    }

    pub fn has_view_size_y(&self) -> bool {
        self.view_size_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_size_y(&mut self, v: i32) {
        self.view_size_y = ::std::option::Option::Some(v);
    }

    // optional int32 cursor_pos_x = 6;

    pub fn cursor_pos_x(&self) -> i32 {
        self.cursor_pos_x.unwrap_or(0)
    }

    pub fn clear_cursor_pos_x(&mut self) {
        self.cursor_pos_x = ::std::option::Option::None;
    }

    pub fn has_cursor_pos_x(&self) -> bool {
        self.cursor_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_pos_x(&mut self, v: i32) {
        self.cursor_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 cursor_pos_y = 7;

    pub fn cursor_pos_y(&self) -> i32 {
        self.cursor_pos_y.unwrap_or(0)
    }

    pub fn clear_cursor_pos_y(&mut self) {
        self.cursor_pos_y = ::std::option::Option::None;
    }

    pub fn has_cursor_pos_y(&self) -> bool {
        self.cursor_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_pos_y(&mut self, v: i32) {
        self.cursor_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 cursor_pos_z = 8;

    pub fn cursor_pos_z(&self) -> i32 {
        self.cursor_pos_z.unwrap_or(0)
    }

    pub fn clear_cursor_pos_z(&mut self) {
        self.cursor_pos_z = ::std::option::Option::None;
    }

    pub fn has_cursor_pos_z(&self) -> bool {
        self.cursor_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_pos_z(&mut self, v: i32) {
        self.cursor_pos_z = ::std::option::Option::Some(v);
    }

    // optional int32 follow_unit_id = 9;

    pub fn follow_unit_id(&self) -> i32 {
        self.follow_unit_id.unwrap_or(-1i32)
    }

    pub fn clear_follow_unit_id(&mut self) {
        self.follow_unit_id = ::std::option::Option::None;
    }

    pub fn has_follow_unit_id(&self) -> bool {
        self.follow_unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow_unit_id(&mut self, v: i32) {
        self.follow_unit_id = ::std::option::Option::Some(v);
    }

    // optional int32 follow_item_id = 10;

    pub fn follow_item_id(&self) -> i32 {
        self.follow_item_id.unwrap_or(-1i32)
    }

    pub fn clear_follow_item_id(&mut self) {
        self.follow_item_id = ::std::option::Option::None;
    }

    pub fn has_follow_item_id(&self) -> bool {
        self.follow_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow_item_id(&mut self, v: i32) {
        self.follow_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_pos_x",
            |m: &ViewInfo| { &m.view_pos_x },
            |m: &mut ViewInfo| { &mut m.view_pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_pos_y",
            |m: &ViewInfo| { &m.view_pos_y },
            |m: &mut ViewInfo| { &mut m.view_pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_pos_z",
            |m: &ViewInfo| { &m.view_pos_z },
            |m: &mut ViewInfo| { &mut m.view_pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_size_x",
            |m: &ViewInfo| { &m.view_size_x },
            |m: &mut ViewInfo| { &mut m.view_size_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_size_y",
            |m: &ViewInfo| { &m.view_size_y },
            |m: &mut ViewInfo| { &mut m.view_size_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_pos_x",
            |m: &ViewInfo| { &m.cursor_pos_x },
            |m: &mut ViewInfo| { &mut m.cursor_pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_pos_y",
            |m: &ViewInfo| { &m.cursor_pos_y },
            |m: &mut ViewInfo| { &mut m.cursor_pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_pos_z",
            |m: &ViewInfo| { &m.cursor_pos_z },
            |m: &mut ViewInfo| { &mut m.cursor_pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "follow_unit_id",
            |m: &ViewInfo| { &m.follow_unit_id },
            |m: &mut ViewInfo| { &mut m.follow_unit_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "follow_item_id",
            |m: &ViewInfo| { &m.follow_item_id },
            |m: &mut ViewInfo| { &mut m.follow_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ViewInfo>(
            "ViewInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ViewInfo {
    const NAME: &'static str = "ViewInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.view_pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.view_pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.view_pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.view_size_x = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.view_size_y = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.cursor_pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.cursor_pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.cursor_pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.follow_unit_id = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.follow_item_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.view_pos_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.view_pos_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.view_pos_z {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.view_size_x {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.view_size_y {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.cursor_pos_x {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.cursor_pos_y {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.cursor_pos_z {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.follow_unit_id {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.follow_item_id {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.view_pos_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.view_pos_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.view_pos_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.view_size_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.view_size_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cursor_pos_x {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.cursor_pos_y {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.cursor_pos_z {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.follow_unit_id {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.follow_item_id {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ViewInfo {
        ViewInfo::new()
    }

    fn clear(&mut self) {
        self.view_pos_x = ::std::option::Option::None;
        self.view_pos_y = ::std::option::Option::None;
        self.view_pos_z = ::std::option::Option::None;
        self.view_size_x = ::std::option::Option::None;
        self.view_size_y = ::std::option::Option::None;
        self.cursor_pos_x = ::std::option::Option::None;
        self.cursor_pos_y = ::std::option::Option::None;
        self.cursor_pos_z = ::std::option::Option::None;
        self.follow_unit_id = ::std::option::Option::None;
        self.follow_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ViewInfo {
        static instance: ViewInfo = ViewInfo {
            view_pos_x: ::std::option::Option::None,
            view_pos_y: ::std::option::Option::None,
            view_pos_z: ::std::option::Option::None,
            view_size_x: ::std::option::Option::None,
            view_size_y: ::std::option::Option::None,
            cursor_pos_x: ::std::option::Option::None,
            cursor_pos_y: ::std::option::Option::None,
            cursor_pos_z: ::std::option::Option::None,
            follow_unit_id: ::std::option::Option::None,
            follow_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ViewInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ViewInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ViewInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.MapInfo)
pub struct MapInfo {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.block_size_x)
    pub block_size_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.block_size_y)
    pub block_size_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.block_size_z)
    pub block_size_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.block_pos_x)
    pub block_pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.block_pos_y)
    pub block_pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.block_pos_z)
    pub block_pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.world_name)
    pub world_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.world_name_english)
    pub world_name_english: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.MapInfo.save_name)
    pub save_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.MapInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapInfo {
    fn default() -> &'a MapInfo {
        <MapInfo as ::protobuf::Message>::default_instance()
    }
}

impl MapInfo {
    pub fn new() -> MapInfo {
        ::std::default::Default::default()
    }

    // optional int32 block_size_x = 1;

    pub fn block_size_x(&self) -> i32 {
        self.block_size_x.unwrap_or(0)
    }

    pub fn clear_block_size_x(&mut self) {
        self.block_size_x = ::std::option::Option::None;
    }

    pub fn has_block_size_x(&self) -> bool {
        self.block_size_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size_x(&mut self, v: i32) {
        self.block_size_x = ::std::option::Option::Some(v);
    }

    // optional int32 block_size_y = 2;

    pub fn block_size_y(&self) -> i32 {
        self.block_size_y.unwrap_or(0)
    }

    pub fn clear_block_size_y(&mut self) {
        self.block_size_y = ::std::option::Option::None;
    }

    pub fn has_block_size_y(&self) -> bool {
        self.block_size_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size_y(&mut self, v: i32) {
        self.block_size_y = ::std::option::Option::Some(v);
    }

    // optional int32 block_size_z = 3;

    pub fn block_size_z(&self) -> i32 {
        self.block_size_z.unwrap_or(0)
    }

    pub fn clear_block_size_z(&mut self) {
        self.block_size_z = ::std::option::Option::None;
    }

    pub fn has_block_size_z(&self) -> bool {
        self.block_size_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size_z(&mut self, v: i32) {
        self.block_size_z = ::std::option::Option::Some(v);
    }

    // optional int32 block_pos_x = 4;

    pub fn block_pos_x(&self) -> i32 {
        self.block_pos_x.unwrap_or(0)
    }

    pub fn clear_block_pos_x(&mut self) {
        self.block_pos_x = ::std::option::Option::None;
    }

    pub fn has_block_pos_x(&self) -> bool {
        self.block_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_pos_x(&mut self, v: i32) {
        self.block_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 block_pos_y = 5;

    pub fn block_pos_y(&self) -> i32 {
        self.block_pos_y.unwrap_or(0)
    }

    pub fn clear_block_pos_y(&mut self) {
        self.block_pos_y = ::std::option::Option::None;
    }

    pub fn has_block_pos_y(&self) -> bool {
        self.block_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_pos_y(&mut self, v: i32) {
        self.block_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 block_pos_z = 6;

    pub fn block_pos_z(&self) -> i32 {
        self.block_pos_z.unwrap_or(0)
    }

    pub fn clear_block_pos_z(&mut self) {
        self.block_pos_z = ::std::option::Option::None;
    }

    pub fn has_block_pos_z(&self) -> bool {
        self.block_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_pos_z(&mut self, v: i32) {
        self.block_pos_z = ::std::option::Option::Some(v);
    }

    // optional string world_name = 7;

    pub fn world_name(&self) -> &str {
        match self.world_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_world_name(&mut self) {
        self.world_name = ::std::option::Option::None;
    }

    pub fn has_world_name(&self) -> bool {
        self.world_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_name(&mut self, v: ::std::string::String) {
        self.world_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_name(&mut self) -> &mut ::std::string::String {
        if self.world_name.is_none() {
            self.world_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.world_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_name(&mut self) -> ::std::string::String {
        self.world_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string world_name_english = 8;

    pub fn world_name_english(&self) -> &str {
        match self.world_name_english.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_world_name_english(&mut self) {
        self.world_name_english = ::std::option::Option::None;
    }

    pub fn has_world_name_english(&self) -> bool {
        self.world_name_english.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_name_english(&mut self, v: ::std::string::String) {
        self.world_name_english = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_name_english(&mut self) -> &mut ::std::string::String {
        if self.world_name_english.is_none() {
            self.world_name_english = ::std::option::Option::Some(::std::string::String::new());
        }
        self.world_name_english.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_name_english(&mut self) -> ::std::string::String {
        self.world_name_english.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string save_name = 9;

    pub fn save_name(&self) -> &str {
        match self.save_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_save_name(&mut self) {
        self.save_name = ::std::option::Option::None;
    }

    pub fn has_save_name(&self) -> bool {
        self.save_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_name(&mut self, v: ::std::string::String) {
        self.save_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_name(&mut self) -> &mut ::std::string::String {
        if self.save_name.is_none() {
            self.save_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.save_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_name(&mut self) -> ::std::string::String {
        self.save_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_size_x",
            |m: &MapInfo| { &m.block_size_x },
            |m: &mut MapInfo| { &mut m.block_size_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_size_y",
            |m: &MapInfo| { &m.block_size_y },
            |m: &mut MapInfo| { &mut m.block_size_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_size_z",
            |m: &MapInfo| { &m.block_size_z },
            |m: &mut MapInfo| { &mut m.block_size_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_pos_x",
            |m: &MapInfo| { &m.block_pos_x },
            |m: &mut MapInfo| { &mut m.block_pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_pos_y",
            |m: &MapInfo| { &m.block_pos_y },
            |m: &mut MapInfo| { &mut m.block_pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_pos_z",
            |m: &MapInfo| { &m.block_pos_z },
            |m: &mut MapInfo| { &mut m.block_pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_name",
            |m: &MapInfo| { &m.world_name },
            |m: &mut MapInfo| { &mut m.world_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_name_english",
            |m: &MapInfo| { &m.world_name_english },
            |m: &mut MapInfo| { &mut m.world_name_english },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "save_name",
            |m: &MapInfo| { &m.save_name },
            |m: &mut MapInfo| { &mut m.save_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapInfo>(
            "MapInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapInfo {
    const NAME: &'static str = "MapInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block_size_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.block_size_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.block_size_z = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.block_pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.block_pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.block_pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.world_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.world_name_english = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.save_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block_size_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.block_size_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.block_size_z {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.block_pos_x {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.block_pos_y {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.block_pos_z {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.world_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.world_name_english.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.save_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block_size_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.block_size_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.block_size_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.block_pos_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.block_pos_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.block_pos_z {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.world_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.world_name_english.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.save_name.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapInfo {
        MapInfo::new()
    }

    fn clear(&mut self) {
        self.block_size_x = ::std::option::Option::None;
        self.block_size_y = ::std::option::Option::None;
        self.block_size_z = ::std::option::Option::None;
        self.block_pos_x = ::std::option::Option::None;
        self.block_pos_y = ::std::option::Option::None;
        self.block_pos_z = ::std::option::Option::None;
        self.world_name = ::std::option::Option::None;
        self.world_name_english = ::std::option::Option::None;
        self.save_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapInfo {
        static instance: MapInfo = MapInfo {
            block_size_x: ::std::option::Option::None,
            block_size_y: ::std::option::Option::None,
            block_size_z: ::std::option::Option::None,
            block_pos_x: ::std::option::Option::None,
            block_pos_y: ::std::option::Option::None,
            block_pos_z: ::std::option::Option::None,
            world_name: ::std::option::Option::None,
            world_name_english: ::std::option::Option::None,
            save_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Cloud)
pub struct Cloud {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Cloud.front)
    pub front: ::std::option::Option<::protobuf::EnumOrUnknown<FrontType>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Cloud.cumulus)
    pub cumulus: ::std::option::Option<::protobuf::EnumOrUnknown<CumulusType>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Cloud.cirrus)
    pub cirrus: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Cloud.stratus)
    pub stratus: ::std::option::Option<::protobuf::EnumOrUnknown<StratusType>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Cloud.fog)
    pub fog: ::std::option::Option<::protobuf::EnumOrUnknown<FogType>>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Cloud.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cloud {
    fn default() -> &'a Cloud {
        <Cloud as ::protobuf::Message>::default_instance()
    }
}

impl Cloud {
    pub fn new() -> Cloud {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.FrontType front = 1;

    pub fn front(&self) -> FrontType {
        match self.front {
            Some(e) => e.enum_value_or(FrontType::FRONT_NONE),
            None => FrontType::FRONT_NONE,
        }
    }

    pub fn clear_front(&mut self) {
        self.front = ::std::option::Option::None;
    }

    pub fn has_front(&self) -> bool {
        self.front.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front(&mut self, v: FrontType) {
        self.front = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RemoteFortressReader.CumulusType cumulus = 2;

    pub fn cumulus(&self) -> CumulusType {
        match self.cumulus {
            Some(e) => e.enum_value_or(CumulusType::CUMULUS_NONE),
            None => CumulusType::CUMULUS_NONE,
        }
    }

    pub fn clear_cumulus(&mut self) {
        self.cumulus = ::std::option::Option::None;
    }

    pub fn has_cumulus(&self) -> bool {
        self.cumulus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cumulus(&mut self, v: CumulusType) {
        self.cumulus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool cirrus = 3;

    pub fn cirrus(&self) -> bool {
        self.cirrus.unwrap_or(false)
    }

    pub fn clear_cirrus(&mut self) {
        self.cirrus = ::std::option::Option::None;
    }

    pub fn has_cirrus(&self) -> bool {
        self.cirrus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cirrus(&mut self, v: bool) {
        self.cirrus = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.StratusType stratus = 4;

    pub fn stratus(&self) -> StratusType {
        match self.stratus {
            Some(e) => e.enum_value_or(StratusType::STRATUS_NONE),
            None => StratusType::STRATUS_NONE,
        }
    }

    pub fn clear_stratus(&mut self) {
        self.stratus = ::std::option::Option::None;
    }

    pub fn has_stratus(&self) -> bool {
        self.stratus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stratus(&mut self, v: StratusType) {
        self.stratus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RemoteFortressReader.FogType fog = 5;

    pub fn fog(&self) -> FogType {
        match self.fog {
            Some(e) => e.enum_value_or(FogType::FOG_NONE),
            None => FogType::FOG_NONE,
        }
    }

    pub fn clear_fog(&mut self) {
        self.fog = ::std::option::Option::None;
    }

    pub fn has_fog(&self) -> bool {
        self.fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fog(&mut self, v: FogType) {
        self.fog = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "front",
            |m: &Cloud| { &m.front },
            |m: &mut Cloud| { &mut m.front },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cumulus",
            |m: &Cloud| { &m.cumulus },
            |m: &mut Cloud| { &mut m.cumulus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cirrus",
            |m: &Cloud| { &m.cirrus },
            |m: &mut Cloud| { &mut m.cirrus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stratus",
            |m: &Cloud| { &m.stratus },
            |m: &mut Cloud| { &mut m.stratus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fog",
            |m: &Cloud| { &m.fog },
            |m: &mut Cloud| { &mut m.fog },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cloud>(
            "Cloud",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cloud {
    const NAME: &'static str = "Cloud";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.front = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.cumulus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.cirrus = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.stratus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.fog = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.front {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.cumulus {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.cirrus {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stratus {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.fog {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.front {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cumulus {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cirrus {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.stratus {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fog {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cloud {
        Cloud::new()
    }

    fn clear(&mut self) {
        self.front = ::std::option::Option::None;
        self.cumulus = ::std::option::Option::None;
        self.cirrus = ::std::option::Option::None;
        self.stratus = ::std::option::Option::None;
        self.fog = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cloud {
        static instance: Cloud = Cloud {
            front: ::std::option::Option::None,
            cumulus: ::std::option::Option::None,
            cirrus: ::std::option::Option::None,
            stratus: ::std::option::Option::None,
            fog: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cloud {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cloud").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cloud {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cloud {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.WorldMap)
pub struct WorldMap {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.world_width)
    pub world_width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.world_height)
    pub world_height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.name)
    pub name: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.name_english)
    pub name_english: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.elevation)
    pub elevation: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.rainfall)
    pub rainfall: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.vegetation)
    pub vegetation: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.temperature)
    pub temperature: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.evilness)
    pub evilness: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.drainage)
    pub drainage: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.volcanism)
    pub volcanism: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.savagery)
    pub savagery: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.clouds)
    pub clouds: ::std::vec::Vec<Cloud>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.salinity)
    pub salinity: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.map_x)
    pub map_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.map_y)
    pub map_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.center_x)
    pub center_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.center_y)
    pub center_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.center_z)
    pub center_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.cur_year)
    pub cur_year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.cur_year_tick)
    pub cur_year_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.world_poles)
    pub world_poles: ::std::option::Option<::protobuf::EnumOrUnknown<WorldPoles>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.river_tiles)
    pub river_tiles: ::std::vec::Vec<RiverTile>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.water_elevation)
    pub water_elevation: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.WorldMap.region_tiles)
    pub region_tiles: ::std::vec::Vec<RegionTile>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.WorldMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorldMap {
    fn default() -> &'a WorldMap {
        <WorldMap as ::protobuf::Message>::default_instance()
    }
}

impl WorldMap {
    pub fn new() -> WorldMap {
        ::std::default::Default::default()
    }

    // required int32 world_width = 1;

    pub fn world_width(&self) -> i32 {
        self.world_width.unwrap_or(0)
    }

    pub fn clear_world_width(&mut self) {
        self.world_width = ::std::option::Option::None;
    }

    pub fn has_world_width(&self) -> bool {
        self.world_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_width(&mut self, v: i32) {
        self.world_width = ::std::option::Option::Some(v);
    }

    // required int32 world_height = 2;

    pub fn world_height(&self) -> i32 {
        self.world_height.unwrap_or(0)
    }

    pub fn clear_world_height(&mut self) {
        self.world_height = ::std::option::Option::None;
    }

    pub fn has_world_height(&self) -> bool {
        self.world_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_height(&mut self, v: i32) {
        self.world_height = ::std::option::Option::Some(v);
    }

    // optional bytes name = 3;

    pub fn name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name_english = 4;

    pub fn name_english(&self) -> &str {
        match self.name_english.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_english(&mut self) {
        self.name_english = ::std::option::Option::None;
    }

    pub fn has_name_english(&self) -> bool {
        self.name_english.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_english(&mut self, v: ::std::string::String) {
        self.name_english = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_english(&mut self) -> &mut ::std::string::String {
        if self.name_english.is_none() {
            self.name_english = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_english.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_english(&mut self) -> ::std::string::String {
        self.name_english.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 map_x = 15;

    pub fn map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }

    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // optional int32 map_y = 16;

    pub fn map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }

    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // optional int32 center_x = 17;

    pub fn center_x(&self) -> i32 {
        self.center_x.unwrap_or(0)
    }

    pub fn clear_center_x(&mut self) {
        self.center_x = ::std::option::Option::None;
    }

    pub fn has_center_x(&self) -> bool {
        self.center_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_x(&mut self, v: i32) {
        self.center_x = ::std::option::Option::Some(v);
    }

    // optional int32 center_y = 18;

    pub fn center_y(&self) -> i32 {
        self.center_y.unwrap_or(0)
    }

    pub fn clear_center_y(&mut self) {
        self.center_y = ::std::option::Option::None;
    }

    pub fn has_center_y(&self) -> bool {
        self.center_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_y(&mut self, v: i32) {
        self.center_y = ::std::option::Option::Some(v);
    }

    // optional int32 center_z = 19;

    pub fn center_z(&self) -> i32 {
        self.center_z.unwrap_or(0)
    }

    pub fn clear_center_z(&mut self) {
        self.center_z = ::std::option::Option::None;
    }

    pub fn has_center_z(&self) -> bool {
        self.center_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_z(&mut self, v: i32) {
        self.center_z = ::std::option::Option::Some(v);
    }

    // optional int32 cur_year = 20;

    pub fn cur_year(&self) -> i32 {
        self.cur_year.unwrap_or(0)
    }

    pub fn clear_cur_year(&mut self) {
        self.cur_year = ::std::option::Option::None;
    }

    pub fn has_cur_year(&self) -> bool {
        self.cur_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_year(&mut self, v: i32) {
        self.cur_year = ::std::option::Option::Some(v);
    }

    // optional int32 cur_year_tick = 21;

    pub fn cur_year_tick(&self) -> i32 {
        self.cur_year_tick.unwrap_or(0)
    }

    pub fn clear_cur_year_tick(&mut self) {
        self.cur_year_tick = ::std::option::Option::None;
    }

    pub fn has_cur_year_tick(&self) -> bool {
        self.cur_year_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_year_tick(&mut self, v: i32) {
        self.cur_year_tick = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.WorldPoles world_poles = 22;

    pub fn world_poles(&self) -> WorldPoles {
        match self.world_poles {
            Some(e) => e.enum_value_or(WorldPoles::NO_POLES),
            None => WorldPoles::NO_POLES,
        }
    }

    pub fn clear_world_poles(&mut self) {
        self.world_poles = ::std::option::Option::None;
    }

    pub fn has_world_poles(&self) -> bool {
        self.world_poles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_poles(&mut self, v: WorldPoles) {
        self.world_poles = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_width",
            |m: &WorldMap| { &m.world_width },
            |m: &mut WorldMap| { &mut m.world_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_height",
            |m: &WorldMap| { &m.world_height },
            |m: &mut WorldMap| { &mut m.world_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &WorldMap| { &m.name },
            |m: &mut WorldMap| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_english",
            |m: &WorldMap| { &m.name_english },
            |m: &mut WorldMap| { &mut m.name_english },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elevation",
            |m: &WorldMap| { &m.elevation },
            |m: &mut WorldMap| { &mut m.elevation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rainfall",
            |m: &WorldMap| { &m.rainfall },
            |m: &mut WorldMap| { &mut m.rainfall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vegetation",
            |m: &WorldMap| { &m.vegetation },
            |m: &mut WorldMap| { &mut m.vegetation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "temperature",
            |m: &WorldMap| { &m.temperature },
            |m: &mut WorldMap| { &mut m.temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "evilness",
            |m: &WorldMap| { &m.evilness },
            |m: &mut WorldMap| { &mut m.evilness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "drainage",
            |m: &WorldMap| { &m.drainage },
            |m: &mut WorldMap| { &mut m.drainage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volcanism",
            |m: &WorldMap| { &m.volcanism },
            |m: &mut WorldMap| { &mut m.volcanism },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "savagery",
            |m: &WorldMap| { &m.savagery },
            |m: &mut WorldMap| { &mut m.savagery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clouds",
            |m: &WorldMap| { &m.clouds },
            |m: &mut WorldMap| { &mut m.clouds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "salinity",
            |m: &WorldMap| { &m.salinity },
            |m: &mut WorldMap| { &mut m.salinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_x",
            |m: &WorldMap| { &m.map_x },
            |m: &mut WorldMap| { &mut m.map_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_y",
            |m: &WorldMap| { &m.map_y },
            |m: &mut WorldMap| { &mut m.map_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "center_x",
            |m: &WorldMap| { &m.center_x },
            |m: &mut WorldMap| { &mut m.center_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "center_y",
            |m: &WorldMap| { &m.center_y },
            |m: &mut WorldMap| { &mut m.center_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "center_z",
            |m: &WorldMap| { &m.center_z },
            |m: &mut WorldMap| { &mut m.center_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cur_year",
            |m: &WorldMap| { &m.cur_year },
            |m: &mut WorldMap| { &mut m.cur_year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cur_year_tick",
            |m: &WorldMap| { &m.cur_year_tick },
            |m: &mut WorldMap| { &mut m.cur_year_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "world_poles",
            |m: &WorldMap| { &m.world_poles },
            |m: &mut WorldMap| { &mut m.world_poles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "river_tiles",
            |m: &WorldMap| { &m.river_tiles },
            |m: &mut WorldMap| { &mut m.river_tiles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "water_elevation",
            |m: &WorldMap| { &m.water_elevation },
            |m: &mut WorldMap| { &mut m.water_elevation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "region_tiles",
            |m: &WorldMap| { &m.region_tiles },
            |m: &mut WorldMap| { &mut m.region_tiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorldMap>(
            "WorldMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorldMap {
    const NAME: &'static str = "WorldMap";

    fn is_initialized(&self) -> bool {
        if self.world_width.is_none() {
            return false;
        }
        if self.world_height.is_none() {
            return false;
        }
        for v in &self.clouds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.river_tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.world_width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.world_height = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.name_english = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.elevation)?;
                },
                40 => {
                    self.elevation.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.rainfall)?;
                },
                48 => {
                    self.rainfall.push(is.read_int32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.vegetation)?;
                },
                56 => {
                    self.vegetation.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.temperature)?;
                },
                64 => {
                    self.temperature.push(is.read_int32()?);
                },
                74 => {
                    is.read_repeated_packed_int32_into(&mut self.evilness)?;
                },
                72 => {
                    self.evilness.push(is.read_int32()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.drainage)?;
                },
                80 => {
                    self.drainage.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.volcanism)?;
                },
                88 => {
                    self.volcanism.push(is.read_int32()?);
                },
                98 => {
                    is.read_repeated_packed_int32_into(&mut self.savagery)?;
                },
                96 => {
                    self.savagery.push(is.read_int32()?);
                },
                106 => {
                    self.clouds.push(is.read_message()?);
                },
                114 => {
                    is.read_repeated_packed_int32_into(&mut self.salinity)?;
                },
                112 => {
                    self.salinity.push(is.read_int32()?);
                },
                120 => {
                    self.map_x = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.map_y = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.center_x = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.center_y = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.center_z = ::std::option::Option::Some(is.read_int32()?);
                },
                160 => {
                    self.cur_year = ::std::option::Option::Some(is.read_int32()?);
                },
                168 => {
                    self.cur_year_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                176 => {
                    self.world_poles = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                186 => {
                    self.river_tiles.push(is.read_message()?);
                },
                194 => {
                    is.read_repeated_packed_int32_into(&mut self.water_elevation)?;
                },
                192 => {
                    self.water_elevation.push(is.read_int32()?);
                },
                202 => {
                    self.region_tiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.world_width {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.world_height {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.name_english.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.elevation {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.rainfall {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        for value in &self.vegetation {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        for value in &self.temperature {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        for value in &self.evilness {
            my_size += ::protobuf::rt::int32_size(9, *value);
        };
        for value in &self.drainage {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        for value in &self.volcanism {
            my_size += ::protobuf::rt::int32_size(11, *value);
        };
        for value in &self.savagery {
            my_size += ::protobuf::rt::int32_size(12, *value);
        };
        for value in &self.clouds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.salinity {
            my_size += ::protobuf::rt::int32_size(14, *value);
        };
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.center_x {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.center_y {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.center_z {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        if let Some(v) = self.cur_year {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.cur_year_tick {
            my_size += ::protobuf::rt::int32_size(21, v);
        }
        if let Some(v) = self.world_poles {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        for value in &self.river_tiles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.water_elevation {
            my_size += ::protobuf::rt::int32_size(24, *value);
        };
        for value in &self.region_tiles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.world_width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.world_height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.name_english.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.elevation {
            os.write_int32(5, *v)?;
        };
        for v in &self.rainfall {
            os.write_int32(6, *v)?;
        };
        for v in &self.vegetation {
            os.write_int32(7, *v)?;
        };
        for v in &self.temperature {
            os.write_int32(8, *v)?;
        };
        for v in &self.evilness {
            os.write_int32(9, *v)?;
        };
        for v in &self.drainage {
            os.write_int32(10, *v)?;
        };
        for v in &self.volcanism {
            os.write_int32(11, *v)?;
        };
        for v in &self.savagery {
            os.write_int32(12, *v)?;
        };
        for v in &self.clouds {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.salinity {
            os.write_int32(14, *v)?;
        };
        if let Some(v) = self.map_x {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.center_x {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.center_y {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.center_z {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.cur_year {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.cur_year_tick {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.world_poles {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.river_tiles {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        for v in &self.water_elevation {
            os.write_int32(24, *v)?;
        };
        for v in &self.region_tiles {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorldMap {
        WorldMap::new()
    }

    fn clear(&mut self) {
        self.world_width = ::std::option::Option::None;
        self.world_height = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.name_english = ::std::option::Option::None;
        self.elevation.clear();
        self.rainfall.clear();
        self.vegetation.clear();
        self.temperature.clear();
        self.evilness.clear();
        self.drainage.clear();
        self.volcanism.clear();
        self.savagery.clear();
        self.clouds.clear();
        self.salinity.clear();
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.center_x = ::std::option::Option::None;
        self.center_y = ::std::option::Option::None;
        self.center_z = ::std::option::Option::None;
        self.cur_year = ::std::option::Option::None;
        self.cur_year_tick = ::std::option::Option::None;
        self.world_poles = ::std::option::Option::None;
        self.river_tiles.clear();
        self.water_elevation.clear();
        self.region_tiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorldMap {
        static instance: WorldMap = WorldMap {
            world_width: ::std::option::Option::None,
            world_height: ::std::option::Option::None,
            name: ::std::option::Option::None,
            name_english: ::std::option::Option::None,
            elevation: ::std::vec::Vec::new(),
            rainfall: ::std::vec::Vec::new(),
            vegetation: ::std::vec::Vec::new(),
            temperature: ::std::vec::Vec::new(),
            evilness: ::std::vec::Vec::new(),
            drainage: ::std::vec::Vec::new(),
            volcanism: ::std::vec::Vec::new(),
            savagery: ::std::vec::Vec::new(),
            clouds: ::std::vec::Vec::new(),
            salinity: ::std::vec::Vec::new(),
            map_x: ::std::option::Option::None,
            map_y: ::std::option::Option::None,
            center_x: ::std::option::Option::None,
            center_y: ::std::option::Option::None,
            center_z: ::std::option::Option::None,
            cur_year: ::std::option::Option::None,
            cur_year_tick: ::std::option::Option::None,
            world_poles: ::std::option::Option::None,
            river_tiles: ::std::vec::Vec::new(),
            water_elevation: ::std::vec::Vec::new(),
            region_tiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorldMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorldMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorldMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.SiteRealizationBuildingWall)
pub struct SiteRealizationBuildingWall {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingWall.start_x)
    pub start_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingWall.start_y)
    pub start_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingWall.start_z)
    pub start_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingWall.end_x)
    pub end_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingWall.end_y)
    pub end_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingWall.end_z)
    pub end_z: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.SiteRealizationBuildingWall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuildingWall {
    fn default() -> &'a SiteRealizationBuildingWall {
        <SiteRealizationBuildingWall as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuildingWall {
    pub fn new() -> SiteRealizationBuildingWall {
        ::std::default::Default::default()
    }

    // optional int32 start_x = 1;

    pub fn start_x(&self) -> i32 {
        self.start_x.unwrap_or(0)
    }

    pub fn clear_start_x(&mut self) {
        self.start_x = ::std::option::Option::None;
    }

    pub fn has_start_x(&self) -> bool {
        self.start_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_x(&mut self, v: i32) {
        self.start_x = ::std::option::Option::Some(v);
    }

    // optional int32 start_y = 2;

    pub fn start_y(&self) -> i32 {
        self.start_y.unwrap_or(0)
    }

    pub fn clear_start_y(&mut self) {
        self.start_y = ::std::option::Option::None;
    }

    pub fn has_start_y(&self) -> bool {
        self.start_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_y(&mut self, v: i32) {
        self.start_y = ::std::option::Option::Some(v);
    }

    // optional int32 start_z = 3;

    pub fn start_z(&self) -> i32 {
        self.start_z.unwrap_or(0)
    }

    pub fn clear_start_z(&mut self) {
        self.start_z = ::std::option::Option::None;
    }

    pub fn has_start_z(&self) -> bool {
        self.start_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_z(&mut self, v: i32) {
        self.start_z = ::std::option::Option::Some(v);
    }

    // optional int32 end_x = 4;

    pub fn end_x(&self) -> i32 {
        self.end_x.unwrap_or(0)
    }

    pub fn clear_end_x(&mut self) {
        self.end_x = ::std::option::Option::None;
    }

    pub fn has_end_x(&self) -> bool {
        self.end_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_x(&mut self, v: i32) {
        self.end_x = ::std::option::Option::Some(v);
    }

    // optional int32 end_y = 5;

    pub fn end_y(&self) -> i32 {
        self.end_y.unwrap_or(0)
    }

    pub fn clear_end_y(&mut self) {
        self.end_y = ::std::option::Option::None;
    }

    pub fn has_end_y(&self) -> bool {
        self.end_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_y(&mut self, v: i32) {
        self.end_y = ::std::option::Option::Some(v);
    }

    // optional int32 end_z = 6;

    pub fn end_z(&self) -> i32 {
        self.end_z.unwrap_or(0)
    }

    pub fn clear_end_z(&mut self) {
        self.end_z = ::std::option::Option::None;
    }

    pub fn has_end_z(&self) -> bool {
        self.end_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_z(&mut self, v: i32) {
        self.end_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_x",
            |m: &SiteRealizationBuildingWall| { &m.start_x },
            |m: &mut SiteRealizationBuildingWall| { &mut m.start_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_y",
            |m: &SiteRealizationBuildingWall| { &m.start_y },
            |m: &mut SiteRealizationBuildingWall| { &mut m.start_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_z",
            |m: &SiteRealizationBuildingWall| { &m.start_z },
            |m: &mut SiteRealizationBuildingWall| { &mut m.start_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_x",
            |m: &SiteRealizationBuildingWall| { &m.end_x },
            |m: &mut SiteRealizationBuildingWall| { &mut m.end_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_y",
            |m: &SiteRealizationBuildingWall| { &m.end_y },
            |m: &mut SiteRealizationBuildingWall| { &mut m.end_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_z",
            |m: &SiteRealizationBuildingWall| { &m.end_z },
            |m: &mut SiteRealizationBuildingWall| { &mut m.end_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SiteRealizationBuildingWall>(
            "SiteRealizationBuildingWall",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SiteRealizationBuildingWall {
    const NAME: &'static str = "SiteRealizationBuildingWall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.start_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.start_z = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end_x = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.end_y = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.end_z = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.start_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.start_z {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.end_x {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.end_y {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.end_z {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.start_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.start_z {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.end_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.end_z {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SiteRealizationBuildingWall {
        SiteRealizationBuildingWall::new()
    }

    fn clear(&mut self) {
        self.start_x = ::std::option::Option::None;
        self.start_y = ::std::option::Option::None;
        self.start_z = ::std::option::Option::None;
        self.end_x = ::std::option::Option::None;
        self.end_y = ::std::option::Option::None;
        self.end_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SiteRealizationBuildingWall {
        static instance: SiteRealizationBuildingWall = SiteRealizationBuildingWall {
            start_x: ::std::option::Option::None,
            start_y: ::std::option::Option::None,
            start_z: ::std::option::Option::None,
            end_x: ::std::option::Option::None,
            end_y: ::std::option::Option::None,
            end_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SiteRealizationBuildingWall {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SiteRealizationBuildingWall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SiteRealizationBuildingWall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuildingWall {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.SiteRealizationBuildingTower)
pub struct SiteRealizationBuildingTower {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingTower.roof_z)
    pub roof_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingTower.round)
    pub round: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingTower.goblin)
    pub goblin: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.SiteRealizationBuildingTower.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuildingTower {
    fn default() -> &'a SiteRealizationBuildingTower {
        <SiteRealizationBuildingTower as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuildingTower {
    pub fn new() -> SiteRealizationBuildingTower {
        ::std::default::Default::default()
    }

    // optional int32 roof_z = 1;

    pub fn roof_z(&self) -> i32 {
        self.roof_z.unwrap_or(0)
    }

    pub fn clear_roof_z(&mut self) {
        self.roof_z = ::std::option::Option::None;
    }

    pub fn has_roof_z(&self) -> bool {
        self.roof_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roof_z(&mut self, v: i32) {
        self.roof_z = ::std::option::Option::Some(v);
    }

    // optional bool round = 2;

    pub fn round(&self) -> bool {
        self.round.unwrap_or(false)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: bool) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional bool goblin = 3;

    pub fn goblin(&self) -> bool {
        self.goblin.unwrap_or(false)
    }

    pub fn clear_goblin(&mut self) {
        self.goblin = ::std::option::Option::None;
    }

    pub fn has_goblin(&self) -> bool {
        self.goblin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goblin(&mut self, v: bool) {
        self.goblin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roof_z",
            |m: &SiteRealizationBuildingTower| { &m.roof_z },
            |m: &mut SiteRealizationBuildingTower| { &mut m.roof_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round",
            |m: &SiteRealizationBuildingTower| { &m.round },
            |m: &mut SiteRealizationBuildingTower| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "goblin",
            |m: &SiteRealizationBuildingTower| { &m.goblin },
            |m: &mut SiteRealizationBuildingTower| { &mut m.goblin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SiteRealizationBuildingTower>(
            "SiteRealizationBuildingTower",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SiteRealizationBuildingTower {
    const NAME: &'static str = "SiteRealizationBuildingTower";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.roof_z = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.round = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.goblin = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.roof_z {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.round {
            my_size += 1 + 1;
        }
        if let Some(v) = self.goblin {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.roof_z {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.round {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.goblin {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SiteRealizationBuildingTower {
        SiteRealizationBuildingTower::new()
    }

    fn clear(&mut self) {
        self.roof_z = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.goblin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SiteRealizationBuildingTower {
        static instance: SiteRealizationBuildingTower = SiteRealizationBuildingTower {
            roof_z: ::std::option::Option::None,
            round: ::std::option::Option::None,
            goblin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SiteRealizationBuildingTower {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SiteRealizationBuildingTower").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SiteRealizationBuildingTower {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuildingTower {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.TrenchSpoke)
pub struct TrenchSpoke {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.TrenchSpoke.mound_start)
    pub mound_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TrenchSpoke.trench_start)
    pub trench_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TrenchSpoke.trench_end)
    pub trench_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TrenchSpoke.mound_end)
    pub mound_end: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.TrenchSpoke.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrenchSpoke {
    fn default() -> &'a TrenchSpoke {
        <TrenchSpoke as ::protobuf::Message>::default_instance()
    }
}

impl TrenchSpoke {
    pub fn new() -> TrenchSpoke {
        ::std::default::Default::default()
    }

    // optional int32 mound_start = 1;

    pub fn mound_start(&self) -> i32 {
        self.mound_start.unwrap_or(0)
    }

    pub fn clear_mound_start(&mut self) {
        self.mound_start = ::std::option::Option::None;
    }

    pub fn has_mound_start(&self) -> bool {
        self.mound_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mound_start(&mut self, v: i32) {
        self.mound_start = ::std::option::Option::Some(v);
    }

    // optional int32 trench_start = 2;

    pub fn trench_start(&self) -> i32 {
        self.trench_start.unwrap_or(0)
    }

    pub fn clear_trench_start(&mut self) {
        self.trench_start = ::std::option::Option::None;
    }

    pub fn has_trench_start(&self) -> bool {
        self.trench_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trench_start(&mut self, v: i32) {
        self.trench_start = ::std::option::Option::Some(v);
    }

    // optional int32 trench_end = 3;

    pub fn trench_end(&self) -> i32 {
        self.trench_end.unwrap_or(0)
    }

    pub fn clear_trench_end(&mut self) {
        self.trench_end = ::std::option::Option::None;
    }

    pub fn has_trench_end(&self) -> bool {
        self.trench_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trench_end(&mut self, v: i32) {
        self.trench_end = ::std::option::Option::Some(v);
    }

    // optional int32 mound_end = 4;

    pub fn mound_end(&self) -> i32 {
        self.mound_end.unwrap_or(0)
    }

    pub fn clear_mound_end(&mut self) {
        self.mound_end = ::std::option::Option::None;
    }

    pub fn has_mound_end(&self) -> bool {
        self.mound_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mound_end(&mut self, v: i32) {
        self.mound_end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mound_start",
            |m: &TrenchSpoke| { &m.mound_start },
            |m: &mut TrenchSpoke| { &mut m.mound_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trench_start",
            |m: &TrenchSpoke| { &m.trench_start },
            |m: &mut TrenchSpoke| { &mut m.trench_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trench_end",
            |m: &TrenchSpoke| { &m.trench_end },
            |m: &mut TrenchSpoke| { &mut m.trench_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mound_end",
            |m: &TrenchSpoke| { &m.mound_end },
            |m: &mut TrenchSpoke| { &mut m.mound_end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrenchSpoke>(
            "TrenchSpoke",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrenchSpoke {
    const NAME: &'static str = "TrenchSpoke";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mound_start = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.trench_start = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.trench_end = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.mound_end = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mound_start {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.trench_start {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.trench_end {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.mound_end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mound_start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.trench_start {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.trench_end {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mound_end {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrenchSpoke {
        TrenchSpoke::new()
    }

    fn clear(&mut self) {
        self.mound_start = ::std::option::Option::None;
        self.trench_start = ::std::option::Option::None;
        self.trench_end = ::std::option::Option::None;
        self.mound_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrenchSpoke {
        static instance: TrenchSpoke = TrenchSpoke {
            mound_start: ::std::option::Option::None,
            trench_start: ::std::option::Option::None,
            trench_end: ::std::option::Option::None,
            mound_end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrenchSpoke {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrenchSpoke").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrenchSpoke {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrenchSpoke {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.SiteRealizationBuildingTrenches)
pub struct SiteRealizationBuildingTrenches {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuildingTrenches.spokes)
    pub spokes: ::std::vec::Vec<TrenchSpoke>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.SiteRealizationBuildingTrenches.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuildingTrenches {
    fn default() -> &'a SiteRealizationBuildingTrenches {
        <SiteRealizationBuildingTrenches as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuildingTrenches {
    pub fn new() -> SiteRealizationBuildingTrenches {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "spokes",
            |m: &SiteRealizationBuildingTrenches| { &m.spokes },
            |m: &mut SiteRealizationBuildingTrenches| { &mut m.spokes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SiteRealizationBuildingTrenches>(
            "SiteRealizationBuildingTrenches",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SiteRealizationBuildingTrenches {
    const NAME: &'static str = "SiteRealizationBuildingTrenches";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.spokes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.spokes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.spokes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SiteRealizationBuildingTrenches {
        SiteRealizationBuildingTrenches::new()
    }

    fn clear(&mut self) {
        self.spokes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SiteRealizationBuildingTrenches {
        static instance: SiteRealizationBuildingTrenches = SiteRealizationBuildingTrenches {
            spokes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SiteRealizationBuildingTrenches {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SiteRealizationBuildingTrenches").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SiteRealizationBuildingTrenches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuildingTrenches {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.SiteRealizationBuilding)
pub struct SiteRealizationBuilding {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.min_x)
    pub min_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.min_y)
    pub min_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.max_x)
    pub max_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.max_y)
    pub max_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.wall_info)
    pub wall_info: ::protobuf::MessageField<SiteRealizationBuildingWall>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.tower_info)
    pub tower_info: ::protobuf::MessageField<SiteRealizationBuildingTower>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.trench_info)
    pub trench_info: ::protobuf::MessageField<SiteRealizationBuildingTrenches>,
    // @@protoc_insertion_point(field:RemoteFortressReader.SiteRealizationBuilding.type)
    pub type_: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.SiteRealizationBuilding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SiteRealizationBuilding {
    fn default() -> &'a SiteRealizationBuilding {
        <SiteRealizationBuilding as ::protobuf::Message>::default_instance()
    }
}

impl SiteRealizationBuilding {
    pub fn new() -> SiteRealizationBuilding {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 min_x = 3;

    pub fn min_x(&self) -> i32 {
        self.min_x.unwrap_or(0)
    }

    pub fn clear_min_x(&mut self) {
        self.min_x = ::std::option::Option::None;
    }

    pub fn has_min_x(&self) -> bool {
        self.min_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_x(&mut self, v: i32) {
        self.min_x = ::std::option::Option::Some(v);
    }

    // optional int32 min_y = 4;

    pub fn min_y(&self) -> i32 {
        self.min_y.unwrap_or(0)
    }

    pub fn clear_min_y(&mut self) {
        self.min_y = ::std::option::Option::None;
    }

    pub fn has_min_y(&self) -> bool {
        self.min_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_y(&mut self, v: i32) {
        self.min_y = ::std::option::Option::Some(v);
    }

    // optional int32 max_x = 5;

    pub fn max_x(&self) -> i32 {
        self.max_x.unwrap_or(0)
    }

    pub fn clear_max_x(&mut self) {
        self.max_x = ::std::option::Option::None;
    }

    pub fn has_max_x(&self) -> bool {
        self.max_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_x(&mut self, v: i32) {
        self.max_x = ::std::option::Option::Some(v);
    }

    // optional int32 max_y = 6;

    pub fn max_y(&self) -> i32 {
        self.max_y.unwrap_or(0)
    }

    pub fn clear_max_y(&mut self) {
        self.max_y = ::std::option::Option::None;
    }

    pub fn has_max_y(&self) -> bool {
        self.max_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_y(&mut self, v: i32) {
        self.max_y = ::std::option::Option::Some(v);
    }

    // optional int32 type = 11;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &SiteRealizationBuilding| { &m.id },
            |m: &mut SiteRealizationBuilding| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_x",
            |m: &SiteRealizationBuilding| { &m.min_x },
            |m: &mut SiteRealizationBuilding| { &mut m.min_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_y",
            |m: &SiteRealizationBuilding| { &m.min_y },
            |m: &mut SiteRealizationBuilding| { &mut m.min_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_x",
            |m: &SiteRealizationBuilding| { &m.max_x },
            |m: &mut SiteRealizationBuilding| { &mut m.max_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_y",
            |m: &SiteRealizationBuilding| { &m.max_y },
            |m: &mut SiteRealizationBuilding| { &mut m.max_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &SiteRealizationBuilding| { &m.material },
            |m: &mut SiteRealizationBuilding| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SiteRealizationBuildingWall>(
            "wall_info",
            |m: &SiteRealizationBuilding| { &m.wall_info },
            |m: &mut SiteRealizationBuilding| { &mut m.wall_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SiteRealizationBuildingTower>(
            "tower_info",
            |m: &SiteRealizationBuilding| { &m.tower_info },
            |m: &mut SiteRealizationBuilding| { &mut m.tower_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SiteRealizationBuildingTrenches>(
            "trench_info",
            |m: &SiteRealizationBuilding| { &m.trench_info },
            |m: &mut SiteRealizationBuilding| { &mut m.trench_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &SiteRealizationBuilding| { &m.type_ },
            |m: &mut SiteRealizationBuilding| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SiteRealizationBuilding>(
            "SiteRealizationBuilding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SiteRealizationBuilding {
    const NAME: &'static str = "SiteRealizationBuilding";

    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wall_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tower_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trench_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.min_x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.min_y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.max_x = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.max_y = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wall_info)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tower_info)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trench_info)?;
                },
                88 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.min_x {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.min_y {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.max_x {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.max_y {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wall_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tower_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trench_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.min_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.max_x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.max_y {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.wall_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.tower_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.trench_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SiteRealizationBuilding {
        SiteRealizationBuilding::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.min_x = ::std::option::Option::None;
        self.min_y = ::std::option::Option::None;
        self.max_x = ::std::option::Option::None;
        self.max_y = ::std::option::Option::None;
        self.material.clear();
        self.wall_info.clear();
        self.tower_info.clear();
        self.trench_info.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SiteRealizationBuilding {
        static instance: SiteRealizationBuilding = SiteRealizationBuilding {
            id: ::std::option::Option::None,
            min_x: ::std::option::Option::None,
            min_y: ::std::option::Option::None,
            max_x: ::std::option::Option::None,
            max_y: ::std::option::Option::None,
            material: ::protobuf::MessageField::none(),
            wall_info: ::protobuf::MessageField::none(),
            tower_info: ::protobuf::MessageField::none(),
            trench_info: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SiteRealizationBuilding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SiteRealizationBuilding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SiteRealizationBuilding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SiteRealizationBuilding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.RegionTile)
pub struct RegionTile {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.elevation)
    pub elevation: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.rainfall)
    pub rainfall: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.vegetation)
    pub vegetation: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.temperature)
    pub temperature: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.evilness)
    pub evilness: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.drainage)
    pub drainage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.volcanism)
    pub volcanism: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.savagery)
    pub savagery: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.salinity)
    pub salinity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.river_tiles)
    pub river_tiles: ::protobuf::MessageField<RiverTile>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.water_elevation)
    pub water_elevation: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.surface_material)
    pub surface_material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.plant_materials)
    pub plant_materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.buildings)
    pub buildings: ::std::vec::Vec<SiteRealizationBuilding>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.stone_materials)
    pub stone_materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.tree_materials)
    pub tree_materials: ::std::vec::Vec<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionTile.snow)
    pub snow: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.RegionTile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegionTile {
    fn default() -> &'a RegionTile {
        <RegionTile as ::protobuf::Message>::default_instance()
    }
}

impl RegionTile {
    pub fn new() -> RegionTile {
        ::std::default::Default::default()
    }

    // optional int32 elevation = 1;

    pub fn elevation(&self) -> i32 {
        self.elevation.unwrap_or(0)
    }

    pub fn clear_elevation(&mut self) {
        self.elevation = ::std::option::Option::None;
    }

    pub fn has_elevation(&self) -> bool {
        self.elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevation(&mut self, v: i32) {
        self.elevation = ::std::option::Option::Some(v);
    }

    // optional int32 rainfall = 2;

    pub fn rainfall(&self) -> i32 {
        self.rainfall.unwrap_or(0)
    }

    pub fn clear_rainfall(&mut self) {
        self.rainfall = ::std::option::Option::None;
    }

    pub fn has_rainfall(&self) -> bool {
        self.rainfall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rainfall(&mut self, v: i32) {
        self.rainfall = ::std::option::Option::Some(v);
    }

    // optional int32 vegetation = 3;

    pub fn vegetation(&self) -> i32 {
        self.vegetation.unwrap_or(0)
    }

    pub fn clear_vegetation(&mut self) {
        self.vegetation = ::std::option::Option::None;
    }

    pub fn has_vegetation(&self) -> bool {
        self.vegetation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vegetation(&mut self, v: i32) {
        self.vegetation = ::std::option::Option::Some(v);
    }

    // optional int32 temperature = 4;

    pub fn temperature(&self) -> i32 {
        self.temperature.unwrap_or(0)
    }

    pub fn clear_temperature(&mut self) {
        self.temperature = ::std::option::Option::None;
    }

    pub fn has_temperature(&self) -> bool {
        self.temperature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: i32) {
        self.temperature = ::std::option::Option::Some(v);
    }

    // optional int32 evilness = 5;

    pub fn evilness(&self) -> i32 {
        self.evilness.unwrap_or(0)
    }

    pub fn clear_evilness(&mut self) {
        self.evilness = ::std::option::Option::None;
    }

    pub fn has_evilness(&self) -> bool {
        self.evilness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evilness(&mut self, v: i32) {
        self.evilness = ::std::option::Option::Some(v);
    }

    // optional int32 drainage = 6;

    pub fn drainage(&self) -> i32 {
        self.drainage.unwrap_or(0)
    }

    pub fn clear_drainage(&mut self) {
        self.drainage = ::std::option::Option::None;
    }

    pub fn has_drainage(&self) -> bool {
        self.drainage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drainage(&mut self, v: i32) {
        self.drainage = ::std::option::Option::Some(v);
    }

    // optional int32 volcanism = 7;

    pub fn volcanism(&self) -> i32 {
        self.volcanism.unwrap_or(0)
    }

    pub fn clear_volcanism(&mut self) {
        self.volcanism = ::std::option::Option::None;
    }

    pub fn has_volcanism(&self) -> bool {
        self.volcanism.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volcanism(&mut self, v: i32) {
        self.volcanism = ::std::option::Option::Some(v);
    }

    // optional int32 savagery = 8;

    pub fn savagery(&self) -> i32 {
        self.savagery.unwrap_or(0)
    }

    pub fn clear_savagery(&mut self) {
        self.savagery = ::std::option::Option::None;
    }

    pub fn has_savagery(&self) -> bool {
        self.savagery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_savagery(&mut self, v: i32) {
        self.savagery = ::std::option::Option::Some(v);
    }

    // optional int32 salinity = 9;

    pub fn salinity(&self) -> i32 {
        self.salinity.unwrap_or(0)
    }

    pub fn clear_salinity(&mut self) {
        self.salinity = ::std::option::Option::None;
    }

    pub fn has_salinity(&self) -> bool {
        self.salinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salinity(&mut self, v: i32) {
        self.salinity = ::std::option::Option::Some(v);
    }

    // optional int32 water_elevation = 11;

    pub fn water_elevation(&self) -> i32 {
        self.water_elevation.unwrap_or(0)
    }

    pub fn clear_water_elevation(&mut self) {
        self.water_elevation = ::std::option::Option::None;
    }

    pub fn has_water_elevation(&self) -> bool {
        self.water_elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_water_elevation(&mut self, v: i32) {
        self.water_elevation = ::std::option::Option::Some(v);
    }

    // optional int32 snow = 17;

    pub fn snow(&self) -> i32 {
        self.snow.unwrap_or(0)
    }

    pub fn clear_snow(&mut self) {
        self.snow = ::std::option::Option::None;
    }

    pub fn has_snow(&self) -> bool {
        self.snow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snow(&mut self, v: i32) {
        self.snow = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevation",
            |m: &RegionTile| { &m.elevation },
            |m: &mut RegionTile| { &mut m.elevation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rainfall",
            |m: &RegionTile| { &m.rainfall },
            |m: &mut RegionTile| { &mut m.rainfall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vegetation",
            |m: &RegionTile| { &m.vegetation },
            |m: &mut RegionTile| { &mut m.vegetation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "temperature",
            |m: &RegionTile| { &m.temperature },
            |m: &mut RegionTile| { &mut m.temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "evilness",
            |m: &RegionTile| { &m.evilness },
            |m: &mut RegionTile| { &mut m.evilness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "drainage",
            |m: &RegionTile| { &m.drainage },
            |m: &mut RegionTile| { &mut m.drainage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volcanism",
            |m: &RegionTile| { &m.volcanism },
            |m: &mut RegionTile| { &mut m.volcanism },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "savagery",
            |m: &RegionTile| { &m.savagery },
            |m: &mut RegionTile| { &mut m.savagery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salinity",
            |m: &RegionTile| { &m.salinity },
            |m: &mut RegionTile| { &mut m.salinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RiverTile>(
            "river_tiles",
            |m: &RegionTile| { &m.river_tiles },
            |m: &mut RegionTile| { &mut m.river_tiles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "water_elevation",
            |m: &RegionTile| { &m.water_elevation },
            |m: &mut RegionTile| { &mut m.water_elevation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "surface_material",
            |m: &RegionTile| { &m.surface_material },
            |m: &mut RegionTile| { &mut m.surface_material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "plant_materials",
            |m: &RegionTile| { &m.plant_materials },
            |m: &mut RegionTile| { &mut m.plant_materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buildings",
            |m: &RegionTile| { &m.buildings },
            |m: &mut RegionTile| { &mut m.buildings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stone_materials",
            |m: &RegionTile| { &m.stone_materials },
            |m: &mut RegionTile| { &mut m.stone_materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tree_materials",
            |m: &RegionTile| { &m.tree_materials },
            |m: &mut RegionTile| { &mut m.tree_materials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snow",
            |m: &RegionTile| { &m.snow },
            |m: &mut RegionTile| { &mut m.snow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegionTile>(
            "RegionTile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegionTile {
    const NAME: &'static str = "RegionTile";

    fn is_initialized(&self) -> bool {
        for v in &self.river_tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.surface_material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plant_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stone_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tree_materials {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.elevation = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.rainfall = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.vegetation = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.temperature = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.evilness = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.drainage = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.volcanism = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.savagery = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.salinity = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.river_tiles)?;
                },
                88 => {
                    self.water_elevation = ::std::option::Option::Some(is.read_int32()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.surface_material)?;
                },
                106 => {
                    self.plant_materials.push(is.read_message()?);
                },
                114 => {
                    self.buildings.push(is.read_message()?);
                },
                122 => {
                    self.stone_materials.push(is.read_message()?);
                },
                130 => {
                    self.tree_materials.push(is.read_message()?);
                },
                136 => {
                    self.snow = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.elevation {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.rainfall {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.vegetation {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.temperature {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.evilness {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.drainage {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.volcanism {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.savagery {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.salinity {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.river_tiles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.water_elevation {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.surface_material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.plant_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stone_materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tree_materials {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.snow {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.elevation {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rainfall {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vegetation {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.temperature {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.evilness {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.drainage {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.volcanism {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.savagery {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.salinity {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.river_tiles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.water_elevation {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.surface_material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.plant_materials {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.buildings {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.stone_materials {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.tree_materials {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if let Some(v) = self.snow {
            os.write_int32(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegionTile {
        RegionTile::new()
    }

    fn clear(&mut self) {
        self.elevation = ::std::option::Option::None;
        self.rainfall = ::std::option::Option::None;
        self.vegetation = ::std::option::Option::None;
        self.temperature = ::std::option::Option::None;
        self.evilness = ::std::option::Option::None;
        self.drainage = ::std::option::Option::None;
        self.volcanism = ::std::option::Option::None;
        self.savagery = ::std::option::Option::None;
        self.salinity = ::std::option::Option::None;
        self.river_tiles.clear();
        self.water_elevation = ::std::option::Option::None;
        self.surface_material.clear();
        self.plant_materials.clear();
        self.buildings.clear();
        self.stone_materials.clear();
        self.tree_materials.clear();
        self.snow = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegionTile {
        static instance: RegionTile = RegionTile {
            elevation: ::std::option::Option::None,
            rainfall: ::std::option::Option::None,
            vegetation: ::std::option::Option::None,
            temperature: ::std::option::Option::None,
            evilness: ::std::option::Option::None,
            drainage: ::std::option::Option::None,
            volcanism: ::std::option::Option::None,
            savagery: ::std::option::Option::None,
            salinity: ::std::option::Option::None,
            river_tiles: ::protobuf::MessageField::none(),
            water_elevation: ::std::option::Option::None,
            surface_material: ::protobuf::MessageField::none(),
            plant_materials: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            stone_materials: ::std::vec::Vec::new(),
            tree_materials: ::std::vec::Vec::new(),
            snow: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegionTile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegionTile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegionTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionTile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.RegionMap)
pub struct RegionMap {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMap.map_x)
    pub map_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMap.map_y)
    pub map_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMap.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMap.name_english)
    pub name_english: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMap.tiles)
    pub tiles: ::std::vec::Vec<RegionTile>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.RegionMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegionMap {
    fn default() -> &'a RegionMap {
        <RegionMap as ::protobuf::Message>::default_instance()
    }
}

impl RegionMap {
    pub fn new() -> RegionMap {
        ::std::default::Default::default()
    }

    // optional int32 map_x = 1;

    pub fn map_x(&self) -> i32 {
        self.map_x.unwrap_or(0)
    }

    pub fn clear_map_x(&mut self) {
        self.map_x = ::std::option::Option::None;
    }

    pub fn has_map_x(&self) -> bool {
        self.map_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_x(&mut self, v: i32) {
        self.map_x = ::std::option::Option::Some(v);
    }

    // optional int32 map_y = 2;

    pub fn map_y(&self) -> i32 {
        self.map_y.unwrap_or(0)
    }

    pub fn clear_map_y(&mut self) {
        self.map_y = ::std::option::Option::None;
    }

    pub fn has_map_y(&self) -> bool {
        self.map_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_y(&mut self, v: i32) {
        self.map_y = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_english = 4;

    pub fn name_english(&self) -> &str {
        match self.name_english.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_english(&mut self) {
        self.name_english = ::std::option::Option::None;
    }

    pub fn has_name_english(&self) -> bool {
        self.name_english.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_english(&mut self, v: ::std::string::String) {
        self.name_english = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_english(&mut self) -> &mut ::std::string::String {
        if self.name_english.is_none() {
            self.name_english = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_english.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_english(&mut self) -> ::std::string::String {
        self.name_english.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_x",
            |m: &RegionMap| { &m.map_x },
            |m: &mut RegionMap| { &mut m.map_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_y",
            |m: &RegionMap| { &m.map_y },
            |m: &mut RegionMap| { &mut m.map_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &RegionMap| { &m.name },
            |m: &mut RegionMap| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_english",
            |m: &RegionMap| { &m.name_english },
            |m: &mut RegionMap| { &mut m.name_english },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tiles",
            |m: &RegionMap| { &m.tiles },
            |m: &mut RegionMap| { &mut m.tiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegionMap>(
            "RegionMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegionMap {
    const NAME: &'static str = "RegionMap";

    fn is_initialized(&self) -> bool {
        for v in &self.tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.map_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.map_y = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.name_english = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.tiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.map_y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.name_english.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.map_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.name_english.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.tiles {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegionMap {
        RegionMap::new()
    }

    fn clear(&mut self) {
        self.map_x = ::std::option::Option::None;
        self.map_y = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.name_english = ::std::option::Option::None;
        self.tiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegionMap {
        static instance: RegionMap = RegionMap {
            map_x: ::std::option::Option::None,
            map_y: ::std::option::Option::None,
            name: ::std::option::Option::None,
            name_english: ::std::option::Option::None,
            tiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegionMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegionMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegionMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.RegionMaps)
pub struct RegionMaps {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMaps.world_maps)
    pub world_maps: ::std::vec::Vec<WorldMap>,
    // @@protoc_insertion_point(field:RemoteFortressReader.RegionMaps.region_maps)
    pub region_maps: ::std::vec::Vec<RegionMap>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.RegionMaps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegionMaps {
    fn default() -> &'a RegionMaps {
        <RegionMaps as ::protobuf::Message>::default_instance()
    }
}

impl RegionMaps {
    pub fn new() -> RegionMaps {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "world_maps",
            |m: &RegionMaps| { &m.world_maps },
            |m: &mut RegionMaps| { &mut m.world_maps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "region_maps",
            |m: &RegionMaps| { &m.region_maps },
            |m: &mut RegionMaps| { &mut m.region_maps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegionMaps>(
            "RegionMaps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegionMaps {
    const NAME: &'static str = "RegionMaps";

    fn is_initialized(&self) -> bool {
        for v in &self.world_maps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_maps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.world_maps.push(is.read_message()?);
                },
                18 => {
                    self.region_maps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.world_maps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.region_maps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.world_maps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.region_maps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegionMaps {
        RegionMaps::new()
    }

    fn clear(&mut self) {
        self.world_maps.clear();
        self.region_maps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegionMaps {
        static instance: RegionMaps = RegionMaps {
            world_maps: ::std::vec::Vec::new(),
            region_maps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegionMaps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegionMaps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegionMaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionMaps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PatternDescriptor)
pub struct PatternDescriptor {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PatternDescriptor.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PatternDescriptor.colors)
    pub colors: ::std::vec::Vec<ColorDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PatternDescriptor.pattern)
    pub pattern: ::std::option::Option<::protobuf::EnumOrUnknown<PatternType>>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PatternDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatternDescriptor {
    fn default() -> &'a PatternDescriptor {
        <PatternDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl PatternDescriptor {
    pub fn new() -> PatternDescriptor {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .RemoteFortressReader.PatternType pattern = 3;

    pub fn pattern(&self) -> PatternType {
        match self.pattern {
            Some(e) => e.enum_value_or(PatternType::MONOTONE),
            None => PatternType::MONOTONE,
        }
    }

    pub fn clear_pattern(&mut self) {
        self.pattern = ::std::option::Option::None;
    }

    pub fn has_pattern(&self) -> bool {
        self.pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: PatternType) {
        self.pattern = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &PatternDescriptor| { &m.id },
            |m: &mut PatternDescriptor| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &PatternDescriptor| { &m.colors },
            |m: &mut PatternDescriptor| { &mut m.colors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pattern",
            |m: &PatternDescriptor| { &m.pattern },
            |m: &mut PatternDescriptor| { &mut m.pattern },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatternDescriptor>(
            "PatternDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatternDescriptor {
    const NAME: &'static str = "PatternDescriptor";

    fn is_initialized(&self) -> bool {
        for v in &self.colors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.colors.push(is.read_message()?);
                },
                24 => {
                    self.pattern = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pattern {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.colors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pattern {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatternDescriptor {
        PatternDescriptor::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.colors.clear();
        self.pattern = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatternDescriptor {
        static instance: PatternDescriptor = PatternDescriptor {
            id: ::std::option::Option::None,
            colors: ::std::vec::Vec::new(),
            pattern: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatternDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatternDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatternDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatternDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ColorModifierRaw)
pub struct ColorModifierRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorModifierRaw.patterns)
    pub patterns: ::std::vec::Vec<PatternDescriptor>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorModifierRaw.body_part_id)
    pub body_part_id: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorModifierRaw.tissue_layer_id)
    pub tissue_layer_id: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorModifierRaw.start_date)
    pub start_date: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorModifierRaw.end_date)
    pub end_date: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ColorModifierRaw.part)
    pub part: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ColorModifierRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorModifierRaw {
    fn default() -> &'a ColorModifierRaw {
        <ColorModifierRaw as ::protobuf::Message>::default_instance()
    }
}

impl ColorModifierRaw {
    pub fn new() -> ColorModifierRaw {
        ::std::default::Default::default()
    }

    // optional int32 start_date = 4;

    pub fn start_date(&self) -> i32 {
        self.start_date.unwrap_or(0)
    }

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: i32) {
        self.start_date = ::std::option::Option::Some(v);
    }

    // optional int32 end_date = 5;

    pub fn end_date(&self) -> i32 {
        self.end_date.unwrap_or(0)
    }

    pub fn clear_end_date(&mut self) {
        self.end_date = ::std::option::Option::None;
    }

    pub fn has_end_date(&self) -> bool {
        self.end_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_date(&mut self, v: i32) {
        self.end_date = ::std::option::Option::Some(v);
    }

    // optional string part = 6;

    pub fn part(&self) -> &str {
        match self.part.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_part(&mut self) {
        self.part = ::std::option::Option::None;
    }

    pub fn has_part(&self) -> bool {
        self.part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_part(&mut self, v: ::std::string::String) {
        self.part = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_part(&mut self) -> &mut ::std::string::String {
        if self.part.is_none() {
            self.part = ::std::option::Option::Some(::std::string::String::new());
        }
        self.part.as_mut().unwrap()
    }

    // Take field
    pub fn take_part(&mut self) -> ::std::string::String {
        self.part.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "patterns",
            |m: &ColorModifierRaw| { &m.patterns },
            |m: &mut ColorModifierRaw| { &mut m.patterns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_part_id",
            |m: &ColorModifierRaw| { &m.body_part_id },
            |m: &mut ColorModifierRaw| { &mut m.body_part_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tissue_layer_id",
            |m: &ColorModifierRaw| { &m.tissue_layer_id },
            |m: &mut ColorModifierRaw| { &mut m.tissue_layer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_date",
            |m: &ColorModifierRaw| { &m.start_date },
            |m: &mut ColorModifierRaw| { &mut m.start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_date",
            |m: &ColorModifierRaw| { &m.end_date },
            |m: &mut ColorModifierRaw| { &mut m.end_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "part",
            |m: &ColorModifierRaw| { &m.part },
            |m: &mut ColorModifierRaw| { &mut m.part },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorModifierRaw>(
            "ColorModifierRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorModifierRaw {
    const NAME: &'static str = "ColorModifierRaw";

    fn is_initialized(&self) -> bool {
        for v in &self.patterns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.patterns.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.body_part_id)?;
                },
                16 => {
                    self.body_part_id.push(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.tissue_layer_id)?;
                },
                24 => {
                    self.tissue_layer_id.push(is.read_int32()?);
                },
                32 => {
                    self.start_date = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.end_date = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.part = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.patterns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.body_part_id {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        for value in &self.tissue_layer_id {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if let Some(v) = self.start_date {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.end_date {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.part.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.patterns {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.body_part_id {
            os.write_int32(2, *v)?;
        };
        for v in &self.tissue_layer_id {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.start_date {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.end_date {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.part.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorModifierRaw {
        ColorModifierRaw::new()
    }

    fn clear(&mut self) {
        self.patterns.clear();
        self.body_part_id.clear();
        self.tissue_layer_id.clear();
        self.start_date = ::std::option::Option::None;
        self.end_date = ::std::option::Option::None;
        self.part = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorModifierRaw {
        static instance: ColorModifierRaw = ColorModifierRaw {
            patterns: ::std::vec::Vec::new(),
            body_part_id: ::std::vec::Vec::new(),
            tissue_layer_id: ::std::vec::Vec::new(),
            start_date: ::std::option::Option::None,
            end_date: ::std::option::Option::None,
            part: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorModifierRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorModifierRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorModifierRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorModifierRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BodyPartLayerRaw)
pub struct BodyPartLayerRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartLayerRaw.layer_name)
    pub layer_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartLayerRaw.tissue_id)
    pub tissue_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartLayerRaw.layer_depth)
    pub layer_depth: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartLayerRaw.bp_modifiers)
    pub bp_modifiers: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BodyPartLayerRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BodyPartLayerRaw {
    fn default() -> &'a BodyPartLayerRaw {
        <BodyPartLayerRaw as ::protobuf::Message>::default_instance()
    }
}

impl BodyPartLayerRaw {
    pub fn new() -> BodyPartLayerRaw {
        ::std::default::Default::default()
    }

    // optional string layer_name = 1;

    pub fn layer_name(&self) -> &str {
        match self.layer_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_layer_name(&mut self) {
        self.layer_name = ::std::option::Option::None;
    }

    pub fn has_layer_name(&self) -> bool {
        self.layer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_name(&mut self, v: ::std::string::String) {
        self.layer_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layer_name(&mut self) -> &mut ::std::string::String {
        if self.layer_name.is_none() {
            self.layer_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.layer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_layer_name(&mut self) -> ::std::string::String {
        self.layer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tissue_id = 2;

    pub fn tissue_id(&self) -> i32 {
        self.tissue_id.unwrap_or(0)
    }

    pub fn clear_tissue_id(&mut self) {
        self.tissue_id = ::std::option::Option::None;
    }

    pub fn has_tissue_id(&self) -> bool {
        self.tissue_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tissue_id(&mut self, v: i32) {
        self.tissue_id = ::std::option::Option::Some(v);
    }

    // optional int32 layer_depth = 3;

    pub fn layer_depth(&self) -> i32 {
        self.layer_depth.unwrap_or(0)
    }

    pub fn clear_layer_depth(&mut self) {
        self.layer_depth = ::std::option::Option::None;
    }

    pub fn has_layer_depth(&self) -> bool {
        self.layer_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layer_depth(&mut self, v: i32) {
        self.layer_depth = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_name",
            |m: &BodyPartLayerRaw| { &m.layer_name },
            |m: &mut BodyPartLayerRaw| { &mut m.layer_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tissue_id",
            |m: &BodyPartLayerRaw| { &m.tissue_id },
            |m: &mut BodyPartLayerRaw| { &mut m.tissue_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layer_depth",
            |m: &BodyPartLayerRaw| { &m.layer_depth },
            |m: &mut BodyPartLayerRaw| { &mut m.layer_depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bp_modifiers",
            |m: &BodyPartLayerRaw| { &m.bp_modifiers },
            |m: &mut BodyPartLayerRaw| { &mut m.bp_modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BodyPartLayerRaw>(
            "BodyPartLayerRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BodyPartLayerRaw {
    const NAME: &'static str = "BodyPartLayerRaw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.layer_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.tissue_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.layer_depth = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.bp_modifiers)?;
                },
                32 => {
                    self.bp_modifiers.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.layer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tissue_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.layer_depth {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.bp_modifiers {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.layer_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.tissue_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.layer_depth {
            os.write_int32(3, v)?;
        }
        for v in &self.bp_modifiers {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BodyPartLayerRaw {
        BodyPartLayerRaw::new()
    }

    fn clear(&mut self) {
        self.layer_name = ::std::option::Option::None;
        self.tissue_id = ::std::option::Option::None;
        self.layer_depth = ::std::option::Option::None;
        self.bp_modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BodyPartLayerRaw {
        static instance: BodyPartLayerRaw = BodyPartLayerRaw {
            layer_name: ::std::option::Option::None,
            tissue_id: ::std::option::Option::None,
            layer_depth: ::std::option::Option::None,
            bp_modifiers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BodyPartLayerRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BodyPartLayerRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BodyPartLayerRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodyPartLayerRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BodyPartRaw)
pub struct BodyPartRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartRaw.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartRaw.category)
    pub category: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartRaw.parent)
    pub parent: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartRaw.flags)
    pub flags: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartRaw.layers)
    pub layers: ::std::vec::Vec<BodyPartLayerRaw>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BodyPartRaw.relsize)
    pub relsize: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BodyPartRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BodyPartRaw {
    fn default() -> &'a BodyPartRaw {
        <BodyPartRaw as ::protobuf::Message>::default_instance()
    }
}

impl BodyPartRaw {
    pub fn new() -> BodyPartRaw {
        ::std::default::Default::default()
    }

    // optional string token = 1;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string category = 2;

    pub fn category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        if self.category.is_none() {
            self.category = ::std::option::Option::Some(::std::string::String::new());
        }
        self.category.as_mut().unwrap()
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        self.category.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 parent = 3;

    pub fn parent(&self) -> i32 {
        self.parent.unwrap_or(0)
    }

    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: i32) {
        self.parent = ::std::option::Option::Some(v);
    }

    // optional int32 relsize = 6;

    pub fn relsize(&self) -> i32 {
        self.relsize.unwrap_or(0)
    }

    pub fn clear_relsize(&mut self) {
        self.relsize = ::std::option::Option::None;
    }

    pub fn has_relsize(&self) -> bool {
        self.relsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relsize(&mut self, v: i32) {
        self.relsize = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &BodyPartRaw| { &m.token },
            |m: &mut BodyPartRaw| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "category",
            |m: &BodyPartRaw| { &m.category },
            |m: &mut BodyPartRaw| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &BodyPartRaw| { &m.parent },
            |m: &mut BodyPartRaw| { &mut m.parent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flags",
            |m: &BodyPartRaw| { &m.flags },
            |m: &mut BodyPartRaw| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "layers",
            |m: &BodyPartRaw| { &m.layers },
            |m: &mut BodyPartRaw| { &mut m.layers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relsize",
            |m: &BodyPartRaw| { &m.relsize },
            |m: &mut BodyPartRaw| { &mut m.relsize },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BodyPartRaw>(
            "BodyPartRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BodyPartRaw {
    const NAME: &'static str = "BodyPartRaw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.category = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.parent = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_bool_into(&mut self.flags)?;
                },
                32 => {
                    self.flags.push(is.read_bool()?);
                },
                42 => {
                    self.layers.push(is.read_message()?);
                },
                48 => {
                    self.relsize = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += 2 * self.flags.len() as u64;
        for value in &self.layers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.relsize {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.category.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.parent {
            os.write_int32(3, v)?;
        }
        for v in &self.flags {
            os.write_bool(4, *v)?;
        };
        for v in &self.layers {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.relsize {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BodyPartRaw {
        BodyPartRaw::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.category = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.flags.clear();
        self.layers.clear();
        self.relsize = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BodyPartRaw {
        static instance: BodyPartRaw = BodyPartRaw {
            token: ::std::option::Option::None,
            category: ::std::option::Option::None,
            parent: ::std::option::Option::None,
            flags: ::std::vec::Vec::new(),
            layers: ::std::vec::Vec::new(),
            relsize: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BodyPartRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BodyPartRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BodyPartRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodyPartRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.BpAppearanceModifier)
pub struct BpAppearanceModifier {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.BpAppearanceModifier.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BpAppearanceModifier.mod_min)
    pub mod_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.BpAppearanceModifier.mod_max)
    pub mod_max: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.BpAppearanceModifier.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BpAppearanceModifier {
    fn default() -> &'a BpAppearanceModifier {
        <BpAppearanceModifier as ::protobuf::Message>::default_instance()
    }
}

impl BpAppearanceModifier {
    pub fn new() -> BpAppearanceModifier {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 mod_min = 2;

    pub fn mod_min(&self) -> i32 {
        self.mod_min.unwrap_or(0)
    }

    pub fn clear_mod_min(&mut self) {
        self.mod_min = ::std::option::Option::None;
    }

    pub fn has_mod_min(&self) -> bool {
        self.mod_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod_min(&mut self, v: i32) {
        self.mod_min = ::std::option::Option::Some(v);
    }

    // optional int32 mod_max = 3;

    pub fn mod_max(&self) -> i32 {
        self.mod_max.unwrap_or(0)
    }

    pub fn clear_mod_max(&mut self) {
        self.mod_max = ::std::option::Option::None;
    }

    pub fn has_mod_max(&self) -> bool {
        self.mod_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod_max(&mut self, v: i32) {
        self.mod_max = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &BpAppearanceModifier| { &m.type_ },
            |m: &mut BpAppearanceModifier| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mod_min",
            |m: &BpAppearanceModifier| { &m.mod_min },
            |m: &mut BpAppearanceModifier| { &mut m.mod_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mod_max",
            |m: &BpAppearanceModifier| { &m.mod_max },
            |m: &mut BpAppearanceModifier| { &mut m.mod_max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BpAppearanceModifier>(
            "BpAppearanceModifier",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BpAppearanceModifier {
    const NAME: &'static str = "BpAppearanceModifier";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.mod_min = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.mod_max = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mod_min {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.mod_max {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mod_min {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mod_max {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BpAppearanceModifier {
        BpAppearanceModifier::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.mod_min = ::std::option::Option::None;
        self.mod_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BpAppearanceModifier {
        static instance: BpAppearanceModifier = BpAppearanceModifier {
            type_: ::std::option::Option::None,
            mod_min: ::std::option::Option::None,
            mod_max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BpAppearanceModifier {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BpAppearanceModifier").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BpAppearanceModifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BpAppearanceModifier {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.TissueRaw)
pub struct TissueRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.TissueRaw.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TissueRaw.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TissueRaw.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TissueRaw.subordinate_to_tissue)
    pub subordinate_to_tissue: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.TissueRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TissueRaw {
    fn default() -> &'a TissueRaw {
        <TissueRaw as ::protobuf::Message>::default_instance()
    }
}

impl TissueRaw {
    pub fn new() -> TissueRaw {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subordinate_to_tissue = 4;

    pub fn subordinate_to_tissue(&self) -> &str {
        match self.subordinate_to_tissue.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subordinate_to_tissue(&mut self) {
        self.subordinate_to_tissue = ::std::option::Option::None;
    }

    pub fn has_subordinate_to_tissue(&self) -> bool {
        self.subordinate_to_tissue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subordinate_to_tissue(&mut self, v: ::std::string::String) {
        self.subordinate_to_tissue = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subordinate_to_tissue(&mut self) -> &mut ::std::string::String {
        if self.subordinate_to_tissue.is_none() {
            self.subordinate_to_tissue = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subordinate_to_tissue.as_mut().unwrap()
    }

    // Take field
    pub fn take_subordinate_to_tissue(&mut self) -> ::std::string::String {
        self.subordinate_to_tissue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &TissueRaw| { &m.id },
            |m: &mut TissueRaw| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &TissueRaw| { &m.name },
            |m: &mut TissueRaw| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &TissueRaw| { &m.material },
            |m: &mut TissueRaw| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subordinate_to_tissue",
            |m: &TissueRaw| { &m.subordinate_to_tissue },
            |m: &mut TissueRaw| { &mut m.subordinate_to_tissue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TissueRaw>(
            "TissueRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TissueRaw {
    const NAME: &'static str = "TissueRaw";

    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                34 => {
                    self.subordinate_to_tissue = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subordinate_to_tissue.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.subordinate_to_tissue.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TissueRaw {
        TissueRaw::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.material.clear();
        self.subordinate_to_tissue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TissueRaw {
        static instance: TissueRaw = TissueRaw {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            material: ::protobuf::MessageField::none(),
            subordinate_to_tissue: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TissueRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TissueRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TissueRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TissueRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.CasteRaw)
pub struct CasteRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.caste_id)
    pub caste_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.caste_name)
    pub caste_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.baby_name)
    pub baby_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.child_name)
    pub child_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.gender)
    pub gender: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.body_parts)
    pub body_parts: ::std::vec::Vec<BodyPartRaw>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.total_relsize)
    pub total_relsize: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.modifiers)
    pub modifiers: ::std::vec::Vec<BpAppearanceModifier>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.modifier_idx)
    pub modifier_idx: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.part_idx)
    pub part_idx: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.layer_idx)
    pub layer_idx: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.body_appearance_modifiers)
    pub body_appearance_modifiers: ::std::vec::Vec<BpAppearanceModifier>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.color_modifiers)
    pub color_modifiers: ::std::vec::Vec<ColorModifierRaw>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CasteRaw.adult_size)
    pub adult_size: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.CasteRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CasteRaw {
    fn default() -> &'a CasteRaw {
        <CasteRaw as ::protobuf::Message>::default_instance()
    }
}

impl CasteRaw {
    pub fn new() -> CasteRaw {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string caste_id = 2;

    pub fn caste_id(&self) -> &str {
        match self.caste_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caste_id(&mut self) {
        self.caste_id = ::std::option::Option::None;
    }

    pub fn has_caste_id(&self) -> bool {
        self.caste_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caste_id(&mut self, v: ::std::string::String) {
        self.caste_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caste_id(&mut self) -> &mut ::std::string::String {
        if self.caste_id.is_none() {
            self.caste_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caste_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_caste_id(&mut self) -> ::std::string::String {
        self.caste_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 gender = 6;

    pub fn gender(&self) -> i32 {
        self.gender.unwrap_or(0)
    }

    pub fn clear_gender(&mut self) {
        self.gender = ::std::option::Option::None;
    }

    pub fn has_gender(&self) -> bool {
        self.gender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: i32) {
        self.gender = ::std::option::Option::Some(v);
    }

    // optional int32 total_relsize = 8;

    pub fn total_relsize(&self) -> i32 {
        self.total_relsize.unwrap_or(0)
    }

    pub fn clear_total_relsize(&mut self) {
        self.total_relsize = ::std::option::Option::None;
    }

    pub fn has_total_relsize(&self) -> bool {
        self.total_relsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_relsize(&mut self, v: i32) {
        self.total_relsize = ::std::option::Option::Some(v);
    }

    // optional string description = 15;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 adult_size = 16;

    pub fn adult_size(&self) -> i32 {
        self.adult_size.unwrap_or(0)
    }

    pub fn clear_adult_size(&mut self) {
        self.adult_size = ::std::option::Option::None;
    }

    pub fn has_adult_size(&self) -> bool {
        self.adult_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_size(&mut self, v: i32) {
        self.adult_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CasteRaw| { &m.index },
            |m: &mut CasteRaw| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caste_id",
            |m: &CasteRaw| { &m.caste_id },
            |m: &mut CasteRaw| { &mut m.caste_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "caste_name",
            |m: &CasteRaw| { &m.caste_name },
            |m: &mut CasteRaw| { &mut m.caste_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "baby_name",
            |m: &CasteRaw| { &m.baby_name },
            |m: &mut CasteRaw| { &mut m.baby_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "child_name",
            |m: &CasteRaw| { &m.child_name },
            |m: &mut CasteRaw| { &mut m.child_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gender",
            |m: &CasteRaw| { &m.gender },
            |m: &mut CasteRaw| { &mut m.gender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_parts",
            |m: &CasteRaw| { &m.body_parts },
            |m: &mut CasteRaw| { &mut m.body_parts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_relsize",
            |m: &CasteRaw| { &m.total_relsize },
            |m: &mut CasteRaw| { &mut m.total_relsize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &CasteRaw| { &m.modifiers },
            |m: &mut CasteRaw| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifier_idx",
            |m: &CasteRaw| { &m.modifier_idx },
            |m: &mut CasteRaw| { &mut m.modifier_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "part_idx",
            |m: &CasteRaw| { &m.part_idx },
            |m: &mut CasteRaw| { &mut m.part_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "layer_idx",
            |m: &CasteRaw| { &m.layer_idx },
            |m: &mut CasteRaw| { &mut m.layer_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_appearance_modifiers",
            |m: &CasteRaw| { &m.body_appearance_modifiers },
            |m: &mut CasteRaw| { &mut m.body_appearance_modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color_modifiers",
            |m: &CasteRaw| { &m.color_modifiers },
            |m: &mut CasteRaw| { &mut m.color_modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CasteRaw| { &m.description },
            |m: &mut CasteRaw| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adult_size",
            |m: &CasteRaw| { &m.adult_size },
            |m: &mut CasteRaw| { &mut m.adult_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CasteRaw>(
            "CasteRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CasteRaw {
    const NAME: &'static str = "CasteRaw";

    fn is_initialized(&self) -> bool {
        for v in &self.body_parts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_appearance_modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.color_modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.caste_id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caste_name.push(is.read_string()?);
                },
                34 => {
                    self.baby_name.push(is.read_string()?);
                },
                42 => {
                    self.child_name.push(is.read_string()?);
                },
                48 => {
                    self.gender = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.body_parts.push(is.read_message()?);
                },
                64 => {
                    self.total_relsize = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.modifiers.push(is.read_message()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.modifier_idx)?;
                },
                80 => {
                    self.modifier_idx.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.part_idx)?;
                },
                88 => {
                    self.part_idx.push(is.read_int32()?);
                },
                98 => {
                    is.read_repeated_packed_int32_into(&mut self.layer_idx)?;
                },
                96 => {
                    self.layer_idx.push(is.read_int32()?);
                },
                106 => {
                    self.body_appearance_modifiers.push(is.read_message()?);
                },
                114 => {
                    self.color_modifiers.push(is.read_message()?);
                },
                122 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.adult_size = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.caste_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.caste_name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.baby_name {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.child_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.gender {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        for value in &self.body_parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_relsize {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.modifier_idx {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        for value in &self.part_idx {
            my_size += ::protobuf::rt::int32_size(11, *value);
        };
        for value in &self.layer_idx {
            my_size += ::protobuf::rt::int32_size(12, *value);
        };
        for value in &self.body_appearance_modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.color_modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.adult_size {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.caste_id.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.caste_name {
            os.write_string(3, &v)?;
        };
        for v in &self.baby_name {
            os.write_string(4, &v)?;
        };
        for v in &self.child_name {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.gender {
            os.write_int32(6, v)?;
        }
        for v in &self.body_parts {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.total_relsize {
            os.write_int32(8, v)?;
        }
        for v in &self.modifiers {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.modifier_idx {
            os.write_int32(10, *v)?;
        };
        for v in &self.part_idx {
            os.write_int32(11, *v)?;
        };
        for v in &self.layer_idx {
            os.write_int32(12, *v)?;
        };
        for v in &self.body_appearance_modifiers {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.color_modifiers {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.description.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.adult_size {
            os.write_int32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CasteRaw {
        CasteRaw::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.caste_id = ::std::option::Option::None;
        self.caste_name.clear();
        self.baby_name.clear();
        self.child_name.clear();
        self.gender = ::std::option::Option::None;
        self.body_parts.clear();
        self.total_relsize = ::std::option::Option::None;
        self.modifiers.clear();
        self.modifier_idx.clear();
        self.part_idx.clear();
        self.layer_idx.clear();
        self.body_appearance_modifiers.clear();
        self.color_modifiers.clear();
        self.description = ::std::option::Option::None;
        self.adult_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CasteRaw {
        static instance: CasteRaw = CasteRaw {
            index: ::std::option::Option::None,
            caste_id: ::std::option::Option::None,
            caste_name: ::std::vec::Vec::new(),
            baby_name: ::std::vec::Vec::new(),
            child_name: ::std::vec::Vec::new(),
            gender: ::std::option::Option::None,
            body_parts: ::std::vec::Vec::new(),
            total_relsize: ::std::option::Option::None,
            modifiers: ::std::vec::Vec::new(),
            modifier_idx: ::std::vec::Vec::new(),
            part_idx: ::std::vec::Vec::new(),
            layer_idx: ::std::vec::Vec::new(),
            body_appearance_modifiers: ::std::vec::Vec::new(),
            color_modifiers: ::std::vec::Vec::new(),
            description: ::std::option::Option::None,
            adult_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CasteRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CasteRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CasteRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CasteRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.CreatureRaw)
pub struct CreatureRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.creature_id)
    pub creature_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.name)
    pub name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.general_baby_name)
    pub general_baby_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.general_child_name)
    pub general_child_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.creature_tile)
    pub creature_tile: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.creature_soldier_tile)
    pub creature_soldier_tile: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.color)
    pub color: ::protobuf::MessageField<ColorDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.adultsize)
    pub adultsize: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.caste)
    pub caste: ::std::vec::Vec<CasteRaw>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.tissues)
    pub tissues: ::std::vec::Vec<TissueRaw>,
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRaw.flags)
    pub flags: ::std::vec::Vec<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.CreatureRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatureRaw {
    fn default() -> &'a CreatureRaw {
        <CreatureRaw as ::protobuf::Message>::default_instance()
    }
}

impl CreatureRaw {
    pub fn new() -> CreatureRaw {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string creature_id = 2;

    pub fn creature_id(&self) -> &str {
        match self.creature_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_creature_id(&mut self) {
        self.creature_id = ::std::option::Option::None;
    }

    pub fn has_creature_id(&self) -> bool {
        self.creature_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_id(&mut self, v: ::std::string::String) {
        self.creature_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creature_id(&mut self) -> &mut ::std::string::String {
        if self.creature_id.is_none() {
            self.creature_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.creature_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_creature_id(&mut self) -> ::std::string::String {
        self.creature_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 creature_tile = 6;

    pub fn creature_tile(&self) -> i32 {
        self.creature_tile.unwrap_or(0)
    }

    pub fn clear_creature_tile(&mut self) {
        self.creature_tile = ::std::option::Option::None;
    }

    pub fn has_creature_tile(&self) -> bool {
        self.creature_tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_tile(&mut self, v: i32) {
        self.creature_tile = ::std::option::Option::Some(v);
    }

    // optional int32 creature_soldier_tile = 7;

    pub fn creature_soldier_tile(&self) -> i32 {
        self.creature_soldier_tile.unwrap_or(0)
    }

    pub fn clear_creature_soldier_tile(&mut self) {
        self.creature_soldier_tile = ::std::option::Option::None;
    }

    pub fn has_creature_soldier_tile(&self) -> bool {
        self.creature_soldier_tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_soldier_tile(&mut self, v: i32) {
        self.creature_soldier_tile = ::std::option::Option::Some(v);
    }

    // optional int32 adultsize = 9;

    pub fn adultsize(&self) -> i32 {
        self.adultsize.unwrap_or(0)
    }

    pub fn clear_adultsize(&mut self) {
        self.adultsize = ::std::option::Option::None;
    }

    pub fn has_adultsize(&self) -> bool {
        self.adultsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adultsize(&mut self, v: i32) {
        self.adultsize = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CreatureRaw| { &m.index },
            |m: &mut CreatureRaw| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creature_id",
            |m: &CreatureRaw| { &m.creature_id },
            |m: &mut CreatureRaw| { &mut m.creature_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "name",
            |m: &CreatureRaw| { &m.name },
            |m: &mut CreatureRaw| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "general_baby_name",
            |m: &CreatureRaw| { &m.general_baby_name },
            |m: &mut CreatureRaw| { &mut m.general_baby_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "general_child_name",
            |m: &CreatureRaw| { &m.general_child_name },
            |m: &mut CreatureRaw| { &mut m.general_child_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creature_tile",
            |m: &CreatureRaw| { &m.creature_tile },
            |m: &mut CreatureRaw| { &mut m.creature_tile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creature_soldier_tile",
            |m: &CreatureRaw| { &m.creature_soldier_tile },
            |m: &mut CreatureRaw| { &mut m.creature_soldier_tile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ColorDefinition>(
            "color",
            |m: &CreatureRaw| { &m.color },
            |m: &mut CreatureRaw| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adultsize",
            |m: &CreatureRaw| { &m.adultsize },
            |m: &mut CreatureRaw| { &mut m.adultsize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "caste",
            |m: &CreatureRaw| { &m.caste },
            |m: &mut CreatureRaw| { &mut m.caste },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tissues",
            |m: &CreatureRaw| { &m.tissues },
            |m: &mut CreatureRaw| { &mut m.tissues },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flags",
            |m: &CreatureRaw| { &m.flags },
            |m: &mut CreatureRaw| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreatureRaw>(
            "CreatureRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreatureRaw {
    const NAME: &'static str = "CreatureRaw";

    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.caste {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tissues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.creature_id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name.push(is.read_string()?);
                },
                34 => {
                    self.general_baby_name.push(is.read_string()?);
                },
                42 => {
                    self.general_child_name.push(is.read_string()?);
                },
                48 => {
                    self.creature_tile = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.creature_soldier_tile = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                72 => {
                    self.adultsize = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.caste.push(is.read_message()?);
                },
                90 => {
                    self.tissues.push(is.read_message()?);
                },
                98 => {
                    is.read_repeated_packed_bool_into(&mut self.flags)?;
                },
                96 => {
                    self.flags.push(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.creature_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.general_baby_name {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.general_child_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.creature_tile {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.creature_soldier_tile {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adultsize {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.caste {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tissues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 2 * self.flags.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.creature_id.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.name {
            os.write_string(3, &v)?;
        };
        for v in &self.general_baby_name {
            os.write_string(4, &v)?;
        };
        for v in &self.general_child_name {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.creature_tile {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.creature_soldier_tile {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.adultsize {
            os.write_int32(9, v)?;
        }
        for v in &self.caste {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.tissues {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.flags {
            os.write_bool(12, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatureRaw {
        CreatureRaw::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.creature_id = ::std::option::Option::None;
        self.name.clear();
        self.general_baby_name.clear();
        self.general_child_name.clear();
        self.creature_tile = ::std::option::Option::None;
        self.creature_soldier_tile = ::std::option::Option::None;
        self.color.clear();
        self.adultsize = ::std::option::Option::None;
        self.caste.clear();
        self.tissues.clear();
        self.flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatureRaw {
        static instance: CreatureRaw = CreatureRaw {
            index: ::std::option::Option::None,
            creature_id: ::std::option::Option::None,
            name: ::std::vec::Vec::new(),
            general_baby_name: ::std::vec::Vec::new(),
            general_child_name: ::std::vec::Vec::new(),
            creature_tile: ::std::option::Option::None,
            creature_soldier_tile: ::std::option::Option::None,
            color: ::protobuf::MessageField::none(),
            adultsize: ::std::option::Option::None,
            caste: ::std::vec::Vec::new(),
            tissues: ::std::vec::Vec::new(),
            flags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreatureRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreatureRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreatureRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatureRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.CreatureRawList)
pub struct CreatureRawList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.CreatureRawList.creature_raws)
    pub creature_raws: ::std::vec::Vec<CreatureRaw>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.CreatureRawList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatureRawList {
    fn default() -> &'a CreatureRawList {
        <CreatureRawList as ::protobuf::Message>::default_instance()
    }
}

impl CreatureRawList {
    pub fn new() -> CreatureRawList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "creature_raws",
            |m: &CreatureRawList| { &m.creature_raws },
            |m: &mut CreatureRawList| { &mut m.creature_raws },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreatureRawList>(
            "CreatureRawList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreatureRawList {
    const NAME: &'static str = "CreatureRawList";

    fn is_initialized(&self) -> bool {
        for v in &self.creature_raws {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.creature_raws.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.creature_raws {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.creature_raws {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatureRawList {
        CreatureRawList::new()
    }

    fn clear(&mut self) {
        self.creature_raws.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatureRawList {
        static instance: CreatureRawList = CreatureRawList {
            creature_raws: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreatureRawList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreatureRawList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreatureRawList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatureRawList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Army)
pub struct Army {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.pos_x)
    pub pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.pos_y)
    pub pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.pos_z)
    pub pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.leader)
    pub leader: ::protobuf::MessageField<UnitDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.members)
    pub members: ::std::vec::Vec<UnitDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Army.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Army.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Army {
    fn default() -> &'a Army {
        <Army as ::protobuf::Message>::default_instance()
    }
}

impl Army {
    pub fn new() -> Army {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 pos_x = 2;

    pub fn pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 pos_y = 3;

    pub fn pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 pos_z = 4;

    pub fn pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Army| { &m.id },
            |m: &mut Army| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &Army| { &m.pos_x },
            |m: &mut Army| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &Army| { &m.pos_y },
            |m: &mut Army| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &Army| { &m.pos_z },
            |m: &mut Army| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitDefinition>(
            "leader",
            |m: &Army| { &m.leader },
            |m: &mut Army| { &mut m.leader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &Army| { &m.members },
            |m: &mut Army| { &mut m.members },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Army| { &m.flags },
            |m: &mut Army| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Army>(
            "Army",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Army {
    const NAME: &'static str = "Army";

    fn is_initialized(&self) -> bool {
        for v in &self.leader {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leader)?;
                },
                50 => {
                    self.members.push(is.read_message()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.leader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leader.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Army {
        Army::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.leader.clear();
        self.members.clear();
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Army {
        static instance: Army = Army {
            id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            leader: ::protobuf::MessageField::none(),
            members: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Army {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Army").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Army {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Army {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ArmyList)
pub struct ArmyList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ArmyList.armies)
    pub armies: ::std::vec::Vec<Army>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ArmyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArmyList {
    fn default() -> &'a ArmyList {
        <ArmyList as ::protobuf::Message>::default_instance()
    }
}

impl ArmyList {
    pub fn new() -> ArmyList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "armies",
            |m: &ArmyList| { &m.armies },
            |m: &mut ArmyList| { &mut m.armies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArmyList>(
            "ArmyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArmyList {
    const NAME: &'static str = "ArmyList";

    fn is_initialized(&self) -> bool {
        for v in &self.armies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.armies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.armies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.armies {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArmyList {
        ArmyList::new()
    }

    fn clear(&mut self) {
        self.armies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArmyList {
        static instance: ArmyList = ArmyList {
            armies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArmyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArmyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArmyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArmyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.GrowthPrint)
pub struct GrowthPrint {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.GrowthPrint.priority)
    pub priority: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.GrowthPrint.color)
    pub color: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.GrowthPrint.timing_start)
    pub timing_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.GrowthPrint.timing_end)
    pub timing_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.GrowthPrint.tile)
    pub tile: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.GrowthPrint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GrowthPrint {
    fn default() -> &'a GrowthPrint {
        <GrowthPrint as ::protobuf::Message>::default_instance()
    }
}

impl GrowthPrint {
    pub fn new() -> GrowthPrint {
        ::std::default::Default::default()
    }

    // optional int32 priority = 1;

    pub fn priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional int32 color = 2;

    pub fn color(&self) -> i32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional int32 timing_start = 3;

    pub fn timing_start(&self) -> i32 {
        self.timing_start.unwrap_or(0)
    }

    pub fn clear_timing_start(&mut self) {
        self.timing_start = ::std::option::Option::None;
    }

    pub fn has_timing_start(&self) -> bool {
        self.timing_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_start(&mut self, v: i32) {
        self.timing_start = ::std::option::Option::Some(v);
    }

    // optional int32 timing_end = 4;

    pub fn timing_end(&self) -> i32 {
        self.timing_end.unwrap_or(0)
    }

    pub fn clear_timing_end(&mut self) {
        self.timing_end = ::std::option::Option::None;
    }

    pub fn has_timing_end(&self) -> bool {
        self.timing_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_end(&mut self, v: i32) {
        self.timing_end = ::std::option::Option::Some(v);
    }

    // optional int32 tile = 5;

    pub fn tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }

    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority",
            |m: &GrowthPrint| { &m.priority },
            |m: &mut GrowthPrint| { &mut m.priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &GrowthPrint| { &m.color },
            |m: &mut GrowthPrint| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_start",
            |m: &GrowthPrint| { &m.timing_start },
            |m: &mut GrowthPrint| { &mut m.timing_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_end",
            |m: &GrowthPrint| { &m.timing_end },
            |m: &mut GrowthPrint| { &mut m.timing_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tile",
            |m: &GrowthPrint| { &m.tile },
            |m: &mut GrowthPrint| { &mut m.tile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GrowthPrint>(
            "GrowthPrint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GrowthPrint {
    const NAME: &'static str = "GrowthPrint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.priority = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.timing_start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.timing_end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.tile = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.timing_start {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.timing_end {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.priority {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.timing_start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.timing_end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.tile {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GrowthPrint {
        GrowthPrint::new()
    }

    fn clear(&mut self) {
        self.priority = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.timing_start = ::std::option::Option::None;
        self.timing_end = ::std::option::Option::None;
        self.tile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GrowthPrint {
        static instance: GrowthPrint = GrowthPrint {
            priority: ::std::option::Option::None,
            color: ::std::option::Option::None,
            timing_start: ::std::option::Option::None,
            timing_end: ::std::option::Option::None,
            tile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GrowthPrint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GrowthPrint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GrowthPrint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrowthPrint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.TreeGrowth)
pub struct TreeGrowth {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.mat)
    pub mat: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.prints)
    pub prints: ::std::vec::Vec<GrowthPrint>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.timing_start)
    pub timing_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.timing_end)
    pub timing_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.twigs)
    pub twigs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.light_branches)
    pub light_branches: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.heavy_branches)
    pub heavy_branches: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.trunk)
    pub trunk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.roots)
    pub roots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.cap)
    pub cap: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.sapling)
    pub sapling: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.trunk_height_start)
    pub trunk_height_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.TreeGrowth.trunk_height_end)
    pub trunk_height_end: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.TreeGrowth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TreeGrowth {
    fn default() -> &'a TreeGrowth {
        <TreeGrowth as ::protobuf::Message>::default_instance()
    }
}

impl TreeGrowth {
    pub fn new() -> TreeGrowth {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 timing_start = 6;

    pub fn timing_start(&self) -> i32 {
        self.timing_start.unwrap_or(0)
    }

    pub fn clear_timing_start(&mut self) {
        self.timing_start = ::std::option::Option::None;
    }

    pub fn has_timing_start(&self) -> bool {
        self.timing_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_start(&mut self, v: i32) {
        self.timing_start = ::std::option::Option::Some(v);
    }

    // optional int32 timing_end = 7;

    pub fn timing_end(&self) -> i32 {
        self.timing_end.unwrap_or(0)
    }

    pub fn clear_timing_end(&mut self) {
        self.timing_end = ::std::option::Option::None;
    }

    pub fn has_timing_end(&self) -> bool {
        self.timing_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing_end(&mut self, v: i32) {
        self.timing_end = ::std::option::Option::Some(v);
    }

    // optional bool twigs = 8;

    pub fn twigs(&self) -> bool {
        self.twigs.unwrap_or(false)
    }

    pub fn clear_twigs(&mut self) {
        self.twigs = ::std::option::Option::None;
    }

    pub fn has_twigs(&self) -> bool {
        self.twigs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twigs(&mut self, v: bool) {
        self.twigs = ::std::option::Option::Some(v);
    }

    // optional bool light_branches = 9;

    pub fn light_branches(&self) -> bool {
        self.light_branches.unwrap_or(false)
    }

    pub fn clear_light_branches(&mut self) {
        self.light_branches = ::std::option::Option::None;
    }

    pub fn has_light_branches(&self) -> bool {
        self.light_branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_light_branches(&mut self, v: bool) {
        self.light_branches = ::std::option::Option::Some(v);
    }

    // optional bool heavy_branches = 10;

    pub fn heavy_branches(&self) -> bool {
        self.heavy_branches.unwrap_or(false)
    }

    pub fn clear_heavy_branches(&mut self) {
        self.heavy_branches = ::std::option::Option::None;
    }

    pub fn has_heavy_branches(&self) -> bool {
        self.heavy_branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heavy_branches(&mut self, v: bool) {
        self.heavy_branches = ::std::option::Option::Some(v);
    }

    // optional bool trunk = 11;

    pub fn trunk(&self) -> bool {
        self.trunk.unwrap_or(false)
    }

    pub fn clear_trunk(&mut self) {
        self.trunk = ::std::option::Option::None;
    }

    pub fn has_trunk(&self) -> bool {
        self.trunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk(&mut self, v: bool) {
        self.trunk = ::std::option::Option::Some(v);
    }

    // optional bool roots = 12;

    pub fn roots(&self) -> bool {
        self.roots.unwrap_or(false)
    }

    pub fn clear_roots(&mut self) {
        self.roots = ::std::option::Option::None;
    }

    pub fn has_roots(&self) -> bool {
        self.roots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roots(&mut self, v: bool) {
        self.roots = ::std::option::Option::Some(v);
    }

    // optional bool cap = 13;

    pub fn cap(&self) -> bool {
        self.cap.unwrap_or(false)
    }

    pub fn clear_cap(&mut self) {
        self.cap = ::std::option::Option::None;
    }

    pub fn has_cap(&self) -> bool {
        self.cap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cap(&mut self, v: bool) {
        self.cap = ::std::option::Option::Some(v);
    }

    // optional bool sapling = 14;

    pub fn sapling(&self) -> bool {
        self.sapling.unwrap_or(false)
    }

    pub fn clear_sapling(&mut self) {
        self.sapling = ::std::option::Option::None;
    }

    pub fn has_sapling(&self) -> bool {
        self.sapling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sapling(&mut self, v: bool) {
        self.sapling = ::std::option::Option::Some(v);
    }

    // optional int32 trunk_height_start = 15;

    pub fn trunk_height_start(&self) -> i32 {
        self.trunk_height_start.unwrap_or(0)
    }

    pub fn clear_trunk_height_start(&mut self) {
        self.trunk_height_start = ::std::option::Option::None;
    }

    pub fn has_trunk_height_start(&self) -> bool {
        self.trunk_height_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk_height_start(&mut self, v: i32) {
        self.trunk_height_start = ::std::option::Option::Some(v);
    }

    // optional int32 trunk_height_end = 16;

    pub fn trunk_height_end(&self) -> i32 {
        self.trunk_height_end.unwrap_or(0)
    }

    pub fn clear_trunk_height_end(&mut self) {
        self.trunk_height_end = ::std::option::Option::None;
    }

    pub fn has_trunk_height_end(&self) -> bool {
        self.trunk_height_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk_height_end(&mut self, v: i32) {
        self.trunk_height_end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &TreeGrowth| { &m.index },
            |m: &mut TreeGrowth| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &TreeGrowth| { &m.id },
            |m: &mut TreeGrowth| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &TreeGrowth| { &m.name },
            |m: &mut TreeGrowth| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "mat",
            |m: &TreeGrowth| { &m.mat },
            |m: &mut TreeGrowth| { &mut m.mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "prints",
            |m: &TreeGrowth| { &m.prints },
            |m: &mut TreeGrowth| { &mut m.prints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_start",
            |m: &TreeGrowth| { &m.timing_start },
            |m: &mut TreeGrowth| { &mut m.timing_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timing_end",
            |m: &TreeGrowth| { &m.timing_end },
            |m: &mut TreeGrowth| { &mut m.timing_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "twigs",
            |m: &TreeGrowth| { &m.twigs },
            |m: &mut TreeGrowth| { &mut m.twigs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "light_branches",
            |m: &TreeGrowth| { &m.light_branches },
            |m: &mut TreeGrowth| { &mut m.light_branches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "heavy_branches",
            |m: &TreeGrowth| { &m.heavy_branches },
            |m: &mut TreeGrowth| { &mut m.heavy_branches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trunk",
            |m: &TreeGrowth| { &m.trunk },
            |m: &mut TreeGrowth| { &mut m.trunk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roots",
            |m: &TreeGrowth| { &m.roots },
            |m: &mut TreeGrowth| { &mut m.roots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cap",
            |m: &TreeGrowth| { &m.cap },
            |m: &mut TreeGrowth| { &mut m.cap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sapling",
            |m: &TreeGrowth| { &m.sapling },
            |m: &mut TreeGrowth| { &mut m.sapling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trunk_height_start",
            |m: &TreeGrowth| { &m.trunk_height_start },
            |m: &mut TreeGrowth| { &mut m.trunk_height_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trunk_height_end",
            |m: &TreeGrowth| { &m.trunk_height_end },
            |m: &mut TreeGrowth| { &mut m.trunk_height_end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TreeGrowth>(
            "TreeGrowth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TreeGrowth {
    const NAME: &'static str = "TreeGrowth";

    fn is_initialized(&self) -> bool {
        for v in &self.mat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mat)?;
                },
                42 => {
                    self.prints.push(is.read_message()?);
                },
                48 => {
                    self.timing_start = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.timing_end = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.twigs = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.light_branches = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.heavy_branches = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.trunk = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.roots = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.cap = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.sapling = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.trunk_height_start = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.trunk_height_end = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.mat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.prints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timing_start {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.timing_end {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.twigs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.light_branches {
            my_size += 1 + 1;
        }
        if let Some(v) = self.heavy_branches {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trunk {
            my_size += 1 + 1;
        }
        if let Some(v) = self.roots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cap {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sapling {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trunk_height_start {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.trunk_height_end {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.mat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.prints {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.timing_start {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.timing_end {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.twigs {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.light_branches {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.heavy_branches {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.trunk {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.roots {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.cap {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.sapling {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.trunk_height_start {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.trunk_height_end {
            os.write_int32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TreeGrowth {
        TreeGrowth::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.mat.clear();
        self.prints.clear();
        self.timing_start = ::std::option::Option::None;
        self.timing_end = ::std::option::Option::None;
        self.twigs = ::std::option::Option::None;
        self.light_branches = ::std::option::Option::None;
        self.heavy_branches = ::std::option::Option::None;
        self.trunk = ::std::option::Option::None;
        self.roots = ::std::option::Option::None;
        self.cap = ::std::option::Option::None;
        self.sapling = ::std::option::Option::None;
        self.trunk_height_start = ::std::option::Option::None;
        self.trunk_height_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TreeGrowth {
        static instance: TreeGrowth = TreeGrowth {
            index: ::std::option::Option::None,
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            mat: ::protobuf::MessageField::none(),
            prints: ::std::vec::Vec::new(),
            timing_start: ::std::option::Option::None,
            timing_end: ::std::option::Option::None,
            twigs: ::std::option::Option::None,
            light_branches: ::std::option::Option::None,
            heavy_branches: ::std::option::Option::None,
            trunk: ::std::option::Option::None,
            roots: ::std::option::Option::None,
            cap: ::std::option::Option::None,
            sapling: ::std::option::Option::None,
            trunk_height_start: ::std::option::Option::None,
            trunk_height_end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TreeGrowth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TreeGrowth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TreeGrowth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeGrowth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PlantRaw)
pub struct PlantRaw {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantRaw.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantRaw.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantRaw.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantRaw.growths)
    pub growths: ::std::vec::Vec<TreeGrowth>,
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantRaw.tile)
    pub tile: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PlantRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlantRaw {
    fn default() -> &'a PlantRaw {
        <PlantRaw as ::protobuf::Message>::default_instance()
    }
}

impl PlantRaw {
    pub fn new() -> PlantRaw {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tile = 5;

    pub fn tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }

    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &PlantRaw| { &m.index },
            |m: &mut PlantRaw| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &PlantRaw| { &m.id },
            |m: &mut PlantRaw| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PlantRaw| { &m.name },
            |m: &mut PlantRaw| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "growths",
            |m: &PlantRaw| { &m.growths },
            |m: &mut PlantRaw| { &mut m.growths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tile",
            |m: &PlantRaw| { &m.tile },
            |m: &mut PlantRaw| { &mut m.tile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlantRaw>(
            "PlantRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlantRaw {
    const NAME: &'static str = "PlantRaw";

    fn is_initialized(&self) -> bool {
        for v in &self.growths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.growths.push(is.read_message()?);
                },
                40 => {
                    self.tile = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.growths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.growths {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.tile {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlantRaw {
        PlantRaw::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.growths.clear();
        self.tile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlantRaw {
        static instance: PlantRaw = PlantRaw {
            index: ::std::option::Option::None,
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            growths: ::std::vec::Vec::new(),
            tile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlantRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlantRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlantRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.PlantRawList)
pub struct PlantRawList {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.PlantRawList.plant_raws)
    pub plant_raws: ::std::vec::Vec<PlantRaw>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.PlantRawList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlantRawList {
    fn default() -> &'a PlantRawList {
        <PlantRawList as ::protobuf::Message>::default_instance()
    }
}

impl PlantRawList {
    pub fn new() -> PlantRawList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "plant_raws",
            |m: &PlantRawList| { &m.plant_raws },
            |m: &mut PlantRawList| { &mut m.plant_raws },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlantRawList>(
            "PlantRawList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlantRawList {
    const NAME: &'static str = "PlantRawList";

    fn is_initialized(&self) -> bool {
        for v in &self.plant_raws {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plant_raws.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.plant_raws {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.plant_raws {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlantRawList {
        PlantRawList::new()
    }

    fn clear(&mut self) {
        self.plant_raws.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlantRawList {
        static instance: PlantRawList = PlantRawList {
            plant_raws: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlantRawList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlantRawList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlantRawList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlantRawList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ScreenTile)
pub struct ScreenTile {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ScreenTile.character)
    pub character: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ScreenTile.foreground)
    pub foreground: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ScreenTile.background)
    pub background: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ScreenTile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScreenTile {
    fn default() -> &'a ScreenTile {
        <ScreenTile as ::protobuf::Message>::default_instance()
    }
}

impl ScreenTile {
    pub fn new() -> ScreenTile {
        ::std::default::Default::default()
    }

    // optional uint32 character = 1;

    pub fn character(&self) -> u32 {
        self.character.unwrap_or(0)
    }

    pub fn clear_character(&mut self) {
        self.character = ::std::option::Option::None;
    }

    pub fn has_character(&self) -> bool {
        self.character.is_some()
    }

    // Param is passed by value, moved
    pub fn set_character(&mut self, v: u32) {
        self.character = ::std::option::Option::Some(v);
    }

    // optional uint32 foreground = 2;

    pub fn foreground(&self) -> u32 {
        self.foreground.unwrap_or(0)
    }

    pub fn clear_foreground(&mut self) {
        self.foreground = ::std::option::Option::None;
    }

    pub fn has_foreground(&self) -> bool {
        self.foreground.is_some()
    }

    // Param is passed by value, moved
    pub fn set_foreground(&mut self, v: u32) {
        self.foreground = ::std::option::Option::Some(v);
    }

    // optional uint32 background = 3;

    pub fn background(&self) -> u32 {
        self.background.unwrap_or(0)
    }

    pub fn clear_background(&mut self) {
        self.background = ::std::option::Option::None;
    }

    pub fn has_background(&self) -> bool {
        self.background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background(&mut self, v: u32) {
        self.background = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "character",
            |m: &ScreenTile| { &m.character },
            |m: &mut ScreenTile| { &mut m.character },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "foreground",
            |m: &ScreenTile| { &m.foreground },
            |m: &mut ScreenTile| { &mut m.foreground },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "background",
            |m: &ScreenTile| { &m.background },
            |m: &mut ScreenTile| { &mut m.background },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScreenTile>(
            "ScreenTile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScreenTile {
    const NAME: &'static str = "ScreenTile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.character = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.foreground = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.background = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.character {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.foreground {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.background {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.character {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.foreground {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.background {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScreenTile {
        ScreenTile::new()
    }

    fn clear(&mut self) {
        self.character = ::std::option::Option::None;
        self.foreground = ::std::option::Option::None;
        self.background = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScreenTile {
        static instance: ScreenTile = ScreenTile {
            character: ::std::option::Option::None,
            foreground: ::std::option::Option::None,
            background: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScreenTile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScreenTile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScreenTile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenTile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ScreenCapture)
pub struct ScreenCapture {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ScreenCapture.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ScreenCapture.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ScreenCapture.tiles)
    pub tiles: ::std::vec::Vec<ScreenTile>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ScreenCapture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScreenCapture {
    fn default() -> &'a ScreenCapture {
        <ScreenCapture as ::protobuf::Message>::default_instance()
    }
}

impl ScreenCapture {
    pub fn new() -> ScreenCapture {
        ::std::default::Default::default()
    }

    // optional uint32 width = 1;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 2;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &ScreenCapture| { &m.width },
            |m: &mut ScreenCapture| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &ScreenCapture| { &m.height },
            |m: &mut ScreenCapture| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tiles",
            |m: &ScreenCapture| { &m.tiles },
            |m: &mut ScreenCapture| { &mut m.tiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScreenCapture>(
            "ScreenCapture",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScreenCapture {
    const NAME: &'static str = "ScreenCapture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.tiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        }
        for v in &self.tiles {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScreenCapture {
        ScreenCapture::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.tiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScreenCapture {
        static instance: ScreenCapture = ScreenCapture {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            tiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScreenCapture {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScreenCapture").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScreenCapture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenCapture {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.KeyboardEvent)
pub struct KeyboardEvent {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.which)
    pub which: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.state)
    pub state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.scancode)
    pub scancode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.sym)
    pub sym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.mod)
    pub mod_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.KeyboardEvent.unicode)
    pub unicode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.KeyboardEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyboardEvent {
    fn default() -> &'a KeyboardEvent {
        <KeyboardEvent as ::protobuf::Message>::default_instance()
    }
}

impl KeyboardEvent {
    pub fn new() -> KeyboardEvent {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint32 which = 2;

    pub fn which(&self) -> u32 {
        self.which.unwrap_or(0)
    }

    pub fn clear_which(&mut self) {
        self.which = ::std::option::Option::None;
    }

    pub fn has_which(&self) -> bool {
        self.which.is_some()
    }

    // Param is passed by value, moved
    pub fn set_which(&mut self, v: u32) {
        self.which = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 3;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional uint32 scancode = 4;

    pub fn scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    // optional uint32 sym = 5;

    pub fn sym(&self) -> u32 {
        self.sym.unwrap_or(0)
    }

    pub fn clear_sym(&mut self) {
        self.sym = ::std::option::Option::None;
    }

    pub fn has_sym(&self) -> bool {
        self.sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sym(&mut self, v: u32) {
        self.sym = ::std::option::Option::Some(v);
    }

    // optional uint32 mod = 6;

    pub fn mod_(&self) -> u32 {
        self.mod_.unwrap_or(0)
    }

    pub fn clear_mod_(&mut self) {
        self.mod_ = ::std::option::Option::None;
    }

    pub fn has_mod(&self) -> bool {
        self.mod_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod(&mut self, v: u32) {
        self.mod_ = ::std::option::Option::Some(v);
    }

    // optional uint32 unicode = 7;

    pub fn unicode(&self) -> u32 {
        self.unicode.unwrap_or(0)
    }

    pub fn clear_unicode(&mut self) {
        self.unicode = ::std::option::Option::None;
    }

    pub fn has_unicode(&self) -> bool {
        self.unicode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unicode(&mut self, v: u32) {
        self.unicode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &KeyboardEvent| { &m.type_ },
            |m: &mut KeyboardEvent| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "which",
            |m: &KeyboardEvent| { &m.which },
            |m: &mut KeyboardEvent| { &mut m.which },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &KeyboardEvent| { &m.state },
            |m: &mut KeyboardEvent| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scancode",
            |m: &KeyboardEvent| { &m.scancode },
            |m: &mut KeyboardEvent| { &mut m.scancode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sym",
            |m: &KeyboardEvent| { &m.sym },
            |m: &mut KeyboardEvent| { &mut m.sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mod",
            |m: &KeyboardEvent| { &m.mod_ },
            |m: &mut KeyboardEvent| { &mut m.mod_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unicode",
            |m: &KeyboardEvent| { &m.unicode },
            |m: &mut KeyboardEvent| { &mut m.unicode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyboardEvent>(
            "KeyboardEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyboardEvent {
    const NAME: &'static str = "KeyboardEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.which = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sym = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.mod_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unicode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.which {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sym {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mod_ {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unicode {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.which {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sym {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mod_ {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unicode {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyboardEvent {
        KeyboardEvent::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.which = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.sym = ::std::option::Option::None;
        self.mod_ = ::std::option::Option::None;
        self.unicode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyboardEvent {
        static instance: KeyboardEvent = KeyboardEvent {
            type_: ::std::option::Option::None,
            which: ::std::option::Option::None,
            state: ::std::option::Option::None,
            scancode: ::std::option::Option::None,
            sym: ::std::option::Option::None,
            mod_: ::std::option::Option::None,
            unicode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyboardEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyboardEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyboardEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyboardEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.DigCommand)
pub struct DigCommand {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.DigCommand.designation)
    pub designation: ::std::option::Option<::protobuf::EnumOrUnknown<TileDigDesignation>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.DigCommand.locations)
    pub locations: ::std::vec::Vec<Coord>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.DigCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DigCommand {
    fn default() -> &'a DigCommand {
        <DigCommand as ::protobuf::Message>::default_instance()
    }
}

impl DigCommand {
    pub fn new() -> DigCommand {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.TileDigDesignation designation = 1;

    pub fn designation(&self) -> TileDigDesignation {
        match self.designation {
            Some(e) => e.enum_value_or(TileDigDesignation::NO_DIG),
            None => TileDigDesignation::NO_DIG,
        }
    }

    pub fn clear_designation(&mut self) {
        self.designation = ::std::option::Option::None;
    }

    pub fn has_designation(&self) -> bool {
        self.designation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_designation(&mut self, v: TileDigDesignation) {
        self.designation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "designation",
            |m: &DigCommand| { &m.designation },
            |m: &mut DigCommand| { &mut m.designation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "locations",
            |m: &DigCommand| { &m.locations },
            |m: &mut DigCommand| { &mut m.locations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DigCommand>(
            "DigCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DigCommand {
    const NAME: &'static str = "DigCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.designation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.locations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.designation {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.designation {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.locations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DigCommand {
        DigCommand::new()
    }

    fn clear(&mut self) {
        self.designation = ::std::option::Option::None;
        self.locations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DigCommand {
        static instance: DigCommand = DigCommand {
            designation: ::std::option::Option::None,
            locations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DigCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DigCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DigCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.SingleBool)
pub struct SingleBool {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.SingleBool.Value)
    pub Value: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.SingleBool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleBool {
    fn default() -> &'a SingleBool {
        <SingleBool as ::protobuf::Message>::default_instance()
    }
}

impl SingleBool {
    pub fn new() -> SingleBool {
        ::std::default::Default::default()
    }

    // optional bool Value = 1;

    pub fn Value(&self) -> bool {
        self.Value.unwrap_or(false)
    }

    pub fn clear_Value(&mut self) {
        self.Value = ::std::option::Option::None;
    }

    pub fn has_Value(&self) -> bool {
        self.Value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Value(&mut self, v: bool) {
        self.Value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Value",
            |m: &SingleBool| { &m.Value },
            |m: &mut SingleBool| { &mut m.Value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleBool>(
            "SingleBool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleBool {
    const NAME: &'static str = "SingleBool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Value = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Value {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Value {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleBool {
        SingleBool::new()
    }

    fn clear(&mut self) {
        self.Value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleBool {
        static instance: SingleBool = SingleBool {
            Value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleBool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleBool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleBool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleBool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.VersionInfo)
pub struct VersionInfo {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.VersionInfo.dwarf_fortress_version)
    pub dwarf_fortress_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.VersionInfo.dfhack_version)
    pub dfhack_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.VersionInfo.remote_fortress_reader_version)
    pub remote_fortress_reader_version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.VersionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VersionInfo {
    fn default() -> &'a VersionInfo {
        <VersionInfo as ::protobuf::Message>::default_instance()
    }
}

impl VersionInfo {
    pub fn new() -> VersionInfo {
        ::std::default::Default::default()
    }

    // optional string dwarf_fortress_version = 1;

    pub fn dwarf_fortress_version(&self) -> &str {
        match self.dwarf_fortress_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dwarf_fortress_version(&mut self) {
        self.dwarf_fortress_version = ::std::option::Option::None;
    }

    pub fn has_dwarf_fortress_version(&self) -> bool {
        self.dwarf_fortress_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dwarf_fortress_version(&mut self, v: ::std::string::String) {
        self.dwarf_fortress_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dwarf_fortress_version(&mut self) -> &mut ::std::string::String {
        if self.dwarf_fortress_version.is_none() {
            self.dwarf_fortress_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dwarf_fortress_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_dwarf_fortress_version(&mut self) -> ::std::string::String {
        self.dwarf_fortress_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dfhack_version = 2;

    pub fn dfhack_version(&self) -> &str {
        match self.dfhack_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dfhack_version(&mut self) {
        self.dfhack_version = ::std::option::Option::None;
    }

    pub fn has_dfhack_version(&self) -> bool {
        self.dfhack_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dfhack_version(&mut self, v: ::std::string::String) {
        self.dfhack_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dfhack_version(&mut self) -> &mut ::std::string::String {
        if self.dfhack_version.is_none() {
            self.dfhack_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dfhack_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_dfhack_version(&mut self) -> ::std::string::String {
        self.dfhack_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_fortress_reader_version = 3;

    pub fn remote_fortress_reader_version(&self) -> &str {
        match self.remote_fortress_reader_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remote_fortress_reader_version(&mut self) {
        self.remote_fortress_reader_version = ::std::option::Option::None;
    }

    pub fn has_remote_fortress_reader_version(&self) -> bool {
        self.remote_fortress_reader_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_fortress_reader_version(&mut self, v: ::std::string::String) {
        self.remote_fortress_reader_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_fortress_reader_version(&mut self) -> &mut ::std::string::String {
        if self.remote_fortress_reader_version.is_none() {
            self.remote_fortress_reader_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remote_fortress_reader_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_fortress_reader_version(&mut self) -> ::std::string::String {
        self.remote_fortress_reader_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dwarf_fortress_version",
            |m: &VersionInfo| { &m.dwarf_fortress_version },
            |m: &mut VersionInfo| { &mut m.dwarf_fortress_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dfhack_version",
            |m: &VersionInfo| { &m.dfhack_version },
            |m: &mut VersionInfo| { &mut m.dfhack_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remote_fortress_reader_version",
            |m: &VersionInfo| { &m.remote_fortress_reader_version },
            |m: &mut VersionInfo| { &mut m.remote_fortress_reader_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionInfo>(
            "VersionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VersionInfo {
    const NAME: &'static str = "VersionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dwarf_fortress_version = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.dfhack_version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.remote_fortress_reader_version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dwarf_fortress_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.dfhack_version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.remote_fortress_reader_version.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dwarf_fortress_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.dfhack_version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.remote_fortress_reader_version.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VersionInfo {
        VersionInfo::new()
    }

    fn clear(&mut self) {
        self.dwarf_fortress_version = ::std::option::Option::None;
        self.dfhack_version = ::std::option::Option::None;
        self.remote_fortress_reader_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VersionInfo {
        static instance: VersionInfo = VersionInfo {
            dwarf_fortress_version: ::std::option::Option::None,
            dfhack_version: ::std::option::Option::None,
            remote_fortress_reader_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VersionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VersionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VersionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ListRequest)
pub struct ListRequest {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ListRequest.list_start)
    pub list_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ListRequest.list_end)
    pub list_end: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    // optional int32 list_start = 1;

    pub fn list_start(&self) -> i32 {
        self.list_start.unwrap_or(0)
    }

    pub fn clear_list_start(&mut self) {
        self.list_start = ::std::option::Option::None;
    }

    pub fn has_list_start(&self) -> bool {
        self.list_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_start(&mut self, v: i32) {
        self.list_start = ::std::option::Option::Some(v);
    }

    // optional int32 list_end = 2;

    pub fn list_end(&self) -> i32 {
        self.list_end.unwrap_or(0)
    }

    pub fn clear_list_end(&mut self) {
        self.list_end = ::std::option::Option::None;
    }

    pub fn has_list_end(&self) -> bool {
        self.list_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_end(&mut self, v: i32) {
        self.list_end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "list_start",
            |m: &ListRequest| { &m.list_start },
            |m: &mut ListRequest| { &mut m.list_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "list_end",
            |m: &ListRequest| { &m.list_end },
            |m: &mut ListRequest| { &mut m.list_end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRequest>(
            "ListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRequest {
    const NAME: &'static str = "ListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.list_start = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.list_end = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.list_start {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.list_end {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.list_start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.list_end {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn clear(&mut self) {
        self.list_start = ::std::option::Option::None;
        self.list_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRequest {
        static instance: ListRequest = ListRequest {
            list_start: ::std::option::Option::None,
            list_end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Report)
pub struct Report {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.color)
    pub color: ::protobuf::MessageField<ColorDefinition>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.continuation)
    pub continuation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.unconscious)
    pub unconscious: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.announcement)
    pub announcement: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.repeat_count)
    pub repeat_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.pos)
    pub pos: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.year)
    pub year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Report.time)
    pub time: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Report.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Report {
    fn default() -> &'a Report {
        <Report as ::protobuf::Message>::default_instance()
    }
}

impl Report {
    pub fn new() -> Report {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 duration = 4;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool continuation = 5;

    pub fn continuation(&self) -> bool {
        self.continuation.unwrap_or(false)
    }

    pub fn clear_continuation(&mut self) {
        self.continuation = ::std::option::Option::None;
    }

    pub fn has_continuation(&self) -> bool {
        self.continuation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continuation(&mut self, v: bool) {
        self.continuation = ::std::option::Option::Some(v);
    }

    // optional bool unconscious = 6;

    pub fn unconscious(&self) -> bool {
        self.unconscious.unwrap_or(false)
    }

    pub fn clear_unconscious(&mut self) {
        self.unconscious = ::std::option::Option::None;
    }

    pub fn has_unconscious(&self) -> bool {
        self.unconscious.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unconscious(&mut self, v: bool) {
        self.unconscious = ::std::option::Option::Some(v);
    }

    // optional bool announcement = 7;

    pub fn announcement(&self) -> bool {
        self.announcement.unwrap_or(false)
    }

    pub fn clear_announcement(&mut self) {
        self.announcement = ::std::option::Option::None;
    }

    pub fn has_announcement(&self) -> bool {
        self.announcement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement(&mut self, v: bool) {
        self.announcement = ::std::option::Option::Some(v);
    }

    // optional int32 repeat_count = 8;

    pub fn repeat_count(&self) -> i32 {
        self.repeat_count.unwrap_or(0)
    }

    pub fn clear_repeat_count(&mut self) {
        self.repeat_count = ::std::option::Option::None;
    }

    pub fn has_repeat_count(&self) -> bool {
        self.repeat_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat_count(&mut self, v: i32) {
        self.repeat_count = ::std::option::Option::Some(v);
    }

    // optional int32 id = 10;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 year = 11;

    pub fn year(&self) -> i32 {
        self.year.unwrap_or(0)
    }

    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: i32) {
        self.year = ::std::option::Option::Some(v);
    }

    // optional int32 time = 12;

    pub fn time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Report| { &m.type_ },
            |m: &mut Report| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Report| { &m.text },
            |m: &mut Report| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ColorDefinition>(
            "color",
            |m: &Report| { &m.color },
            |m: &mut Report| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &Report| { &m.duration },
            |m: &mut Report| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "continuation",
            |m: &Report| { &m.continuation },
            |m: &mut Report| { &mut m.continuation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unconscious",
            |m: &Report| { &m.unconscious },
            |m: &mut Report| { &mut m.unconscious },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "announcement",
            |m: &Report| { &m.announcement },
            |m: &mut Report| { &mut m.announcement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repeat_count",
            |m: &Report| { &m.repeat_count },
            |m: &mut Report| { &mut m.repeat_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "pos",
            |m: &Report| { &m.pos },
            |m: &mut Report| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Report| { &m.id },
            |m: &mut Report| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "year",
            |m: &Report| { &m.year },
            |m: &mut Report| { &mut m.year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &Report| { &m.time },
            |m: &mut Report| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Report>(
            "Report",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Report {
    const NAME: &'static str = "Report";

    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                32 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.continuation = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.unconscious = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.announcement = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.repeat_count = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                80 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.year = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.continuation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unconscious {
            my_size += 1 + 1;
        }
        if let Some(v) = self.announcement {
            my_size += 1 + 1;
        }
        if let Some(v) = self.repeat_count {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.continuation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.unconscious {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.announcement {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.repeat_count {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.year {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Report {
        Report::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.color.clear();
        self.duration = ::std::option::Option::None;
        self.continuation = ::std::option::Option::None;
        self.unconscious = ::std::option::Option::None;
        self.announcement = ::std::option::Option::None;
        self.repeat_count = ::std::option::Option::None;
        self.pos.clear();
        self.id = ::std::option::Option::None;
        self.year = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Report {
        static instance: Report = Report {
            type_: ::std::option::Option::None,
            text: ::std::option::Option::None,
            color: ::protobuf::MessageField::none(),
            duration: ::std::option::Option::None,
            continuation: ::std::option::Option::None,
            unconscious: ::std::option::Option::None,
            announcement: ::std::option::Option::None,
            repeat_count: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            id: ::std::option::Option::None,
            year: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Report {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Report").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Report {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Report {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Status)
pub struct Status {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Status.reports)
    pub reports: ::std::vec::Vec<Report>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Status.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reports",
            |m: &Status| { &m.reports },
            |m: &mut Status| { &mut m.reports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Status>(
            "Status",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Status {
    const NAME: &'static str = "Status";

    fn is_initialized(&self) -> bool {
        for v in &self.reports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.reports {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Status {
        Status::new()
    }

    fn clear(&mut self) {
        self.reports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Status {
        static instance: Status = Status {
            reports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Status {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Status").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ShapeDescriptior)
pub struct ShapeDescriptior {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ShapeDescriptior.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ShapeDescriptior.tile)
    pub tile: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ShapeDescriptior.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShapeDescriptior {
    fn default() -> &'a ShapeDescriptior {
        <ShapeDescriptior as ::protobuf::Message>::default_instance()
    }
}

impl ShapeDescriptior {
    pub fn new() -> ShapeDescriptior {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tile = 2;

    pub fn tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }

    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ShapeDescriptior| { &m.id },
            |m: &mut ShapeDescriptior| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tile",
            |m: &ShapeDescriptior| { &m.tile },
            |m: &mut ShapeDescriptior| { &mut m.tile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShapeDescriptior>(
            "ShapeDescriptior",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShapeDescriptior {
    const NAME: &'static str = "ShapeDescriptior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.tile = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.tile {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShapeDescriptior {
        ShapeDescriptior::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.tile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShapeDescriptior {
        static instance: ShapeDescriptior = ShapeDescriptior {
            id: ::std::option::Option::None,
            tile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShapeDescriptior {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShapeDescriptior").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShapeDescriptior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShapeDescriptior {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Language)
pub struct Language {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Language.shapes)
    pub shapes: ::std::vec::Vec<ShapeDescriptior>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Language.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Language {
    fn default() -> &'a Language {
        <Language as ::protobuf::Message>::default_instance()
    }
}

impl Language {
    pub fn new() -> Language {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shapes",
            |m: &Language| { &m.shapes },
            |m: &mut Language| { &mut m.shapes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Language>(
            "Language",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Language {
    const NAME: &'static str = "Language";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shapes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.shapes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Language {
        Language::new()
    }

    fn clear(&mut self) {
        self.shapes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Language {
        static instance: Language = Language {
            shapes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Language {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Language").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Language {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Language {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ItemImprovement)
pub struct ItemImprovement {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ItemImprovement.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ItemImprovement.shape)
    pub shape: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ItemImprovement.specific_type)
    pub specific_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ItemImprovement.image)
    pub image: ::protobuf::MessageField<ArtImage>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ItemImprovement.type)
    pub type_: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ItemImprovement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ItemImprovement {
    fn default() -> &'a ItemImprovement {
        <ItemImprovement as ::protobuf::Message>::default_instance()
    }
}

impl ItemImprovement {
    pub fn new() -> ItemImprovement {
        ::std::default::Default::default()
    }

    // optional int32 shape = 3;

    pub fn shape(&self) -> i32 {
        self.shape.unwrap_or(0)
    }

    pub fn clear_shape(&mut self) {
        self.shape = ::std::option::Option::None;
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: i32) {
        self.shape = ::std::option::Option::Some(v);
    }

    // optional int32 specific_type = 4;

    pub fn specific_type(&self) -> i32 {
        self.specific_type.unwrap_or(0)
    }

    pub fn clear_specific_type(&mut self) {
        self.specific_type = ::std::option::Option::None;
    }

    pub fn has_specific_type(&self) -> bool {
        self.specific_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specific_type(&mut self, v: i32) {
        self.specific_type = ::std::option::Option::Some(v);
    }

    // optional int32 type = 6;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &ItemImprovement| { &m.material },
            |m: &mut ItemImprovement| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shape",
            |m: &ItemImprovement| { &m.shape },
            |m: &mut ItemImprovement| { &mut m.shape },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specific_type",
            |m: &ItemImprovement| { &m.specific_type },
            |m: &mut ItemImprovement| { &mut m.specific_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArtImage>(
            "image",
            |m: &ItemImprovement| { &m.image },
            |m: &mut ItemImprovement| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ItemImprovement| { &m.type_ },
            |m: &mut ItemImprovement| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemImprovement>(
            "ItemImprovement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ItemImprovement {
    const NAME: &'static str = "ItemImprovement";

    fn is_initialized(&self) -> bool {
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                24 => {
                    self.shape = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.specific_type = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                48 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shape {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.specific_type {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.shape {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.specific_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ItemImprovement {
        ItemImprovement::new()
    }

    fn clear(&mut self) {
        self.material.clear();
        self.shape = ::std::option::Option::None;
        self.specific_type = ::std::option::Option::None;
        self.image.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ItemImprovement {
        static instance: ItemImprovement = ItemImprovement {
            material: ::protobuf::MessageField::none(),
            shape: ::std::option::Option::None,
            specific_type: ::std::option::Option::None,
            image: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ItemImprovement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ItemImprovement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ItemImprovement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemImprovement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ArtImageElement)
pub struct ArtImageElement {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageElement.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageElement.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ArtImageElementType>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageElement.creature_item)
    pub creature_item: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageElement.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageElement.id)
    pub id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ArtImageElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtImageElement {
    fn default() -> &'a ArtImageElement {
        <ArtImageElement as ::protobuf::Message>::default_instance()
    }
}

impl ArtImageElement {
    pub fn new() -> ArtImageElement {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImageElementType type = 2;

    pub fn type_(&self) -> ArtImageElementType {
        match self.type_ {
            Some(e) => e.enum_value_or(ArtImageElementType::IMAGE_CREATURE),
            None => ArtImageElementType::IMAGE_CREATURE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ArtImageElementType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 id = 6;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &ArtImageElement| { &m.count },
            |m: &mut ArtImageElement| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ArtImageElement| { &m.type_ },
            |m: &mut ArtImageElement| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "creature_item",
            |m: &ArtImageElement| { &m.creature_item },
            |m: &mut ArtImageElement| { &mut m.creature_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &ArtImageElement| { &m.material },
            |m: &mut ArtImageElement| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ArtImageElement| { &m.id },
            |m: &mut ArtImageElement| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtImageElement>(
            "ArtImageElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtImageElement {
    const NAME: &'static str = "ArtImageElement";

    fn is_initialized(&self) -> bool {
        for v in &self.creature_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.creature_item)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                48 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.creature_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.creature_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtImageElement {
        ArtImageElement::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.creature_item.clear();
        self.material.clear();
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtImageElement {
        static instance: ArtImageElement = ArtImageElement {
            count: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            creature_item: ::protobuf::MessageField::none(),
            material: ::protobuf::MessageField::none(),
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtImageElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtImageElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtImageElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImageElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ArtImageProperty)
pub struct ArtImageProperty {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageProperty.subject)
    pub subject: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageProperty.object)
    pub object: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageProperty.verb)
    pub verb: ::std::option::Option<::protobuf::EnumOrUnknown<ArtImageVerb>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImageProperty.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ArtImagePropertyType>>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ArtImageProperty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtImageProperty {
    fn default() -> &'a ArtImageProperty {
        <ArtImageProperty as ::protobuf::Message>::default_instance()
    }
}

impl ArtImageProperty {
    pub fn new() -> ArtImageProperty {
        ::std::default::Default::default()
    }

    // optional int32 subject = 1;

    pub fn subject(&self) -> i32 {
        self.subject.unwrap_or(0)
    }

    pub fn clear_subject(&mut self) {
        self.subject = ::std::option::Option::None;
    }

    pub fn has_subject(&self) -> bool {
        self.subject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: i32) {
        self.subject = ::std::option::Option::Some(v);
    }

    // optional int32 object = 2;

    pub fn object(&self) -> i32 {
        self.object.unwrap_or(0)
    }

    pub fn clear_object(&mut self) {
        self.object = ::std::option::Option::None;
    }

    pub fn has_object(&self) -> bool {
        self.object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: i32) {
        self.object = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.ArtImageVerb verb = 3;

    pub fn verb(&self) -> ArtImageVerb {
        match self.verb {
            Some(e) => e.enum_value_or(ArtImageVerb::VERB_WITHERING),
            None => ArtImageVerb::VERB_WITHERING,
        }
    }

    pub fn clear_verb(&mut self) {
        self.verb = ::std::option::Option::None;
    }

    pub fn has_verb(&self) -> bool {
        self.verb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verb(&mut self, v: ArtImageVerb) {
        self.verb = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RemoteFortressReader.ArtImagePropertyType type = 4;

    pub fn type_(&self) -> ArtImagePropertyType {
        match self.type_ {
            Some(e) => e.enum_value_or(ArtImagePropertyType::TRANSITIVE_VERB),
            None => ArtImagePropertyType::TRANSITIVE_VERB,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ArtImagePropertyType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject",
            |m: &ArtImageProperty| { &m.subject },
            |m: &mut ArtImageProperty| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "object",
            |m: &ArtImageProperty| { &m.object },
            |m: &mut ArtImageProperty| { &mut m.object },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verb",
            |m: &ArtImageProperty| { &m.verb },
            |m: &mut ArtImageProperty| { &mut m.verb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ArtImageProperty| { &m.type_ },
            |m: &mut ArtImageProperty| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtImageProperty>(
            "ArtImageProperty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtImageProperty {
    const NAME: &'static str = "ArtImageProperty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.object = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.verb = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subject {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.object {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.verb {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subject {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.object {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.verb {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtImageProperty {
        ArtImageProperty::new()
    }

    fn clear(&mut self) {
        self.subject = ::std::option::Option::None;
        self.object = ::std::option::Option::None;
        self.verb = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtImageProperty {
        static instance: ArtImageProperty = ArtImageProperty {
            subject: ::std::option::Option::None,
            object: ::std::option::Option::None,
            verb: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtImageProperty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtImageProperty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtImageProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImageProperty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.ArtImage)
pub struct ArtImage {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImage.elements)
    pub elements: ::std::vec::Vec<ArtImageElement>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImage.id)
    pub id: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.ArtImage.properties)
    pub properties: ::std::vec::Vec<ArtImageProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.ArtImage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtImage {
    fn default() -> &'a ArtImage {
        <ArtImage as ::protobuf::Message>::default_instance()
    }
}

impl ArtImage {
    pub fn new() -> ArtImage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elements",
            |m: &ArtImage| { &m.elements },
            |m: &mut ArtImage| { &mut m.elements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "id",
            |m: &ArtImage| { &m.id },
            |m: &mut ArtImage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &ArtImage| { &m.properties },
            |m: &mut ArtImage| { &mut m.properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtImage>(
            "ArtImage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtImage {
    const NAME: &'static str = "ArtImage";

    fn is_initialized(&self) -> bool {
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.elements.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                26 => {
                    self.properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.elements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.properties {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtImage {
        ArtImage::new()
    }

    fn clear(&mut self) {
        self.elements.clear();
        self.id.clear();
        self.properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtImage {
        static instance: ArtImage = ArtImage {
            elements: ::std::vec::Vec::new(),
            id: ::protobuf::MessageField::none(),
            properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtImage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtImage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtImage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Engraving)
pub struct Engraving {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.pos)
    pub pos: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.tile)
    pub tile: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.image)
    pub image: ::protobuf::MessageField<ArtImage>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.floor)
    pub floor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.west)
    pub west: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.east)
    pub east: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.north)
    pub north: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.south)
    pub south: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.northwest)
    pub northwest: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.northeast)
    pub northeast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.southwest)
    pub southwest: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Engraving.southeast)
    pub southeast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Engraving.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Engraving {
    fn default() -> &'a Engraving {
        <Engraving as ::protobuf::Message>::default_instance()
    }
}

impl Engraving {
    pub fn new() -> Engraving {
        ::std::default::Default::default()
    }

    // optional int32 quality = 2;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional int32 tile = 3;

    pub fn tile(&self) -> i32 {
        self.tile.unwrap_or(0)
    }

    pub fn clear_tile(&mut self) {
        self.tile = ::std::option::Option::None;
    }

    pub fn has_tile(&self) -> bool {
        self.tile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile(&mut self, v: i32) {
        self.tile = ::std::option::Option::Some(v);
    }

    // optional bool floor = 5;

    pub fn floor(&self) -> bool {
        self.floor.unwrap_or(false)
    }

    pub fn clear_floor(&mut self) {
        self.floor = ::std::option::Option::None;
    }

    pub fn has_floor(&self) -> bool {
        self.floor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_floor(&mut self, v: bool) {
        self.floor = ::std::option::Option::Some(v);
    }

    // optional bool west = 6;

    pub fn west(&self) -> bool {
        self.west.unwrap_or(false)
    }

    pub fn clear_west(&mut self) {
        self.west = ::std::option::Option::None;
    }

    pub fn has_west(&self) -> bool {
        self.west.is_some()
    }

    // Param is passed by value, moved
    pub fn set_west(&mut self, v: bool) {
        self.west = ::std::option::Option::Some(v);
    }

    // optional bool east = 7;

    pub fn east(&self) -> bool {
        self.east.unwrap_or(false)
    }

    pub fn clear_east(&mut self) {
        self.east = ::std::option::Option::None;
    }

    pub fn has_east(&self) -> bool {
        self.east.is_some()
    }

    // Param is passed by value, moved
    pub fn set_east(&mut self, v: bool) {
        self.east = ::std::option::Option::Some(v);
    }

    // optional bool north = 8;

    pub fn north(&self) -> bool {
        self.north.unwrap_or(false)
    }

    pub fn clear_north(&mut self) {
        self.north = ::std::option::Option::None;
    }

    pub fn has_north(&self) -> bool {
        self.north.is_some()
    }

    // Param is passed by value, moved
    pub fn set_north(&mut self, v: bool) {
        self.north = ::std::option::Option::Some(v);
    }

    // optional bool south = 9;

    pub fn south(&self) -> bool {
        self.south.unwrap_or(false)
    }

    pub fn clear_south(&mut self) {
        self.south = ::std::option::Option::None;
    }

    pub fn has_south(&self) -> bool {
        self.south.is_some()
    }

    // Param is passed by value, moved
    pub fn set_south(&mut self, v: bool) {
        self.south = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 10;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional bool northwest = 11;

    pub fn northwest(&self) -> bool {
        self.northwest.unwrap_or(false)
    }

    pub fn clear_northwest(&mut self) {
        self.northwest = ::std::option::Option::None;
    }

    pub fn has_northwest(&self) -> bool {
        self.northwest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_northwest(&mut self, v: bool) {
        self.northwest = ::std::option::Option::Some(v);
    }

    // optional bool northeast = 12;

    pub fn northeast(&self) -> bool {
        self.northeast.unwrap_or(false)
    }

    pub fn clear_northeast(&mut self) {
        self.northeast = ::std::option::Option::None;
    }

    pub fn has_northeast(&self) -> bool {
        self.northeast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_northeast(&mut self, v: bool) {
        self.northeast = ::std::option::Option::Some(v);
    }

    // optional bool southwest = 13;

    pub fn southwest(&self) -> bool {
        self.southwest.unwrap_or(false)
    }

    pub fn clear_southwest(&mut self) {
        self.southwest = ::std::option::Option::None;
    }

    pub fn has_southwest(&self) -> bool {
        self.southwest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_southwest(&mut self, v: bool) {
        self.southwest = ::std::option::Option::Some(v);
    }

    // optional bool southeast = 14;

    pub fn southeast(&self) -> bool {
        self.southeast.unwrap_or(false)
    }

    pub fn clear_southeast(&mut self) {
        self.southeast = ::std::option::Option::None;
    }

    pub fn has_southeast(&self) -> bool {
        self.southeast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_southeast(&mut self, v: bool) {
        self.southeast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "pos",
            |m: &Engraving| { &m.pos },
            |m: &mut Engraving| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &Engraving| { &m.quality },
            |m: &mut Engraving| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tile",
            |m: &Engraving| { &m.tile },
            |m: &mut Engraving| { &mut m.tile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArtImage>(
            "image",
            |m: &Engraving| { &m.image },
            |m: &mut Engraving| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "floor",
            |m: &Engraving| { &m.floor },
            |m: &mut Engraving| { &mut m.floor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "west",
            |m: &Engraving| { &m.west },
            |m: &mut Engraving| { &mut m.west },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "east",
            |m: &Engraving| { &m.east },
            |m: &mut Engraving| { &mut m.east },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "north",
            |m: &Engraving| { &m.north },
            |m: &mut Engraving| { &mut m.north },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "south",
            |m: &Engraving| { &m.south },
            |m: &mut Engraving| { &mut m.south },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &Engraving| { &m.hidden },
            |m: &mut Engraving| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "northwest",
            |m: &Engraving| { &m.northwest },
            |m: &mut Engraving| { &mut m.northwest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "northeast",
            |m: &Engraving| { &m.northeast },
            |m: &mut Engraving| { &mut m.northeast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "southwest",
            |m: &Engraving| { &m.southwest },
            |m: &mut Engraving| { &mut m.southwest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "southeast",
            |m: &Engraving| { &m.southeast },
            |m: &mut Engraving| { &mut m.southeast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Engraving>(
            "Engraving",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Engraving {
    const NAME: &'static str = "Engraving";

    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                16 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.tile = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                40 => {
                    self.floor = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.west = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.east = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.north = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.south = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.northwest = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.northeast = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.southwest = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.southeast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.tile {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.floor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.west {
            my_size += 1 + 1;
        }
        if let Some(v) = self.east {
            my_size += 1 + 1;
        }
        if let Some(v) = self.north {
            my_size += 1 + 1;
        }
        if let Some(v) = self.south {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.northwest {
            my_size += 1 + 1;
        }
        if let Some(v) = self.northeast {
            my_size += 1 + 1;
        }
        if let Some(v) = self.southwest {
            my_size += 1 + 1;
        }
        if let Some(v) = self.southeast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.tile {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.floor {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.west {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.east {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.north {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.south {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.northwest {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.northeast {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.southwest {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.southeast {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Engraving {
        Engraving::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.quality = ::std::option::Option::None;
        self.tile = ::std::option::Option::None;
        self.image.clear();
        self.floor = ::std::option::Option::None;
        self.west = ::std::option::Option::None;
        self.east = ::std::option::Option::None;
        self.north = ::std::option::Option::None;
        self.south = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.northwest = ::std::option::Option::None;
        self.northeast = ::std::option::Option::None;
        self.southwest = ::std::option::Option::None;
        self.southeast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Engraving {
        static instance: Engraving = Engraving {
            pos: ::protobuf::MessageField::none(),
            quality: ::std::option::Option::None,
            tile: ::std::option::Option::None,
            image: ::protobuf::MessageField::none(),
            floor: ::std::option::Option::None,
            west: ::std::option::Option::None,
            east: ::std::option::Option::None,
            north: ::std::option::Option::None,
            south: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            northwest: ::std::option::Option::None,
            northeast: ::std::option::Option::None,
            southwest: ::std::option::Option::None,
            southeast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Engraving {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Engraving").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Engraving {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Engraving {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.FlowInfo)
pub struct FlowInfo {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<FlowType>>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.density)
    pub density: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.pos)
    pub pos: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.dest)
    pub dest: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.expanding)
    pub expanding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.reuse)
    pub reuse: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.guide_id)
    pub guide_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.material)
    pub material: ::protobuf::MessageField<MatPair>,
    // @@protoc_insertion_point(field:RemoteFortressReader.FlowInfo.item)
    pub item: ::protobuf::MessageField<MatPair>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.FlowInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowInfo {
    fn default() -> &'a FlowInfo {
        <FlowInfo as ::protobuf::Message>::default_instance()
    }
}

impl FlowInfo {
    pub fn new() -> FlowInfo {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.FlowType type = 2;

    pub fn type_(&self) -> FlowType {
        match self.type_ {
            Some(e) => e.enum_value_or(FlowType::Miasma),
            None => FlowType::Miasma,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: FlowType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 density = 3;

    pub fn density(&self) -> i32 {
        self.density.unwrap_or(0)
    }

    pub fn clear_density(&mut self) {
        self.density = ::std::option::Option::None;
    }

    pub fn has_density(&self) -> bool {
        self.density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_density(&mut self, v: i32) {
        self.density = ::std::option::Option::Some(v);
    }

    // optional bool expanding = 6;

    pub fn expanding(&self) -> bool {
        self.expanding.unwrap_or(false)
    }

    pub fn clear_expanding(&mut self) {
        self.expanding = ::std::option::Option::None;
    }

    pub fn has_expanding(&self) -> bool {
        self.expanding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expanding(&mut self, v: bool) {
        self.expanding = ::std::option::Option::Some(v);
    }

    // optional bool reuse = 7;

    pub fn reuse(&self) -> bool {
        self.reuse.unwrap_or(false)
    }

    pub fn clear_reuse(&mut self) {
        self.reuse = ::std::option::Option::None;
    }

    pub fn has_reuse(&self) -> bool {
        self.reuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reuse(&mut self, v: bool) {
        self.reuse = ::std::option::Option::Some(v);
    }

    // optional int32 guide_id = 8;

    pub fn guide_id(&self) -> i32 {
        self.guide_id.unwrap_or(0)
    }

    pub fn clear_guide_id(&mut self) {
        self.guide_id = ::std::option::Option::None;
    }

    pub fn has_guide_id(&self) -> bool {
        self.guide_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guide_id(&mut self, v: i32) {
        self.guide_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &FlowInfo| { &m.index },
            |m: &mut FlowInfo| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FlowInfo| { &m.type_ },
            |m: &mut FlowInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "density",
            |m: &FlowInfo| { &m.density },
            |m: &mut FlowInfo| { &mut m.density },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "pos",
            |m: &FlowInfo| { &m.pos },
            |m: &mut FlowInfo| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "dest",
            |m: &FlowInfo| { &m.dest },
            |m: &mut FlowInfo| { &mut m.dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expanding",
            |m: &FlowInfo| { &m.expanding },
            |m: &mut FlowInfo| { &mut m.expanding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reuse",
            |m: &FlowInfo| { &m.reuse },
            |m: &mut FlowInfo| { &mut m.reuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guide_id",
            |m: &FlowInfo| { &m.guide_id },
            |m: &mut FlowInfo| { &mut m.guide_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "material",
            |m: &FlowInfo| { &m.material },
            |m: &mut FlowInfo| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatPair>(
            "item",
            |m: &FlowInfo| { &m.item },
            |m: &mut FlowInfo| { &mut m.item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowInfo>(
            "FlowInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowInfo {
    const NAME: &'static str = "FlowInfo";

    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.material {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.density = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dest)?;
                },
                48 => {
                    self.expanding = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.reuse = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.guide_id = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.density {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expanding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reuse {
            my_size += 1 + 1;
        }
        if let Some(v) = self.guide_id {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.material.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.density {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.dest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.expanding {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.reuse {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.guide_id {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.material.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowInfo {
        FlowInfo::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.density = ::std::option::Option::None;
        self.pos.clear();
        self.dest.clear();
        self.expanding = ::std::option::Option::None;
        self.reuse = ::std::option::Option::None;
        self.guide_id = ::std::option::Option::None;
        self.material.clear();
        self.item.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowInfo {
        static instance: FlowInfo = FlowInfo {
            index: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            density: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            dest: ::protobuf::MessageField::none(),
            expanding: ::std::option::Option::None,
            reuse: ::std::option::Option::None,
            guide_id: ::std::option::Option::None,
            material: ::protobuf::MessageField::none(),
            item: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoteFortressReader.Wave)
pub struct Wave {
    // message fields
    // @@protoc_insertion_point(field:RemoteFortressReader.Wave.dest)
    pub dest: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:RemoteFortressReader.Wave.pos)
    pub pos: ::protobuf::MessageField<Coord>,
    // special fields
    // @@protoc_insertion_point(special_field:RemoteFortressReader.Wave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Wave {
    fn default() -> &'a Wave {
        <Wave as ::protobuf::Message>::default_instance()
    }
}

impl Wave {
    pub fn new() -> Wave {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "dest",
            |m: &Wave| { &m.dest },
            |m: &mut Wave| { &mut m.dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "pos",
            |m: &Wave| { &m.pos },
            |m: &mut Wave| { &mut m.pos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Wave>(
            "Wave",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Wave {
    const NAME: &'static str = "Wave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dest)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Wave {
        Wave::new()
    }

    fn clear(&mut self) {
        self.dest.clear();
        self.pos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Wave {
        static instance: Wave = Wave {
            dest: ::protobuf::MessageField::none(),
            pos: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Wave {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Wave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Wave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Wave {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.TiletypeShape)
pub enum TiletypeShape {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.NO_SHAPE)
    NO_SHAPE = -1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.EMPTY)
    EMPTY = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.FLOOR)
    FLOOR = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.BOULDER)
    BOULDER = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.PEBBLES)
    PEBBLES = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.WALL)
    WALL = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.FORTIFICATION)
    FORTIFICATION = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.STAIR_UP)
    STAIR_UP = 6,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.STAIR_DOWN)
    STAIR_DOWN = 7,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.STAIR_UPDOWN)
    STAIR_UPDOWN = 8,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.RAMP)
    RAMP = 9,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.RAMP_TOP)
    RAMP_TOP = 10,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.BROOK_BED)
    BROOK_BED = 11,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.BROOK_TOP)
    BROOK_TOP = 12,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.TREE_SHAPE)
    TREE_SHAPE = 13,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.SAPLING)
    SAPLING = 14,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.SHRUB)
    SHRUB = 15,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.ENDLESS_PIT)
    ENDLESS_PIT = 16,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.BRANCH)
    BRANCH = 17,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.TRUNK_BRANCH)
    TRUNK_BRANCH = 18,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeShape.TWIG)
    TWIG = 19,
}

impl ::protobuf::Enum for TiletypeShape {
    const NAME: &'static str = "TiletypeShape";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeShape> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeShape::NO_SHAPE),
            0 => ::std::option::Option::Some(TiletypeShape::EMPTY),
            1 => ::std::option::Option::Some(TiletypeShape::FLOOR),
            2 => ::std::option::Option::Some(TiletypeShape::BOULDER),
            3 => ::std::option::Option::Some(TiletypeShape::PEBBLES),
            4 => ::std::option::Option::Some(TiletypeShape::WALL),
            5 => ::std::option::Option::Some(TiletypeShape::FORTIFICATION),
            6 => ::std::option::Option::Some(TiletypeShape::STAIR_UP),
            7 => ::std::option::Option::Some(TiletypeShape::STAIR_DOWN),
            8 => ::std::option::Option::Some(TiletypeShape::STAIR_UPDOWN),
            9 => ::std::option::Option::Some(TiletypeShape::RAMP),
            10 => ::std::option::Option::Some(TiletypeShape::RAMP_TOP),
            11 => ::std::option::Option::Some(TiletypeShape::BROOK_BED),
            12 => ::std::option::Option::Some(TiletypeShape::BROOK_TOP),
            13 => ::std::option::Option::Some(TiletypeShape::TREE_SHAPE),
            14 => ::std::option::Option::Some(TiletypeShape::SAPLING),
            15 => ::std::option::Option::Some(TiletypeShape::SHRUB),
            16 => ::std::option::Option::Some(TiletypeShape::ENDLESS_PIT),
            17 => ::std::option::Option::Some(TiletypeShape::BRANCH),
            18 => ::std::option::Option::Some(TiletypeShape::TRUNK_BRANCH),
            19 => ::std::option::Option::Some(TiletypeShape::TWIG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TiletypeShape] = &[
        TiletypeShape::NO_SHAPE,
        TiletypeShape::EMPTY,
        TiletypeShape::FLOOR,
        TiletypeShape::BOULDER,
        TiletypeShape::PEBBLES,
        TiletypeShape::WALL,
        TiletypeShape::FORTIFICATION,
        TiletypeShape::STAIR_UP,
        TiletypeShape::STAIR_DOWN,
        TiletypeShape::STAIR_UPDOWN,
        TiletypeShape::RAMP,
        TiletypeShape::RAMP_TOP,
        TiletypeShape::BROOK_BED,
        TiletypeShape::BROOK_TOP,
        TiletypeShape::TREE_SHAPE,
        TiletypeShape::SAPLING,
        TiletypeShape::SHRUB,
        TiletypeShape::ENDLESS_PIT,
        TiletypeShape::BRANCH,
        TiletypeShape::TRUNK_BRANCH,
        TiletypeShape::TWIG,
    ];
}

impl ::protobuf::EnumFull for TiletypeShape {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TiletypeShape").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TiletypeShape::NO_SHAPE => 0,
            TiletypeShape::EMPTY => 1,
            TiletypeShape::FLOOR => 2,
            TiletypeShape::BOULDER => 3,
            TiletypeShape::PEBBLES => 4,
            TiletypeShape::WALL => 5,
            TiletypeShape::FORTIFICATION => 6,
            TiletypeShape::STAIR_UP => 7,
            TiletypeShape::STAIR_DOWN => 8,
            TiletypeShape::STAIR_UPDOWN => 9,
            TiletypeShape::RAMP => 10,
            TiletypeShape::RAMP_TOP => 11,
            TiletypeShape::BROOK_BED => 12,
            TiletypeShape::BROOK_TOP => 13,
            TiletypeShape::TREE_SHAPE => 14,
            TiletypeShape::SAPLING => 15,
            TiletypeShape::SHRUB => 16,
            TiletypeShape::ENDLESS_PIT => 17,
            TiletypeShape::BRANCH => 18,
            TiletypeShape::TRUNK_BRANCH => 19,
            TiletypeShape::TWIG => 20,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeShape {
    fn default() -> Self {
        TiletypeShape::NO_SHAPE
    }
}

impl TiletypeShape {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TiletypeShape>("TiletypeShape")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.TiletypeSpecial)
pub enum TiletypeSpecial {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.NO_SPECIAL)
    NO_SPECIAL = -1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.NORMAL)
    NORMAL = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.RIVER_SOURCE)
    RIVER_SOURCE = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.WATERFALL)
    WATERFALL = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.SMOOTH)
    SMOOTH = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.FURROWED)
    FURROWED = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.WET)
    WET = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.DEAD)
    DEAD = 6,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.WORN_1)
    WORN_1 = 7,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.WORN_2)
    WORN_2 = 8,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.WORN_3)
    WORN_3 = 9,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.TRACK)
    TRACK = 10,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeSpecial.SMOOTH_DEAD)
    SMOOTH_DEAD = 11,
}

impl ::protobuf::Enum for TiletypeSpecial {
    const NAME: &'static str = "TiletypeSpecial";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeSpecial> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeSpecial::NO_SPECIAL),
            0 => ::std::option::Option::Some(TiletypeSpecial::NORMAL),
            1 => ::std::option::Option::Some(TiletypeSpecial::RIVER_SOURCE),
            2 => ::std::option::Option::Some(TiletypeSpecial::WATERFALL),
            3 => ::std::option::Option::Some(TiletypeSpecial::SMOOTH),
            4 => ::std::option::Option::Some(TiletypeSpecial::FURROWED),
            5 => ::std::option::Option::Some(TiletypeSpecial::WET),
            6 => ::std::option::Option::Some(TiletypeSpecial::DEAD),
            7 => ::std::option::Option::Some(TiletypeSpecial::WORN_1),
            8 => ::std::option::Option::Some(TiletypeSpecial::WORN_2),
            9 => ::std::option::Option::Some(TiletypeSpecial::WORN_3),
            10 => ::std::option::Option::Some(TiletypeSpecial::TRACK),
            11 => ::std::option::Option::Some(TiletypeSpecial::SMOOTH_DEAD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TiletypeSpecial] = &[
        TiletypeSpecial::NO_SPECIAL,
        TiletypeSpecial::NORMAL,
        TiletypeSpecial::RIVER_SOURCE,
        TiletypeSpecial::WATERFALL,
        TiletypeSpecial::SMOOTH,
        TiletypeSpecial::FURROWED,
        TiletypeSpecial::WET,
        TiletypeSpecial::DEAD,
        TiletypeSpecial::WORN_1,
        TiletypeSpecial::WORN_2,
        TiletypeSpecial::WORN_3,
        TiletypeSpecial::TRACK,
        TiletypeSpecial::SMOOTH_DEAD,
    ];
}

impl ::protobuf::EnumFull for TiletypeSpecial {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TiletypeSpecial").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TiletypeSpecial::NO_SPECIAL => 0,
            TiletypeSpecial::NORMAL => 1,
            TiletypeSpecial::RIVER_SOURCE => 2,
            TiletypeSpecial::WATERFALL => 3,
            TiletypeSpecial::SMOOTH => 4,
            TiletypeSpecial::FURROWED => 5,
            TiletypeSpecial::WET => 6,
            TiletypeSpecial::DEAD => 7,
            TiletypeSpecial::WORN_1 => 8,
            TiletypeSpecial::WORN_2 => 9,
            TiletypeSpecial::WORN_3 => 10,
            TiletypeSpecial::TRACK => 11,
            TiletypeSpecial::SMOOTH_DEAD => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeSpecial {
    fn default() -> Self {
        TiletypeSpecial::NO_SPECIAL
    }
}

impl TiletypeSpecial {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TiletypeSpecial>("TiletypeSpecial")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.TiletypeMaterial)
pub enum TiletypeMaterial {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.NO_MATERIAL)
    NO_MATERIAL = -1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.AIR)
    AIR = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.SOIL)
    SOIL = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.STONE)
    STONE = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.FEATURE)
    FEATURE = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.LAVA_STONE)
    LAVA_STONE = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.MINERAL)
    MINERAL = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.FROZEN_LIQUID)
    FROZEN_LIQUID = 6,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.CONSTRUCTION)
    CONSTRUCTION = 7,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.GRASS_LIGHT)
    GRASS_LIGHT = 8,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.GRASS_DARK)
    GRASS_DARK = 9,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.GRASS_DRY)
    GRASS_DRY = 10,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.GRASS_DEAD)
    GRASS_DEAD = 11,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.PLANT)
    PLANT = 12,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.HFS)
    HFS = 13,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.CAMPFIRE)
    CAMPFIRE = 14,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.FIRE)
    FIRE = 15,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.ASHES)
    ASHES = 16,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.MAGMA)
    MAGMA = 17,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.DRIFTWOOD)
    DRIFTWOOD = 18,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.POOL)
    POOL = 19,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.BROOK)
    BROOK = 20,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.RIVER)
    RIVER = 21,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.ROOT)
    ROOT = 22,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.TREE_MATERIAL)
    TREE_MATERIAL = 23,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.MUSHROOM)
    MUSHROOM = 24,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeMaterial.UNDERWORLD_GATE)
    UNDERWORLD_GATE = 25,
}

impl ::protobuf::Enum for TiletypeMaterial {
    const NAME: &'static str = "TiletypeMaterial";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeMaterial> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeMaterial::NO_MATERIAL),
            0 => ::std::option::Option::Some(TiletypeMaterial::AIR),
            1 => ::std::option::Option::Some(TiletypeMaterial::SOIL),
            2 => ::std::option::Option::Some(TiletypeMaterial::STONE),
            3 => ::std::option::Option::Some(TiletypeMaterial::FEATURE),
            4 => ::std::option::Option::Some(TiletypeMaterial::LAVA_STONE),
            5 => ::std::option::Option::Some(TiletypeMaterial::MINERAL),
            6 => ::std::option::Option::Some(TiletypeMaterial::FROZEN_LIQUID),
            7 => ::std::option::Option::Some(TiletypeMaterial::CONSTRUCTION),
            8 => ::std::option::Option::Some(TiletypeMaterial::GRASS_LIGHT),
            9 => ::std::option::Option::Some(TiletypeMaterial::GRASS_DARK),
            10 => ::std::option::Option::Some(TiletypeMaterial::GRASS_DRY),
            11 => ::std::option::Option::Some(TiletypeMaterial::GRASS_DEAD),
            12 => ::std::option::Option::Some(TiletypeMaterial::PLANT),
            13 => ::std::option::Option::Some(TiletypeMaterial::HFS),
            14 => ::std::option::Option::Some(TiletypeMaterial::CAMPFIRE),
            15 => ::std::option::Option::Some(TiletypeMaterial::FIRE),
            16 => ::std::option::Option::Some(TiletypeMaterial::ASHES),
            17 => ::std::option::Option::Some(TiletypeMaterial::MAGMA),
            18 => ::std::option::Option::Some(TiletypeMaterial::DRIFTWOOD),
            19 => ::std::option::Option::Some(TiletypeMaterial::POOL),
            20 => ::std::option::Option::Some(TiletypeMaterial::BROOK),
            21 => ::std::option::Option::Some(TiletypeMaterial::RIVER),
            22 => ::std::option::Option::Some(TiletypeMaterial::ROOT),
            23 => ::std::option::Option::Some(TiletypeMaterial::TREE_MATERIAL),
            24 => ::std::option::Option::Some(TiletypeMaterial::MUSHROOM),
            25 => ::std::option::Option::Some(TiletypeMaterial::UNDERWORLD_GATE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TiletypeMaterial] = &[
        TiletypeMaterial::NO_MATERIAL,
        TiletypeMaterial::AIR,
        TiletypeMaterial::SOIL,
        TiletypeMaterial::STONE,
        TiletypeMaterial::FEATURE,
        TiletypeMaterial::LAVA_STONE,
        TiletypeMaterial::MINERAL,
        TiletypeMaterial::FROZEN_LIQUID,
        TiletypeMaterial::CONSTRUCTION,
        TiletypeMaterial::GRASS_LIGHT,
        TiletypeMaterial::GRASS_DARK,
        TiletypeMaterial::GRASS_DRY,
        TiletypeMaterial::GRASS_DEAD,
        TiletypeMaterial::PLANT,
        TiletypeMaterial::HFS,
        TiletypeMaterial::CAMPFIRE,
        TiletypeMaterial::FIRE,
        TiletypeMaterial::ASHES,
        TiletypeMaterial::MAGMA,
        TiletypeMaterial::DRIFTWOOD,
        TiletypeMaterial::POOL,
        TiletypeMaterial::BROOK,
        TiletypeMaterial::RIVER,
        TiletypeMaterial::ROOT,
        TiletypeMaterial::TREE_MATERIAL,
        TiletypeMaterial::MUSHROOM,
        TiletypeMaterial::UNDERWORLD_GATE,
    ];
}

impl ::protobuf::EnumFull for TiletypeMaterial {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TiletypeMaterial").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TiletypeMaterial::NO_MATERIAL => 0,
            TiletypeMaterial::AIR => 1,
            TiletypeMaterial::SOIL => 2,
            TiletypeMaterial::STONE => 3,
            TiletypeMaterial::FEATURE => 4,
            TiletypeMaterial::LAVA_STONE => 5,
            TiletypeMaterial::MINERAL => 6,
            TiletypeMaterial::FROZEN_LIQUID => 7,
            TiletypeMaterial::CONSTRUCTION => 8,
            TiletypeMaterial::GRASS_LIGHT => 9,
            TiletypeMaterial::GRASS_DARK => 10,
            TiletypeMaterial::GRASS_DRY => 11,
            TiletypeMaterial::GRASS_DEAD => 12,
            TiletypeMaterial::PLANT => 13,
            TiletypeMaterial::HFS => 14,
            TiletypeMaterial::CAMPFIRE => 15,
            TiletypeMaterial::FIRE => 16,
            TiletypeMaterial::ASHES => 17,
            TiletypeMaterial::MAGMA => 18,
            TiletypeMaterial::DRIFTWOOD => 19,
            TiletypeMaterial::POOL => 20,
            TiletypeMaterial::BROOK => 21,
            TiletypeMaterial::RIVER => 22,
            TiletypeMaterial::ROOT => 23,
            TiletypeMaterial::TREE_MATERIAL => 24,
            TiletypeMaterial::MUSHROOM => 25,
            TiletypeMaterial::UNDERWORLD_GATE => 26,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeMaterial {
    fn default() -> Self {
        TiletypeMaterial::NO_MATERIAL
    }
}

impl TiletypeMaterial {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TiletypeMaterial>("TiletypeMaterial")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.TiletypeVariant)
pub enum TiletypeVariant {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeVariant.NO_VARIANT)
    NO_VARIANT = -1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeVariant.VAR_1)
    VAR_1 = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeVariant.VAR_2)
    VAR_2 = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeVariant.VAR_3)
    VAR_3 = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TiletypeVariant.VAR_4)
    VAR_4 = 3,
}

impl ::protobuf::Enum for TiletypeVariant {
    const NAME: &'static str = "TiletypeVariant";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TiletypeVariant> {
        match value {
            -1 => ::std::option::Option::Some(TiletypeVariant::NO_VARIANT),
            0 => ::std::option::Option::Some(TiletypeVariant::VAR_1),
            1 => ::std::option::Option::Some(TiletypeVariant::VAR_2),
            2 => ::std::option::Option::Some(TiletypeVariant::VAR_3),
            3 => ::std::option::Option::Some(TiletypeVariant::VAR_4),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TiletypeVariant] = &[
        TiletypeVariant::NO_VARIANT,
        TiletypeVariant::VAR_1,
        TiletypeVariant::VAR_2,
        TiletypeVariant::VAR_3,
        TiletypeVariant::VAR_4,
    ];
}

impl ::protobuf::EnumFull for TiletypeVariant {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TiletypeVariant").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TiletypeVariant::NO_VARIANT => 0,
            TiletypeVariant::VAR_1 => 1,
            TiletypeVariant::VAR_2 => 2,
            TiletypeVariant::VAR_3 => 3,
            TiletypeVariant::VAR_4 => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TiletypeVariant {
    fn default() -> Self {
        TiletypeVariant::NO_VARIANT
    }
}

impl TiletypeVariant {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TiletypeVariant>("TiletypeVariant")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.WorldPoles)
pub enum WorldPoles {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.WorldPoles.NO_POLES)
    NO_POLES = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.WorldPoles.NORTH_POLE)
    NORTH_POLE = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.WorldPoles.SOUTH_POLE)
    SOUTH_POLE = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.WorldPoles.BOTH_POLES)
    BOTH_POLES = 3,
}

impl ::protobuf::Enum for WorldPoles {
    const NAME: &'static str = "WorldPoles";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorldPoles> {
        match value {
            0 => ::std::option::Option::Some(WorldPoles::NO_POLES),
            1 => ::std::option::Option::Some(WorldPoles::NORTH_POLE),
            2 => ::std::option::Option::Some(WorldPoles::SOUTH_POLE),
            3 => ::std::option::Option::Some(WorldPoles::BOTH_POLES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WorldPoles] = &[
        WorldPoles::NO_POLES,
        WorldPoles::NORTH_POLE,
        WorldPoles::SOUTH_POLE,
        WorldPoles::BOTH_POLES,
    ];
}

impl ::protobuf::EnumFull for WorldPoles {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WorldPoles").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WorldPoles {
    fn default() -> Self {
        WorldPoles::NO_POLES
    }
}

impl WorldPoles {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WorldPoles>("WorldPoles")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.BuildingDirection)
pub enum BuildingDirection {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.BuildingDirection.NORTH)
    NORTH = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.BuildingDirection.EAST)
    EAST = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.BuildingDirection.SOUTH)
    SOUTH = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.BuildingDirection.WEST)
    WEST = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.BuildingDirection.NONE)
    NONE = 4,
}

impl ::protobuf::Enum for BuildingDirection {
    const NAME: &'static str = "BuildingDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuildingDirection> {
        match value {
            0 => ::std::option::Option::Some(BuildingDirection::NORTH),
            1 => ::std::option::Option::Some(BuildingDirection::EAST),
            2 => ::std::option::Option::Some(BuildingDirection::SOUTH),
            3 => ::std::option::Option::Some(BuildingDirection::WEST),
            4 => ::std::option::Option::Some(BuildingDirection::NONE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BuildingDirection] = &[
        BuildingDirection::NORTH,
        BuildingDirection::EAST,
        BuildingDirection::SOUTH,
        BuildingDirection::WEST,
        BuildingDirection::NONE,
    ];
}

impl ::protobuf::EnumFull for BuildingDirection {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BuildingDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BuildingDirection {
    fn default() -> Self {
        BuildingDirection::NORTH
    }
}

impl BuildingDirection {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BuildingDirection>("BuildingDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.TileDigDesignation)
pub enum TileDigDesignation {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.NO_DIG)
    NO_DIG = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.DEFAULT_DIG)
    DEFAULT_DIG = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.UP_DOWN_STAIR_DIG)
    UP_DOWN_STAIR_DIG = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.CHANNEL_DIG)
    CHANNEL_DIG = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.RAMP_DIG)
    RAMP_DIG = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.DOWN_STAIR_DIG)
    DOWN_STAIR_DIG = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.TileDigDesignation.UP_STAIR_DIG)
    UP_STAIR_DIG = 6,
}

impl ::protobuf::Enum for TileDigDesignation {
    const NAME: &'static str = "TileDigDesignation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TileDigDesignation> {
        match value {
            0 => ::std::option::Option::Some(TileDigDesignation::NO_DIG),
            1 => ::std::option::Option::Some(TileDigDesignation::DEFAULT_DIG),
            2 => ::std::option::Option::Some(TileDigDesignation::UP_DOWN_STAIR_DIG),
            3 => ::std::option::Option::Some(TileDigDesignation::CHANNEL_DIG),
            4 => ::std::option::Option::Some(TileDigDesignation::RAMP_DIG),
            5 => ::std::option::Option::Some(TileDigDesignation::DOWN_STAIR_DIG),
            6 => ::std::option::Option::Some(TileDigDesignation::UP_STAIR_DIG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TileDigDesignation] = &[
        TileDigDesignation::NO_DIG,
        TileDigDesignation::DEFAULT_DIG,
        TileDigDesignation::UP_DOWN_STAIR_DIG,
        TileDigDesignation::CHANNEL_DIG,
        TileDigDesignation::RAMP_DIG,
        TileDigDesignation::DOWN_STAIR_DIG,
        TileDigDesignation::UP_STAIR_DIG,
    ];
}

impl ::protobuf::EnumFull for TileDigDesignation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TileDigDesignation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TileDigDesignation {
    fn default() -> Self {
        TileDigDesignation::NO_DIG
    }
}

impl TileDigDesignation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TileDigDesignation>("TileDigDesignation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.HairStyle)
pub enum HairStyle {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.HairStyle.UNKEMPT)
    UNKEMPT = -1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.HairStyle.NEATLY_COMBED)
    NEATLY_COMBED = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.HairStyle.BRAIDED)
    BRAIDED = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.HairStyle.DOUBLE_BRAID)
    DOUBLE_BRAID = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.HairStyle.PONY_TAILS)
    PONY_TAILS = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.HairStyle.CLEAN_SHAVEN)
    CLEAN_SHAVEN = 4,
}

impl ::protobuf::Enum for HairStyle {
    const NAME: &'static str = "HairStyle";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HairStyle> {
        match value {
            -1 => ::std::option::Option::Some(HairStyle::UNKEMPT),
            0 => ::std::option::Option::Some(HairStyle::NEATLY_COMBED),
            1 => ::std::option::Option::Some(HairStyle::BRAIDED),
            2 => ::std::option::Option::Some(HairStyle::DOUBLE_BRAID),
            3 => ::std::option::Option::Some(HairStyle::PONY_TAILS),
            4 => ::std::option::Option::Some(HairStyle::CLEAN_SHAVEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [HairStyle] = &[
        HairStyle::UNKEMPT,
        HairStyle::NEATLY_COMBED,
        HairStyle::BRAIDED,
        HairStyle::DOUBLE_BRAID,
        HairStyle::PONY_TAILS,
        HairStyle::CLEAN_SHAVEN,
    ];
}

impl ::protobuf::EnumFull for HairStyle {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("HairStyle").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            HairStyle::UNKEMPT => 0,
            HairStyle::NEATLY_COMBED => 1,
            HairStyle::BRAIDED => 2,
            HairStyle::DOUBLE_BRAID => 3,
            HairStyle::PONY_TAILS => 4,
            HairStyle::CLEAN_SHAVEN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HairStyle {
    fn default() -> Self {
        HairStyle::UNKEMPT
    }
}

impl HairStyle {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HairStyle>("HairStyle")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.InventoryMode)
pub enum InventoryMode {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Hauled)
    Hauled = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Weapon)
    Weapon = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Worn)
    Worn = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Piercing)
    Piercing = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Flask)
    Flask = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.WrappedAround)
    WrappedAround = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.StuckIn)
    StuckIn = 6,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.InMouth)
    InMouth = 7,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Pet)
    Pet = 8,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.SewnInto)
    SewnInto = 9,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.InventoryMode.Strapped)
    Strapped = 10,
}

impl ::protobuf::Enum for InventoryMode {
    const NAME: &'static str = "InventoryMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InventoryMode> {
        match value {
            0 => ::std::option::Option::Some(InventoryMode::Hauled),
            1 => ::std::option::Option::Some(InventoryMode::Weapon),
            2 => ::std::option::Option::Some(InventoryMode::Worn),
            3 => ::std::option::Option::Some(InventoryMode::Piercing),
            4 => ::std::option::Option::Some(InventoryMode::Flask),
            5 => ::std::option::Option::Some(InventoryMode::WrappedAround),
            6 => ::std::option::Option::Some(InventoryMode::StuckIn),
            7 => ::std::option::Option::Some(InventoryMode::InMouth),
            8 => ::std::option::Option::Some(InventoryMode::Pet),
            9 => ::std::option::Option::Some(InventoryMode::SewnInto),
            10 => ::std::option::Option::Some(InventoryMode::Strapped),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InventoryMode] = &[
        InventoryMode::Hauled,
        InventoryMode::Weapon,
        InventoryMode::Worn,
        InventoryMode::Piercing,
        InventoryMode::Flask,
        InventoryMode::WrappedAround,
        InventoryMode::StuckIn,
        InventoryMode::InMouth,
        InventoryMode::Pet,
        InventoryMode::SewnInto,
        InventoryMode::Strapped,
    ];
}

impl ::protobuf::EnumFull for InventoryMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("InventoryMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for InventoryMode {
    fn default() -> Self {
        InventoryMode::Hauled
    }
}

impl InventoryMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InventoryMode>("InventoryMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.ArmorLayer)
pub enum ArmorLayer {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArmorLayer.LAYER_UNDER)
    LAYER_UNDER = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArmorLayer.LAYER_OVER)
    LAYER_OVER = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArmorLayer.LAYER_ARMOR)
    LAYER_ARMOR = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArmorLayer.LAYER_COVER)
    LAYER_COVER = 3,
}

impl ::protobuf::Enum for ArmorLayer {
    const NAME: &'static str = "ArmorLayer";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArmorLayer> {
        match value {
            0 => ::std::option::Option::Some(ArmorLayer::LAYER_UNDER),
            1 => ::std::option::Option::Some(ArmorLayer::LAYER_OVER),
            2 => ::std::option::Option::Some(ArmorLayer::LAYER_ARMOR),
            3 => ::std::option::Option::Some(ArmorLayer::LAYER_COVER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ArmorLayer] = &[
        ArmorLayer::LAYER_UNDER,
        ArmorLayer::LAYER_OVER,
        ArmorLayer::LAYER_ARMOR,
        ArmorLayer::LAYER_COVER,
    ];
}

impl ::protobuf::EnumFull for ArmorLayer {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ArmorLayer").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ArmorLayer {
    fn default() -> Self {
        ArmorLayer::LAYER_UNDER
    }
}

impl ArmorLayer {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArmorLayer>("ArmorLayer")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.MatterState)
pub enum MatterState {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.MatterState.Solid)
    Solid = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.MatterState.Liquid)
    Liquid = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.MatterState.Gas)
    Gas = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.MatterState.Powder)
    Powder = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.MatterState.Paste)
    Paste = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.MatterState.Pressed)
    Pressed = 5,
}

impl ::protobuf::Enum for MatterState {
    const NAME: &'static str = "MatterState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatterState> {
        match value {
            0 => ::std::option::Option::Some(MatterState::Solid),
            1 => ::std::option::Option::Some(MatterState::Liquid),
            2 => ::std::option::Option::Some(MatterState::Gas),
            3 => ::std::option::Option::Some(MatterState::Powder),
            4 => ::std::option::Option::Some(MatterState::Paste),
            5 => ::std::option::Option::Some(MatterState::Pressed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatterState] = &[
        MatterState::Solid,
        MatterState::Liquid,
        MatterState::Gas,
        MatterState::Powder,
        MatterState::Paste,
        MatterState::Pressed,
    ];
}

impl ::protobuf::EnumFull for MatterState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MatterState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MatterState {
    fn default() -> Self {
        MatterState::Solid
    }
}

impl MatterState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatterState>("MatterState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.FrontType)
pub enum FrontType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FrontType.FRONT_NONE)
    FRONT_NONE = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FrontType.FRONT_WARM)
    FRONT_WARM = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FrontType.FRONT_COLD)
    FRONT_COLD = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FrontType.FRONT_OCCLUDED)
    FRONT_OCCLUDED = 3,
}

impl ::protobuf::Enum for FrontType {
    const NAME: &'static str = "FrontType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FrontType> {
        match value {
            0 => ::std::option::Option::Some(FrontType::FRONT_NONE),
            1 => ::std::option::Option::Some(FrontType::FRONT_WARM),
            2 => ::std::option::Option::Some(FrontType::FRONT_COLD),
            3 => ::std::option::Option::Some(FrontType::FRONT_OCCLUDED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FrontType] = &[
        FrontType::FRONT_NONE,
        FrontType::FRONT_WARM,
        FrontType::FRONT_COLD,
        FrontType::FRONT_OCCLUDED,
    ];
}

impl ::protobuf::EnumFull for FrontType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FrontType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FrontType {
    fn default() -> Self {
        FrontType::FRONT_NONE
    }
}

impl FrontType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FrontType>("FrontType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.CumulusType)
pub enum CumulusType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.CumulusType.CUMULUS_NONE)
    CUMULUS_NONE = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.CumulusType.CUMULUS_MEDIUM)
    CUMULUS_MEDIUM = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.CumulusType.CUMULUS_MULTI)
    CUMULUS_MULTI = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.CumulusType.CUMULUS_NIMBUS)
    CUMULUS_NIMBUS = 3,
}

impl ::protobuf::Enum for CumulusType {
    const NAME: &'static str = "CumulusType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CumulusType> {
        match value {
            0 => ::std::option::Option::Some(CumulusType::CUMULUS_NONE),
            1 => ::std::option::Option::Some(CumulusType::CUMULUS_MEDIUM),
            2 => ::std::option::Option::Some(CumulusType::CUMULUS_MULTI),
            3 => ::std::option::Option::Some(CumulusType::CUMULUS_NIMBUS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CumulusType] = &[
        CumulusType::CUMULUS_NONE,
        CumulusType::CUMULUS_MEDIUM,
        CumulusType::CUMULUS_MULTI,
        CumulusType::CUMULUS_NIMBUS,
    ];
}

impl ::protobuf::EnumFull for CumulusType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CumulusType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CumulusType {
    fn default() -> Self {
        CumulusType::CUMULUS_NONE
    }
}

impl CumulusType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CumulusType>("CumulusType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.StratusType)
pub enum StratusType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.StratusType.STRATUS_NONE)
    STRATUS_NONE = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.StratusType.STRATUS_ALTO)
    STRATUS_ALTO = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.StratusType.STRATUS_PROPER)
    STRATUS_PROPER = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.StratusType.STRATUS_NIMBUS)
    STRATUS_NIMBUS = 3,
}

impl ::protobuf::Enum for StratusType {
    const NAME: &'static str = "StratusType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StratusType> {
        match value {
            0 => ::std::option::Option::Some(StratusType::STRATUS_NONE),
            1 => ::std::option::Option::Some(StratusType::STRATUS_ALTO),
            2 => ::std::option::Option::Some(StratusType::STRATUS_PROPER),
            3 => ::std::option::Option::Some(StratusType::STRATUS_NIMBUS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [StratusType] = &[
        StratusType::STRATUS_NONE,
        StratusType::STRATUS_ALTO,
        StratusType::STRATUS_PROPER,
        StratusType::STRATUS_NIMBUS,
    ];
}

impl ::protobuf::EnumFull for StratusType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("StratusType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for StratusType {
    fn default() -> Self {
        StratusType::STRATUS_NONE
    }
}

impl StratusType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StratusType>("StratusType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.FogType)
pub enum FogType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FogType.FOG_NONE)
    FOG_NONE = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FogType.FOG_MIST)
    FOG_MIST = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FogType.FOG_NORMAL)
    FOG_NORMAL = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FogType.F0G_THICK)
    F0G_THICK = 3,
}

impl ::protobuf::Enum for FogType {
    const NAME: &'static str = "FogType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FogType> {
        match value {
            0 => ::std::option::Option::Some(FogType::FOG_NONE),
            1 => ::std::option::Option::Some(FogType::FOG_MIST),
            2 => ::std::option::Option::Some(FogType::FOG_NORMAL),
            3 => ::std::option::Option::Some(FogType::F0G_THICK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FogType] = &[
        FogType::FOG_NONE,
        FogType::FOG_MIST,
        FogType::FOG_NORMAL,
        FogType::F0G_THICK,
    ];
}

impl ::protobuf::EnumFull for FogType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FogType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FogType {
    fn default() -> Self {
        FogType::FOG_NONE
    }
}

impl FogType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FogType>("FogType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.PatternType)
pub enum PatternType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.PatternType.MONOTONE)
    MONOTONE = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.PatternType.STRIPES)
    STRIPES = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.PatternType.IRIS_EYE)
    IRIS_EYE = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.PatternType.SPOTS)
    SPOTS = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.PatternType.PUPIL_EYE)
    PUPIL_EYE = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.PatternType.MOTTLED)
    MOTTLED = 5,
}

impl ::protobuf::Enum for PatternType {
    const NAME: &'static str = "PatternType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatternType> {
        match value {
            0 => ::std::option::Option::Some(PatternType::MONOTONE),
            1 => ::std::option::Option::Some(PatternType::STRIPES),
            2 => ::std::option::Option::Some(PatternType::IRIS_EYE),
            3 => ::std::option::Option::Some(PatternType::SPOTS),
            4 => ::std::option::Option::Some(PatternType::PUPIL_EYE),
            5 => ::std::option::Option::Some(PatternType::MOTTLED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PatternType] = &[
        PatternType::MONOTONE,
        PatternType::STRIPES,
        PatternType::IRIS_EYE,
        PatternType::SPOTS,
        PatternType::PUPIL_EYE,
        PatternType::MOTTLED,
    ];
}

impl ::protobuf::EnumFull for PatternType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PatternType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PatternType {
    fn default() -> Self {
        PatternType::MONOTONE
    }
}

impl PatternType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PatternType>("PatternType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.ArtImageElementType)
pub enum ArtImageElementType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageElementType.IMAGE_CREATURE)
    IMAGE_CREATURE = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageElementType.IMAGE_PLANT)
    IMAGE_PLANT = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageElementType.IMAGE_TREE)
    IMAGE_TREE = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageElementType.IMAGE_SHAPE)
    IMAGE_SHAPE = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageElementType.IMAGE_ITEM)
    IMAGE_ITEM = 4,
}

impl ::protobuf::Enum for ArtImageElementType {
    const NAME: &'static str = "ArtImageElementType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtImageElementType> {
        match value {
            0 => ::std::option::Option::Some(ArtImageElementType::IMAGE_CREATURE),
            1 => ::std::option::Option::Some(ArtImageElementType::IMAGE_PLANT),
            2 => ::std::option::Option::Some(ArtImageElementType::IMAGE_TREE),
            3 => ::std::option::Option::Some(ArtImageElementType::IMAGE_SHAPE),
            4 => ::std::option::Option::Some(ArtImageElementType::IMAGE_ITEM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ArtImageElementType] = &[
        ArtImageElementType::IMAGE_CREATURE,
        ArtImageElementType::IMAGE_PLANT,
        ArtImageElementType::IMAGE_TREE,
        ArtImageElementType::IMAGE_SHAPE,
        ArtImageElementType::IMAGE_ITEM,
    ];
}

impl ::protobuf::EnumFull for ArtImageElementType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ArtImageElementType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ArtImageElementType {
    fn default() -> Self {
        ArtImageElementType::IMAGE_CREATURE
    }
}

impl ArtImageElementType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArtImageElementType>("ArtImageElementType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.ArtImagePropertyType)
pub enum ArtImagePropertyType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImagePropertyType.TRANSITIVE_VERB)
    TRANSITIVE_VERB = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImagePropertyType.INTRANSITIVE_VERB)
    INTRANSITIVE_VERB = 1,
}

impl ::protobuf::Enum for ArtImagePropertyType {
    const NAME: &'static str = "ArtImagePropertyType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtImagePropertyType> {
        match value {
            0 => ::std::option::Option::Some(ArtImagePropertyType::TRANSITIVE_VERB),
            1 => ::std::option::Option::Some(ArtImagePropertyType::INTRANSITIVE_VERB),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ArtImagePropertyType] = &[
        ArtImagePropertyType::TRANSITIVE_VERB,
        ArtImagePropertyType::INTRANSITIVE_VERB,
    ];
}

impl ::protobuf::EnumFull for ArtImagePropertyType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ArtImagePropertyType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ArtImagePropertyType {
    fn default() -> Self {
        ArtImagePropertyType::TRANSITIVE_VERB
    }
}

impl ArtImagePropertyType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArtImagePropertyType>("ArtImagePropertyType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.ArtImageVerb)
pub enum ArtImageVerb {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_WITHERING)
    VERB_WITHERING = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SURROUNDEDBY)
    VERB_SURROUNDEDBY = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_MASSACRING)
    VERB_MASSACRING = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_FIGHTING)
    VERB_FIGHTING = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_LABORING)
    VERB_LABORING = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_GREETING)
    VERB_GREETING = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_REFUSING)
    VERB_REFUSING = 6,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SPEAKING)
    VERB_SPEAKING = 7,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_EMBRACING)
    VERB_EMBRACING = 8,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_STRIKINGDOWN)
    VERB_STRIKINGDOWN = 9,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_MENACINGPOSE)
    VERB_MENACINGPOSE = 10,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_TRAVELING)
    VERB_TRAVELING = 11,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_RAISING)
    VERB_RAISING = 12,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_HIDING)
    VERB_HIDING = 13,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_LOOKINGCONFUSED)
    VERB_LOOKINGCONFUSED = 14,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_LOOKINGTERRIFIED)
    VERB_LOOKINGTERRIFIED = 15,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_DEVOURING)
    VERB_DEVOURING = 16,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_ADMIRING)
    VERB_ADMIRING = 17,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_BURNING)
    VERB_BURNING = 18,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_WEEPING)
    VERB_WEEPING = 19,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_LOOKINGDEJECTED)
    VERB_LOOKINGDEJECTED = 20,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_CRINGING)
    VERB_CRINGING = 21,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SCREAMING)
    VERB_SCREAMING = 22,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SUBMISSIVEGESTURE)
    VERB_SUBMISSIVEGESTURE = 23,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_FETALPOSITION)
    VERB_FETALPOSITION = 24,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SMEAREDINTOSPIRAL)
    VERB_SMEAREDINTOSPIRAL = 25,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_FALLING)
    VERB_FALLING = 26,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_DEAD)
    VERB_DEAD = 27,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_LAUGHING)
    VERB_LAUGHING = 28,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_LOOKINGOFFENDED)
    VERB_LOOKINGOFFENDED = 29,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_BEINGSHOT)
    VERB_BEINGSHOT = 30,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_PLAINTIVEGESTURE)
    VERB_PLAINTIVEGESTURE = 31,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_MELTING)
    VERB_MELTING = 32,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SHOOTING)
    VERB_SHOOTING = 33,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_TORTURING)
    VERB_TORTURING = 34,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_COMMITTINGDEPRAVEDACT)
    VERB_COMMITTINGDEPRAVEDACT = 35,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_PRAYING)
    VERB_PRAYING = 36,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_CONTEMPLATING)
    VERB_CONTEMPLATING = 37,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_COOKING)
    VERB_COOKING = 38,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_ENGRAVING)
    VERB_ENGRAVING = 39,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_PROSTRATING)
    VERB_PROSTRATING = 40,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_SUFFERING)
    VERB_SUFFERING = 41,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_BEINGIMPALED)
    VERB_BEINGIMPALED = 42,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_BEINGCONTORTED)
    VERB_BEINGCONTORTED = 43,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_BEINGFLAYED)
    VERB_BEINGFLAYED = 44,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_HANGINGFROM)
    VERB_HANGINGFROM = 45,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_BEINGMUTILATED)
    VERB_BEINGMUTILATED = 46,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.ArtImageVerb.VERB_TRIUMPHANTPOSE)
    VERB_TRIUMPHANTPOSE = 47,
}

impl ::protobuf::Enum for ArtImageVerb {
    const NAME: &'static str = "ArtImageVerb";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArtImageVerb> {
        match value {
            0 => ::std::option::Option::Some(ArtImageVerb::VERB_WITHERING),
            1 => ::std::option::Option::Some(ArtImageVerb::VERB_SURROUNDEDBY),
            2 => ::std::option::Option::Some(ArtImageVerb::VERB_MASSACRING),
            3 => ::std::option::Option::Some(ArtImageVerb::VERB_FIGHTING),
            4 => ::std::option::Option::Some(ArtImageVerb::VERB_LABORING),
            5 => ::std::option::Option::Some(ArtImageVerb::VERB_GREETING),
            6 => ::std::option::Option::Some(ArtImageVerb::VERB_REFUSING),
            7 => ::std::option::Option::Some(ArtImageVerb::VERB_SPEAKING),
            8 => ::std::option::Option::Some(ArtImageVerb::VERB_EMBRACING),
            9 => ::std::option::Option::Some(ArtImageVerb::VERB_STRIKINGDOWN),
            10 => ::std::option::Option::Some(ArtImageVerb::VERB_MENACINGPOSE),
            11 => ::std::option::Option::Some(ArtImageVerb::VERB_TRAVELING),
            12 => ::std::option::Option::Some(ArtImageVerb::VERB_RAISING),
            13 => ::std::option::Option::Some(ArtImageVerb::VERB_HIDING),
            14 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGCONFUSED),
            15 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGTERRIFIED),
            16 => ::std::option::Option::Some(ArtImageVerb::VERB_DEVOURING),
            17 => ::std::option::Option::Some(ArtImageVerb::VERB_ADMIRING),
            18 => ::std::option::Option::Some(ArtImageVerb::VERB_BURNING),
            19 => ::std::option::Option::Some(ArtImageVerb::VERB_WEEPING),
            20 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGDEJECTED),
            21 => ::std::option::Option::Some(ArtImageVerb::VERB_CRINGING),
            22 => ::std::option::Option::Some(ArtImageVerb::VERB_SCREAMING),
            23 => ::std::option::Option::Some(ArtImageVerb::VERB_SUBMISSIVEGESTURE),
            24 => ::std::option::Option::Some(ArtImageVerb::VERB_FETALPOSITION),
            25 => ::std::option::Option::Some(ArtImageVerb::VERB_SMEAREDINTOSPIRAL),
            26 => ::std::option::Option::Some(ArtImageVerb::VERB_FALLING),
            27 => ::std::option::Option::Some(ArtImageVerb::VERB_DEAD),
            28 => ::std::option::Option::Some(ArtImageVerb::VERB_LAUGHING),
            29 => ::std::option::Option::Some(ArtImageVerb::VERB_LOOKINGOFFENDED),
            30 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGSHOT),
            31 => ::std::option::Option::Some(ArtImageVerb::VERB_PLAINTIVEGESTURE),
            32 => ::std::option::Option::Some(ArtImageVerb::VERB_MELTING),
            33 => ::std::option::Option::Some(ArtImageVerb::VERB_SHOOTING),
            34 => ::std::option::Option::Some(ArtImageVerb::VERB_TORTURING),
            35 => ::std::option::Option::Some(ArtImageVerb::VERB_COMMITTINGDEPRAVEDACT),
            36 => ::std::option::Option::Some(ArtImageVerb::VERB_PRAYING),
            37 => ::std::option::Option::Some(ArtImageVerb::VERB_CONTEMPLATING),
            38 => ::std::option::Option::Some(ArtImageVerb::VERB_COOKING),
            39 => ::std::option::Option::Some(ArtImageVerb::VERB_ENGRAVING),
            40 => ::std::option::Option::Some(ArtImageVerb::VERB_PROSTRATING),
            41 => ::std::option::Option::Some(ArtImageVerb::VERB_SUFFERING),
            42 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGIMPALED),
            43 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGCONTORTED),
            44 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGFLAYED),
            45 => ::std::option::Option::Some(ArtImageVerb::VERB_HANGINGFROM),
            46 => ::std::option::Option::Some(ArtImageVerb::VERB_BEINGMUTILATED),
            47 => ::std::option::Option::Some(ArtImageVerb::VERB_TRIUMPHANTPOSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ArtImageVerb] = &[
        ArtImageVerb::VERB_WITHERING,
        ArtImageVerb::VERB_SURROUNDEDBY,
        ArtImageVerb::VERB_MASSACRING,
        ArtImageVerb::VERB_FIGHTING,
        ArtImageVerb::VERB_LABORING,
        ArtImageVerb::VERB_GREETING,
        ArtImageVerb::VERB_REFUSING,
        ArtImageVerb::VERB_SPEAKING,
        ArtImageVerb::VERB_EMBRACING,
        ArtImageVerb::VERB_STRIKINGDOWN,
        ArtImageVerb::VERB_MENACINGPOSE,
        ArtImageVerb::VERB_TRAVELING,
        ArtImageVerb::VERB_RAISING,
        ArtImageVerb::VERB_HIDING,
        ArtImageVerb::VERB_LOOKINGCONFUSED,
        ArtImageVerb::VERB_LOOKINGTERRIFIED,
        ArtImageVerb::VERB_DEVOURING,
        ArtImageVerb::VERB_ADMIRING,
        ArtImageVerb::VERB_BURNING,
        ArtImageVerb::VERB_WEEPING,
        ArtImageVerb::VERB_LOOKINGDEJECTED,
        ArtImageVerb::VERB_CRINGING,
        ArtImageVerb::VERB_SCREAMING,
        ArtImageVerb::VERB_SUBMISSIVEGESTURE,
        ArtImageVerb::VERB_FETALPOSITION,
        ArtImageVerb::VERB_SMEAREDINTOSPIRAL,
        ArtImageVerb::VERB_FALLING,
        ArtImageVerb::VERB_DEAD,
        ArtImageVerb::VERB_LAUGHING,
        ArtImageVerb::VERB_LOOKINGOFFENDED,
        ArtImageVerb::VERB_BEINGSHOT,
        ArtImageVerb::VERB_PLAINTIVEGESTURE,
        ArtImageVerb::VERB_MELTING,
        ArtImageVerb::VERB_SHOOTING,
        ArtImageVerb::VERB_TORTURING,
        ArtImageVerb::VERB_COMMITTINGDEPRAVEDACT,
        ArtImageVerb::VERB_PRAYING,
        ArtImageVerb::VERB_CONTEMPLATING,
        ArtImageVerb::VERB_COOKING,
        ArtImageVerb::VERB_ENGRAVING,
        ArtImageVerb::VERB_PROSTRATING,
        ArtImageVerb::VERB_SUFFERING,
        ArtImageVerb::VERB_BEINGIMPALED,
        ArtImageVerb::VERB_BEINGCONTORTED,
        ArtImageVerb::VERB_BEINGFLAYED,
        ArtImageVerb::VERB_HANGINGFROM,
        ArtImageVerb::VERB_BEINGMUTILATED,
        ArtImageVerb::VERB_TRIUMPHANTPOSE,
    ];
}

impl ::protobuf::EnumFull for ArtImageVerb {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ArtImageVerb").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ArtImageVerb {
    fn default() -> Self {
        ArtImageVerb::VERB_WITHERING
    }
}

impl ArtImageVerb {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArtImageVerb>("ArtImageVerb")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RemoteFortressReader.FlowType)
pub enum FlowType {
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Miasma)
    Miasma = 0,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Steam)
    Steam = 1,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Mist)
    Mist = 2,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.MaterialDust)
    MaterialDust = 3,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.MagmaMist)
    MagmaMist = 4,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Smoke)
    Smoke = 5,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Dragonfire)
    Dragonfire = 6,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Fire)
    Fire = 7,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.Web)
    Web = 8,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.MaterialGas)
    MaterialGas = 9,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.MaterialVapor)
    MaterialVapor = 10,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.OceanWave)
    OceanWave = 11,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.SeaFoam)
    SeaFoam = 12,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.ItemCloud)
    ItemCloud = 13,
    // @@protoc_insertion_point(enum_value:RemoteFortressReader.FlowType.CampFire)
    CampFire = -1,
}

impl ::protobuf::Enum for FlowType {
    const NAME: &'static str = "FlowType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowType> {
        match value {
            0 => ::std::option::Option::Some(FlowType::Miasma),
            1 => ::std::option::Option::Some(FlowType::Steam),
            2 => ::std::option::Option::Some(FlowType::Mist),
            3 => ::std::option::Option::Some(FlowType::MaterialDust),
            4 => ::std::option::Option::Some(FlowType::MagmaMist),
            5 => ::std::option::Option::Some(FlowType::Smoke),
            6 => ::std::option::Option::Some(FlowType::Dragonfire),
            7 => ::std::option::Option::Some(FlowType::Fire),
            8 => ::std::option::Option::Some(FlowType::Web),
            9 => ::std::option::Option::Some(FlowType::MaterialGas),
            10 => ::std::option::Option::Some(FlowType::MaterialVapor),
            11 => ::std::option::Option::Some(FlowType::OceanWave),
            12 => ::std::option::Option::Some(FlowType::SeaFoam),
            13 => ::std::option::Option::Some(FlowType::ItemCloud),
            -1 => ::std::option::Option::Some(FlowType::CampFire),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FlowType] = &[
        FlowType::Miasma,
        FlowType::Steam,
        FlowType::Mist,
        FlowType::MaterialDust,
        FlowType::MagmaMist,
        FlowType::Smoke,
        FlowType::Dragonfire,
        FlowType::Fire,
        FlowType::Web,
        FlowType::MaterialGas,
        FlowType::MaterialVapor,
        FlowType::OceanWave,
        FlowType::SeaFoam,
        FlowType::ItemCloud,
        FlowType::CampFire,
    ];
}

impl ::protobuf::EnumFull for FlowType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FlowType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FlowType::Miasma => 0,
            FlowType::Steam => 1,
            FlowType::Mist => 2,
            FlowType::MaterialDust => 3,
            FlowType::MagmaMist => 4,
            FlowType::Smoke => 5,
            FlowType::Dragonfire => 6,
            FlowType::Fire => 7,
            FlowType::Web => 8,
            FlowType::MaterialGas => 9,
            FlowType::MaterialVapor => 10,
            FlowType::OceanWave => 11,
            FlowType::SeaFoam => 12,
            FlowType::ItemCloud => 13,
            FlowType::CampFire => 14,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FlowType {
    fn default() -> Self {
        FlowType::Miasma
    }
}

impl FlowType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FlowType>("FlowType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1aRemoteFortressReader.proto\x12\x14RemoteFortressReader\x1a\x17Item\
    defInstrument.proto\"1\n\x05Coord\x12\x0c\n\x01x\x18\x01\x20\x01(\x05R\
    \x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\x12\x0c\n\x01z\x18\x03\
    \x20\x01(\x05R\x01z\"\xe7\x02\n\x08Tiletype\x12\x0e\n\x02id\x18\x01\x20\
    \x02(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x18\n\
    \x07caption\x18\x03\x20\x01(\tR\x07caption\x129\n\x05shape\x18\x04\x20\
    \x01(\x0e2#.RemoteFortressReader.TiletypeShapeR\x05shape\x12?\n\x07speci\
    al\x18\x05\x20\x01(\x0e2%.RemoteFortressReader.TiletypeSpecialR\x07speci\
    al\x12B\n\x08material\x18\x06\x20\x01(\x0e2&.RemoteFortressReader.Tilety\
    peMaterialR\x08material\x12?\n\x07variant\x18\x07\x20\x01(\x0e2%.RemoteF\
    ortressReader.TiletypeVariantR\x07variant\x12\x1c\n\tdirection\x18\x08\
    \x20\x01(\tR\tdirection\"S\n\x0cTiletypeList\x12C\n\rtiletype_list\x18\
    \x01\x20\x03(\x0b2\x1e.RemoteFortressReader.TiletypeR\x0ctiletypeList\"\
    \x83\x01\n\x0fBuildingExtents\x12\x13\n\x05pos_x\x18\x01\x20\x02(\x05R\
    \x04posX\x12\x13\n\x05pos_y\x18\x02\x20\x02(\x05R\x04posY\x12\x14\n\x05w\
    idth\x18\x03\x20\x02(\x05R\x05width\x12\x16\n\x06height\x18\x04\x20\x02(\
    \x05R\x06height\x12\x18\n\x07extents\x18\x05\x20\x03(\x05R\x07extents\"R\
    \n\x0cBuildingItem\x12.\n\x04item\x18\x01\x20\x01(\x0b2\x1a.RemoteFortre\
    ssReader.ItemR\x04item\x12\x12\n\x04mode\x18\x02\x20\x01(\x05R\x04mode\"\
    \xe8\x04\n\x10BuildingInstance\x12\x14\n\x05index\x18\x01\x20\x02(\x05R\
    \x05index\x12\x1a\n\tpos_x_min\x18\x02\x20\x01(\x05R\x07posXMin\x12\x1a\
    \n\tpos_y_min\x18\x03\x20\x01(\x05R\x07posYMin\x12\x1a\n\tpos_z_min\x18\
    \x04\x20\x01(\x05R\x07posZMin\x12\x1a\n\tpos_x_max\x18\x05\x20\x01(\x05R\
    \x07posXMax\x12\x1a\n\tpos_y_max\x18\x06\x20\x01(\x05R\x07posYMax\x12\
    \x1a\n\tpos_z_max\x18\x07\x20\x01(\x05R\x07posZMax\x12G\n\rbuilding_type\
    \x18\x08\x20\x01(\x0b2\".RemoteFortressReader.BuildingTypeR\x0cbuildingT\
    ype\x129\n\x08material\x18\t\x20\x01(\x0b2\x1d.RemoteFortressReader.MatP\
    airR\x08material\x12%\n\x0ebuilding_flags\x18\n\x20\x01(\rR\rbuildingFla\
    gs\x12\x17\n\x07is_room\x18\x0b\x20\x01(\x08R\x06isRoom\x129\n\x04room\
    \x18\x0c\x20\x01(\x0b2%.RemoteFortressReader.BuildingExtentsR\x04room\
    \x12E\n\tdirection\x18\r\x20\x01(\x0e2'.RemoteFortressReader.BuildingDir\
    ectionR\tdirection\x128\n\x05items\x18\x0e\x20\x03(\x0b2\".RemoteFortres\
    sReader.BuildingItemR\x05items\x12\x16\n\x06active\x18\x0f\x20\x01(\x05R\
    \x06active\"s\n\tRiverEdge\x12\x17\n\x07min_pos\x18\x01\x20\x01(\x05R\
    \x06minPos\x12\x17\n\x07max_pos\x18\x02\x20\x01(\x05R\x06maxPos\x12\x16\
    \n\x06active\x18\x03\x20\x01(\x05R\x06active\x12\x1c\n\televation\x18\
    \x04\x20\x01(\x05R\televation\"\xe3\x01\n\tRiverTile\x125\n\x05north\x18\
    \x01\x20\x01(\x0b2\x1f.RemoteFortressReader.RiverEdgeR\x05north\x125\n\
    \x05south\x18\x02\x20\x01(\x0b2\x1f.RemoteFortressReader.RiverEdgeR\x05s\
    outh\x123\n\x04east\x18\x03\x20\x01(\x0b2\x1f.RemoteFortressReader.River\
    EdgeR\x04east\x123\n\x04west\x18\x04\x20\x01(\x0b2\x1f.RemoteFortressRea\
    der.RiverEdgeR\x04west\"\xc8\x01\n\x07Spatter\x129\n\x08material\x18\x01\
    \x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08material\x12\x16\n\
    \x06amount\x18\x02\x20\x01(\x05R\x06amount\x127\n\x05state\x18\x03\x20\
    \x01(\x0e2!.RemoteFortressReader.MatterStateR\x05state\x121\n\x04item\
    \x18\x04\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x04item\"H\n\
    \x0bSpatterPile\x129\n\x08spatters\x18\x01\x20\x03(\x0b2\x1d.RemoteFortr\
    essReader.SpatterR\x08spatters\"\xa2\x05\n\x04Item\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x05R\x02id\x12-\n\x03pos\x18\x02\x20\x01(\x0b2\x1b.RemoteF\
    ortressReader.CoordR\x03pos\x12\x16\n\x06flags1\x18\x03\x20\x01(\rR\x06f\
    lags1\x12\x16\n\x06flags2\x18\x04\x20\x01(\rR\x06flags2\x121\n\x04type\
    \x18\x05\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x04type\x129\n\
    \x08material\x18\x06\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08\
    material\x127\n\x03dye\x18\x07\x20\x01(\x0b2%.RemoteFortressReader.Color\
    DefinitionR\x03dye\x12\x1d\n\nstack_size\x18\x08\x20\x01(\x05R\tstackSiz\
    e\x12\x19\n\x08subpos_x\x18\t\x20\x01(\x02R\x07subposX\x12\x19\n\x08subp\
    os_y\x18\n\x20\x01(\x02R\x07subposY\x12\x19\n\x08subpos_z\x18\x0b\x20\
    \x01(\x02R\x07subposZ\x12\x1e\n\nprojectile\x18\x0c\x20\x01(\x08R\nproje\
    ctile\x12\x1d\n\nvelocity_x\x18\r\x20\x01(\x02R\tvelocityX\x12\x1d\n\nve\
    locity_y\x18\x0e\x20\x01(\x02R\tvelocityY\x12\x1d\n\nvelocity_z\x18\x0f\
    \x20\x01(\x02R\tvelocityZ\x12\x16\n\x06volume\x18\x10\x20\x01(\x05R\x06v\
    olume\x12I\n\x0cimprovements\x18\x11\x20\x03(\x0b2%.RemoteFortressReader\
    .ItemImprovementR\x0cimprovements\x124\n\x05image\x18\x12\x20\x01(\x0b2\
    \x1e.RemoteFortressReader.ArtImageR\x05image\"\xbf\x02\n\tPlantTile\x12\
    \x14\n\x05trunk\x18\x01\x20\x01(\x08R\x05trunk\x12'\n\x0fconnection_east\
    \x18\x02\x20\x01(\x08R\x0econnectionEast\x12)\n\x10connection_south\x18\
    \x03\x20\x01(\x08R\x0fconnectionSouth\x12'\n\x0fconnection_west\x18\x04\
    \x20\x01(\x08R\x0econnectionWest\x12)\n\x10connection_north\x18\x05\x20\
    \x01(\x08R\x0fconnectionNorth\x12\x1a\n\x08branches\x18\x06\x20\x01(\x08\
    R\x08branches\x12\x14\n\x05twigs\x18\x07\x20\x01(\x08R\x05twigs\x12B\n\t\
    tile_type\x18\x08\x20\x01(\x0e2%.RemoteFortressReader.TiletypeSpecialR\
    \x08tileType\"r\n\x08TreeInfo\x12/\n\x04size\x18\x01\x20\x01(\x0b2\x1b.R\
    emoteFortressReader.CoordR\x04size\x125\n\x05tiles\x18\x02\x20\x03(\x0b2\
    \x1f.RemoteFortressReader.PlantTileR\x05tiles\"\x9a\x01\n\rPlantInstance\
    \x12\x1d\n\nplant_type\x18\x01\x20\x01(\x05R\tplantType\x12-\n\x03pos\
    \x18\x02\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03pos\x12;\n\ttr\
    ee_info\x18\x03\x20\x01(\x0b2\x1e.RemoteFortressReader.TreeInfoR\x08tree\
    Info\"\x8c\n\n\x08MapBlock\x12\x13\n\x05map_x\x18\x01\x20\x02(\x05R\x04m\
    apX\x12\x13\n\x05map_y\x18\x02\x20\x02(\x05R\x04mapY\x12\x13\n\x05map_z\
    \x18\x03\x20\x02(\x05R\x04mapZ\x12\x14\n\x05tiles\x18\x04\x20\x03(\x05R\
    \x05tiles\x12;\n\tmaterials\x18\x05\x20\x03(\x0b2\x1d.RemoteFortressRead\
    er.MatPairR\tmaterials\x12F\n\x0flayer_materials\x18\x06\x20\x03(\x0b2\
    \x1d.RemoteFortressReader.MatPairR\x0elayerMaterials\x12D\n\x0evein_mate\
    rials\x18\x07\x20\x03(\x0b2\x1d.RemoteFortressReader.MatPairR\rveinMater\
    ials\x12D\n\x0ebase_materials\x18\x08\x20\x03(\x0b2\x1d.RemoteFortressRe\
    ader.MatPairR\rbaseMaterials\x12\x14\n\x05magma\x18\t\x20\x03(\x05R\x05m\
    agma\x12\x14\n\x05water\x18\n\x20\x03(\x05R\x05water\x12\x16\n\x06hidden\
    \x18\x0b\x20\x03(\x08R\x06hidden\x12\x14\n\x05light\x18\x0c\x20\x03(\x08\
    R\x05light\x12\"\n\x0csubterranean\x18\r\x20\x03(\x08R\x0csubterranean\
    \x12\x18\n\x07outside\x18\x0e\x20\x03(\x08R\x07outside\x12\x18\n\x07aqui\
    fer\x18\x0f\x20\x03(\x08R\x07aquifer\x12%\n\x0ewater_stagnant\x18\x10\
    \x20\x03(\x08R\rwaterStagnant\x12\x1d\n\nwater_salt\x18\x11\x20\x03(\x08\
    R\twaterSalt\x12L\n\x12construction_items\x18\x12\x20\x03(\x0b2\x1d.Remo\
    teFortressReader.MatPairR\x11constructionItems\x12D\n\tbuildings\x18\x13\
    \x20\x03(\x0b2&.RemoteFortressReader.BuildingInstanceR\tbuildings\x12!\n\
    \x0ctree_percent\x18\x14\x20\x03(\x05R\x0btreePercent\x12\x15\n\x06tree_\
    x\x18\x15\x20\x03(\x05R\x05treeX\x12\x15\n\x06tree_y\x18\x16\x20\x03(\
    \x05R\x05treeY\x12\x15\n\x06tree_z\x18\x17\x20\x03(\x05R\x05treeZ\x12Z\n\
    \x14tile_dig_designation\x18\x18\x20\x03(\x0e2(.RemoteFortressReader.Til\
    eDigDesignationR\x12tileDigDesignation\x12C\n\x0bspatterPile\x18\x19\x20\
    \x03(\x0b2!.RemoteFortressReader.SpatterPileR\x0bspatterPile\x120\n\x05i\
    tems\x18\x1a\x20\x03(\x0b2\x1a.RemoteFortressReader.ItemR\x05items\x12=\
    \n\x1btile_dig_designation_marker\x18\x1b\x20\x03(\x08R\x18tileDigDesign\
    ationMarker\x129\n\x19tile_dig_designation_auto\x18\x1c\x20\x03(\x08R\
    \x16tileDigDesignationAuto\x12#\n\rgrass_percent\x18\x1d\x20\x03(\x05R\
    \x0cgrassPercent\x124\n\x05flows\x18\x1e\x20\x03(\x0b2\x1e.RemoteFortres\
    sReader.FlowInfoR\x05flows\"A\n\x07MatPair\x12\x19\n\x08mat_type\x18\x01\
    \x20\x02(\x05R\x07matType\x12\x1b\n\tmat_index\x18\x02\x20\x02(\x05R\x08\
    matIndex\"M\n\x0fColorDefinition\x12\x10\n\x03red\x18\x01\x20\x02(\x05R\
    \x03red\x12\x14\n\x05green\x18\x02\x20\x02(\x05R\x05green\x12\x12\n\x04b\
    lue\x18\x03\x20\x02(\x05R\x04blue\"\xea\x02\n\x12MaterialDefinition\x128\
    \n\x08mat_pair\x18\x01\x20\x02(\x0b2\x1d.RemoteFortressReader.MatPairR\
    \x07matPair\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x12\n\x04name\
    \x18\x03\x20\x01(\x0cR\x04name\x12F\n\x0bstate_color\x18\x04\x20\x01(\
    \x0b2%.RemoteFortressReader.ColorDefinitionR\nstateColor\x12@\n\ninstrum\
    ent\x18\x05\x20\x01(\x0b2\x20.ItemdefInstrument.InstrumentDefR\ninstrume\
    nt\x12\x17\n\x07up_step\x18\x06\x20\x01(\x05R\x06upStep\x12\x1b\n\tdown_\
    step\x18\x07\x20\x01(\x05R\x08downStep\x126\n\x05layer\x18\x08\x20\x01(\
    \x0e2\x20.RemoteFortressReader.ArmorLayerR\x05layer\"\x87\x01\n\x0cBuild\
    ingType\x12#\n\rbuilding_type\x18\x01\x20\x02(\x05R\x0cbuildingType\x12)\
    \n\x10building_subtype\x18\x02\x20\x02(\x05R\x0fbuildingSubtype\x12'\n\
    \x0fbuilding_custom\x18\x03\x20\x02(\x05R\x0ebuildingCustom\"\x81\x01\n\
    \x12BuildingDefinition\x12G\n\rbuilding_type\x18\x01\x20\x02(\x0b2\".Rem\
    oteFortressReader.BuildingTypeR\x0cbuildingType\x12\x0e\n\x02id\x18\x02\
    \x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"]\n\
    \x0cBuildingList\x12M\n\rbuilding_list\x18\x01\x20\x03(\x0b2(.RemoteFort\
    ressReader.BuildingDefinitionR\x0cbuildingList\"]\n\x0cMaterialList\x12M\
    \n\rmaterial_list\x18\x01\x20\x03(\x0b2(.RemoteFortressReader.MaterialDe\
    finitionR\x0cmaterialList\"U\n\x04Hair\x12\x16\n\x06length\x18\x01\x20\
    \x01(\x05R\x06length\x125\n\x05style\x18\x02\x20\x01(\x0e2\x1f.RemoteFor\
    tressReader.HairStyleR\x05style\"\xbe\x01\n\x0cBodySizeInfo\x12\x19\n\
    \x08size_cur\x18\x01\x20\x01(\x05R\x07sizeCur\x12\x1b\n\tsize_base\x18\
    \x02\x20\x01(\x05R\x08sizeBase\x12\x19\n\x08area_cur\x18\x03\x20\x01(\
    \x05R\x07areaCur\x12\x1b\n\tarea_base\x18\x04\x20\x01(\x05R\x08areaBase\
    \x12\x1d\n\nlength_cur\x18\x05\x20\x01(\x05R\tlengthCur\x12\x1f\n\x0blen\
    gth_base\x18\x06\x20\x01(\x05R\nlengthBase\"\xa0\x03\n\x0eUnitAppearance\
    \x12%\n\x0ebody_modifiers\x18\x01\x20\x03(\x05R\rbodyModifiers\x12!\n\
    \x0cbp_modifiers\x18\x02\x20\x03(\x05R\x0bbpModifiers\x12#\n\rsize_modif\
    ier\x18\x03\x20\x01(\x05R\x0csizeModifier\x12\x16\n\x06colors\x18\x04\
    \x20\x03(\x05R\x06colors\x12.\n\x04hair\x18\x05\x20\x01(\x0b2\x1a.Remote\
    FortressReader.HairR\x04hair\x120\n\x05beard\x18\x06\x20\x01(\x0b2\x1a.R\
    emoteFortressReader.HairR\x05beard\x128\n\tmoustache\x18\x07\x20\x01(\
    \x0b2\x1a.RemoteFortressReader.HairR\tmoustache\x128\n\tsideburns\x18\
    \x08\x20\x01(\x0b2\x1a.RemoteFortressReader.HairR\tsideburns\x121\n\x14p\
    hysical_description\x18\t\x20\x01(\tR\x13physicalDescription\"\x9a\x01\n\
    \rInventoryItem\x127\n\x04mode\x18\x01\x20\x01(\x0e2#.RemoteFortressRead\
    er.InventoryModeR\x04mode\x12.\n\x04item\x18\x02\x20\x01(\x0b2\x1a.Remot\
    eFortressReader.ItemR\x04item\x12\x20\n\x0cbody_part_id\x18\x03\x20\x01(\
    \x05R\nbodyPartId\"t\n\tWoundPart\x12(\n\x10global_layer_idx\x18\x01\x20\
    \x01(\x05R\x0eglobalLayerIdx\x12\x20\n\x0cbody_part_id\x18\x02\x20\x01(\
    \x05R\nbodyPartId\x12\x1b\n\tlayer_idx\x18\x03\x20\x01(\x05R\x08layerIdx\
    \"e\n\tUnitWound\x125\n\x05parts\x18\x01\x20\x03(\x0b2\x1f.RemoteFortres\
    sReader.WoundPartR\x05parts\x12!\n\x0csevered_part\x18\x02\x20\x01(\x08R\
    \x0bseveredPart\"\xbb\x07\n\x0eUnitDefinition\x12\x0e\n\x02id\x18\x01\
    \x20\x02(\x05R\x02id\x12\x18\n\x07isValid\x18\x02\x20\x01(\x08R\x07isVal\
    id\x12\x13\n\x05pos_x\x18\x03\x20\x01(\x05R\x04posX\x12\x13\n\x05pos_y\
    \x18\x04\x20\x01(\x05R\x04posY\x12\x13\n\x05pos_z\x18\x05\x20\x01(\x05R\
    \x04posZ\x121\n\x04race\x18\x06\x20\x01(\x0b2\x1d.RemoteFortressReader.M\
    atPairR\x04race\x12P\n\x10profession_color\x18\x07\x20\x01(\x0b2%.Remote\
    FortressReader.ColorDefinitionR\x0fprofessionColor\x12\x16\n\x06flags1\
    \x18\x08\x20\x01(\rR\x06flags1\x12\x16\n\x06flags2\x18\t\x20\x01(\rR\x06\
    flags2\x12\x16\n\x06flags3\x18\n\x20\x01(\rR\x06flags3\x12\x1d\n\nis_sol\
    dier\x18\x0b\x20\x01(\x08R\tisSoldier\x12?\n\tsize_info\x18\x0c\x20\x01(\
    \x0b2\".RemoteFortressReader.BodySizeInfoR\x08sizeInfo\x12\x12\n\x04name\
    \x18\r\x20\x01(\tR\x04name\x12\x1b\n\tblood_max\x18\x0e\x20\x01(\x05R\
    \x08bloodMax\x12\x1f\n\x0bblood_count\x18\x0f\x20\x01(\x05R\nbloodCount\
    \x12D\n\nappearance\x18\x10\x20\x01(\x0b2$.RemoteFortressReader.UnitAppe\
    aranceR\nappearance\x12#\n\rprofession_id\x18\x11\x20\x01(\x05R\x0cprofe\
    ssionId\x12'\n\x0fnoble_positions\x18\x12\x20\x03(\tR\x0enoblePositions\
    \x12\x19\n\x08rider_id\x18\x13\x20\x01(\x05R\x07riderId\x12A\n\tinventor\
    y\x18\x14\x20\x03(\x0b2#.RemoteFortressReader.InventoryItemR\tinventory\
    \x12\x19\n\x08subpos_x\x18\x15\x20\x01(\x02R\x07subposX\x12\x19\n\x08sub\
    pos_y\x18\x16\x20\x01(\x02R\x07subposY\x12\x19\n\x08subpos_z\x18\x17\x20\
    \x01(\x02R\x07subposZ\x123\n\x06facing\x18\x18\x20\x01(\x0b2\x1b.RemoteF\
    ortressReader.CoordR\x06facing\x12\x10\n\x03age\x18\x19\x20\x01(\x05R\
    \x03age\x127\n\x06wounds\x18\x1a\x20\x03(\x0b2\x1f.RemoteFortressReader.\
    UnitWoundR\x06wounds\"U\n\x08UnitList\x12I\n\rcreature_list\x18\x01\x20\
    \x03(\x0b2$.RemoteFortressReader.UnitDefinitionR\x0ccreatureList\"\xb1\
    \x01\n\x0cBlockRequest\x12#\n\rblocks_needed\x18\x01\x20\x01(\x05R\x0cbl\
    ocksNeeded\x12\x13\n\x05min_x\x18\x02\x20\x01(\x05R\x04minX\x12\x13\n\
    \x05max_x\x18\x03\x20\x01(\x05R\x04maxX\x12\x13\n\x05min_y\x18\x04\x20\
    \x01(\x05R\x04minY\x12\x13\n\x05max_y\x18\x05\x20\x01(\x05R\x04maxY\x12\
    \x13\n\x05min_z\x18\x06\x20\x01(\x05R\x04minZ\x12\x13\n\x05max_z\x18\x07\
    \x20\x01(\x05R\x04maxZ\"\xf2\x01\n\tBlockList\x12=\n\nmap_blocks\x18\x01\
    \x20\x03(\x0b2\x1e.RemoteFortressReader.MapBlockR\tmapBlocks\x12\x13\n\
    \x05map_x\x18\x02\x20\x01(\x05R\x04mapX\x12\x13\n\x05map_y\x18\x03\x20\
    \x01(\x05R\x04mapY\x12?\n\nengravings\x18\x04\x20\x03(\x0b2\x1f.RemoteFo\
    rtressReader.EngravingR\nengravings\x12;\n\x0bocean_waves\x18\x05\x20\
    \x03(\x0b2\x1a.RemoteFortressReader.WaveR\noceanWaves\"_\n\x08PlantDef\
    \x12\x13\n\x05pos_x\x18\x01\x20\x02(\x05R\x04posX\x12\x13\n\x05pos_y\x18\
    \x02\x20\x02(\x05R\x04posY\x12\x13\n\x05pos_z\x18\x03\x20\x02(\x05R\x04p\
    osZ\x12\x14\n\x05index\x18\x04\x20\x02(\x05R\x05index\"J\n\tPlantList\
    \x12=\n\nplant_list\x18\x01\x20\x03(\x0b2\x1e.RemoteFortressReader.Plant\
    DefR\tplantList\"\xe2\x02\n\x08ViewInfo\x12\x1c\n\nview_pos_x\x18\x01\
    \x20\x01(\x05R\x08viewPosX\x12\x1c\n\nview_pos_y\x18\x02\x20\x01(\x05R\
    \x08viewPosY\x12\x1c\n\nview_pos_z\x18\x03\x20\x01(\x05R\x08viewPosZ\x12\
    \x1e\n\x0bview_size_x\x18\x04\x20\x01(\x05R\tviewSizeX\x12\x1e\n\x0bview\
    _size_y\x18\x05\x20\x01(\x05R\tviewSizeY\x12\x20\n\x0ccursor_pos_x\x18\
    \x06\x20\x01(\x05R\ncursorPosX\x12\x20\n\x0ccursor_pos_y\x18\x07\x20\x01\
    (\x05R\ncursorPosY\x12\x20\n\x0ccursor_pos_z\x18\x08\x20\x01(\x05R\ncurs\
    orPosZ\x12*\n\x0efollow_unit_id\x18\t\x20\x01(\x05:\x02-1R\x0cfollowUnit\
    IdB\0\x12*\n\x0efollow_item_id\x18\n\x20\x01(\x05:\x02-1R\x0cfollowItemI\
    dB\0\"\xb9\x02\n\x07MapInfo\x12\x20\n\x0cblock_size_x\x18\x01\x20\x01(\
    \x05R\nblockSizeX\x12\x20\n\x0cblock_size_y\x18\x02\x20\x01(\x05R\nblock\
    SizeY\x12\x20\n\x0cblock_size_z\x18\x03\x20\x01(\x05R\nblockSizeZ\x12\
    \x1e\n\x0bblock_pos_x\x18\x04\x20\x01(\x05R\tblockPosX\x12\x1e\n\x0bbloc\
    k_pos_y\x18\x05\x20\x01(\x05R\tblockPosY\x12\x1e\n\x0bblock_pos_z\x18\
    \x06\x20\x01(\x05R\tblockPosZ\x12\x1d\n\nworld_name\x18\x07\x20\x01(\tR\
    \tworldName\x12,\n\x12world_name_english\x18\x08\x20\x01(\tR\x10worldNam\
    eEnglish\x12\x1b\n\tsave_name\x18\t\x20\x01(\tR\x08saveName\"\x81\x02\n\
    \x05Cloud\x125\n\x05front\x18\x01\x20\x01(\x0e2\x1f.RemoteFortressReader\
    .FrontTypeR\x05front\x12;\n\x07cumulus\x18\x02\x20\x01(\x0e2!.RemoteFort\
    ressReader.CumulusTypeR\x07cumulus\x12\x16\n\x06cirrus\x18\x03\x20\x01(\
    \x08R\x06cirrus\x12;\n\x07stratus\x18\x04\x20\x01(\x0e2!.RemoteFortressR\
    eader.StratusTypeR\x07stratus\x12/\n\x03fog\x18\x05\x20\x01(\x0e2\x1d.Re\
    moteFortressReader.FogTypeR\x03fog\"\xf1\x06\n\x08WorldMap\x12\x1f\n\x0b\
    world_width\x18\x01\x20\x02(\x05R\nworldWidth\x12!\n\x0cworld_height\x18\
    \x02\x20\x02(\x05R\x0bworldHeight\x12\x12\n\x04name\x18\x03\x20\x01(\x0c\
    R\x04name\x12!\n\x0cname_english\x18\x04\x20\x01(\tR\x0bnameEnglish\x12\
    \x1c\n\televation\x18\x05\x20\x03(\x05R\televation\x12\x1a\n\x08rainfall\
    \x18\x06\x20\x03(\x05R\x08rainfall\x12\x1e\n\nvegetation\x18\x07\x20\x03\
    (\x05R\nvegetation\x12\x20\n\x0btemperature\x18\x08\x20\x03(\x05R\x0btem\
    perature\x12\x1a\n\x08evilness\x18\t\x20\x03(\x05R\x08evilness\x12\x1a\n\
    \x08drainage\x18\n\x20\x03(\x05R\x08drainage\x12\x1c\n\tvolcanism\x18\
    \x0b\x20\x03(\x05R\tvolcanism\x12\x1a\n\x08savagery\x18\x0c\x20\x03(\x05\
    R\x08savagery\x123\n\x06clouds\x18\r\x20\x03(\x0b2\x1b.RemoteFortressRea\
    der.CloudR\x06clouds\x12\x1a\n\x08salinity\x18\x0e\x20\x03(\x05R\x08sali\
    nity\x12\x13\n\x05map_x\x18\x0f\x20\x01(\x05R\x04mapX\x12\x13\n\x05map_y\
    \x18\x10\x20\x01(\x05R\x04mapY\x12\x19\n\x08center_x\x18\x11\x20\x01(\
    \x05R\x07centerX\x12\x19\n\x08center_y\x18\x12\x20\x01(\x05R\x07centerY\
    \x12\x19\n\x08center_z\x18\x13\x20\x01(\x05R\x07centerZ\x12\x19\n\x08cur\
    _year\x18\x14\x20\x01(\x05R\x07curYear\x12\"\n\rcur_year_tick\x18\x15\
    \x20\x01(\x05R\x0bcurYearTick\x12A\n\x0bworld_poles\x18\x16\x20\x01(\x0e\
    2\x20.RemoteFortressReader.WorldPolesR\nworldPoles\x12@\n\x0briver_tiles\
    \x18\x17\x20\x03(\x0b2\x1f.RemoteFortressReader.RiverTileR\nriverTiles\
    \x12'\n\x0fwater_elevation\x18\x18\x20\x03(\x05R\x0ewaterElevation\x12C\
    \n\x0cregion_tiles\x18\x19\x20\x03(\x0b2\x20.RemoteFortressReader.Region\
    TileR\x0bregionTiles\"\xa7\x01\n\x1bSiteRealizationBuildingWall\x12\x17\
    \n\x07start_x\x18\x01\x20\x01(\x05R\x06startX\x12\x17\n\x07start_y\x18\
    \x02\x20\x01(\x05R\x06startY\x12\x17\n\x07start_z\x18\x03\x20\x01(\x05R\
    \x06startZ\x12\x13\n\x05end_x\x18\x04\x20\x01(\x05R\x04endX\x12\x13\n\
    \x05end_y\x18\x05\x20\x01(\x05R\x04endY\x12\x13\n\x05end_z\x18\x06\x20\
    \x01(\x05R\x04endZ\"c\n\x1cSiteRealizationBuildingTower\x12\x15\n\x06roo\
    f_z\x18\x01\x20\x01(\x05R\x05roofZ\x12\x14\n\x05round\x18\x02\x20\x01(\
    \x08R\x05round\x12\x16\n\x06goblin\x18\x03\x20\x01(\x08R\x06goblin\"\x8d\
    \x01\n\x0bTrenchSpoke\x12\x1f\n\x0bmound_start\x18\x01\x20\x01(\x05R\nmo\
    undStart\x12!\n\x0ctrench_start\x18\x02\x20\x01(\x05R\x0btrenchStart\x12\
    \x1d\n\ntrench_end\x18\x03\x20\x01(\x05R\ttrenchEnd\x12\x1b\n\tmound_end\
    \x18\x04\x20\x01(\x05R\x08moundEnd\"\\\n\x1fSiteRealizationBuildingTrenc\
    hes\x129\n\x06spokes\x18\x01\x20\x03(\x0b2!.RemoteFortressReader.TrenchS\
    pokeR\x06spokes\"\xc7\x03\n\x17SiteRealizationBuilding\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x13\n\x05min_x\x18\x03\x20\x01(\x05R\
    \x04minX\x12\x13\n\x05min_y\x18\x04\x20\x01(\x05R\x04minY\x12\x13\n\x05m\
    ax_x\x18\x05\x20\x01(\x05R\x04maxX\x12\x13\n\x05max_y\x18\x06\x20\x01(\
    \x05R\x04maxY\x129\n\x08material\x18\x07\x20\x01(\x0b2\x1d.RemoteFortres\
    sReader.MatPairR\x08material\x12N\n\twall_info\x18\x08\x20\x01(\x0b21.Re\
    moteFortressReader.SiteRealizationBuildingWallR\x08wallInfo\x12Q\n\ntowe\
    r_info\x18\t\x20\x01(\x0b22.RemoteFortressReader.SiteRealizationBuilding\
    TowerR\ttowerInfo\x12V\n\x0btrench_info\x18\n\x20\x01(\x0b25.RemoteFortr\
    essReader.SiteRealizationBuildingTrenchesR\ntrenchInfo\x12\x12\n\x04type\
    \x18\x0b\x20\x01(\x05R\x04type\"\x82\x06\n\nRegionTile\x12\x1c\n\televat\
    ion\x18\x01\x20\x01(\x05R\televation\x12\x1a\n\x08rainfall\x18\x02\x20\
    \x01(\x05R\x08rainfall\x12\x1e\n\nvegetation\x18\x03\x20\x01(\x05R\nvege\
    tation\x12\x20\n\x0btemperature\x18\x04\x20\x01(\x05R\x0btemperature\x12\
    \x1a\n\x08evilness\x18\x05\x20\x01(\x05R\x08evilness\x12\x1a\n\x08draina\
    ge\x18\x06\x20\x01(\x05R\x08drainage\x12\x1c\n\tvolcanism\x18\x07\x20\
    \x01(\x05R\tvolcanism\x12\x1a\n\x08savagery\x18\x08\x20\x01(\x05R\x08sav\
    agery\x12\x1a\n\x08salinity\x18\t\x20\x01(\x05R\x08salinity\x12@\n\x0bri\
    ver_tiles\x18\n\x20\x01(\x0b2\x1f.RemoteFortressReader.RiverTileR\nriver\
    Tiles\x12'\n\x0fwater_elevation\x18\x0b\x20\x01(\x05R\x0ewaterElevation\
    \x12H\n\x10surface_material\x18\x0c\x20\x01(\x0b2\x1d.RemoteFortressRead\
    er.MatPairR\x0fsurfaceMaterial\x12F\n\x0fplant_materials\x18\r\x20\x03(\
    \x0b2\x1d.RemoteFortressReader.MatPairR\x0eplantMaterials\x12K\n\tbuildi\
    ngs\x18\x0e\x20\x03(\x0b2-.RemoteFortressReader.SiteRealizationBuildingR\
    \tbuildings\x12F\n\x0fstone_materials\x18\x0f\x20\x03(\x0b2\x1d.RemoteFo\
    rtressReader.MatPairR\x0estoneMaterials\x12D\n\x0etree_materials\x18\x10\
    \x20\x03(\x0b2\x1d.RemoteFortressReader.MatPairR\rtreeMaterials\x12\x12\
    \n\x04snow\x18\x11\x20\x01(\x05R\x04snow\"\xa4\x01\n\tRegionMap\x12\x13\
    \n\x05map_x\x18\x01\x20\x01(\x05R\x04mapX\x12\x13\n\x05map_y\x18\x02\x20\
    \x01(\x05R\x04mapY\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12!\n\
    \x0cname_english\x18\x04\x20\x01(\tR\x0bnameEnglish\x126\n\x05tiles\x18\
    \x05\x20\x03(\x0b2\x20.RemoteFortressReader.RegionTileR\x05tiles\"\x8d\
    \x01\n\nRegionMaps\x12=\n\nworld_maps\x18\x01\x20\x03(\x0b2\x1e.RemoteFo\
    rtressReader.WorldMapR\tworldMaps\x12@\n\x0bregion_maps\x18\x02\x20\x03(\
    \x0b2\x1f.RemoteFortressReader.RegionMapR\nregionMaps\"\x9f\x01\n\x11Pat\
    ternDescriptor\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12=\n\x06color\
    s\x18\x02\x20\x03(\x0b2%.RemoteFortressReader.ColorDefinitionR\x06colors\
    \x12;\n\x07pattern\x18\x03\x20\x01(\x0e2!.RemoteFortressReader.PatternTy\
    peR\x07pattern\"\xef\x01\n\x10ColorModifierRaw\x12C\n\x08patterns\x18\
    \x01\x20\x03(\x0b2'.RemoteFortressReader.PatternDescriptorR\x08patterns\
    \x12\x20\n\x0cbody_part_id\x18\x02\x20\x03(\x05R\nbodyPartId\x12&\n\x0ft\
    issue_layer_id\x18\x03\x20\x03(\x05R\rtissueLayerId\x12\x1d\n\nstart_dat\
    e\x18\x04\x20\x01(\x05R\tstartDate\x12\x19\n\x08end_date\x18\x05\x20\x01\
    (\x05R\x07endDate\x12\x12\n\x04part\x18\x06\x20\x01(\tR\x04part\"\x92\
    \x01\n\x10BodyPartLayerRaw\x12\x1d\n\nlayer_name\x18\x01\x20\x01(\tR\tla\
    yerName\x12\x1b\n\ttissue_id\x18\x02\x20\x01(\x05R\x08tissueId\x12\x1f\n\
    \x0blayer_depth\x18\x03\x20\x01(\x05R\nlayerDepth\x12!\n\x0cbp_modifiers\
    \x18\x04\x20\x03(\x05R\x0bbpModifiers\"\xc7\x01\n\x0bBodyPartRaw\x12\x14\
    \n\x05token\x18\x01\x20\x01(\tR\x05token\x12\x1a\n\x08category\x18\x02\
    \x20\x01(\tR\x08category\x12\x16\n\x06parent\x18\x03\x20\x01(\x05R\x06pa\
    rent\x12\x14\n\x05flags\x18\x04\x20\x03(\x08R\x05flags\x12>\n\x06layers\
    \x18\x05\x20\x03(\x0b2&.RemoteFortressReader.BodyPartLayerRawR\x06layers\
    \x12\x18\n\x07relsize\x18\x06\x20\x01(\x05R\x07relsize\"\\\n\x14BpAppear\
    anceModifier\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x17\n\x07\
    mod_min\x18\x02\x20\x01(\x05R\x06modMin\x12\x17\n\x07mod_max\x18\x03\x20\
    \x01(\x05R\x06modMax\"\x9e\x01\n\tTissueRaw\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x129\n\x08m\
    aterial\x18\x03\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08mater\
    ial\x122\n\x15subordinate_to_tissue\x18\x04\x20\x01(\tR\x13subordinateTo\
    Tissue\"\xb4\x05\n\x08CasteRaw\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\
    \x05index\x12\x19\n\x08caste_id\x18\x02\x20\x01(\tR\x07casteId\x12\x1d\n\
    \ncaste_name\x18\x03\x20\x03(\tR\tcasteName\x12\x1b\n\tbaby_name\x18\x04\
    \x20\x03(\tR\x08babyName\x12\x1d\n\nchild_name\x18\x05\x20\x03(\tR\tchil\
    dName\x12\x16\n\x06gender\x18\x06\x20\x01(\x05R\x06gender\x12@\n\nbody_p\
    arts\x18\x07\x20\x03(\x0b2!.RemoteFortressReader.BodyPartRawR\tbodyParts\
    \x12#\n\rtotal_relsize\x18\x08\x20\x01(\x05R\x0ctotalRelsize\x12H\n\tmod\
    ifiers\x18\t\x20\x03(\x0b2*.RemoteFortressReader.BpAppearanceModifierR\t\
    modifiers\x12!\n\x0cmodifier_idx\x18\n\x20\x03(\x05R\x0bmodifierIdx\x12\
    \x19\n\x08part_idx\x18\x0b\x20\x03(\x05R\x07partIdx\x12\x1b\n\tlayer_idx\
    \x18\x0c\x20\x03(\x05R\x08layerIdx\x12f\n\x19body_appearance_modifiers\
    \x18\r\x20\x03(\x0b2*.RemoteFortressReader.BpAppearanceModifierR\x17body\
    AppearanceModifiers\x12O\n\x0fcolor_modifiers\x18\x0e\x20\x03(\x0b2&.Rem\
    oteFortressReader.ColorModifierRawR\x0ecolorModifiers\x12\x20\n\x0bdescr\
    iption\x18\x0f\x20\x01(\tR\x0bdescription\x12\x1d\n\nadult_size\x18\x10\
    \x20\x01(\x05R\tadultSize\"\xed\x03\n\x0bCreatureRaw\x12\x14\n\x05index\
    \x18\x01\x20\x01(\x05R\x05index\x12\x1f\n\x0bcreature_id\x18\x02\x20\x01\
    (\tR\ncreatureId\x12\x12\n\x04name\x18\x03\x20\x03(\tR\x04name\x12*\n\
    \x11general_baby_name\x18\x04\x20\x03(\tR\x0fgeneralBabyName\x12,\n\x12g\
    eneral_child_name\x18\x05\x20\x03(\tR\x10generalChildName\x12#\n\rcreatu\
    re_tile\x18\x06\x20\x01(\x05R\x0ccreatureTile\x122\n\x15creature_soldier\
    _tile\x18\x07\x20\x01(\x05R\x13creatureSoldierTile\x12;\n\x05color\x18\
    \x08\x20\x01(\x0b2%.RemoteFortressReader.ColorDefinitionR\x05color\x12\
    \x1c\n\tadultsize\x18\t\x20\x01(\x05R\tadultsize\x124\n\x05caste\x18\n\
    \x20\x03(\x0b2\x1e.RemoteFortressReader.CasteRawR\x05caste\x129\n\x07tis\
    sues\x18\x0b\x20\x03(\x0b2\x1f.RemoteFortressReader.TissueRawR\x07tissue\
    s\x12\x14\n\x05flags\x18\x0c\x20\x03(\x08R\x05flags\"Y\n\x0fCreatureRawL\
    ist\x12F\n\rcreature_raws\x18\x01\x20\x03(\x0b2!.RemoteFortressReader.Cr\
    eatureRawR\x0ccreatureRaws\"\xe9\x01\n\x04Army\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x05R\x02id\x12\x13\n\x05pos_x\x18\x02\x20\x01(\x05R\x04posX\
    \x12\x13\n\x05pos_y\x18\x03\x20\x01(\x05R\x04posY\x12\x13\n\x05pos_z\x18\
    \x04\x20\x01(\x05R\x04posZ\x12<\n\x06leader\x18\x05\x20\x01(\x0b2$.Remot\
    eFortressReader.UnitDefinitionR\x06leader\x12>\n\x07members\x18\x06\x20\
    \x03(\x0b2$.RemoteFortressReader.UnitDefinitionR\x07members\x12\x14\n\
    \x05flags\x18\x07\x20\x01(\rR\x05flags\">\n\x08ArmyList\x122\n\x06armies\
    \x18\x01\x20\x03(\x0b2\x1a.RemoteFortressReader.ArmyR\x06armies\"\x95\
    \x01\n\x0bGrowthPrint\x12\x1a\n\x08priority\x18\x01\x20\x01(\x05R\x08pri\
    ority\x12\x14\n\x05color\x18\x02\x20\x01(\x05R\x05color\x12!\n\x0ctiming\
    _start\x18\x03\x20\x01(\x05R\x0btimingStart\x12\x1d\n\ntiming_end\x18\
    \x04\x20\x01(\x05R\ttimingEnd\x12\x12\n\x04tile\x18\x05\x20\x01(\x05R\
    \x04tile\"\x88\x04\n\nTreeGrowth\x12\x14\n\x05index\x18\x01\x20\x01(\x05\
    R\x05index\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x12\n\x04name\
    \x18\x03\x20\x01(\tR\x04name\x12/\n\x03mat\x18\x04\x20\x01(\x0b2\x1d.Rem\
    oteFortressReader.MatPairR\x03mat\x129\n\x06prints\x18\x05\x20\x03(\x0b2\
    !.RemoteFortressReader.GrowthPrintR\x06prints\x12!\n\x0ctiming_start\x18\
    \x06\x20\x01(\x05R\x0btimingStart\x12\x1d\n\ntiming_end\x18\x07\x20\x01(\
    \x05R\ttimingEnd\x12\x14\n\x05twigs\x18\x08\x20\x01(\x08R\x05twigs\x12%\
    \n\x0elight_branches\x18\t\x20\x01(\x08R\rlightBranches\x12%\n\x0eheavy_\
    branches\x18\n\x20\x01(\x08R\rheavyBranches\x12\x14\n\x05trunk\x18\x0b\
    \x20\x01(\x08R\x05trunk\x12\x14\n\x05roots\x18\x0c\x20\x01(\x08R\x05root\
    s\x12\x10\n\x03cap\x18\r\x20\x01(\x08R\x03cap\x12\x18\n\x07sapling\x18\
    \x0e\x20\x01(\x08R\x07sapling\x12,\n\x12trunk_height_start\x18\x0f\x20\
    \x01(\x05R\x10trunkHeightStart\x12(\n\x10trunk_height_end\x18\x10\x20\
    \x01(\x05R\x0etrunkHeightEnd\"\x94\x01\n\x08PlantRaw\x12\x14\n\x05index\
    \x18\x01\x20\x01(\x05R\x05index\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02i\
    d\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12:\n\x07growths\x18\
    \x04\x20\x03(\x0b2\x20.RemoteFortressReader.TreeGrowthR\x07growths\x12\
    \x12\n\x04tile\x18\x05\x20\x01(\x05R\x04tile\"M\n\x0cPlantRawList\x12=\n\
    \nplant_raws\x18\x01\x20\x03(\x0b2\x1e.RemoteFortressReader.PlantRawR\tp\
    lantRaws\"j\n\nScreenTile\x12\x1c\n\tcharacter\x18\x01\x20\x01(\rR\tchar\
    acter\x12\x1e\n\nforeground\x18\x02\x20\x01(\rR\nforeground\x12\x1e\n\nb\
    ackground\x18\x03\x20\x01(\rR\nbackground\"u\n\rScreenCapture\x12\x14\n\
    \x05width\x18\x01\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x02\x20\
    \x01(\rR\x06height\x126\n\x05tiles\x18\x03\x20\x03(\x0b2\x20.RemoteFortr\
    essReader.ScreenTileR\x05tiles\"\xa9\x01\n\rKeyboardEvent\x12\x12\n\x04t\
    ype\x18\x01\x20\x01(\rR\x04type\x12\x14\n\x05which\x18\x02\x20\x01(\rR\
    \x05which\x12\x14\n\x05state\x18\x03\x20\x01(\rR\x05state\x12\x1a\n\x08s\
    cancode\x18\x04\x20\x01(\rR\x08scancode\x12\x10\n\x03sym\x18\x05\x20\x01\
    (\rR\x03sym\x12\x10\n\x03mod\x18\x06\x20\x01(\rR\x03mod\x12\x18\n\x07uni\
    code\x18\x07\x20\x01(\rR\x07unicode\"\x93\x01\n\nDigCommand\x12J\n\x0bde\
    signation\x18\x01\x20\x01(\x0e2(.RemoteFortressReader.TileDigDesignation\
    R\x0bdesignation\x129\n\tlocations\x18\x02\x20\x03(\x0b2\x1b.RemoteFortr\
    essReader.CoordR\tlocations\"\"\n\nSingleBool\x12\x14\n\x05Value\x18\x01\
    \x20\x01(\x08R\x05Value\"\xaf\x01\n\x0bVersionInfo\x124\n\x16dwarf_fortr\
    ess_version\x18\x01\x20\x01(\tR\x14dwarfFortressVersion\x12%\n\x0edfhack\
    _version\x18\x02\x20\x01(\tR\rdfhackVersion\x12C\n\x1eremote_fortress_re\
    ader_version\x18\x03\x20\x01(\tR\x1bremoteFortressReaderVersion\"G\n\x0b\
    ListRequest\x12\x1d\n\nlist_start\x18\x01\x20\x01(\x05R\tlistStart\x12\
    \x19\n\x08list_end\x18\x02\x20\x01(\x05R\x07listEnd\"\xfd\x02\n\x06Repor\
    t\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text\x12;\n\x05color\x18\x03\x20\x01(\x0b2%.RemoteFo\
    rtressReader.ColorDefinitionR\x05color\x12\x1a\n\x08duration\x18\x04\x20\
    \x01(\x05R\x08duration\x12\"\n\x0ccontinuation\x18\x05\x20\x01(\x08R\x0c\
    continuation\x12\x20\n\x0bunconscious\x18\x06\x20\x01(\x08R\x0bunconscio\
    us\x12\"\n\x0cannouncement\x18\x07\x20\x01(\x08R\x0cannouncement\x12!\n\
    \x0crepeat_count\x18\x08\x20\x01(\x05R\x0brepeatCount\x12-\n\x03pos\x18\
    \t\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03pos\x12\x0e\n\x02id\
    \x18\n\x20\x01(\x05R\x02id\x12\x12\n\x04year\x18\x0b\x20\x01(\x05R\x04ye\
    ar\x12\x12\n\x04time\x18\x0c\x20\x01(\x05R\x04time\"@\n\x06Status\x126\n\
    \x07reports\x18\x01\x20\x03(\x0b2\x1c.RemoteFortressReader.ReportR\x07re\
    ports\"6\n\x10ShapeDescriptior\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x12\n\x04tile\x18\x02\x20\x01(\x05R\x04tile\"J\n\x08Language\x12>\n\
    \x06shapes\x18\x01\x20\x03(\x0b2&.RemoteFortressReader.ShapeDescriptiorR\
    \x06shapes\"\xd1\x01\n\x0fItemImprovement\x129\n\x08material\x18\x01\x20\
    \x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08material\x12\x14\n\x05sh\
    ape\x18\x03\x20\x01(\x05R\x05shape\x12#\n\rspecific_type\x18\x04\x20\x01\
    (\x05R\x0cspecificType\x124\n\x05image\x18\x05\x20\x01(\x0b2\x1e.RemoteF\
    ortressReader.ArtImageR\x05image\x12\x12\n\x04type\x18\x06\x20\x01(\x05R\
    \x04type\"\xf5\x01\n\x0fArtImageElement\x12\x14\n\x05count\x18\x01\x20\
    \x01(\x05R\x05count\x12=\n\x04type\x18\x02\x20\x01(\x0e2).RemoteFortress\
    Reader.ArtImageElementTypeR\x04type\x12B\n\rcreature_item\x18\x03\x20\
    \x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x0ccreatureItem\x129\n\x08m\
    aterial\x18\x05\x20\x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x08mater\
    ial\x12\x0e\n\x02id\x18\x06\x20\x01(\x05R\x02id\"\xbc\x01\n\x10ArtImageP\
    roperty\x12\x18\n\x07subject\x18\x01\x20\x01(\x05R\x07subject\x12\x16\n\
    \x06object\x18\x02\x20\x01(\x05R\x06object\x126\n\x04verb\x18\x03\x20\
    \x01(\x0e2\".RemoteFortressReader.ArtImageVerbR\x04verb\x12>\n\x04type\
    \x18\x04\x20\x01(\x0e2*.RemoteFortressReader.ArtImagePropertyTypeR\x04ty\
    pe\"\xc4\x01\n\x08ArtImage\x12A\n\x08elements\x18\x01\x20\x03(\x0b2%.Rem\
    oteFortressReader.ArtImageElementR\x08elements\x12-\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1d.RemoteFortressReader.MatPairR\x02id\x12F\n\nproperties\
    \x18\x03\x20\x03(\x0b2&.RemoteFortressReader.ArtImagePropertyR\nproperti\
    es\"\x98\x03\n\tEngraving\x12-\n\x03pos\x18\x01\x20\x01(\x0b2\x1b.Remote\
    FortressReader.CoordR\x03pos\x12\x18\n\x07quality\x18\x02\x20\x01(\x05R\
    \x07quality\x12\x12\n\x04tile\x18\x03\x20\x01(\x05R\x04tile\x124\n\x05im\
    age\x18\x04\x20\x01(\x0b2\x1e.RemoteFortressReader.ArtImageR\x05image\
    \x12\x14\n\x05floor\x18\x05\x20\x01(\x08R\x05floor\x12\x12\n\x04west\x18\
    \x06\x20\x01(\x08R\x04west\x12\x12\n\x04east\x18\x07\x20\x01(\x08R\x04ea\
    st\x12\x14\n\x05north\x18\x08\x20\x01(\x08R\x05north\x12\x14\n\x05south\
    \x18\t\x20\x01(\x08R\x05south\x12\x16\n\x06hidden\x18\n\x20\x01(\x08R\
    \x06hidden\x12\x1c\n\tnorthwest\x18\x0b\x20\x01(\x08R\tnorthwest\x12\x1c\
    \n\tnortheast\x18\x0c\x20\x01(\x08R\tnortheast\x12\x1c\n\tsouthwest\x18\
    \r\x20\x01(\x08R\tsouthwest\x12\x1c\n\tsoutheast\x18\x0e\x20\x01(\x08R\t\
    southeast\"\x8b\x03\n\x08FlowInfo\x12\x14\n\x05index\x18\x01\x20\x01(\
    \x05R\x05index\x122\n\x04type\x18\x02\x20\x01(\x0e2\x1e.RemoteFortressRe\
    ader.FlowTypeR\x04type\x12\x18\n\x07density\x18\x03\x20\x01(\x05R\x07den\
    sity\x12-\n\x03pos\x18\x04\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\
    \x03pos\x12/\n\x04dest\x18\x05\x20\x01(\x0b2\x1b.RemoteFortressReader.Co\
    ordR\x04dest\x12\x1c\n\texpanding\x18\x06\x20\x01(\x08R\texpanding\x12\
    \x14\n\x05reuse\x18\x07\x20\x01(\x08R\x05reuse\x12\x19\n\x08guide_id\x18\
    \x08\x20\x01(\x05R\x07guideId\x129\n\x08material\x18\t\x20\x01(\x0b2\x1d\
    .RemoteFortressReader.MatPairR\x08material\x121\n\x04item\x18\n\x20\x01(\
    \x0b2\x1d.RemoteFortressReader.MatPairR\x04item\"f\n\x04Wave\x12/\n\x04d\
    est\x18\x01\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x04dest\x12-\n\
    \x03pos\x18\x02\x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x03pos*\
    \xba\x02\n\rTiletypeShape\x12\x15\n\x08NO_SHAPE\x10\xff\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12\t\n\x05EMPTY\x10\0\x12\t\n\x05FLOOR\x10\x01\x12\
    \x0b\n\x07BOULDER\x10\x02\x12\x0b\n\x07PEBBLES\x10\x03\x12\x08\n\x04WALL\
    \x10\x04\x12\x11\n\rFORTIFICATION\x10\x05\x12\x0c\n\x08STAIR_UP\x10\x06\
    \x12\x0e\n\nSTAIR_DOWN\x10\x07\x12\x10\n\x0cSTAIR_UPDOWN\x10\x08\x12\x08\
    \n\x04RAMP\x10\t\x12\x0c\n\x08RAMP_TOP\x10\n\x12\r\n\tBROOK_BED\x10\x0b\
    \x12\r\n\tBROOK_TOP\x10\x0c\x12\x0e\n\nTREE_SHAPE\x10\r\x12\x0b\n\x07SAP\
    LING\x10\x0e\x12\t\n\x05SHRUB\x10\x0f\x12\x0f\n\x0bENDLESS_PIT\x10\x10\
    \x12\n\n\x06BRANCH\x10\x11\x12\x10\n\x0cTRUNK_BRANCH\x10\x12\x12\x08\n\
    \x04TWIG\x10\x13*\xc4\x01\n\x0fTiletypeSpecial\x12\x17\n\nNO_SPECIAL\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\n\n\x06NORMAL\x10\0\x12\x10\
    \n\x0cRIVER_SOURCE\x10\x01\x12\r\n\tWATERFALL\x10\x02\x12\n\n\x06SMOOTH\
    \x10\x03\x12\x0c\n\x08FURROWED\x10\x04\x12\x07\n\x03WET\x10\x05\x12\x08\
    \n\x04DEAD\x10\x06\x12\n\n\x06WORN_1\x10\x07\x12\n\n\x06WORN_2\x10\x08\
    \x12\n\n\x06WORN_3\x10\t\x12\t\n\x05TRACK\x10\n\x12\x0f\n\x0bSMOOTH_DEAD\
    \x10\x0b*\x8a\x03\n\x10TiletypeMaterial\x12\x18\n\x0bNO_MATERIAL\x10\xff\
    \xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x07\n\x03AIR\x10\0\x12\x08\n\
    \x04SOIL\x10\x01\x12\t\n\x05STONE\x10\x02\x12\x0b\n\x07FEATURE\x10\x03\
    \x12\x0e\n\nLAVA_STONE\x10\x04\x12\x0b\n\x07MINERAL\x10\x05\x12\x11\n\rF\
    ROZEN_LIQUID\x10\x06\x12\x10\n\x0cCONSTRUCTION\x10\x07\x12\x0f\n\x0bGRAS\
    S_LIGHT\x10\x08\x12\x0e\n\nGRASS_DARK\x10\t\x12\r\n\tGRASS_DRY\x10\n\x12\
    \x0e\n\nGRASS_DEAD\x10\x0b\x12\t\n\x05PLANT\x10\x0c\x12\x07\n\x03HFS\x10\
    \r\x12\x0c\n\x08CAMPFIRE\x10\x0e\x12\x08\n\x04FIRE\x10\x0f\x12\t\n\x05AS\
    HES\x10\x10\x12\t\n\x05MAGMA\x10\x11\x12\r\n\tDRIFTWOOD\x10\x12\x12\x08\
    \n\x04POOL\x10\x13\x12\t\n\x05BROOK\x10\x14\x12\t\n\x05RIVER\x10\x15\x12\
    \x08\n\x04ROOT\x10\x16\x12\x11\n\rTREE_MATERIAL\x10\x17\x12\x0c\n\x08MUS\
    HROOM\x10\x18\x12\x13\n\x0fUNDERWORLD_GATE\x10\x19*V\n\x0fTiletypeVarian\
    t\x12\x17\n\nNO_VARIANT\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\
    \t\n\x05VAR_1\x10\0\x12\t\n\x05VAR_2\x10\x01\x12\t\n\x05VAR_3\x10\x02\
    \x12\t\n\x05VAR_4\x10\x03*J\n\nWorldPoles\x12\x0c\n\x08NO_POLES\x10\0\
    \x12\x0e\n\nNORTH_POLE\x10\x01\x12\x0e\n\nSOUTH_POLE\x10\x02\x12\x0e\n\n\
    BOTH_POLES\x10\x03*G\n\x11BuildingDirection\x12\t\n\x05NORTH\x10\0\x12\
    \x08\n\x04EAST\x10\x01\x12\t\n\x05SOUTH\x10\x02\x12\x08\n\x04WEST\x10\
    \x03\x12\x08\n\x04NONE\x10\x04*\x8d\x01\n\x12TileDigDesignation\x12\n\n\
    \x06NO_DIG\x10\0\x12\x0f\n\x0bDEFAULT_DIG\x10\x01\x12\x15\n\x11UP_DOWN_S\
    TAIR_DIG\x10\x02\x12\x0f\n\x0bCHANNEL_DIG\x10\x03\x12\x0c\n\x08RAMP_DIG\
    \x10\x04\x12\x12\n\x0eDOWN_STAIR_DIG\x10\x05\x12\x10\n\x0cUP_STAIR_DIG\
    \x10\x06*u\n\tHairStyle\x12\x14\n\x07UNKEMPT\x10\xff\xff\xff\xff\xff\xff\
    \xff\xff\xff\x01\x12\x11\n\rNEATLY_COMBED\x10\0\x12\x0b\n\x07BRAIDED\x10\
    \x01\x12\x10\n\x0cDOUBLE_BRAID\x10\x02\x12\x0e\n\nPONY_TAILS\x10\x03\x12\
    \x10\n\x0cCLEAN_SHAVEN\x10\x04*\x9c\x01\n\rInventoryMode\x12\n\n\x06Haul\
    ed\x10\0\x12\n\n\x06Weapon\x10\x01\x12\x08\n\x04Worn\x10\x02\x12\x0c\n\
    \x08Piercing\x10\x03\x12\t\n\x05Flask\x10\x04\x12\x11\n\rWrappedAround\
    \x10\x05\x12\x0b\n\x07StuckIn\x10\x06\x12\x0b\n\x07InMouth\x10\x07\x12\
    \x07\n\x03Pet\x10\x08\x12\x0c\n\x08SewnInto\x10\t\x12\x0c\n\x08Strapped\
    \x10\n*O\n\nArmorLayer\x12\x0f\n\x0bLAYER_UNDER\x10\0\x12\x0e\n\nLAYER_O\
    VER\x10\x01\x12\x0f\n\x0bLAYER_ARMOR\x10\x02\x12\x0f\n\x0bLAYER_COVER\
    \x10\x03*Q\n\x0bMatterState\x12\t\n\x05Solid\x10\0\x12\n\n\x06Liquid\x10\
    \x01\x12\x07\n\x03Gas\x10\x02\x12\n\n\x06Powder\x10\x03\x12\t\n\x05Paste\
    \x10\x04\x12\x0b\n\x07Pressed\x10\x05*O\n\tFrontType\x12\x0e\n\nFRONT_NO\
    NE\x10\0\x12\x0e\n\nFRONT_WARM\x10\x01\x12\x0e\n\nFRONT_COLD\x10\x02\x12\
    \x12\n\x0eFRONT_OCCLUDED\x10\x03*Z\n\x0bCumulusType\x12\x10\n\x0cCUMULUS\
    _NONE\x10\0\x12\x12\n\x0eCUMULUS_MEDIUM\x10\x01\x12\x11\n\rCUMULUS_MULTI\
    \x10\x02\x12\x12\n\x0eCUMULUS_NIMBUS\x10\x03*Y\n\x0bStratusType\x12\x10\
    \n\x0cSTRATUS_NONE\x10\0\x12\x10\n\x0cSTRATUS_ALTO\x10\x01\x12\x12\n\x0e\
    STRATUS_PROPER\x10\x02\x12\x12\n\x0eSTRATUS_NIMBUS\x10\x03*D\n\x07FogTyp\
    e\x12\x0c\n\x08FOG_NONE\x10\0\x12\x0c\n\x08FOG_MIST\x10\x01\x12\x0e\n\nF\
    OG_NORMAL\x10\x02\x12\r\n\tF0G_THICK\x10\x03*]\n\x0bPatternType\x12\x0c\
    \n\x08MONOTONE\x10\0\x12\x0b\n\x07STRIPES\x10\x01\x12\x0c\n\x08IRIS_EYE\
    \x10\x02\x12\t\n\x05SPOTS\x10\x03\x12\r\n\tPUPIL_EYE\x10\x04\x12\x0b\n\
    \x07MOTTLED\x10\x05*k\n\x13ArtImageElementType\x12\x12\n\x0eIMAGE_CREATU\
    RE\x10\0\x12\x0f\n\x0bIMAGE_PLANT\x10\x01\x12\x0e\n\nIMAGE_TREE\x10\x02\
    \x12\x0f\n\x0bIMAGE_SHAPE\x10\x03\x12\x0e\n\nIMAGE_ITEM\x10\x04*B\n\x14A\
    rtImagePropertyType\x12\x13\n\x0fTRANSITIVE_VERB\x10\0\x12\x15\n\x11INTR\
    ANSITIVE_VERB\x10\x01*\x95\x08\n\x0cArtImageVerb\x12\x12\n\x0eVERB_WITHE\
    RING\x10\0\x12\x15\n\x11VERB_SURROUNDEDBY\x10\x01\x12\x13\n\x0fVERB_MASS\
    ACRING\x10\x02\x12\x11\n\rVERB_FIGHTING\x10\x03\x12\x11\n\rVERB_LABORING\
    \x10\x04\x12\x11\n\rVERB_GREETING\x10\x05\x12\x11\n\rVERB_REFUSING\x10\
    \x06\x12\x11\n\rVERB_SPEAKING\x10\x07\x12\x12\n\x0eVERB_EMBRACING\x10\
    \x08\x12\x15\n\x11VERB_STRIKINGDOWN\x10\t\x12\x15\n\x11VERB_MENACINGPOSE\
    \x10\n\x12\x12\n\x0eVERB_TRAVELING\x10\x0b\x12\x10\n\x0cVERB_RAISING\x10\
    \x0c\x12\x0f\n\x0bVERB_HIDING\x10\r\x12\x18\n\x14VERB_LOOKINGCONFUSED\
    \x10\x0e\x12\x19\n\x15VERB_LOOKINGTERRIFIED\x10\x0f\x12\x12\n\x0eVERB_DE\
    VOURING\x10\x10\x12\x11\n\rVERB_ADMIRING\x10\x11\x12\x10\n\x0cVERB_BURNI\
    NG\x10\x12\x12\x10\n\x0cVERB_WEEPING\x10\x13\x12\x18\n\x14VERB_LOOKINGDE\
    JECTED\x10\x14\x12\x11\n\rVERB_CRINGING\x10\x15\x12\x12\n\x0eVERB_SCREAM\
    ING\x10\x16\x12\x1a\n\x16VERB_SUBMISSIVEGESTURE\x10\x17\x12\x16\n\x12VER\
    B_FETALPOSITION\x10\x18\x12\x1a\n\x16VERB_SMEAREDINTOSPIRAL\x10\x19\x12\
    \x10\n\x0cVERB_FALLING\x10\x1a\x12\r\n\tVERB_DEAD\x10\x1b\x12\x11\n\rVER\
    B_LAUGHING\x10\x1c\x12\x18\n\x14VERB_LOOKINGOFFENDED\x10\x1d\x12\x12\n\
    \x0eVERB_BEINGSHOT\x10\x1e\x12\x19\n\x15VERB_PLAINTIVEGESTURE\x10\x1f\
    \x12\x10\n\x0cVERB_MELTING\x10\x20\x12\x11\n\rVERB_SHOOTING\x10!\x12\x12\
    \n\x0eVERB_TORTURING\x10\"\x12\x1e\n\x1aVERB_COMMITTINGDEPRAVEDACT\x10#\
    \x12\x10\n\x0cVERB_PRAYING\x10$\x12\x16\n\x12VERB_CONTEMPLATING\x10%\x12\
    \x10\n\x0cVERB_COOKING\x10&\x12\x12\n\x0eVERB_ENGRAVING\x10'\x12\x14\n\
    \x10VERB_PROSTRATING\x10(\x12\x12\n\x0eVERB_SUFFERING\x10)\x12\x15\n\x11\
    VERB_BEINGIMPALED\x10*\x12\x17\n\x13VERB_BEINGCONTORTED\x10+\x12\x14\n\
    \x10VERB_BEINGFLAYED\x10,\x12\x14\n\x10VERB_HANGINGFROM\x10-\x12\x17\n\
    \x13VERB_BEINGMUTILATED\x10.\x12\x17\n\x13VERB_TRIUMPHANTPOSE\x10/*\xe0\
    \x01\n\x08FlowType\x12\n\n\x06Miasma\x10\0\x12\t\n\x05Steam\x10\x01\x12\
    \x08\n\x04Mist\x10\x02\x12\x10\n\x0cMaterialDust\x10\x03\x12\r\n\tMagmaM\
    ist\x10\x04\x12\t\n\x05Smoke\x10\x05\x12\x0e\n\nDragonfire\x10\x06\x12\
    \x08\n\x04Fire\x10\x07\x12\x07\n\x03Web\x10\x08\x12\x0f\n\x0bMaterialGas\
    \x10\t\x12\x11\n\rMaterialVapor\x10\n\x12\r\n\tOceanWave\x10\x0b\x12\x0b\
    \n\x07SeaFoam\x10\x0c\x12\r\n\tItemCloud\x10\r\x12\x15\n\x08CampFire\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01B\x02H\x03b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::ItemdefInstrument::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(79);
            messages.push(Coord::generated_message_descriptor_data());
            messages.push(Tiletype::generated_message_descriptor_data());
            messages.push(TiletypeList::generated_message_descriptor_data());
            messages.push(BuildingExtents::generated_message_descriptor_data());
            messages.push(BuildingItem::generated_message_descriptor_data());
            messages.push(BuildingInstance::generated_message_descriptor_data());
            messages.push(RiverEdge::generated_message_descriptor_data());
            messages.push(RiverTile::generated_message_descriptor_data());
            messages.push(Spatter::generated_message_descriptor_data());
            messages.push(SpatterPile::generated_message_descriptor_data());
            messages.push(Item::generated_message_descriptor_data());
            messages.push(PlantTile::generated_message_descriptor_data());
            messages.push(TreeInfo::generated_message_descriptor_data());
            messages.push(PlantInstance::generated_message_descriptor_data());
            messages.push(MapBlock::generated_message_descriptor_data());
            messages.push(MatPair::generated_message_descriptor_data());
            messages.push(ColorDefinition::generated_message_descriptor_data());
            messages.push(MaterialDefinition::generated_message_descriptor_data());
            messages.push(BuildingType::generated_message_descriptor_data());
            messages.push(BuildingDefinition::generated_message_descriptor_data());
            messages.push(BuildingList::generated_message_descriptor_data());
            messages.push(MaterialList::generated_message_descriptor_data());
            messages.push(Hair::generated_message_descriptor_data());
            messages.push(BodySizeInfo::generated_message_descriptor_data());
            messages.push(UnitAppearance::generated_message_descriptor_data());
            messages.push(InventoryItem::generated_message_descriptor_data());
            messages.push(WoundPart::generated_message_descriptor_data());
            messages.push(UnitWound::generated_message_descriptor_data());
            messages.push(UnitDefinition::generated_message_descriptor_data());
            messages.push(UnitList::generated_message_descriptor_data());
            messages.push(BlockRequest::generated_message_descriptor_data());
            messages.push(BlockList::generated_message_descriptor_data());
            messages.push(PlantDef::generated_message_descriptor_data());
            messages.push(PlantList::generated_message_descriptor_data());
            messages.push(ViewInfo::generated_message_descriptor_data());
            messages.push(MapInfo::generated_message_descriptor_data());
            messages.push(Cloud::generated_message_descriptor_data());
            messages.push(WorldMap::generated_message_descriptor_data());
            messages.push(SiteRealizationBuildingWall::generated_message_descriptor_data());
            messages.push(SiteRealizationBuildingTower::generated_message_descriptor_data());
            messages.push(TrenchSpoke::generated_message_descriptor_data());
            messages.push(SiteRealizationBuildingTrenches::generated_message_descriptor_data());
            messages.push(SiteRealizationBuilding::generated_message_descriptor_data());
            messages.push(RegionTile::generated_message_descriptor_data());
            messages.push(RegionMap::generated_message_descriptor_data());
            messages.push(RegionMaps::generated_message_descriptor_data());
            messages.push(PatternDescriptor::generated_message_descriptor_data());
            messages.push(ColorModifierRaw::generated_message_descriptor_data());
            messages.push(BodyPartLayerRaw::generated_message_descriptor_data());
            messages.push(BodyPartRaw::generated_message_descriptor_data());
            messages.push(BpAppearanceModifier::generated_message_descriptor_data());
            messages.push(TissueRaw::generated_message_descriptor_data());
            messages.push(CasteRaw::generated_message_descriptor_data());
            messages.push(CreatureRaw::generated_message_descriptor_data());
            messages.push(CreatureRawList::generated_message_descriptor_data());
            messages.push(Army::generated_message_descriptor_data());
            messages.push(ArmyList::generated_message_descriptor_data());
            messages.push(GrowthPrint::generated_message_descriptor_data());
            messages.push(TreeGrowth::generated_message_descriptor_data());
            messages.push(PlantRaw::generated_message_descriptor_data());
            messages.push(PlantRawList::generated_message_descriptor_data());
            messages.push(ScreenTile::generated_message_descriptor_data());
            messages.push(ScreenCapture::generated_message_descriptor_data());
            messages.push(KeyboardEvent::generated_message_descriptor_data());
            messages.push(DigCommand::generated_message_descriptor_data());
            messages.push(SingleBool::generated_message_descriptor_data());
            messages.push(VersionInfo::generated_message_descriptor_data());
            messages.push(ListRequest::generated_message_descriptor_data());
            messages.push(Report::generated_message_descriptor_data());
            messages.push(Status::generated_message_descriptor_data());
            messages.push(ShapeDescriptior::generated_message_descriptor_data());
            messages.push(Language::generated_message_descriptor_data());
            messages.push(ItemImprovement::generated_message_descriptor_data());
            messages.push(ArtImageElement::generated_message_descriptor_data());
            messages.push(ArtImageProperty::generated_message_descriptor_data());
            messages.push(ArtImage::generated_message_descriptor_data());
            messages.push(Engraving::generated_message_descriptor_data());
            messages.push(FlowInfo::generated_message_descriptor_data());
            messages.push(Wave::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(20);
            enums.push(TiletypeShape::generated_enum_descriptor_data());
            enums.push(TiletypeSpecial::generated_enum_descriptor_data());
            enums.push(TiletypeMaterial::generated_enum_descriptor_data());
            enums.push(TiletypeVariant::generated_enum_descriptor_data());
            enums.push(WorldPoles::generated_enum_descriptor_data());
            enums.push(BuildingDirection::generated_enum_descriptor_data());
            enums.push(TileDigDesignation::generated_enum_descriptor_data());
            enums.push(HairStyle::generated_enum_descriptor_data());
            enums.push(InventoryMode::generated_enum_descriptor_data());
            enums.push(ArmorLayer::generated_enum_descriptor_data());
            enums.push(MatterState::generated_enum_descriptor_data());
            enums.push(FrontType::generated_enum_descriptor_data());
            enums.push(CumulusType::generated_enum_descriptor_data());
            enums.push(StratusType::generated_enum_descriptor_data());
            enums.push(FogType::generated_enum_descriptor_data());
            enums.push(PatternType::generated_enum_descriptor_data());
            enums.push(ArtImageElementType::generated_enum_descriptor_data());
            enums.push(ArtImagePropertyType::generated_enum_descriptor_data());
            enums.push(ArtImageVerb::generated_enum_descriptor_data());
            enums.push(FlowType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
