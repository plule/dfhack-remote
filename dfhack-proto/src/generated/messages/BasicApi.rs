// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `BasicApi.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct GetWorldInfoOut {
    // message fields
    mode: ::std::option::Option<GetWorldInfoOut_Mode>,
    save_dir: ::protobuf::SingularField<::std::string::String>,
    pub world_name: ::protobuf::SingularPtrField<super::Basic::NameInfo>,
    civ_id: ::std::option::Option<i32>,
    site_id: ::std::option::Option<i32>,
    group_id: ::std::option::Option<i32>,
    race_id: ::std::option::Option<i32>,
    player_unit_id: ::std::option::Option<i32>,
    player_histfig_id: ::std::option::Option<i32>,
    pub companion_histfig_ids: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWorldInfoOut {
    fn default() -> &'a GetWorldInfoOut {
        <GetWorldInfoOut as ::protobuf::Message>::default_instance()
    }
}

impl GetWorldInfoOut {
    pub fn new() -> GetWorldInfoOut {
        ::std::default::Default::default()
    }

    // required .dfproto.GetWorldInfoOut.Mode mode = 1;


    pub fn get_mode(&self) -> GetWorldInfoOut_Mode {
        self.mode.unwrap_or(GetWorldInfoOut_Mode::MODE_DWARF)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: GetWorldInfoOut_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    // required string save_dir = 2;


    pub fn get_save_dir(&self) -> &str {
        match self.save_dir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_save_dir(&mut self) {
        self.save_dir.clear();
    }

    pub fn has_save_dir(&self) -> bool {
        self.save_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_dir(&mut self, v: ::std::string::String) {
        self.save_dir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_dir(&mut self) -> &mut ::std::string::String {
        if self.save_dir.is_none() {
            self.save_dir.set_default();
        }
        self.save_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_dir(&mut self) -> ::std::string::String {
        self.save_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .dfproto.NameInfo world_name = 3;


    pub fn get_world_name(&self) -> &super::Basic::NameInfo {
        self.world_name.as_ref().unwrap_or_else(|| <super::Basic::NameInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_world_name(&mut self) {
        self.world_name.clear();
    }

    pub fn has_world_name(&self) -> bool {
        self.world_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_name(&mut self, v: super::Basic::NameInfo) {
        self.world_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_name(&mut self) -> &mut super::Basic::NameInfo {
        if self.world_name.is_none() {
            self.world_name.set_default();
        }
        self.world_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_name(&mut self) -> super::Basic::NameInfo {
        self.world_name.take().unwrap_or_else(|| super::Basic::NameInfo::new())
    }

    // optional int32 civ_id = 4;


    pub fn get_civ_id(&self) -> i32 {
        self.civ_id.unwrap_or(0)
    }
    pub fn clear_civ_id(&mut self) {
        self.civ_id = ::std::option::Option::None;
    }

    pub fn has_civ_id(&self) -> bool {
        self.civ_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_civ_id(&mut self, v: i32) {
        self.civ_id = ::std::option::Option::Some(v);
    }

    // optional int32 site_id = 5;


    pub fn get_site_id(&self) -> i32 {
        self.site_id.unwrap_or(0)
    }
    pub fn clear_site_id(&mut self) {
        self.site_id = ::std::option::Option::None;
    }

    pub fn has_site_id(&self) -> bool {
        self.site_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_site_id(&mut self, v: i32) {
        self.site_id = ::std::option::Option::Some(v);
    }

    // optional int32 group_id = 6;


    pub fn get_group_id(&self) -> i32 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: i32) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional int32 race_id = 7;


    pub fn get_race_id(&self) -> i32 {
        self.race_id.unwrap_or(0)
    }
    pub fn clear_race_id(&mut self) {
        self.race_id = ::std::option::Option::None;
    }

    pub fn has_race_id(&self) -> bool {
        self.race_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race_id(&mut self, v: i32) {
        self.race_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_unit_id = 8;


    pub fn get_player_unit_id(&self) -> i32 {
        self.player_unit_id.unwrap_or(0)
    }
    pub fn clear_player_unit_id(&mut self) {
        self.player_unit_id = ::std::option::Option::None;
    }

    pub fn has_player_unit_id(&self) -> bool {
        self.player_unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_unit_id(&mut self, v: i32) {
        self.player_unit_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_histfig_id = 9;


    pub fn get_player_histfig_id(&self) -> i32 {
        self.player_histfig_id.unwrap_or(0)
    }
    pub fn clear_player_histfig_id(&mut self) {
        self.player_histfig_id = ::std::option::Option::None;
    }

    pub fn has_player_histfig_id(&self) -> bool {
        self.player_histfig_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_histfig_id(&mut self, v: i32) {
        self.player_histfig_id = ::std::option::Option::Some(v);
    }

    // repeated int32 companion_histfig_ids = 10;


    pub fn get_companion_histfig_ids(&self) -> &[i32] {
        &self.companion_histfig_ids
    }
    pub fn clear_companion_histfig_ids(&mut self) {
        self.companion_histfig_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_companion_histfig_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.companion_histfig_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_companion_histfig_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.companion_histfig_ids
    }

    // Take field
    pub fn take_companion_histfig_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.companion_histfig_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetWorldInfoOut {
    fn is_initialized(&self) -> bool {
        if self.mode.is_none() {
            return false;
        }
        if self.save_dir.is_none() {
            return false;
        }
        for v in &self.world_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.save_dir)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.world_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.civ_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.site_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.race_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_unit_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_histfig_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.companion_histfig_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.save_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.world_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.civ_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.site_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.race_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_unit_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_histfig_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.companion_histfig_ids {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.save_dir.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.world_name.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.civ_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.site_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.group_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.race_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.player_unit_id {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.player_histfig_id {
            os.write_int32(9, v)?;
        }
        for v in &self.companion_histfig_ids {
            os.write_int32(10, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWorldInfoOut {
        GetWorldInfoOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetWorldInfoOut_Mode>>(
                "mode",
                |m: &GetWorldInfoOut| { &m.mode },
                |m: &mut GetWorldInfoOut| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "save_dir",
                |m: &GetWorldInfoOut| { &m.save_dir },
                |m: &mut GetWorldInfoOut| { &mut m.save_dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::NameInfo>>(
                "world_name",
                |m: &GetWorldInfoOut| { &m.world_name },
                |m: &mut GetWorldInfoOut| { &mut m.world_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "civ_id",
                |m: &GetWorldInfoOut| { &m.civ_id },
                |m: &mut GetWorldInfoOut| { &mut m.civ_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "site_id",
                |m: &GetWorldInfoOut| { &m.site_id },
                |m: &mut GetWorldInfoOut| { &mut m.site_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_id",
                |m: &GetWorldInfoOut| { &m.group_id },
                |m: &mut GetWorldInfoOut| { &mut m.group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "race_id",
                |m: &GetWorldInfoOut| { &m.race_id },
                |m: &mut GetWorldInfoOut| { &mut m.race_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "player_unit_id",
                |m: &GetWorldInfoOut| { &m.player_unit_id },
                |m: &mut GetWorldInfoOut| { &mut m.player_unit_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "player_histfig_id",
                |m: &GetWorldInfoOut| { &m.player_histfig_id },
                |m: &mut GetWorldInfoOut| { &mut m.player_histfig_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "companion_histfig_ids",
                |m: &GetWorldInfoOut| { &m.companion_histfig_ids },
                |m: &mut GetWorldInfoOut| { &mut m.companion_histfig_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetWorldInfoOut>(
                "GetWorldInfoOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetWorldInfoOut {
        static instance: ::protobuf::rt::LazyV2<GetWorldInfoOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWorldInfoOut::new)
    }
}

impl ::protobuf::Clear for GetWorldInfoOut {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.save_dir.clear();
        self.world_name.clear();
        self.civ_id = ::std::option::Option::None;
        self.site_id = ::std::option::Option::None;
        self.group_id = ::std::option::Option::None;
        self.race_id = ::std::option::Option::None;
        self.player_unit_id = ::std::option::Option::None;
        self.player_histfig_id = ::std::option::Option::None;
        self.companion_histfig_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWorldInfoOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorldInfoOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetWorldInfoOut_Mode {
    MODE_DWARF = 1,
    MODE_ADVENTURE = 2,
    MODE_LEGENDS = 3,
}

impl ::protobuf::ProtobufEnum for GetWorldInfoOut_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetWorldInfoOut_Mode> {
        match value {
            1 => ::std::option::Option::Some(GetWorldInfoOut_Mode::MODE_DWARF),
            2 => ::std::option::Option::Some(GetWorldInfoOut_Mode::MODE_ADVENTURE),
            3 => ::std::option::Option::Some(GetWorldInfoOut_Mode::MODE_LEGENDS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetWorldInfoOut_Mode] = &[
            GetWorldInfoOut_Mode::MODE_DWARF,
            GetWorldInfoOut_Mode::MODE_ADVENTURE,
            GetWorldInfoOut_Mode::MODE_LEGENDS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetWorldInfoOut_Mode>("GetWorldInfoOut.Mode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetWorldInfoOut_Mode {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GetWorldInfoOut_Mode {
    fn default() -> Self {
        GetWorldInfoOut_Mode::MODE_DWARF
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorldInfoOut_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEnumsOut {
    // message fields
    pub material_flags: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub inorganic_flags: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub unit_flags1: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub unit_flags2: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub unit_flags3: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub unit_labor: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub job_skill: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub cie_add_tag_mask1: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub cie_add_tag_mask2: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub death_info_flags: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    pub profession: ::protobuf::RepeatedField<super::Basic::EnumItemName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEnumsOut {
    fn default() -> &'a ListEnumsOut {
        <ListEnumsOut as ::protobuf::Message>::default_instance()
    }
}

impl ListEnumsOut {
    pub fn new() -> ListEnumsOut {
        ::std::default::Default::default()
    }

    // repeated .dfproto.EnumItemName material_flags = 1;


    pub fn get_material_flags(&self) -> &[super::Basic::EnumItemName] {
        &self.material_flags
    }
    pub fn clear_material_flags(&mut self) {
        self.material_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_material_flags(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.material_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_material_flags(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.material_flags
    }

    // Take field
    pub fn take_material_flags(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.material_flags, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName inorganic_flags = 2;


    pub fn get_inorganic_flags(&self) -> &[super::Basic::EnumItemName] {
        &self.inorganic_flags
    }
    pub fn clear_inorganic_flags(&mut self) {
        self.inorganic_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_inorganic_flags(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.inorganic_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inorganic_flags(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.inorganic_flags
    }

    // Take field
    pub fn take_inorganic_flags(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.inorganic_flags, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName unit_flags1 = 3;


    pub fn get_unit_flags1(&self) -> &[super::Basic::EnumItemName] {
        &self.unit_flags1
    }
    pub fn clear_unit_flags1(&mut self) {
        self.unit_flags1.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_flags1(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.unit_flags1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_flags1(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.unit_flags1
    }

    // Take field
    pub fn take_unit_flags1(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.unit_flags1, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName unit_flags2 = 4;


    pub fn get_unit_flags2(&self) -> &[super::Basic::EnumItemName] {
        &self.unit_flags2
    }
    pub fn clear_unit_flags2(&mut self) {
        self.unit_flags2.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_flags2(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.unit_flags2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_flags2(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.unit_flags2
    }

    // Take field
    pub fn take_unit_flags2(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.unit_flags2, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName unit_flags3 = 5;


    pub fn get_unit_flags3(&self) -> &[super::Basic::EnumItemName] {
        &self.unit_flags3
    }
    pub fn clear_unit_flags3(&mut self) {
        self.unit_flags3.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_flags3(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.unit_flags3 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_flags3(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.unit_flags3
    }

    // Take field
    pub fn take_unit_flags3(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.unit_flags3, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName unit_labor = 6;


    pub fn get_unit_labor(&self) -> &[super::Basic::EnumItemName] {
        &self.unit_labor
    }
    pub fn clear_unit_labor(&mut self) {
        self.unit_labor.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_labor(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.unit_labor = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_labor(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.unit_labor
    }

    // Take field
    pub fn take_unit_labor(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.unit_labor, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName job_skill = 7;


    pub fn get_job_skill(&self) -> &[super::Basic::EnumItemName] {
        &self.job_skill
    }
    pub fn clear_job_skill(&mut self) {
        self.job_skill.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_skill(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.job_skill = v;
    }

    // Mutable pointer to the field.
    pub fn mut_job_skill(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.job_skill
    }

    // Take field
    pub fn take_job_skill(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.job_skill, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName cie_add_tag_mask1 = 8;


    pub fn get_cie_add_tag_mask1(&self) -> &[super::Basic::EnumItemName] {
        &self.cie_add_tag_mask1
    }
    pub fn clear_cie_add_tag_mask1(&mut self) {
        self.cie_add_tag_mask1.clear();
    }

    // Param is passed by value, moved
    pub fn set_cie_add_tag_mask1(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.cie_add_tag_mask1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cie_add_tag_mask1(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.cie_add_tag_mask1
    }

    // Take field
    pub fn take_cie_add_tag_mask1(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.cie_add_tag_mask1, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName cie_add_tag_mask2 = 9;


    pub fn get_cie_add_tag_mask2(&self) -> &[super::Basic::EnumItemName] {
        &self.cie_add_tag_mask2
    }
    pub fn clear_cie_add_tag_mask2(&mut self) {
        self.cie_add_tag_mask2.clear();
    }

    // Param is passed by value, moved
    pub fn set_cie_add_tag_mask2(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.cie_add_tag_mask2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cie_add_tag_mask2(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.cie_add_tag_mask2
    }

    // Take field
    pub fn take_cie_add_tag_mask2(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.cie_add_tag_mask2, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName death_info_flags = 10;


    pub fn get_death_info_flags(&self) -> &[super::Basic::EnumItemName] {
        &self.death_info_flags
    }
    pub fn clear_death_info_flags(&mut self) {
        self.death_info_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_death_info_flags(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.death_info_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_death_info_flags(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.death_info_flags
    }

    // Take field
    pub fn take_death_info_flags(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.death_info_flags, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.EnumItemName profession = 11;


    pub fn get_profession(&self) -> &[super::Basic::EnumItemName] {
        &self.profession
    }
    pub fn clear_profession(&mut self) {
        self.profession.clear();
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: ::protobuf::RepeatedField<super::Basic::EnumItemName>) {
        self.profession = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profession(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        &mut self.profession
    }

    // Take field
    pub fn take_profession(&mut self) -> ::protobuf::RepeatedField<super::Basic::EnumItemName> {
        ::std::mem::replace(&mut self.profession, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListEnumsOut {
    fn is_initialized(&self) -> bool {
        for v in &self.material_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inorganic_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_flags1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_flags2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_flags3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_labor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.job_skill {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cie_add_tag_mask1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cie_add_tag_mask2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.death_info_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profession {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.material_flags)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inorganic_flags)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unit_flags1)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unit_flags2)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unit_flags3)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unit_labor)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.job_skill)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cie_add_tag_mask1)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cie_add_tag_mask2)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.death_info_flags)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profession)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.material_flags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.inorganic_flags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unit_flags1 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unit_flags2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unit_flags3 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unit_labor {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.job_skill {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.cie_add_tag_mask1 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.cie_add_tag_mask2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.death_info_flags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.profession {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.material_flags {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.inorganic_flags {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unit_flags1 {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unit_flags2 {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unit_flags3 {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unit_labor {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.job_skill {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.cie_add_tag_mask1 {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.cie_add_tag_mask2 {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.death_info_flags {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.profession {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEnumsOut {
        ListEnumsOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "material_flags",
                |m: &ListEnumsOut| { &m.material_flags },
                |m: &mut ListEnumsOut| { &mut m.material_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "inorganic_flags",
                |m: &ListEnumsOut| { &m.inorganic_flags },
                |m: &mut ListEnumsOut| { &mut m.inorganic_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "unit_flags1",
                |m: &ListEnumsOut| { &m.unit_flags1 },
                |m: &mut ListEnumsOut| { &mut m.unit_flags1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "unit_flags2",
                |m: &ListEnumsOut| { &m.unit_flags2 },
                |m: &mut ListEnumsOut| { &mut m.unit_flags2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "unit_flags3",
                |m: &ListEnumsOut| { &m.unit_flags3 },
                |m: &mut ListEnumsOut| { &mut m.unit_flags3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "unit_labor",
                |m: &ListEnumsOut| { &m.unit_labor },
                |m: &mut ListEnumsOut| { &mut m.unit_labor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "job_skill",
                |m: &ListEnumsOut| { &m.job_skill },
                |m: &mut ListEnumsOut| { &mut m.job_skill },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "cie_add_tag_mask1",
                |m: &ListEnumsOut| { &m.cie_add_tag_mask1 },
                |m: &mut ListEnumsOut| { &mut m.cie_add_tag_mask1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "cie_add_tag_mask2",
                |m: &ListEnumsOut| { &m.cie_add_tag_mask2 },
                |m: &mut ListEnumsOut| { &mut m.cie_add_tag_mask2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "death_info_flags",
                |m: &ListEnumsOut| { &m.death_info_flags },
                |m: &mut ListEnumsOut| { &mut m.death_info_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::EnumItemName>>(
                "profession",
                |m: &ListEnumsOut| { &m.profession },
                |m: &mut ListEnumsOut| { &mut m.profession },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEnumsOut>(
                "ListEnumsOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEnumsOut {
        static instance: ::protobuf::rt::LazyV2<ListEnumsOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEnumsOut::new)
    }
}

impl ::protobuf::Clear for ListEnumsOut {
    fn clear(&mut self) {
        self.material_flags.clear();
        self.inorganic_flags.clear();
        self.unit_flags1.clear();
        self.unit_flags2.clear();
        self.unit_flags3.clear();
        self.unit_labor.clear();
        self.job_skill.clear();
        self.cie_add_tag_mask1.clear();
        self.cie_add_tag_mask2.clear();
        self.death_info_flags.clear();
        self.profession.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEnumsOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEnumsOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListJobSkillsOut {
    // message fields
    pub skill: ::protobuf::RepeatedField<super::Basic::JobSkillAttr>,
    pub profession: ::protobuf::RepeatedField<super::Basic::ProfessionAttr>,
    pub labor: ::protobuf::RepeatedField<super::Basic::UnitLaborAttr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListJobSkillsOut {
    fn default() -> &'a ListJobSkillsOut {
        <ListJobSkillsOut as ::protobuf::Message>::default_instance()
    }
}

impl ListJobSkillsOut {
    pub fn new() -> ListJobSkillsOut {
        ::std::default::Default::default()
    }

    // repeated .dfproto.JobSkillAttr skill = 1;


    pub fn get_skill(&self) -> &[super::Basic::JobSkillAttr] {
        &self.skill
    }
    pub fn clear_skill(&mut self) {
        self.skill.clear();
    }

    // Param is passed by value, moved
    pub fn set_skill(&mut self, v: ::protobuf::RepeatedField<super::Basic::JobSkillAttr>) {
        self.skill = v;
    }

    // Mutable pointer to the field.
    pub fn mut_skill(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::JobSkillAttr> {
        &mut self.skill
    }

    // Take field
    pub fn take_skill(&mut self) -> ::protobuf::RepeatedField<super::Basic::JobSkillAttr> {
        ::std::mem::replace(&mut self.skill, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.ProfessionAttr profession = 2;


    pub fn get_profession(&self) -> &[super::Basic::ProfessionAttr] {
        &self.profession
    }
    pub fn clear_profession(&mut self) {
        self.profession.clear();
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: ::protobuf::RepeatedField<super::Basic::ProfessionAttr>) {
        self.profession = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profession(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::ProfessionAttr> {
        &mut self.profession
    }

    // Take field
    pub fn take_profession(&mut self) -> ::protobuf::RepeatedField<super::Basic::ProfessionAttr> {
        ::std::mem::replace(&mut self.profession, ::protobuf::RepeatedField::new())
    }

    // repeated .dfproto.UnitLaborAttr labor = 3;


    pub fn get_labor(&self) -> &[super::Basic::UnitLaborAttr] {
        &self.labor
    }
    pub fn clear_labor(&mut self) {
        self.labor.clear();
    }

    // Param is passed by value, moved
    pub fn set_labor(&mut self, v: ::protobuf::RepeatedField<super::Basic::UnitLaborAttr>) {
        self.labor = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labor(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::UnitLaborAttr> {
        &mut self.labor
    }

    // Take field
    pub fn take_labor(&mut self) -> ::protobuf::RepeatedField<super::Basic::UnitLaborAttr> {
        ::std::mem::replace(&mut self.labor, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListJobSkillsOut {
    fn is_initialized(&self) -> bool {
        for v in &self.skill {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profession {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.labor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.skill)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profession)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.labor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.skill {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.profession {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.labor {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.skill {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.profession {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.labor {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListJobSkillsOut {
        ListJobSkillsOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::JobSkillAttr>>(
                "skill",
                |m: &ListJobSkillsOut| { &m.skill },
                |m: &mut ListJobSkillsOut| { &mut m.skill },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::ProfessionAttr>>(
                "profession",
                |m: &ListJobSkillsOut| { &m.profession },
                |m: &mut ListJobSkillsOut| { &mut m.profession },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::UnitLaborAttr>>(
                "labor",
                |m: &ListJobSkillsOut| { &m.labor },
                |m: &mut ListJobSkillsOut| { &mut m.labor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListJobSkillsOut>(
                "ListJobSkillsOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListJobSkillsOut {
        static instance: ::protobuf::rt::LazyV2<ListJobSkillsOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListJobSkillsOut::new)
    }
}

impl ::protobuf::Clear for ListJobSkillsOut {
    fn clear(&mut self) {
        self.skill.clear();
        self.profession.clear();
        self.labor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListJobSkillsOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListJobSkillsOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMaterialsIn {
    // message fields
    pub mask: ::protobuf::SingularPtrField<super::Basic::BasicMaterialInfoMask>,
    pub id_list: ::protobuf::RepeatedField<super::Basic::BasicMaterialId>,
    builtin: ::std::option::Option<bool>,
    inorganic: ::std::option::Option<bool>,
    creatures: ::std::option::Option<bool>,
    plants: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMaterialsIn {
    fn default() -> &'a ListMaterialsIn {
        <ListMaterialsIn as ::protobuf::Message>::default_instance()
    }
}

impl ListMaterialsIn {
    pub fn new() -> ListMaterialsIn {
        ::std::default::Default::default()
    }

    // optional .dfproto.BasicMaterialInfoMask mask = 1;


    pub fn get_mask(&self) -> &super::Basic::BasicMaterialInfoMask {
        self.mask.as_ref().unwrap_or_else(|| <super::Basic::BasicMaterialInfoMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::Basic::BasicMaterialInfoMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::Basic::BasicMaterialInfoMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::Basic::BasicMaterialInfoMask {
        self.mask.take().unwrap_or_else(|| super::Basic::BasicMaterialInfoMask::new())
    }

    // repeated .dfproto.BasicMaterialId id_list = 2;


    pub fn get_id_list(&self) -> &[super::Basic::BasicMaterialId] {
        &self.id_list
    }
    pub fn clear_id_list(&mut self) {
        self.id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_list(&mut self, v: ::protobuf::RepeatedField<super::Basic::BasicMaterialId>) {
        self.id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id_list(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::BasicMaterialId> {
        &mut self.id_list
    }

    // Take field
    pub fn take_id_list(&mut self) -> ::protobuf::RepeatedField<super::Basic::BasicMaterialId> {
        ::std::mem::replace(&mut self.id_list, ::protobuf::RepeatedField::new())
    }

    // optional bool builtin = 3;


    pub fn get_builtin(&self) -> bool {
        self.builtin.unwrap_or(false)
    }
    pub fn clear_builtin(&mut self) {
        self.builtin = ::std::option::Option::None;
    }

    pub fn has_builtin(&self) -> bool {
        self.builtin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_builtin(&mut self, v: bool) {
        self.builtin = ::std::option::Option::Some(v);
    }

    // optional bool inorganic = 4;


    pub fn get_inorganic(&self) -> bool {
        self.inorganic.unwrap_or(false)
    }
    pub fn clear_inorganic(&mut self) {
        self.inorganic = ::std::option::Option::None;
    }

    pub fn has_inorganic(&self) -> bool {
        self.inorganic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inorganic(&mut self, v: bool) {
        self.inorganic = ::std::option::Option::Some(v);
    }

    // optional bool creatures = 5;


    pub fn get_creatures(&self) -> bool {
        self.creatures.unwrap_or(false)
    }
    pub fn clear_creatures(&mut self) {
        self.creatures = ::std::option::Option::None;
    }

    pub fn has_creatures(&self) -> bool {
        self.creatures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creatures(&mut self, v: bool) {
        self.creatures = ::std::option::Option::Some(v);
    }

    // optional bool plants = 6;


    pub fn get_plants(&self) -> bool {
        self.plants.unwrap_or(false)
    }
    pub fn clear_plants(&mut self) {
        self.plants = ::std::option::Option::None;
    }

    pub fn has_plants(&self) -> bool {
        self.plants.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plants(&mut self, v: bool) {
        self.plants = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListMaterialsIn {
    fn is_initialized(&self) -> bool {
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.id_list)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.builtin = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inorganic = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.creatures = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.plants = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.id_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.builtin {
            my_size += 2;
        }
        if let Some(v) = self.inorganic {
            my_size += 2;
        }
        if let Some(v) = self.creatures {
            my_size += 2;
        }
        if let Some(v) = self.plants {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.id_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.builtin {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.inorganic {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.creatures {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.plants {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMaterialsIn {
        ListMaterialsIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::BasicMaterialInfoMask>>(
                "mask",
                |m: &ListMaterialsIn| { &m.mask },
                |m: &mut ListMaterialsIn| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::BasicMaterialId>>(
                "id_list",
                |m: &ListMaterialsIn| { &m.id_list },
                |m: &mut ListMaterialsIn| { &mut m.id_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "builtin",
                |m: &ListMaterialsIn| { &m.builtin },
                |m: &mut ListMaterialsIn| { &mut m.builtin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inorganic",
                |m: &ListMaterialsIn| { &m.inorganic },
                |m: &mut ListMaterialsIn| { &mut m.inorganic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "creatures",
                |m: &ListMaterialsIn| { &m.creatures },
                |m: &mut ListMaterialsIn| { &mut m.creatures },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "plants",
                |m: &ListMaterialsIn| { &m.plants },
                |m: &mut ListMaterialsIn| { &mut m.plants },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMaterialsIn>(
                "ListMaterialsIn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListMaterialsIn {
        static instance: ::protobuf::rt::LazyV2<ListMaterialsIn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMaterialsIn::new)
    }
}

impl ::protobuf::Clear for ListMaterialsIn {
    fn clear(&mut self) {
        self.mask.clear();
        self.id_list.clear();
        self.builtin = ::std::option::Option::None;
        self.inorganic = ::std::option::Option::None;
        self.creatures = ::std::option::Option::None;
        self.plants = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMaterialsIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMaterialsIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMaterialsOut {
    // message fields
    pub value: ::protobuf::RepeatedField<super::Basic::BasicMaterialInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMaterialsOut {
    fn default() -> &'a ListMaterialsOut {
        <ListMaterialsOut as ::protobuf::Message>::default_instance()
    }
}

impl ListMaterialsOut {
    pub fn new() -> ListMaterialsOut {
        ::std::default::Default::default()
    }

    // repeated .dfproto.BasicMaterialInfo value = 1;


    pub fn get_value(&self) -> &[super::Basic::BasicMaterialInfo] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<super::Basic::BasicMaterialInfo>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::BasicMaterialInfo> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<super::Basic::BasicMaterialInfo> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListMaterialsOut {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMaterialsOut {
        ListMaterialsOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::BasicMaterialInfo>>(
                "value",
                |m: &ListMaterialsOut| { &m.value },
                |m: &mut ListMaterialsOut| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMaterialsOut>(
                "ListMaterialsOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListMaterialsOut {
        static instance: ::protobuf::rt::LazyV2<ListMaterialsOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMaterialsOut::new)
    }
}

impl ::protobuf::Clear for ListMaterialsOut {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMaterialsOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMaterialsOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUnitsIn {
    // message fields
    pub mask: ::protobuf::SingularPtrField<super::Basic::BasicUnitInfoMask>,
    pub id_list: ::std::vec::Vec<i32>,
    scan_all: ::std::option::Option<bool>,
    race: ::std::option::Option<i32>,
    civ_id: ::std::option::Option<i32>,
    dead: ::std::option::Option<bool>,
    alive: ::std::option::Option<bool>,
    sane: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUnitsIn {
    fn default() -> &'a ListUnitsIn {
        <ListUnitsIn as ::protobuf::Message>::default_instance()
    }
}

impl ListUnitsIn {
    pub fn new() -> ListUnitsIn {
        ::std::default::Default::default()
    }

    // optional .dfproto.BasicUnitInfoMask mask = 1;


    pub fn get_mask(&self) -> &super::Basic::BasicUnitInfoMask {
        self.mask.as_ref().unwrap_or_else(|| <super::Basic::BasicUnitInfoMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::Basic::BasicUnitInfoMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::Basic::BasicUnitInfoMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::Basic::BasicUnitInfoMask {
        self.mask.take().unwrap_or_else(|| super::Basic::BasicUnitInfoMask::new())
    }

    // repeated int32 id_list = 2;


    pub fn get_id_list(&self) -> &[i32] {
        &self.id_list
    }
    pub fn clear_id_list(&mut self) {
        self.id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.id_list
    }

    // Take field
    pub fn take_id_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.id_list, ::std::vec::Vec::new())
    }

    // optional bool scan_all = 5;


    pub fn get_scan_all(&self) -> bool {
        self.scan_all.unwrap_or(false)
    }
    pub fn clear_scan_all(&mut self) {
        self.scan_all = ::std::option::Option::None;
    }

    pub fn has_scan_all(&self) -> bool {
        self.scan_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scan_all(&mut self, v: bool) {
        self.scan_all = ::std::option::Option::Some(v);
    }

    // optional int32 race = 3;


    pub fn get_race(&self) -> i32 {
        self.race.unwrap_or(0)
    }
    pub fn clear_race(&mut self) {
        self.race = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        self.race.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: i32) {
        self.race = ::std::option::Option::Some(v);
    }

    // optional int32 civ_id = 4;


    pub fn get_civ_id(&self) -> i32 {
        self.civ_id.unwrap_or(0)
    }
    pub fn clear_civ_id(&mut self) {
        self.civ_id = ::std::option::Option::None;
    }

    pub fn has_civ_id(&self) -> bool {
        self.civ_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_civ_id(&mut self, v: i32) {
        self.civ_id = ::std::option::Option::Some(v);
    }

    // optional bool dead = 6;


    pub fn get_dead(&self) -> bool {
        self.dead.unwrap_or(false)
    }
    pub fn clear_dead(&mut self) {
        self.dead = ::std::option::Option::None;
    }

    pub fn has_dead(&self) -> bool {
        self.dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dead(&mut self, v: bool) {
        self.dead = ::std::option::Option::Some(v);
    }

    // optional bool alive = 7;


    pub fn get_alive(&self) -> bool {
        self.alive.unwrap_or(false)
    }
    pub fn clear_alive(&mut self) {
        self.alive = ::std::option::Option::None;
    }

    pub fn has_alive(&self) -> bool {
        self.alive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alive(&mut self, v: bool) {
        self.alive = ::std::option::Option::Some(v);
    }

    // optional bool sane = 8;


    pub fn get_sane(&self) -> bool {
        self.sane.unwrap_or(false)
    }
    pub fn clear_sane(&mut self) {
        self.sane = ::std::option::Option::None;
    }

    pub fn has_sane(&self) -> bool {
        self.sane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sane(&mut self, v: bool) {
        self.sane = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListUnitsIn {
    fn is_initialized(&self) -> bool {
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.id_list)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.scan_all = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.race = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.civ_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dead = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.alive = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sane = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.id_list {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.scan_all {
            my_size += 2;
        }
        if let Some(v) = self.race {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.civ_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dead {
            my_size += 2;
        }
        if let Some(v) = self.alive {
            my_size += 2;
        }
        if let Some(v) = self.sane {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.id_list {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.scan_all {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.race {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.civ_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dead {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.alive {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sane {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUnitsIn {
        ListUnitsIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::BasicUnitInfoMask>>(
                "mask",
                |m: &ListUnitsIn| { &m.mask },
                |m: &mut ListUnitsIn| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id_list",
                |m: &ListUnitsIn| { &m.id_list },
                |m: &mut ListUnitsIn| { &mut m.id_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "scan_all",
                |m: &ListUnitsIn| { &m.scan_all },
                |m: &mut ListUnitsIn| { &mut m.scan_all },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "race",
                |m: &ListUnitsIn| { &m.race },
                |m: &mut ListUnitsIn| { &mut m.race },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "civ_id",
                |m: &ListUnitsIn| { &m.civ_id },
                |m: &mut ListUnitsIn| { &mut m.civ_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dead",
                |m: &ListUnitsIn| { &m.dead },
                |m: &mut ListUnitsIn| { &mut m.dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "alive",
                |m: &ListUnitsIn| { &m.alive },
                |m: &mut ListUnitsIn| { &mut m.alive },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sane",
                |m: &ListUnitsIn| { &m.sane },
                |m: &mut ListUnitsIn| { &mut m.sane },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUnitsIn>(
                "ListUnitsIn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUnitsIn {
        static instance: ::protobuf::rt::LazyV2<ListUnitsIn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUnitsIn::new)
    }
}

impl ::protobuf::Clear for ListUnitsIn {
    fn clear(&mut self) {
        self.mask.clear();
        self.id_list.clear();
        self.scan_all = ::std::option::Option::None;
        self.race = ::std::option::Option::None;
        self.civ_id = ::std::option::Option::None;
        self.dead = ::std::option::Option::None;
        self.alive = ::std::option::Option::None;
        self.sane = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUnitsIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUnitsIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUnitsOut {
    // message fields
    pub value: ::protobuf::RepeatedField<super::Basic::BasicUnitInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUnitsOut {
    fn default() -> &'a ListUnitsOut {
        <ListUnitsOut as ::protobuf::Message>::default_instance()
    }
}

impl ListUnitsOut {
    pub fn new() -> ListUnitsOut {
        ::std::default::Default::default()
    }

    // repeated .dfproto.BasicUnitInfo value = 1;


    pub fn get_value(&self) -> &[super::Basic::BasicUnitInfo] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<super::Basic::BasicUnitInfo>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::BasicUnitInfo> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<super::Basic::BasicUnitInfo> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListUnitsOut {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUnitsOut {
        ListUnitsOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::BasicUnitInfo>>(
                "value",
                |m: &ListUnitsOut| { &m.value },
                |m: &mut ListUnitsOut| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUnitsOut>(
                "ListUnitsOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUnitsOut {
        static instance: ::protobuf::rt::LazyV2<ListUnitsOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUnitsOut::new)
    }
}

impl ::protobuf::Clear for ListUnitsOut {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUnitsOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUnitsOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSquadsIn {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSquadsIn {
    fn default() -> &'a ListSquadsIn {
        <ListSquadsIn as ::protobuf::Message>::default_instance()
    }
}

impl ListSquadsIn {
    pub fn new() -> ListSquadsIn {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListSquadsIn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSquadsIn {
        ListSquadsIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSquadsIn>(
                "ListSquadsIn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSquadsIn {
        static instance: ::protobuf::rt::LazyV2<ListSquadsIn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSquadsIn::new)
    }
}

impl ::protobuf::Clear for ListSquadsIn {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSquadsIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSquadsIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSquadsOut {
    // message fields
    pub value: ::protobuf::RepeatedField<super::Basic::BasicSquadInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSquadsOut {
    fn default() -> &'a ListSquadsOut {
        <ListSquadsOut as ::protobuf::Message>::default_instance()
    }
}

impl ListSquadsOut {
    pub fn new() -> ListSquadsOut {
        ::std::default::Default::default()
    }

    // repeated .dfproto.BasicSquadInfo value = 1;


    pub fn get_value(&self) -> &[super::Basic::BasicSquadInfo] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<super::Basic::BasicSquadInfo>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::BasicSquadInfo> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<super::Basic::BasicSquadInfo> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListSquadsOut {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSquadsOut {
        ListSquadsOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::BasicSquadInfo>>(
                "value",
                |m: &ListSquadsOut| { &m.value },
                |m: &mut ListSquadsOut| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSquadsOut>(
                "ListSquadsOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSquadsOut {
        static instance: ::protobuf::rt::LazyV2<ListSquadsOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSquadsOut::new)
    }
}

impl ::protobuf::Clear for ListSquadsOut {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSquadsOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSquadsOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetUnitLaborsIn {
    // message fields
    pub change: ::protobuf::RepeatedField<super::Basic::UnitLaborState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetUnitLaborsIn {
    fn default() -> &'a SetUnitLaborsIn {
        <SetUnitLaborsIn as ::protobuf::Message>::default_instance()
    }
}

impl SetUnitLaborsIn {
    pub fn new() -> SetUnitLaborsIn {
        ::std::default::Default::default()
    }

    // repeated .dfproto.UnitLaborState change = 1;


    pub fn get_change(&self) -> &[super::Basic::UnitLaborState] {
        &self.change
    }
    pub fn clear_change(&mut self) {
        self.change.clear();
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: ::protobuf::RepeatedField<super::Basic::UnitLaborState>) {
        self.change = v;
    }

    // Mutable pointer to the field.
    pub fn mut_change(&mut self) -> &mut ::protobuf::RepeatedField<super::Basic::UnitLaborState> {
        &mut self.change
    }

    // Take field
    pub fn take_change(&mut self) -> ::protobuf::RepeatedField<super::Basic::UnitLaborState> {
        ::std::mem::replace(&mut self.change, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetUnitLaborsIn {
    fn is_initialized(&self) -> bool {
        for v in &self.change {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.change)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.change {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.change {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetUnitLaborsIn {
        SetUnitLaborsIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Basic::UnitLaborState>>(
                "change",
                |m: &SetUnitLaborsIn| { &m.change },
                |m: &mut SetUnitLaborsIn| { &mut m.change },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetUnitLaborsIn>(
                "SetUnitLaborsIn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetUnitLaborsIn {
        static instance: ::protobuf::rt::LazyV2<SetUnitLaborsIn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetUnitLaborsIn::new)
    }
}

impl ::protobuf::Clear for SetUnitLaborsIn {
    fn clear(&mut self) {
        self.change.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetUnitLaborsIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetUnitLaborsIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eBasicApi.proto\x12\x07dfproto\x1a\x0bBasic.proto\"\xd1\x03\n\x0fGe\
    tWorldInfoOut\x123\n\x04mode\x18\x01\x20\x02(\x0e2\x1d.dfproto.GetWorldI\
    nfoOut.ModeR\x04modeB\0\x12\x1b\n\x08save_dir\x18\x02\x20\x02(\tR\x07sav\
    eDirB\0\x122\n\nworld_name\x18\x03\x20\x01(\x0b2\x11.dfproto.NameInfoR\t\
    worldNameB\0\x12\x17\n\x06civ_id\x18\x04\x20\x01(\x05R\x05civIdB\0\x12\
    \x19\n\x07site_id\x18\x05\x20\x01(\x05R\x06siteIdB\0\x12\x1b\n\x08group_\
    id\x18\x06\x20\x01(\x05R\x07groupIdB\0\x12\x19\n\x07race_id\x18\x07\x20\
    \x01(\x05R\x06raceIdB\0\x12&\n\x0eplayer_unit_id\x18\x08\x20\x01(\x05R\
    \x0cplayerUnitIdB\0\x12,\n\x11player_histfig_id\x18\t\x20\x01(\x05R\x0fp\
    layerHistfigIdB\0\x124\n\x15companion_histfig_ids\x18\n\x20\x03(\x05R\
    \x13companionHistfigIdsB\0\">\n\x04Mode\x12\x0e\n\nMODE_DWARF\x10\x01\
    \x12\x12\n\x0eMODE_ADVENTURE\x10\x02\x12\x10\n\x0cMODE_LEGENDS\x10\x03\
    \x1a\0:\0\"\xb2\x05\n\x0cListEnumsOut\x12>\n\x0ematerial_flags\x18\x01\
    \x20\x03(\x0b2\x15.dfproto.EnumItemNameR\rmaterialFlagsB\0\x12@\n\x0fino\
    rganic_flags\x18\x02\x20\x03(\x0b2\x15.dfproto.EnumItemNameR\x0einorgani\
    cFlagsB\0\x128\n\x0bunit_flags1\x18\x03\x20\x03(\x0b2\x15.dfproto.EnumIt\
    emNameR\nunitFlags1B\0\x128\n\x0bunit_flags2\x18\x04\x20\x03(\x0b2\x15.d\
    fproto.EnumItemNameR\nunitFlags2B\0\x128\n\x0bunit_flags3\x18\x05\x20\
    \x03(\x0b2\x15.dfproto.EnumItemNameR\nunitFlags3B\0\x126\n\nunit_labor\
    \x18\x06\x20\x03(\x0b2\x15.dfproto.EnumItemNameR\tunitLaborB\0\x124\n\tj\
    ob_skill\x18\x07\x20\x03(\x0b2\x15.dfproto.EnumItemNameR\x08jobSkillB\0\
    \x12B\n\x11cie_add_tag_mask1\x18\x08\x20\x03(\x0b2\x15.dfproto.EnumItemN\
    ameR\x0ecieAddTagMask1B\0\x12B\n\x11cie_add_tag_mask2\x18\t\x20\x03(\x0b\
    2\x15.dfproto.EnumItemNameR\x0ecieAddTagMask2B\0\x12A\n\x10death_info_fl\
    ags\x18\n\x20\x03(\x0b2\x15.dfproto.EnumItemNameR\x0edeathInfoFlagsB\0\
    \x127\n\nprofession\x18\x0b\x20\x03(\x0b2\x15.dfproto.EnumItemNameR\npro\
    fessionB\0:\0\"\xae\x01\n\x10ListJobSkillsOut\x12-\n\x05skill\x18\x01\
    \x20\x03(\x0b2\x15.dfproto.JobSkillAttrR\x05skillB\0\x129\n\nprofession\
    \x18\x02\x20\x03(\x0b2\x17.dfproto.ProfessionAttrR\nprofessionB\0\x12.\n\
    \x05labor\x18\x03\x20\x03(\x0b2\x16.dfproto.UnitLaborAttrR\x05laborB\0:\
    \0\"\xf4\x01\n\x0fListMaterialsIn\x124\n\x04mask\x18\x01\x20\x01(\x0b2\
    \x1e.dfproto.BasicMaterialInfoMaskR\x04maskB\0\x123\n\x07id_list\x18\x02\
    \x20\x03(\x0b2\x18.dfproto.BasicMaterialIdR\x06idListB\0\x12\x1a\n\x07bu\
    iltin\x18\x03\x20\x01(\x08R\x07builtinB\0\x12\x1e\n\tinorganic\x18\x04\
    \x20\x01(\x08R\tinorganicB\0\x12\x1e\n\tcreatures\x18\x05\x20\x01(\x08R\
    \tcreaturesB\0\x12\x18\n\x06plants\x18\x06\x20\x01(\x08R\x06plantsB\0:\0\
    \"H\n\x10ListMaterialsOut\x122\n\x05value\x18\x01\x20\x03(\x0b2\x1a.dfpr\
    oto.BasicMaterialInfoR\x05valueB\0:\0\"\xec\x01\n\x0bListUnitsIn\x120\n\
    \x04mask\x18\x01\x20\x01(\x0b2\x1a.dfproto.BasicUnitInfoMaskR\x04maskB\0\
    \x12\x19\n\x07id_list\x18\x02\x20\x03(\x05R\x06idListB\0\x12\x1b\n\x08sc\
    an_all\x18\x05\x20\x01(\x08R\x07scanAllB\0\x12\x14\n\x04race\x18\x03\x20\
    \x01(\x05R\x04raceB\0\x12\x17\n\x06civ_id\x18\x04\x20\x01(\x05R\x05civId\
    B\0\x12\x14\n\x04dead\x18\x06\x20\x01(\x08R\x04deadB\0\x12\x16\n\x05aliv\
    e\x18\x07\x20\x01(\x08R\x05aliveB\0\x12\x14\n\x04sane\x18\x08\x20\x01(\
    \x08R\x04saneB\0:\0\"@\n\x0cListUnitsOut\x12.\n\x05value\x18\x01\x20\x03\
    (\x0b2\x16.dfproto.BasicUnitInfoR\x05valueB\0:\0\"\x10\n\x0cListSquadsIn\
    :\0\"B\n\rListSquadsOut\x12/\n\x05value\x18\x01\x20\x03(\x0b2\x17.dfprot\
    o.BasicSquadInfoR\x05valueB\0:\0\"F\n\x0fSetUnitLaborsIn\x121\n\x06chang\
    e\x18\x01\x20\x03(\x0b2\x17.dfproto.UnitLaborStateR\x06changeB\0:\0B\0b\
    \x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
