// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `DwarfControl.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct SidebarState {
    // message fields
    mode: ::std::option::Option<super::ui_sidebar_mode::ui_sidebar_mode>,
    pub menu_items: ::protobuf::RepeatedField<MenuItem>,
    pub build_selector: ::protobuf::SingularPtrField<BuildSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SidebarState {
    fn default() -> &'a SidebarState {
        <SidebarState as ::protobuf::Message>::default_instance()
    }
}

impl SidebarState {
    pub fn new() -> SidebarState {
        ::std::default::Default::default()
    }

    // optional .proto.enums.ui_sidebar_mode.ui_sidebar_mode mode = 1;


    pub fn get_mode(&self) -> super::ui_sidebar_mode::ui_sidebar_mode {
        self.mode.unwrap_or(super::ui_sidebar_mode::ui_sidebar_mode::Default)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::ui_sidebar_mode::ui_sidebar_mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    // repeated .DwarfControl.MenuItem menu_items = 2;


    pub fn get_menu_items(&self) -> &[MenuItem] {
        &self.menu_items
    }
    pub fn clear_menu_items(&mut self) {
        self.menu_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_menu_items(&mut self, v: ::protobuf::RepeatedField<MenuItem>) {
        self.menu_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_menu_items(&mut self) -> &mut ::protobuf::RepeatedField<MenuItem> {
        &mut self.menu_items
    }

    // Take field
    pub fn take_menu_items(&mut self) -> ::protobuf::RepeatedField<MenuItem> {
        ::std::mem::replace(&mut self.menu_items, ::protobuf::RepeatedField::new())
    }

    // optional .DwarfControl.BuildSelector build_selector = 3;


    pub fn get_build_selector(&self) -> &BuildSelector {
        self.build_selector.as_ref().unwrap_or_else(|| <BuildSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_build_selector(&mut self) {
        self.build_selector.clear();
    }

    pub fn has_build_selector(&self) -> bool {
        self.build_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_selector(&mut self, v: BuildSelector) {
        self.build_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_selector(&mut self) -> &mut BuildSelector {
        if self.build_selector.is_none() {
            self.build_selector.set_default();
        }
        self.build_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_selector(&mut self) -> BuildSelector {
        self.build_selector.take().unwrap_or_else(|| BuildSelector::new())
    }
}

impl ::protobuf::Message for SidebarState {
    fn is_initialized(&self) -> bool {
        for v in &self.menu_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.menu_items)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.build_selector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.menu_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.build_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.menu_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.build_selector.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SidebarState {
        SidebarState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::ui_sidebar_mode::ui_sidebar_mode>>(
                "mode",
                |m: &SidebarState| { &m.mode },
                |m: &mut SidebarState| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MenuItem>>(
                "menu_items",
                |m: &SidebarState| { &m.menu_items },
                |m: &mut SidebarState| { &mut m.menu_items },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildSelector>>(
                "build_selector",
                |m: &SidebarState| { &m.build_selector },
                |m: &mut SidebarState| { &mut m.build_selector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SidebarState>(
                "SidebarState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SidebarState {
        static instance: ::protobuf::rt::LazyV2<SidebarState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SidebarState::new)
    }
}

impl ::protobuf::Clear for SidebarState {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.menu_items.clear();
        self.build_selector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SidebarState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SidebarState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MenuItem {
    // message fields
    pub building_type: ::protobuf::SingularPtrField<super::RemoteFortressReader::BuildingType>,
    existing_count: ::std::option::Option<i32>,
    build_category: ::std::option::Option<BuildCategory>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MenuItem {
    fn default() -> &'a MenuItem {
        <MenuItem as ::protobuf::Message>::default_instance()
    }
}

impl MenuItem {
    pub fn new() -> MenuItem {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.BuildingType building_type = 1;


    pub fn get_building_type(&self) -> &super::RemoteFortressReader::BuildingType {
        self.building_type.as_ref().unwrap_or_else(|| <super::RemoteFortressReader::BuildingType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_building_type(&mut self) {
        self.building_type.clear();
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: super::RemoteFortressReader::BuildingType) {
        self.building_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_building_type(&mut self) -> &mut super::RemoteFortressReader::BuildingType {
        if self.building_type.is_none() {
            self.building_type.set_default();
        }
        self.building_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_building_type(&mut self) -> super::RemoteFortressReader::BuildingType {
        self.building_type.take().unwrap_or_else(|| super::RemoteFortressReader::BuildingType::new())
    }

    // optional int32 existing_count = 2;


    pub fn get_existing_count(&self) -> i32 {
        self.existing_count.unwrap_or(0)
    }
    pub fn clear_existing_count(&mut self) {
        self.existing_count = ::std::option::Option::None;
    }

    pub fn has_existing_count(&self) -> bool {
        self.existing_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existing_count(&mut self, v: i32) {
        self.existing_count = ::std::option::Option::Some(v);
    }

    // optional .DwarfControl.BuildCategory build_category = 3;


    pub fn get_build_category(&self) -> BuildCategory {
        self.build_category.unwrap_or(BuildCategory::NotCategory)
    }
    pub fn clear_build_category(&mut self) {
        self.build_category = ::std::option::Option::None;
    }

    pub fn has_build_category(&self) -> bool {
        self.build_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_category(&mut self, v: BuildCategory) {
        self.build_category = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MenuItem {
    fn is_initialized(&self) -> bool {
        for v in &self.building_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.building_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.existing_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.build_category, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.building_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.existing_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.build_category {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.building_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.existing_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.build_category {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MenuItem {
        MenuItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::RemoteFortressReader::BuildingType>>(
                "building_type",
                |m: &MenuItem| { &m.building_type },
                |m: &mut MenuItem| { &mut m.building_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "existing_count",
                |m: &MenuItem| { &m.existing_count },
                |m: &mut MenuItem| { &mut m.existing_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BuildCategory>>(
                "build_category",
                |m: &MenuItem| { &m.build_category },
                |m: &mut MenuItem| { &mut m.build_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MenuItem>(
                "MenuItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MenuItem {
        static instance: ::protobuf::rt::LazyV2<MenuItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MenuItem::new)
    }
}

impl ::protobuf::Clear for MenuItem {
    fn clear(&mut self) {
        self.building_type.clear();
        self.existing_count = ::std::option::Option::None;
        self.build_category = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MenuItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MenuItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SidebarCommand {
    // message fields
    mode: ::std::option::Option<super::ui_sidebar_mode::ui_sidebar_mode>,
    menu_index: ::std::option::Option<i32>,
    action: ::std::option::Option<MenuAction>,
    pub selection_coord: ::protobuf::SingularPtrField<super::RemoteFortressReader::Coord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SidebarCommand {
    fn default() -> &'a SidebarCommand {
        <SidebarCommand as ::protobuf::Message>::default_instance()
    }
}

impl SidebarCommand {
    pub fn new() -> SidebarCommand {
        ::std::default::Default::default()
    }

    // optional .proto.enums.ui_sidebar_mode.ui_sidebar_mode mode = 1;


    pub fn get_mode(&self) -> super::ui_sidebar_mode::ui_sidebar_mode {
        self.mode.unwrap_or(super::ui_sidebar_mode::ui_sidebar_mode::Default)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::ui_sidebar_mode::ui_sidebar_mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional int32 menu_index = 2;


    pub fn get_menu_index(&self) -> i32 {
        self.menu_index.unwrap_or(0)
    }
    pub fn clear_menu_index(&mut self) {
        self.menu_index = ::std::option::Option::None;
    }

    pub fn has_menu_index(&self) -> bool {
        self.menu_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_index(&mut self, v: i32) {
        self.menu_index = ::std::option::Option::Some(v);
    }

    // optional .DwarfControl.MenuAction action = 3;


    pub fn get_action(&self) -> MenuAction {
        self.action.unwrap_or(MenuAction::MenuNone)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: MenuAction) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord selection_coord = 4;


    pub fn get_selection_coord(&self) -> &super::RemoteFortressReader::Coord {
        self.selection_coord.as_ref().unwrap_or_else(|| <super::RemoteFortressReader::Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selection_coord(&mut self) {
        self.selection_coord.clear();
    }

    pub fn has_selection_coord(&self) -> bool {
        self.selection_coord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_coord(&mut self, v: super::RemoteFortressReader::Coord) {
        self.selection_coord = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selection_coord(&mut self) -> &mut super::RemoteFortressReader::Coord {
        if self.selection_coord.is_none() {
            self.selection_coord.set_default();
        }
        self.selection_coord.as_mut().unwrap()
    }

    // Take field
    pub fn take_selection_coord(&mut self) -> super::RemoteFortressReader::Coord {
        self.selection_coord.take().unwrap_or_else(|| super::RemoteFortressReader::Coord::new())
    }
}

impl ::protobuf::Message for SidebarCommand {
    fn is_initialized(&self) -> bool {
        for v in &self.selection_coord {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.menu_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selection_coord)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.menu_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.selection_coord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.menu_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.selection_coord.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SidebarCommand {
        SidebarCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::ui_sidebar_mode::ui_sidebar_mode>>(
                "mode",
                |m: &SidebarCommand| { &m.mode },
                |m: &mut SidebarCommand| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "menu_index",
                |m: &SidebarCommand| { &m.menu_index },
                |m: &mut SidebarCommand| { &mut m.menu_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MenuAction>>(
                "action",
                |m: &SidebarCommand| { &m.action },
                |m: &mut SidebarCommand| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::RemoteFortressReader::Coord>>(
                "selection_coord",
                |m: &SidebarCommand| { &m.selection_coord },
                |m: &mut SidebarCommand| { &mut m.selection_coord },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SidebarCommand>(
                "SidebarCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SidebarCommand {
        static instance: ::protobuf::rt::LazyV2<SidebarCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SidebarCommand::new)
    }
}

impl ::protobuf::Clear for SidebarCommand {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.menu_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.selection_coord.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SidebarCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SidebarCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuiildReqChoice {
    // message fields
    distance: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    num_candidates: ::std::option::Option<i32>,
    used_count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuiildReqChoice {
    fn default() -> &'a BuiildReqChoice {
        <BuiildReqChoice as ::protobuf::Message>::default_instance()
    }
}

impl BuiildReqChoice {
    pub fn new() -> BuiildReqChoice {
        ::std::default::Default::default()
    }

    // optional int32 distance = 1;


    pub fn get_distance(&self) -> i32 {
        self.distance.unwrap_or(0)
    }
    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: i32) {
        self.distance = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 num_candidates = 3;


    pub fn get_num_candidates(&self) -> i32 {
        self.num_candidates.unwrap_or(0)
    }
    pub fn clear_num_candidates(&mut self) {
        self.num_candidates = ::std::option::Option::None;
    }

    pub fn has_num_candidates(&self) -> bool {
        self.num_candidates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_candidates(&mut self, v: i32) {
        self.num_candidates = ::std::option::Option::Some(v);
    }

    // optional int32 used_count = 4;


    pub fn get_used_count(&self) -> i32 {
        self.used_count.unwrap_or(0)
    }
    pub fn clear_used_count(&mut self) {
        self.used_count = ::std::option::Option::None;
    }

    pub fn has_used_count(&self) -> bool {
        self.used_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used_count(&mut self, v: i32) {
        self.used_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BuiildReqChoice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.distance = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_candidates = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.used_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.distance {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.num_candidates {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.distance {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.num_candidates {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.used_count {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuiildReqChoice {
        BuiildReqChoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "distance",
                |m: &BuiildReqChoice| { &m.distance },
                |m: &mut BuiildReqChoice| { &mut m.distance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BuiildReqChoice| { &m.name },
                |m: &mut BuiildReqChoice| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_candidates",
                |m: &BuiildReqChoice| { &m.num_candidates },
                |m: &mut BuiildReqChoice| { &mut m.num_candidates },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "used_count",
                |m: &BuiildReqChoice| { &m.used_count },
                |m: &mut BuiildReqChoice| { &mut m.used_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuiildReqChoice>(
                "BuiildReqChoice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuiildReqChoice {
        static instance: ::protobuf::rt::LazyV2<BuiildReqChoice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuiildReqChoice::new)
    }
}

impl ::protobuf::Clear for BuiildReqChoice {
    fn clear(&mut self) {
        self.distance = ::std::option::Option::None;
        self.name.clear();
        self.num_candidates = ::std::option::Option::None;
        self.used_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuiildReqChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuiildReqChoice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildItemReq {
    // message fields
    count_required: ::std::option::Option<i32>,
    count_max: ::std::option::Option<i32>,
    count_provided: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildItemReq {
    fn default() -> &'a BuildItemReq {
        <BuildItemReq as ::protobuf::Message>::default_instance()
    }
}

impl BuildItemReq {
    pub fn new() -> BuildItemReq {
        ::std::default::Default::default()
    }

    // optional int32 count_required = 2;


    pub fn get_count_required(&self) -> i32 {
        self.count_required.unwrap_or(0)
    }
    pub fn clear_count_required(&mut self) {
        self.count_required = ::std::option::Option::None;
    }

    pub fn has_count_required(&self) -> bool {
        self.count_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_required(&mut self, v: i32) {
        self.count_required = ::std::option::Option::Some(v);
    }

    // optional int32 count_max = 3;


    pub fn get_count_max(&self) -> i32 {
        self.count_max.unwrap_or(0)
    }
    pub fn clear_count_max(&mut self) {
        self.count_max = ::std::option::Option::None;
    }

    pub fn has_count_max(&self) -> bool {
        self.count_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_max(&mut self, v: i32) {
        self.count_max = ::std::option::Option::Some(v);
    }

    // optional int32 count_provided = 4;


    pub fn get_count_provided(&self) -> i32 {
        self.count_provided.unwrap_or(0)
    }
    pub fn clear_count_provided(&mut self) {
        self.count_provided = ::std::option::Option::None;
    }

    pub fn has_count_provided(&self) -> bool {
        self.count_provided.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_provided(&mut self, v: i32) {
        self.count_provided = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BuildItemReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count_required = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count_max = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count_provided = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count_required {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_max {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_provided {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count_required {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.count_max {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.count_provided {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildItemReq {
        BuildItemReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count_required",
                |m: &BuildItemReq| { &m.count_required },
                |m: &mut BuildItemReq| { &mut m.count_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count_max",
                |m: &BuildItemReq| { &m.count_max },
                |m: &mut BuildItemReq| { &mut m.count_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count_provided",
                |m: &BuildItemReq| { &m.count_provided },
                |m: &mut BuildItemReq| { &mut m.count_provided },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildItemReq>(
                "BuildItemReq",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildItemReq {
        static instance: ::protobuf::rt::LazyV2<BuildItemReq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildItemReq::new)
    }
}

impl ::protobuf::Clear for BuildItemReq {
    fn clear(&mut self) {
        self.count_required = ::std::option::Option::None;
        self.count_max = ::std::option::Option::None;
        self.count_provided = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildItemReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildItemReq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildSelector {
    // message fields
    pub building_type: ::protobuf::SingularPtrField<super::RemoteFortressReader::BuildingType>,
    stage: ::std::option::Option<BuildSelectorStage>,
    pub choices: ::protobuf::RepeatedField<BuiildReqChoice>,
    sel_index: ::std::option::Option<i32>,
    pub requirements: ::protobuf::RepeatedField<BuildItemReq>,
    req_index: ::std::option::Option<i32>,
    pub errors: ::protobuf::RepeatedField<::std::string::String>,
    radius_x_low: ::std::option::Option<i32>,
    radius_y_low: ::std::option::Option<i32>,
    radius_x_high: ::std::option::Option<i32>,
    radius_y_high: ::std::option::Option<i32>,
    pub cursor: ::protobuf::SingularPtrField<super::RemoteFortressReader::Coord>,
    pub tiles: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildSelector {
    fn default() -> &'a BuildSelector {
        <BuildSelector as ::protobuf::Message>::default_instance()
    }
}

impl BuildSelector {
    pub fn new() -> BuildSelector {
        ::std::default::Default::default()
    }

    // optional .RemoteFortressReader.BuildingType building_type = 1;


    pub fn get_building_type(&self) -> &super::RemoteFortressReader::BuildingType {
        self.building_type.as_ref().unwrap_or_else(|| <super::RemoteFortressReader::BuildingType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_building_type(&mut self) {
        self.building_type.clear();
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: super::RemoteFortressReader::BuildingType) {
        self.building_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_building_type(&mut self) -> &mut super::RemoteFortressReader::BuildingType {
        if self.building_type.is_none() {
            self.building_type.set_default();
        }
        self.building_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_building_type(&mut self) -> super::RemoteFortressReader::BuildingType {
        self.building_type.take().unwrap_or_else(|| super::RemoteFortressReader::BuildingType::new())
    }

    // optional .DwarfControl.BuildSelectorStage stage = 2;


    pub fn get_stage(&self) -> BuildSelectorStage {
        self.stage.unwrap_or(BuildSelectorStage::StageNoMat)
    }
    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: BuildSelectorStage) {
        self.stage = ::std::option::Option::Some(v);
    }

    // repeated .DwarfControl.BuiildReqChoice choices = 3;


    pub fn get_choices(&self) -> &[BuiildReqChoice] {
        &self.choices
    }
    pub fn clear_choices(&mut self) {
        self.choices.clear();
    }

    // Param is passed by value, moved
    pub fn set_choices(&mut self, v: ::protobuf::RepeatedField<BuiildReqChoice>) {
        self.choices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choices(&mut self) -> &mut ::protobuf::RepeatedField<BuiildReqChoice> {
        &mut self.choices
    }

    // Take field
    pub fn take_choices(&mut self) -> ::protobuf::RepeatedField<BuiildReqChoice> {
        ::std::mem::replace(&mut self.choices, ::protobuf::RepeatedField::new())
    }

    // optional int32 sel_index = 4;


    pub fn get_sel_index(&self) -> i32 {
        self.sel_index.unwrap_or(0)
    }
    pub fn clear_sel_index(&mut self) {
        self.sel_index = ::std::option::Option::None;
    }

    pub fn has_sel_index(&self) -> bool {
        self.sel_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sel_index(&mut self, v: i32) {
        self.sel_index = ::std::option::Option::Some(v);
    }

    // repeated .DwarfControl.BuildItemReq requirements = 5;


    pub fn get_requirements(&self) -> &[BuildItemReq] {
        &self.requirements
    }
    pub fn clear_requirements(&mut self) {
        self.requirements.clear();
    }

    // Param is passed by value, moved
    pub fn set_requirements(&mut self, v: ::protobuf::RepeatedField<BuildItemReq>) {
        self.requirements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requirements(&mut self) -> &mut ::protobuf::RepeatedField<BuildItemReq> {
        &mut self.requirements
    }

    // Take field
    pub fn take_requirements(&mut self) -> ::protobuf::RepeatedField<BuildItemReq> {
        ::std::mem::replace(&mut self.requirements, ::protobuf::RepeatedField::new())
    }

    // optional int32 req_index = 6;


    pub fn get_req_index(&self) -> i32 {
        self.req_index.unwrap_or(0)
    }
    pub fn clear_req_index(&mut self) {
        self.req_index = ::std::option::Option::None;
    }

    pub fn has_req_index(&self) -> bool {
        self.req_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_req_index(&mut self, v: i32) {
        self.req_index = ::std::option::Option::Some(v);
    }

    // repeated string errors = 7;


    pub fn get_errors(&self) -> &[::std::string::String] {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.errors, ::protobuf::RepeatedField::new())
    }

    // optional int32 radius_x_low = 8;


    pub fn get_radius_x_low(&self) -> i32 {
        self.radius_x_low.unwrap_or(0)
    }
    pub fn clear_radius_x_low(&mut self) {
        self.radius_x_low = ::std::option::Option::None;
    }

    pub fn has_radius_x_low(&self) -> bool {
        self.radius_x_low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius_x_low(&mut self, v: i32) {
        self.radius_x_low = ::std::option::Option::Some(v);
    }

    // optional int32 radius_y_low = 9;


    pub fn get_radius_y_low(&self) -> i32 {
        self.radius_y_low.unwrap_or(0)
    }
    pub fn clear_radius_y_low(&mut self) {
        self.radius_y_low = ::std::option::Option::None;
    }

    pub fn has_radius_y_low(&self) -> bool {
        self.radius_y_low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius_y_low(&mut self, v: i32) {
        self.radius_y_low = ::std::option::Option::Some(v);
    }

    // optional int32 radius_x_high = 10;


    pub fn get_radius_x_high(&self) -> i32 {
        self.radius_x_high.unwrap_or(0)
    }
    pub fn clear_radius_x_high(&mut self) {
        self.radius_x_high = ::std::option::Option::None;
    }

    pub fn has_radius_x_high(&self) -> bool {
        self.radius_x_high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius_x_high(&mut self, v: i32) {
        self.radius_x_high = ::std::option::Option::Some(v);
    }

    // optional int32 radius_y_high = 11;


    pub fn get_radius_y_high(&self) -> i32 {
        self.radius_y_high.unwrap_or(0)
    }
    pub fn clear_radius_y_high(&mut self) {
        self.radius_y_high = ::std::option::Option::None;
    }

    pub fn has_radius_y_high(&self) -> bool {
        self.radius_y_high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius_y_high(&mut self, v: i32) {
        self.radius_y_high = ::std::option::Option::Some(v);
    }

    // optional .RemoteFortressReader.Coord cursor = 12;


    pub fn get_cursor(&self) -> &super::RemoteFortressReader::Coord {
        self.cursor.as_ref().unwrap_or_else(|| <super::RemoteFortressReader::Coord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: super::RemoteFortressReader::Coord) {
        self.cursor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut super::RemoteFortressReader::Coord {
        if self.cursor.is_none() {
            self.cursor.set_default();
        }
        self.cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_cursor(&mut self) -> super::RemoteFortressReader::Coord {
        self.cursor.take().unwrap_or_else(|| super::RemoteFortressReader::Coord::new())
    }

    // repeated int32 tiles = 13;


    pub fn get_tiles(&self) -> &[i32] {
        &self.tiles
    }
    pub fn clear_tiles(&mut self) {
        self.tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiles(&mut self, v: ::std::vec::Vec<i32>) {
        self.tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiles(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.tiles
    }

    // Take field
    pub fn take_tiles(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.tiles, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BuildSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.building_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.choices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requirements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cursor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.building_type)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stage, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.choices)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sel_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requirements)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.req_index = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.errors)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.radius_x_low = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.radius_y_low = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.radius_x_high = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.radius_y_high = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cursor)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.tiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.building_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        for value in &self.choices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.sel_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requirements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.req_index {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.errors {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.radius_x_low {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.radius_y_low {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.radius_x_high {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.radius_y_high {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cursor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tiles {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.building_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stage {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.choices {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.sel_index {
            os.write_int32(4, v)?;
        }
        for v in &self.requirements {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.req_index {
            os.write_int32(6, v)?;
        }
        for v in &self.errors {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.radius_x_low {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.radius_y_low {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.radius_x_high {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.radius_y_high {
            os.write_int32(11, v)?;
        }
        if let Some(ref v) = self.cursor.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tiles {
            os.write_int32(13, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildSelector {
        BuildSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::RemoteFortressReader::BuildingType>>(
                "building_type",
                |m: &BuildSelector| { &m.building_type },
                |m: &mut BuildSelector| { &mut m.building_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BuildSelectorStage>>(
                "stage",
                |m: &BuildSelector| { &m.stage },
                |m: &mut BuildSelector| { &mut m.stage },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuiildReqChoice>>(
                "choices",
                |m: &BuildSelector| { &m.choices },
                |m: &mut BuildSelector| { &mut m.choices },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sel_index",
                |m: &BuildSelector| { &m.sel_index },
                |m: &mut BuildSelector| { &mut m.sel_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildItemReq>>(
                "requirements",
                |m: &BuildSelector| { &m.requirements },
                |m: &mut BuildSelector| { &mut m.requirements },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "req_index",
                |m: &BuildSelector| { &m.req_index },
                |m: &mut BuildSelector| { &mut m.req_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errors",
                |m: &BuildSelector| { &m.errors },
                |m: &mut BuildSelector| { &mut m.errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "radius_x_low",
                |m: &BuildSelector| { &m.radius_x_low },
                |m: &mut BuildSelector| { &mut m.radius_x_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "radius_y_low",
                |m: &BuildSelector| { &m.radius_y_low },
                |m: &mut BuildSelector| { &mut m.radius_y_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "radius_x_high",
                |m: &BuildSelector| { &m.radius_x_high },
                |m: &mut BuildSelector| { &mut m.radius_x_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "radius_y_high",
                |m: &BuildSelector| { &m.radius_y_high },
                |m: &mut BuildSelector| { &mut m.radius_y_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::RemoteFortressReader::Coord>>(
                "cursor",
                |m: &BuildSelector| { &m.cursor },
                |m: &mut BuildSelector| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tiles",
                |m: &BuildSelector| { &m.tiles },
                |m: &mut BuildSelector| { &mut m.tiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildSelector>(
                "BuildSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildSelector {
        static instance: ::protobuf::rt::LazyV2<BuildSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildSelector::new)
    }
}

impl ::protobuf::Clear for BuildSelector {
    fn clear(&mut self) {
        self.building_type.clear();
        self.stage = ::std::option::Option::None;
        self.choices.clear();
        self.sel_index = ::std::option::Option::None;
        self.requirements.clear();
        self.req_index = ::std::option::Option::None;
        self.errors.clear();
        self.radius_x_low = ::std::option::Option::None;
        self.radius_y_low = ::std::option::Option::None;
        self.radius_x_high = ::std::option::Option::None;
        self.radius_y_high = ::std::option::Option::None;
        self.cursor.clear();
        self.tiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuildCategory {
    NotCategory = 0,
    SiegeEngines = 1,
    Traps = 2,
    Workshops = 3,
    Furnaces = 4,
    Constructions = 5,
    MachineComponents = 6,
    Track = 7,
}

impl ::protobuf::ProtobufEnum for BuildCategory {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuildCategory> {
        match value {
            0 => ::std::option::Option::Some(BuildCategory::NotCategory),
            1 => ::std::option::Option::Some(BuildCategory::SiegeEngines),
            2 => ::std::option::Option::Some(BuildCategory::Traps),
            3 => ::std::option::Option::Some(BuildCategory::Workshops),
            4 => ::std::option::Option::Some(BuildCategory::Furnaces),
            5 => ::std::option::Option::Some(BuildCategory::Constructions),
            6 => ::std::option::Option::Some(BuildCategory::MachineComponents),
            7 => ::std::option::Option::Some(BuildCategory::Track),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuildCategory] = &[
            BuildCategory::NotCategory,
            BuildCategory::SiegeEngines,
            BuildCategory::Traps,
            BuildCategory::Workshops,
            BuildCategory::Furnaces,
            BuildCategory::Constructions,
            BuildCategory::MachineComponents,
            BuildCategory::Track,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BuildCategory>("BuildCategory", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BuildCategory {
}

impl ::std::default::Default for BuildCategory {
    fn default() -> Self {
        BuildCategory::NotCategory
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildCategory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MenuAction {
    MenuNone = 0,
    MenuSelect = 1,
    MenuCancel = 2,
    MenuSelectAll = 3,
}

impl ::protobuf::ProtobufEnum for MenuAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MenuAction> {
        match value {
            0 => ::std::option::Option::Some(MenuAction::MenuNone),
            1 => ::std::option::Option::Some(MenuAction::MenuSelect),
            2 => ::std::option::Option::Some(MenuAction::MenuCancel),
            3 => ::std::option::Option::Some(MenuAction::MenuSelectAll),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MenuAction] = &[
            MenuAction::MenuNone,
            MenuAction::MenuSelect,
            MenuAction::MenuCancel,
            MenuAction::MenuSelectAll,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MenuAction>("MenuAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MenuAction {
}

impl ::std::default::Default for MenuAction {
    fn default() -> Self {
        MenuAction::MenuNone
    }
}

impl ::protobuf::reflect::ProtobufValue for MenuAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuildSelectorStage {
    StageNoMat = 0,
    StagePlace = 1,
    StageItemSelect = 2,
}

impl ::protobuf::ProtobufEnum for BuildSelectorStage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuildSelectorStage> {
        match value {
            0 => ::std::option::Option::Some(BuildSelectorStage::StageNoMat),
            1 => ::std::option::Option::Some(BuildSelectorStage::StagePlace),
            2 => ::std::option::Option::Some(BuildSelectorStage::StageItemSelect),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuildSelectorStage] = &[
            BuildSelectorStage::StageNoMat,
            BuildSelectorStage::StagePlace,
            BuildSelectorStage::StageItemSelect,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BuildSelectorStage>("BuildSelectorStage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BuildSelectorStage {
}

impl ::std::default::Default for BuildSelectorStage {
    fn default() -> Self {
        BuildSelectorStage::StageNoMat
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildSelectorStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12DwarfControl.proto\x12\x0cDwarfControl\x1a\x15ui_sidebar_mode.prot\
    o\x1a\x1aRemoteFortressReader.proto\"\xd3\x01\n\x0cSidebarState\x12B\n\
    \x04mode\x18\x01\x20\x01(\x0e2,.proto.enums.ui_sidebar_mode.ui_sidebar_m\
    odeR\x04modeB\0\x127\n\nmenu_items\x18\x02\x20\x03(\x0b2\x16.DwarfContro\
    l.MenuItemR\tmenuItemsB\0\x12D\n\x0ebuild_selector\x18\x03\x20\x01(\x0b2\
    \x1b.DwarfControl.BuildSelectorR\rbuildSelectorB\0:\0\"\xc6\x01\n\x08Men\
    uItem\x12I\n\rbuilding_type\x18\x01\x20\x01(\x0b2\".RemoteFortressReader\
    .BuildingTypeR\x0cbuildingTypeB\0\x12'\n\x0eexisting_count\x18\x02\x20\
    \x01(\x05R\rexistingCountB\0\x12D\n\x0ebuild_category\x18\x03\x20\x01(\
    \x0e2\x1b.DwarfControl.BuildCategoryR\rbuildCategoryB\0:\0\"\xf3\x01\n\
    \x0eSidebarCommand\x12B\n\x04mode\x18\x01\x20\x01(\x0e2,.proto.enums.ui_\
    sidebar_mode.ui_sidebar_modeR\x04modeB\0\x12\x1f\n\nmenu_index\x18\x02\
    \x20\x01(\x05R\tmenuIndexB\0\x122\n\x06action\x18\x03\x20\x01(\x0e2\x18.\
    DwarfControl.MenuActionR\x06actionB\0\x12F\n\x0fselection_coord\x18\x04\
    \x20\x01(\x0b2\x1b.RemoteFortressReader.CoordR\x0eselectionCoordB\0:\0\"\
    \x91\x01\n\x0fBuiildReqChoice\x12\x1c\n\x08distance\x18\x01\x20\x01(\x05\
    R\x08distanceB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12'\n\
    \x0enum_candidates\x18\x03\x20\x01(\x05R\rnumCandidatesB\0\x12\x1f\n\nus\
    ed_count\x18\x04\x20\x01(\x05R\tusedCountB\0:\0\"\x81\x01\n\x0cBuildItem\
    Req\x12'\n\x0ecount_required\x18\x02\x20\x01(\x05R\rcountRequiredB\0\x12\
    \x1d\n\tcount_max\x18\x03\x20\x01(\x05R\x08countMaxB\0\x12'\n\x0ecount_p\
    rovided\x18\x04\x20\x01(\x05R\rcountProvidedB\0:\0\"\xce\x04\n\rBuildSel\
    ector\x12I\n\rbuilding_type\x18\x01\x20\x01(\x0b2\".RemoteFortressReader\
    .BuildingTypeR\x0cbuildingTypeB\0\x128\n\x05stage\x18\x02\x20\x01(\x0e2\
    \x20.DwarfControl.BuildSelectorStageR\x05stageB\0\x129\n\x07choices\x18\
    \x03\x20\x03(\x0b2\x1d.DwarfControl.BuiildReqChoiceR\x07choicesB\0\x12\
    \x1d\n\tsel_index\x18\x04\x20\x01(\x05R\x08selIndexB\0\x12@\n\x0crequire\
    ments\x18\x05\x20\x03(\x0b2\x1a.DwarfControl.BuildItemReqR\x0crequiremen\
    tsB\0\x12\x1d\n\treq_index\x18\x06\x20\x01(\x05R\x08reqIndexB\0\x12\x18\
    \n\x06errors\x18\x07\x20\x03(\tR\x06errorsB\0\x12\"\n\x0cradius_x_low\
    \x18\x08\x20\x01(\x05R\nradiusXLowB\0\x12\"\n\x0cradius_y_low\x18\t\x20\
    \x01(\x05R\nradiusYLowB\0\x12$\n\rradius_x_high\x18\n\x20\x01(\x05R\x0br\
    adiusXHighB\0\x12$\n\rradius_y_high\x18\x0b\x20\x01(\x05R\x0bradiusYHigh\
    B\0\x125\n\x06cursor\x18\x0c\x20\x01(\x0b2\x1b.RemoteFortressReader.Coor\
    dR\x06cursorB\0\x12\x16\n\x05tiles\x18\r\x20\x03(\x05R\x05tilesB\0:\0*\
    \x91\x01\n\rBuildCategory\x12\x0f\n\x0bNotCategory\x10\0\x12\x10\n\x0cSi\
    egeEngines\x10\x01\x12\t\n\x05Traps\x10\x02\x12\r\n\tWorkshops\x10\x03\
    \x12\x0c\n\x08Furnaces\x10\x04\x12\x11\n\rConstructions\x10\x05\x12\x15\
    \n\x11MachineComponents\x10\x06\x12\t\n\x05Track\x10\x07\x1a\0*O\n\nMenu\
    Action\x12\x0c\n\x08MenuNone\x10\0\x12\x0e\n\nMenuSelect\x10\x01\x12\x0e\
    \n\nMenuCancel\x10\x02\x12\x11\n\rMenuSelectAll\x10\x03\x1a\0*K\n\x12Bui\
    ldSelectorStage\x12\x0e\n\nStageNoMat\x10\0\x12\x0e\n\nStagePlace\x10\
    \x01\x12\x13\n\x0fStageItemSelect\x10\x02\x1a\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
