// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ItemdefInstrument.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct InstrumentFlags {
    // message fields
    indefinite_pitch: ::std::option::Option<bool>,
    placed_as_building: ::std::option::Option<bool>,
    metal_mat: ::std::option::Option<bool>,
    stone_mat: ::std::option::Option<bool>,
    wood_mat: ::std::option::Option<bool>,
    glass_mat: ::std::option::Option<bool>,
    ceramic_mat: ::std::option::Option<bool>,
    shell_mat: ::std::option::Option<bool>,
    bone_mat: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentFlags {
    fn default() -> &'a InstrumentFlags {
        <InstrumentFlags as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentFlags {
    pub fn new() -> InstrumentFlags {
        ::std::default::Default::default()
    }

    // optional bool indefinite_pitch = 1;


    pub fn get_indefinite_pitch(&self) -> bool {
        self.indefinite_pitch.unwrap_or(false)
    }
    pub fn clear_indefinite_pitch(&mut self) {
        self.indefinite_pitch = ::std::option::Option::None;
    }

    pub fn has_indefinite_pitch(&self) -> bool {
        self.indefinite_pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indefinite_pitch(&mut self, v: bool) {
        self.indefinite_pitch = ::std::option::Option::Some(v);
    }

    // optional bool placed_as_building = 2;


    pub fn get_placed_as_building(&self) -> bool {
        self.placed_as_building.unwrap_or(false)
    }
    pub fn clear_placed_as_building(&mut self) {
        self.placed_as_building = ::std::option::Option::None;
    }

    pub fn has_placed_as_building(&self) -> bool {
        self.placed_as_building.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placed_as_building(&mut self, v: bool) {
        self.placed_as_building = ::std::option::Option::Some(v);
    }

    // optional bool metal_mat = 3;


    pub fn get_metal_mat(&self) -> bool {
        self.metal_mat.unwrap_or(false)
    }
    pub fn clear_metal_mat(&mut self) {
        self.metal_mat = ::std::option::Option::None;
    }

    pub fn has_metal_mat(&self) -> bool {
        self.metal_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metal_mat(&mut self, v: bool) {
        self.metal_mat = ::std::option::Option::Some(v);
    }

    // optional bool stone_mat = 4;


    pub fn get_stone_mat(&self) -> bool {
        self.stone_mat.unwrap_or(false)
    }
    pub fn clear_stone_mat(&mut self) {
        self.stone_mat = ::std::option::Option::None;
    }

    pub fn has_stone_mat(&self) -> bool {
        self.stone_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stone_mat(&mut self, v: bool) {
        self.stone_mat = ::std::option::Option::Some(v);
    }

    // optional bool wood_mat = 5;


    pub fn get_wood_mat(&self) -> bool {
        self.wood_mat.unwrap_or(false)
    }
    pub fn clear_wood_mat(&mut self) {
        self.wood_mat = ::std::option::Option::None;
    }

    pub fn has_wood_mat(&self) -> bool {
        self.wood_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wood_mat(&mut self, v: bool) {
        self.wood_mat = ::std::option::Option::Some(v);
    }

    // optional bool glass_mat = 6;


    pub fn get_glass_mat(&self) -> bool {
        self.glass_mat.unwrap_or(false)
    }
    pub fn clear_glass_mat(&mut self) {
        self.glass_mat = ::std::option::Option::None;
    }

    pub fn has_glass_mat(&self) -> bool {
        self.glass_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glass_mat(&mut self, v: bool) {
        self.glass_mat = ::std::option::Option::Some(v);
    }

    // optional bool ceramic_mat = 7;


    pub fn get_ceramic_mat(&self) -> bool {
        self.ceramic_mat.unwrap_or(false)
    }
    pub fn clear_ceramic_mat(&mut self) {
        self.ceramic_mat = ::std::option::Option::None;
    }

    pub fn has_ceramic_mat(&self) -> bool {
        self.ceramic_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ceramic_mat(&mut self, v: bool) {
        self.ceramic_mat = ::std::option::Option::Some(v);
    }

    // optional bool shell_mat = 8;


    pub fn get_shell_mat(&self) -> bool {
        self.shell_mat.unwrap_or(false)
    }
    pub fn clear_shell_mat(&mut self) {
        self.shell_mat = ::std::option::Option::None;
    }

    pub fn has_shell_mat(&self) -> bool {
        self.shell_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shell_mat(&mut self, v: bool) {
        self.shell_mat = ::std::option::Option::Some(v);
    }

    // optional bool bone_mat = 9;


    pub fn get_bone_mat(&self) -> bool {
        self.bone_mat.unwrap_or(false)
    }
    pub fn clear_bone_mat(&mut self) {
        self.bone_mat = ::std::option::Option::None;
    }

    pub fn has_bone_mat(&self) -> bool {
        self.bone_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bone_mat(&mut self, v: bool) {
        self.bone_mat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for InstrumentFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.indefinite_pitch = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.placed_as_building = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.metal_mat = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stone_mat = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wood_mat = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.glass_mat = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ceramic_mat = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shell_mat = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bone_mat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.indefinite_pitch {
            my_size += 2;
        }
        if let Some(v) = self.placed_as_building {
            my_size += 2;
        }
        if let Some(v) = self.metal_mat {
            my_size += 2;
        }
        if let Some(v) = self.stone_mat {
            my_size += 2;
        }
        if let Some(v) = self.wood_mat {
            my_size += 2;
        }
        if let Some(v) = self.glass_mat {
            my_size += 2;
        }
        if let Some(v) = self.ceramic_mat {
            my_size += 2;
        }
        if let Some(v) = self.shell_mat {
            my_size += 2;
        }
        if let Some(v) = self.bone_mat {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.indefinite_pitch {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.placed_as_building {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.metal_mat {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.stone_mat {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.wood_mat {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.glass_mat {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.ceramic_mat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.shell_mat {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.bone_mat {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentFlags {
        InstrumentFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "indefinite_pitch",
                |m: &InstrumentFlags| { &m.indefinite_pitch },
                |m: &mut InstrumentFlags| { &mut m.indefinite_pitch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "placed_as_building",
                |m: &InstrumentFlags| { &m.placed_as_building },
                |m: &mut InstrumentFlags| { &mut m.placed_as_building },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "metal_mat",
                |m: &InstrumentFlags| { &m.metal_mat },
                |m: &mut InstrumentFlags| { &mut m.metal_mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stone_mat",
                |m: &InstrumentFlags| { &m.stone_mat },
                |m: &mut InstrumentFlags| { &mut m.stone_mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wood_mat",
                |m: &InstrumentFlags| { &m.wood_mat },
                |m: &mut InstrumentFlags| { &mut m.wood_mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "glass_mat",
                |m: &InstrumentFlags| { &m.glass_mat },
                |m: &mut InstrumentFlags| { &mut m.glass_mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ceramic_mat",
                |m: &InstrumentFlags| { &m.ceramic_mat },
                |m: &mut InstrumentFlags| { &mut m.ceramic_mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shell_mat",
                |m: &InstrumentFlags| { &m.shell_mat },
                |m: &mut InstrumentFlags| { &mut m.shell_mat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bone_mat",
                |m: &InstrumentFlags| { &m.bone_mat },
                |m: &mut InstrumentFlags| { &mut m.bone_mat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentFlags>(
                "InstrumentFlags",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentFlags {
        static instance: ::protobuf::rt::LazyV2<InstrumentFlags> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentFlags::new)
    }
}

impl ::protobuf::Clear for InstrumentFlags {
    fn clear(&mut self) {
        self.indefinite_pitch = ::std::option::Option::None;
        self.placed_as_building = ::std::option::Option::None;
        self.metal_mat = ::std::option::Option::None;
        self.stone_mat = ::std::option::Option::None;
        self.wood_mat = ::std::option::Option::None;
        self.glass_mat = ::std::option::Option::None;
        self.ceramic_mat = ::std::option::Option::None;
        self.shell_mat = ::std::option::Option::None;
        self.bone_mat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstrumentPiece {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    name_plural: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentPiece {
    fn default() -> &'a InstrumentPiece {
        <InstrumentPiece as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentPiece {
    pub fn new() -> InstrumentPiece {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_plural = 4;


    pub fn get_name_plural(&self) -> &str {
        match self.name_plural.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name_plural(&mut self) {
        self.name_plural.clear();
    }

    pub fn has_name_plural(&self) -> bool {
        self.name_plural.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_plural(&mut self, v: ::std::string::String) {
        self.name_plural = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_plural(&mut self) -> &mut ::std::string::String {
        if self.name_plural.is_none() {
            self.name_plural.set_default();
        }
        self.name_plural.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_plural(&mut self) -> ::std::string::String {
        self.name_plural.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for InstrumentPiece {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_plural)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.name_plural.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.name_plural.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentPiece {
        InstrumentPiece::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &InstrumentPiece| { &m.field_type },
                |m: &mut InstrumentPiece| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &InstrumentPiece| { &m.id },
                |m: &mut InstrumentPiece| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &InstrumentPiece| { &m.name },
                |m: &mut InstrumentPiece| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name_plural",
                |m: &InstrumentPiece| { &m.name_plural },
                |m: &mut InstrumentPiece| { &mut m.name_plural },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentPiece>(
                "InstrumentPiece",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentPiece {
        static instance: ::protobuf::rt::LazyV2<InstrumentPiece> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentPiece::new)
    }
}

impl ::protobuf::Clear for InstrumentPiece {
    fn clear(&mut self) {
        self.field_type.clear();
        self.id.clear();
        self.name.clear();
        self.name_plural.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentPiece {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentPiece {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstrumentRegister {
    // message fields
    pitch_range_min: ::std::option::Option<i32>,
    pitch_range_max: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentRegister {
    fn default() -> &'a InstrumentRegister {
        <InstrumentRegister as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentRegister {
    pub fn new() -> InstrumentRegister {
        ::std::default::Default::default()
    }

    // optional int32 pitch_range_min = 1;


    pub fn get_pitch_range_min(&self) -> i32 {
        self.pitch_range_min.unwrap_or(0)
    }
    pub fn clear_pitch_range_min(&mut self) {
        self.pitch_range_min = ::std::option::Option::None;
    }

    pub fn has_pitch_range_min(&self) -> bool {
        self.pitch_range_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_min(&mut self, v: i32) {
        self.pitch_range_min = ::std::option::Option::Some(v);
    }

    // optional int32 pitch_range_max = 2;


    pub fn get_pitch_range_max(&self) -> i32 {
        self.pitch_range_max.unwrap_or(0)
    }
    pub fn clear_pitch_range_max(&mut self) {
        self.pitch_range_max = ::std::option::Option::None;
    }

    pub fn has_pitch_range_max(&self) -> bool {
        self.pitch_range_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_max(&mut self, v: i32) {
        self.pitch_range_max = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for InstrumentRegister {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pitch_range_min = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pitch_range_max = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pitch_range_min {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pitch_range_max {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pitch_range_min {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pitch_range_max {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentRegister {
        InstrumentRegister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pitch_range_min",
                |m: &InstrumentRegister| { &m.pitch_range_min },
                |m: &mut InstrumentRegister| { &mut m.pitch_range_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pitch_range_max",
                |m: &InstrumentRegister| { &m.pitch_range_max },
                |m: &mut InstrumentRegister| { &mut m.pitch_range_max },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentRegister>(
                "InstrumentRegister",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentRegister {
        static instance: ::protobuf::rt::LazyV2<InstrumentRegister> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentRegister::new)
    }
}

impl ::protobuf::Clear for InstrumentRegister {
    fn clear(&mut self) {
        self.pitch_range_min = ::std::option::Option::None;
        self.pitch_range_max = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentRegister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentRegister {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstrumentDef {
    // message fields
    pub flags: ::protobuf::SingularPtrField<InstrumentFlags>,
    size: ::std::option::Option<i32>,
    value: ::std::option::Option<i32>,
    material_size: ::std::option::Option<i32>,
    pub pieces: ::protobuf::RepeatedField<InstrumentPiece>,
    pitch_range_min: ::std::option::Option<i32>,
    pitch_range_max: ::std::option::Option<i32>,
    volume_mb_min: ::std::option::Option<i32>,
    volume_mb_max: ::std::option::Option<i32>,
    pub sound_production: ::std::vec::Vec<SoundProductionType>,
    pub sound_production_parm1: ::protobuf::RepeatedField<::std::string::String>,
    pub sound_production_parm2: ::protobuf::RepeatedField<::std::string::String>,
    pub pitch_choice: ::std::vec::Vec<PitchChoiceType>,
    pub pitch_choice_parm1: ::protobuf::RepeatedField<::std::string::String>,
    pub pitch_choice_parm2: ::protobuf::RepeatedField<::std::string::String>,
    pub tuning: ::std::vec::Vec<TuningType>,
    pub tuning_parm: ::protobuf::RepeatedField<::std::string::String>,
    pub registers: ::protobuf::RepeatedField<InstrumentRegister>,
    description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentDef {
    fn default() -> &'a InstrumentDef {
        <InstrumentDef as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentDef {
    pub fn new() -> InstrumentDef {
        ::std::default::Default::default()
    }

    // optional .ItemdefInstrument.InstrumentFlags flags = 1;


    pub fn get_flags(&self) -> &InstrumentFlags {
        self.flags.as_ref().unwrap_or_else(|| <InstrumentFlags as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: InstrumentFlags) {
        self.flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&mut self) -> &mut InstrumentFlags {
        if self.flags.is_none() {
            self.flags.set_default();
        }
        self.flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_flags(&mut self) -> InstrumentFlags {
        self.flags.take().unwrap_or_else(|| InstrumentFlags::new())
    }

    // optional int32 size = 2;


    pub fn get_size(&self) -> i32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional int32 value = 3;


    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 material_size = 4;


    pub fn get_material_size(&self) -> i32 {
        self.material_size.unwrap_or(0)
    }
    pub fn clear_material_size(&mut self) {
        self.material_size = ::std::option::Option::None;
    }

    pub fn has_material_size(&self) -> bool {
        self.material_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material_size(&mut self, v: i32) {
        self.material_size = ::std::option::Option::Some(v);
    }

    // repeated .ItemdefInstrument.InstrumentPiece pieces = 5;


    pub fn get_pieces(&self) -> &[InstrumentPiece] {
        &self.pieces
    }
    pub fn clear_pieces(&mut self) {
        self.pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_pieces(&mut self, v: ::protobuf::RepeatedField<InstrumentPiece>) {
        self.pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pieces(&mut self) -> &mut ::protobuf::RepeatedField<InstrumentPiece> {
        &mut self.pieces
    }

    // Take field
    pub fn take_pieces(&mut self) -> ::protobuf::RepeatedField<InstrumentPiece> {
        ::std::mem::replace(&mut self.pieces, ::protobuf::RepeatedField::new())
    }

    // optional int32 pitch_range_min = 6;


    pub fn get_pitch_range_min(&self) -> i32 {
        self.pitch_range_min.unwrap_or(0)
    }
    pub fn clear_pitch_range_min(&mut self) {
        self.pitch_range_min = ::std::option::Option::None;
    }

    pub fn has_pitch_range_min(&self) -> bool {
        self.pitch_range_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_min(&mut self, v: i32) {
        self.pitch_range_min = ::std::option::Option::Some(v);
    }

    // optional int32 pitch_range_max = 7;


    pub fn get_pitch_range_max(&self) -> i32 {
        self.pitch_range_max.unwrap_or(0)
    }
    pub fn clear_pitch_range_max(&mut self) {
        self.pitch_range_max = ::std::option::Option::None;
    }

    pub fn has_pitch_range_max(&self) -> bool {
        self.pitch_range_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_max(&mut self, v: i32) {
        self.pitch_range_max = ::std::option::Option::Some(v);
    }

    // optional int32 volume_mb_min = 8;


    pub fn get_volume_mb_min(&self) -> i32 {
        self.volume_mb_min.unwrap_or(0)
    }
    pub fn clear_volume_mb_min(&mut self) {
        self.volume_mb_min = ::std::option::Option::None;
    }

    pub fn has_volume_mb_min(&self) -> bool {
        self.volume_mb_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_mb_min(&mut self, v: i32) {
        self.volume_mb_min = ::std::option::Option::Some(v);
    }

    // optional int32 volume_mb_max = 9;


    pub fn get_volume_mb_max(&self) -> i32 {
        self.volume_mb_max.unwrap_or(0)
    }
    pub fn clear_volume_mb_max(&mut self) {
        self.volume_mb_max = ::std::option::Option::None;
    }

    pub fn has_volume_mb_max(&self) -> bool {
        self.volume_mb_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_mb_max(&mut self, v: i32) {
        self.volume_mb_max = ::std::option::Option::Some(v);
    }

    // repeated .ItemdefInstrument.SoundProductionType sound_production = 10;


    pub fn get_sound_production(&self) -> &[SoundProductionType] {
        &self.sound_production
    }
    pub fn clear_sound_production(&mut self) {
        self.sound_production.clear();
    }

    // Param is passed by value, moved
    pub fn set_sound_production(&mut self, v: ::std::vec::Vec<SoundProductionType>) {
        self.sound_production = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sound_production(&mut self) -> &mut ::std::vec::Vec<SoundProductionType> {
        &mut self.sound_production
    }

    // Take field
    pub fn take_sound_production(&mut self) -> ::std::vec::Vec<SoundProductionType> {
        ::std::mem::replace(&mut self.sound_production, ::std::vec::Vec::new())
    }

    // repeated string sound_production_parm1 = 11;


    pub fn get_sound_production_parm1(&self) -> &[::std::string::String] {
        &self.sound_production_parm1
    }
    pub fn clear_sound_production_parm1(&mut self) {
        self.sound_production_parm1.clear();
    }

    // Param is passed by value, moved
    pub fn set_sound_production_parm1(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.sound_production_parm1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sound_production_parm1(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.sound_production_parm1
    }

    // Take field
    pub fn take_sound_production_parm1(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.sound_production_parm1, ::protobuf::RepeatedField::new())
    }

    // repeated string sound_production_parm2 = 12;


    pub fn get_sound_production_parm2(&self) -> &[::std::string::String] {
        &self.sound_production_parm2
    }
    pub fn clear_sound_production_parm2(&mut self) {
        self.sound_production_parm2.clear();
    }

    // Param is passed by value, moved
    pub fn set_sound_production_parm2(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.sound_production_parm2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sound_production_parm2(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.sound_production_parm2
    }

    // Take field
    pub fn take_sound_production_parm2(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.sound_production_parm2, ::protobuf::RepeatedField::new())
    }

    // repeated .ItemdefInstrument.PitchChoiceType pitch_choice = 13;


    pub fn get_pitch_choice(&self) -> &[PitchChoiceType] {
        &self.pitch_choice
    }
    pub fn clear_pitch_choice(&mut self) {
        self.pitch_choice.clear();
    }

    // Param is passed by value, moved
    pub fn set_pitch_choice(&mut self, v: ::std::vec::Vec<PitchChoiceType>) {
        self.pitch_choice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pitch_choice(&mut self) -> &mut ::std::vec::Vec<PitchChoiceType> {
        &mut self.pitch_choice
    }

    // Take field
    pub fn take_pitch_choice(&mut self) -> ::std::vec::Vec<PitchChoiceType> {
        ::std::mem::replace(&mut self.pitch_choice, ::std::vec::Vec::new())
    }

    // repeated string pitch_choice_parm1 = 14;


    pub fn get_pitch_choice_parm1(&self) -> &[::std::string::String] {
        &self.pitch_choice_parm1
    }
    pub fn clear_pitch_choice_parm1(&mut self) {
        self.pitch_choice_parm1.clear();
    }

    // Param is passed by value, moved
    pub fn set_pitch_choice_parm1(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.pitch_choice_parm1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pitch_choice_parm1(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.pitch_choice_parm1
    }

    // Take field
    pub fn take_pitch_choice_parm1(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.pitch_choice_parm1, ::protobuf::RepeatedField::new())
    }

    // repeated string pitch_choice_parm2 = 15;


    pub fn get_pitch_choice_parm2(&self) -> &[::std::string::String] {
        &self.pitch_choice_parm2
    }
    pub fn clear_pitch_choice_parm2(&mut self) {
        self.pitch_choice_parm2.clear();
    }

    // Param is passed by value, moved
    pub fn set_pitch_choice_parm2(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.pitch_choice_parm2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pitch_choice_parm2(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.pitch_choice_parm2
    }

    // Take field
    pub fn take_pitch_choice_parm2(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.pitch_choice_parm2, ::protobuf::RepeatedField::new())
    }

    // repeated .ItemdefInstrument.TuningType tuning = 16;


    pub fn get_tuning(&self) -> &[TuningType] {
        &self.tuning
    }
    pub fn clear_tuning(&mut self) {
        self.tuning.clear();
    }

    // Param is passed by value, moved
    pub fn set_tuning(&mut self, v: ::std::vec::Vec<TuningType>) {
        self.tuning = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tuning(&mut self) -> &mut ::std::vec::Vec<TuningType> {
        &mut self.tuning
    }

    // Take field
    pub fn take_tuning(&mut self) -> ::std::vec::Vec<TuningType> {
        ::std::mem::replace(&mut self.tuning, ::std::vec::Vec::new())
    }

    // repeated string tuning_parm = 17;


    pub fn get_tuning_parm(&self) -> &[::std::string::String] {
        &self.tuning_parm
    }
    pub fn clear_tuning_parm(&mut self) {
        self.tuning_parm.clear();
    }

    // Param is passed by value, moved
    pub fn set_tuning_parm(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tuning_parm = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tuning_parm(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tuning_parm
    }

    // Take field
    pub fn take_tuning_parm(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tuning_parm, ::protobuf::RepeatedField::new())
    }

    // repeated .ItemdefInstrument.InstrumentRegister registers = 18;


    pub fn get_registers(&self) -> &[InstrumentRegister] {
        &self.registers
    }
    pub fn clear_registers(&mut self) {
        self.registers.clear();
    }

    // Param is passed by value, moved
    pub fn set_registers(&mut self, v: ::protobuf::RepeatedField<InstrumentRegister>) {
        self.registers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_registers(&mut self) -> &mut ::protobuf::RepeatedField<InstrumentRegister> {
        &mut self.registers
    }

    // Take field
    pub fn take_registers(&mut self) -> ::protobuf::RepeatedField<InstrumentRegister> {
        ::std::mem::replace(&mut self.registers, ::protobuf::RepeatedField::new())
    }

    // optional string description = 19;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for InstrumentDef {
    fn is_initialized(&self) -> bool {
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flags)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.material_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pieces)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pitch_range_min = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pitch_range_max = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.volume_mb_min = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.volume_mb_max = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.sound_production, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.sound_production_parm1)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.sound_production_parm2)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.pitch_choice, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pitch_choice_parm1)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pitch_choice_parm2)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.tuning, 16, &mut self.unknown_fields)?
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tuning_parm)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.registers)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.material_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.pitch_range_min {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pitch_range_max {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.volume_mb_min {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.volume_mb_max {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.sound_production {
            my_size += ::protobuf::rt::enum_size(10, *value);
        };
        for value in &self.sound_production_parm1 {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.sound_production_parm2 {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.pitch_choice {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        for value in &self.pitch_choice_parm1 {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.pitch_choice_parm2 {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.tuning {
            my_size += ::protobuf::rt::enum_size(16, *value);
        };
        for value in &self.tuning_parm {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.registers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.flags.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.size {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.material_size {
            os.write_int32(4, v)?;
        }
        for v in &self.pieces {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.pitch_range_min {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pitch_range_max {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.volume_mb_min {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.volume_mb_max {
            os.write_int32(9, v)?;
        }
        for v in &self.sound_production {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.sound_production_parm1 {
            os.write_string(11, &v)?;
        };
        for v in &self.sound_production_parm2 {
            os.write_string(12, &v)?;
        };
        for v in &self.pitch_choice {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.pitch_choice_parm1 {
            os.write_string(14, &v)?;
        };
        for v in &self.pitch_choice_parm2 {
            os.write_string(15, &v)?;
        };
        for v in &self.tuning {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.tuning_parm {
            os.write_string(17, &v)?;
        };
        for v in &self.registers {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(19, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentDef {
        InstrumentDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentFlags>>(
                "flags",
                |m: &InstrumentDef| { &m.flags },
                |m: &mut InstrumentDef| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &InstrumentDef| { &m.size },
                |m: &mut InstrumentDef| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &InstrumentDef| { &m.value },
                |m: &mut InstrumentDef| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "material_size",
                |m: &InstrumentDef| { &m.material_size },
                |m: &mut InstrumentDef| { &mut m.material_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentPiece>>(
                "pieces",
                |m: &InstrumentDef| { &m.pieces },
                |m: &mut InstrumentDef| { &mut m.pieces },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pitch_range_min",
                |m: &InstrumentDef| { &m.pitch_range_min },
                |m: &mut InstrumentDef| { &mut m.pitch_range_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pitch_range_max",
                |m: &InstrumentDef| { &m.pitch_range_max },
                |m: &mut InstrumentDef| { &mut m.pitch_range_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "volume_mb_min",
                |m: &InstrumentDef| { &m.volume_mb_min },
                |m: &mut InstrumentDef| { &mut m.volume_mb_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "volume_mb_max",
                |m: &InstrumentDef| { &m.volume_mb_max },
                |m: &mut InstrumentDef| { &mut m.volume_mb_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SoundProductionType>>(
                "sound_production",
                |m: &InstrumentDef| { &m.sound_production },
                |m: &mut InstrumentDef| { &mut m.sound_production },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sound_production_parm1",
                |m: &InstrumentDef| { &m.sound_production_parm1 },
                |m: &mut InstrumentDef| { &mut m.sound_production_parm1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sound_production_parm2",
                |m: &InstrumentDef| { &m.sound_production_parm2 },
                |m: &mut InstrumentDef| { &mut m.sound_production_parm2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PitchChoiceType>>(
                "pitch_choice",
                |m: &InstrumentDef| { &m.pitch_choice },
                |m: &mut InstrumentDef| { &mut m.pitch_choice },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pitch_choice_parm1",
                |m: &InstrumentDef| { &m.pitch_choice_parm1 },
                |m: &mut InstrumentDef| { &mut m.pitch_choice_parm1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pitch_choice_parm2",
                |m: &InstrumentDef| { &m.pitch_choice_parm2 },
                |m: &mut InstrumentDef| { &mut m.pitch_choice_parm2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TuningType>>(
                "tuning",
                |m: &InstrumentDef| { &m.tuning },
                |m: &mut InstrumentDef| { &mut m.tuning },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tuning_parm",
                |m: &InstrumentDef| { &m.tuning_parm },
                |m: &mut InstrumentDef| { &mut m.tuning_parm },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentRegister>>(
                "registers",
                |m: &InstrumentDef| { &m.registers },
                |m: &mut InstrumentDef| { &mut m.registers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &InstrumentDef| { &m.description },
                |m: &mut InstrumentDef| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentDef>(
                "InstrumentDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentDef {
        static instance: ::protobuf::rt::LazyV2<InstrumentDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentDef::new)
    }
}

impl ::protobuf::Clear for InstrumentDef {
    fn clear(&mut self) {
        self.flags.clear();
        self.size = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.material_size = ::std::option::Option::None;
        self.pieces.clear();
        self.pitch_range_min = ::std::option::Option::None;
        self.pitch_range_max = ::std::option::Option::None;
        self.volume_mb_min = ::std::option::Option::None;
        self.volume_mb_max = ::std::option::Option::None;
        self.sound_production.clear();
        self.sound_production_parm1.clear();
        self.sound_production_parm2.clear();
        self.pitch_choice.clear();
        self.pitch_choice_parm1.clear();
        self.pitch_choice_parm2.clear();
        self.tuning.clear();
        self.tuning_parm.clear();
        self.registers.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PitchChoiceType {
    MEMBRANE_POSITION = 0,
    SUBPART_CHOICE = 1,
    KEYBOARD = 2,
    STOPPING_FRET = 3,
    STOPPING_AGAINST_BODY = 4,
    STOPPING_HOLE = 5,
    STOPPING_HOLE_KEY = 6,
    SLIDE = 7,
    HARMONIC_SERIES = 8,
    VALVE_ROUTES_AIR = 9,
    BP_IN_BELL = 10,
    FOOT_PEDALS = 11,
}

impl ::protobuf::ProtobufEnum for PitchChoiceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PitchChoiceType> {
        match value {
            0 => ::std::option::Option::Some(PitchChoiceType::MEMBRANE_POSITION),
            1 => ::std::option::Option::Some(PitchChoiceType::SUBPART_CHOICE),
            2 => ::std::option::Option::Some(PitchChoiceType::KEYBOARD),
            3 => ::std::option::Option::Some(PitchChoiceType::STOPPING_FRET),
            4 => ::std::option::Option::Some(PitchChoiceType::STOPPING_AGAINST_BODY),
            5 => ::std::option::Option::Some(PitchChoiceType::STOPPING_HOLE),
            6 => ::std::option::Option::Some(PitchChoiceType::STOPPING_HOLE_KEY),
            7 => ::std::option::Option::Some(PitchChoiceType::SLIDE),
            8 => ::std::option::Option::Some(PitchChoiceType::HARMONIC_SERIES),
            9 => ::std::option::Option::Some(PitchChoiceType::VALVE_ROUTES_AIR),
            10 => ::std::option::Option::Some(PitchChoiceType::BP_IN_BELL),
            11 => ::std::option::Option::Some(PitchChoiceType::FOOT_PEDALS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PitchChoiceType] = &[
            PitchChoiceType::MEMBRANE_POSITION,
            PitchChoiceType::SUBPART_CHOICE,
            PitchChoiceType::KEYBOARD,
            PitchChoiceType::STOPPING_FRET,
            PitchChoiceType::STOPPING_AGAINST_BODY,
            PitchChoiceType::STOPPING_HOLE,
            PitchChoiceType::STOPPING_HOLE_KEY,
            PitchChoiceType::SLIDE,
            PitchChoiceType::HARMONIC_SERIES,
            PitchChoiceType::VALVE_ROUTES_AIR,
            PitchChoiceType::BP_IN_BELL,
            PitchChoiceType::FOOT_PEDALS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PitchChoiceType>("PitchChoiceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PitchChoiceType {
}

impl ::std::default::Default for PitchChoiceType {
    fn default() -> Self {
        PitchChoiceType::MEMBRANE_POSITION
    }
}

impl ::protobuf::reflect::ProtobufValue for PitchChoiceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SoundProductionType {
    PLUCKED_BY_BP = 0,
    PLUCKED = 1,
    BOWED = 2,
    STRUCK_BY_BP = 3,
    STRUCK = 4,
    VIBRATE_BP_AGAINST_OPENING = 5,
    BLOW_AGAINST_FIPPLE = 6,
    BLOW_OVER_OPENING_SIDE = 7,
    BLOW_OVER_OPENING_END = 8,
    BLOW_OVER_SINGLE_REED = 9,
    BLOW_OVER_DOUBLE_REED = 10,
    BLOW_OVER_FREE_REED = 11,
    STRUCK_TOGETHER = 12,
    SHAKEN = 13,
    SCRAPED = 14,
    FRICTION = 15,
    RESONATOR = 16,
    BAG_OVER_REED = 17,
    AIR_OVER_REED = 18,
    AIR_OVER_FREE_REED = 19,
    AIR_AGAINST_FIPPLE = 20,
}

impl ::protobuf::ProtobufEnum for SoundProductionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SoundProductionType> {
        match value {
            0 => ::std::option::Option::Some(SoundProductionType::PLUCKED_BY_BP),
            1 => ::std::option::Option::Some(SoundProductionType::PLUCKED),
            2 => ::std::option::Option::Some(SoundProductionType::BOWED),
            3 => ::std::option::Option::Some(SoundProductionType::STRUCK_BY_BP),
            4 => ::std::option::Option::Some(SoundProductionType::STRUCK),
            5 => ::std::option::Option::Some(SoundProductionType::VIBRATE_BP_AGAINST_OPENING),
            6 => ::std::option::Option::Some(SoundProductionType::BLOW_AGAINST_FIPPLE),
            7 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_OPENING_SIDE),
            8 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_OPENING_END),
            9 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_SINGLE_REED),
            10 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_DOUBLE_REED),
            11 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_FREE_REED),
            12 => ::std::option::Option::Some(SoundProductionType::STRUCK_TOGETHER),
            13 => ::std::option::Option::Some(SoundProductionType::SHAKEN),
            14 => ::std::option::Option::Some(SoundProductionType::SCRAPED),
            15 => ::std::option::Option::Some(SoundProductionType::FRICTION),
            16 => ::std::option::Option::Some(SoundProductionType::RESONATOR),
            17 => ::std::option::Option::Some(SoundProductionType::BAG_OVER_REED),
            18 => ::std::option::Option::Some(SoundProductionType::AIR_OVER_REED),
            19 => ::std::option::Option::Some(SoundProductionType::AIR_OVER_FREE_REED),
            20 => ::std::option::Option::Some(SoundProductionType::AIR_AGAINST_FIPPLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SoundProductionType] = &[
            SoundProductionType::PLUCKED_BY_BP,
            SoundProductionType::PLUCKED,
            SoundProductionType::BOWED,
            SoundProductionType::STRUCK_BY_BP,
            SoundProductionType::STRUCK,
            SoundProductionType::VIBRATE_BP_AGAINST_OPENING,
            SoundProductionType::BLOW_AGAINST_FIPPLE,
            SoundProductionType::BLOW_OVER_OPENING_SIDE,
            SoundProductionType::BLOW_OVER_OPENING_END,
            SoundProductionType::BLOW_OVER_SINGLE_REED,
            SoundProductionType::BLOW_OVER_DOUBLE_REED,
            SoundProductionType::BLOW_OVER_FREE_REED,
            SoundProductionType::STRUCK_TOGETHER,
            SoundProductionType::SHAKEN,
            SoundProductionType::SCRAPED,
            SoundProductionType::FRICTION,
            SoundProductionType::RESONATOR,
            SoundProductionType::BAG_OVER_REED,
            SoundProductionType::AIR_OVER_REED,
            SoundProductionType::AIR_OVER_FREE_REED,
            SoundProductionType::AIR_AGAINST_FIPPLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SoundProductionType>("SoundProductionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SoundProductionType {
}

impl ::std::default::Default for SoundProductionType {
    fn default() -> Self {
        SoundProductionType::PLUCKED_BY_BP
    }
}

impl ::protobuf::reflect::ProtobufValue for SoundProductionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TuningType {
    PEGS = 0,
    ADJUSTABLE_BRIDGES = 1,
    CROOKS = 2,
    TIGHTENING = 3,
    LEVERS = 4,
}

impl ::protobuf::ProtobufEnum for TuningType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TuningType> {
        match value {
            0 => ::std::option::Option::Some(TuningType::PEGS),
            1 => ::std::option::Option::Some(TuningType::ADJUSTABLE_BRIDGES),
            2 => ::std::option::Option::Some(TuningType::CROOKS),
            3 => ::std::option::Option::Some(TuningType::TIGHTENING),
            4 => ::std::option::Option::Some(TuningType::LEVERS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TuningType] = &[
            TuningType::PEGS,
            TuningType::ADJUSTABLE_BRIDGES,
            TuningType::CROOKS,
            TuningType::TIGHTENING,
            TuningType::LEVERS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TuningType>("TuningType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TuningType {
}

impl ::std::default::Default for TuningType {
    fn default() -> Self {
        TuningType::PEGS
    }
}

impl ::protobuf::reflect::ProtobufValue for TuningType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17ItemdefInstrument.proto\x12\x11ItemdefInstrument\"\xc9\x02\n\x0fIn\
    strumentFlags\x12+\n\x10indefinite_pitch\x18\x01\x20\x01(\x08R\x0findefi\
    nitePitchB\0\x12.\n\x12placed_as_building\x18\x02\x20\x01(\x08R\x10place\
    dAsBuildingB\0\x12\x1d\n\tmetal_mat\x18\x03\x20\x01(\x08R\x08metalMatB\0\
    \x12\x1d\n\tstone_mat\x18\x04\x20\x01(\x08R\x08stoneMatB\0\x12\x1b\n\x08\
    wood_mat\x18\x05\x20\x01(\x08R\x07woodMatB\0\x12\x1d\n\tglass_mat\x18\
    \x06\x20\x01(\x08R\x08glassMatB\0\x12!\n\x0bceramic_mat\x18\x07\x20\x01(\
    \x08R\nceramicMatB\0\x12\x1d\n\tshell_mat\x18\x08\x20\x01(\x08R\x08shell\
    MatB\0\x12\x1b\n\x08bone_mat\x18\t\x20\x01(\x08R\x07boneMatB\0:\0\"t\n\
    \x0fInstrumentPiece\x12\x14\n\x04type\x18\x01\x20\x01(\tR\x04typeB\0\x12\
    \x10\n\x02id\x18\x02\x20\x01(\tR\x02idB\0\x12\x14\n\x04name\x18\x03\x20\
    \x01(\tR\x04nameB\0\x12!\n\x0bname_plural\x18\x04\x20\x01(\tR\nnamePlura\
    lB\0:\0\"j\n\x12InstrumentRegister\x12(\n\x0fpitch_range_min\x18\x01\x20\
    \x01(\x05R\rpitchRangeMinB\0\x12(\n\x0fpitch_range_max\x18\x02\x20\x01(\
    \x05R\rpitchRangeMaxB\0:\0\"\xb5\x07\n\rInstrumentDef\x12:\n\x05flags\
    \x18\x01\x20\x01(\x0b2\".ItemdefInstrument.InstrumentFlagsR\x05flagsB\0\
    \x12\x14\n\x04size\x18\x02\x20\x01(\x05R\x04sizeB\0\x12\x16\n\x05value\
    \x18\x03\x20\x01(\x05R\x05valueB\0\x12%\n\rmaterial_size\x18\x04\x20\x01\
    (\x05R\x0cmaterialSizeB\0\x12<\n\x06pieces\x18\x05\x20\x03(\x0b2\".Itemd\
    efInstrument.InstrumentPieceR\x06piecesB\0\x12(\n\x0fpitch_range_min\x18\
    \x06\x20\x01(\x05R\rpitchRangeMinB\0\x12(\n\x0fpitch_range_max\x18\x07\
    \x20\x01(\x05R\rpitchRangeMaxB\0\x12$\n\rvolume_mb_min\x18\x08\x20\x01(\
    \x05R\x0bvolumeMbMinB\0\x12$\n\rvolume_mb_max\x18\t\x20\x01(\x05R\x0bvol\
    umeMbMaxB\0\x12S\n\x10sound_production\x18\n\x20\x03(\x0e2&.ItemdefInstr\
    ument.SoundProductionTypeR\x0fsoundProductionB\0\x126\n\x16sound_product\
    ion_parm1\x18\x0b\x20\x03(\tR\x14soundProductionParm1B\0\x126\n\x16sound\
    _production_parm2\x18\x0c\x20\x03(\tR\x14soundProductionParm2B\0\x12G\n\
    \x0cpitch_choice\x18\r\x20\x03(\x0e2\".ItemdefInstrument.PitchChoiceType\
    R\x0bpitchChoiceB\0\x12.\n\x12pitch_choice_parm1\x18\x0e\x20\x03(\tR\x10\
    pitchChoiceParm1B\0\x12.\n\x12pitch_choice_parm2\x18\x0f\x20\x03(\tR\x10\
    pitchChoiceParm2B\0\x127\n\x06tuning\x18\x10\x20\x03(\x0e2\x1d.ItemdefIn\
    strument.TuningTypeR\x06tuningB\0\x12!\n\x0btuning_parm\x18\x11\x20\x03(\
    \tR\ntuningParmB\0\x12E\n\tregisters\x18\x12\x20\x03(\x0b2%.ItemdefInstr\
    ument.InstrumentRegisterR\tregistersB\0\x12\"\n\x0bdescription\x18\x13\
    \x20\x01(\tR\x0bdescriptionB\0:\0*\xfb\x01\n\x0fPitchChoiceType\x12\x15\
    \n\x11MEMBRANE_POSITION\x10\0\x12\x12\n\x0eSUBPART_CHOICE\x10\x01\x12\
    \x0c\n\x08KEYBOARD\x10\x02\x12\x11\n\rSTOPPING_FRET\x10\x03\x12\x19\n\
    \x15STOPPING_AGAINST_BODY\x10\x04\x12\x11\n\rSTOPPING_HOLE\x10\x05\x12\
    \x15\n\x11STOPPING_HOLE_KEY\x10\x06\x12\t\n\x05SLIDE\x10\x07\x12\x13\n\
    \x0fHARMONIC_SERIES\x10\x08\x12\x14\n\x10VALVE_ROUTES_AIR\x10\t\x12\x0e\
    \n\nBP_IN_BELL\x10\n\x12\x0f\n\x0bFOOT_PEDALS\x10\x0b\x1a\0*\xc0\x03\n\
    \x13SoundProductionType\x12\x11\n\rPLUCKED_BY_BP\x10\0\x12\x0b\n\x07PLUC\
    KED\x10\x01\x12\t\n\x05BOWED\x10\x02\x12\x10\n\x0cSTRUCK_BY_BP\x10\x03\
    \x12\n\n\x06STRUCK\x10\x04\x12\x1e\n\x1aVIBRATE_BP_AGAINST_OPENING\x10\
    \x05\x12\x17\n\x13BLOW_AGAINST_FIPPLE\x10\x06\x12\x1a\n\x16BLOW_OVER_OPE\
    NING_SIDE\x10\x07\x12\x19\n\x15BLOW_OVER_OPENING_END\x10\x08\x12\x19\n\
    \x15BLOW_OVER_SINGLE_REED\x10\t\x12\x19\n\x15BLOW_OVER_DOUBLE_REED\x10\n\
    \x12\x17\n\x13BLOW_OVER_FREE_REED\x10\x0b\x12\x13\n\x0fSTRUCK_TOGETHER\
    \x10\x0c\x12\n\n\x06SHAKEN\x10\r\x12\x0b\n\x07SCRAPED\x10\x0e\x12\x0c\n\
    \x08FRICTION\x10\x0f\x12\r\n\tRESONATOR\x10\x10\x12\x11\n\rBAG_OVER_REED\
    \x10\x11\x12\x11\n\rAIR_OVER_REED\x10\x12\x12\x16\n\x12AIR_OVER_FREE_REE\
    D\x10\x13\x12\x16\n\x12AIR_AGAINST_FIPPLE\x10\x14\x1a\0*X\n\nTuningType\
    \x12\x08\n\x04PEGS\x10\0\x12\x16\n\x12ADJUSTABLE_BRIDGES\x10\x01\x12\n\n\
    \x06CROOKS\x10\x02\x12\x0e\n\nTIGHTENING\x10\x03\x12\n\n\x06LEVERS\x10\
    \x04\x1a\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
