// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ItemdefInstrument.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ItemdefInstrument.InstrumentFlags)
pub struct InstrumentFlags {
    // message fields
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.indefinite_pitch)
    pub indefinite_pitch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.placed_as_building)
    pub placed_as_building: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.metal_mat)
    pub metal_mat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.stone_mat)
    pub stone_mat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.wood_mat)
    pub wood_mat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.glass_mat)
    pub glass_mat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.ceramic_mat)
    pub ceramic_mat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.shell_mat)
    pub shell_mat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentFlags.bone_mat)
    pub bone_mat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ItemdefInstrument.InstrumentFlags.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstrumentFlags {
    fn default() -> &'a InstrumentFlags {
        <InstrumentFlags as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentFlags {
    pub fn new() -> InstrumentFlags {
        ::std::default::Default::default()
    }

    // optional bool indefinite_pitch = 1;

    pub fn indefinite_pitch(&self) -> bool {
        self.indefinite_pitch.unwrap_or(false)
    }

    pub fn clear_indefinite_pitch(&mut self) {
        self.indefinite_pitch = ::std::option::Option::None;
    }

    pub fn has_indefinite_pitch(&self) -> bool {
        self.indefinite_pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indefinite_pitch(&mut self, v: bool) {
        self.indefinite_pitch = ::std::option::Option::Some(v);
    }

    // optional bool placed_as_building = 2;

    pub fn placed_as_building(&self) -> bool {
        self.placed_as_building.unwrap_or(false)
    }

    pub fn clear_placed_as_building(&mut self) {
        self.placed_as_building = ::std::option::Option::None;
    }

    pub fn has_placed_as_building(&self) -> bool {
        self.placed_as_building.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placed_as_building(&mut self, v: bool) {
        self.placed_as_building = ::std::option::Option::Some(v);
    }

    // optional bool metal_mat = 3;

    pub fn metal_mat(&self) -> bool {
        self.metal_mat.unwrap_or(false)
    }

    pub fn clear_metal_mat(&mut self) {
        self.metal_mat = ::std::option::Option::None;
    }

    pub fn has_metal_mat(&self) -> bool {
        self.metal_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metal_mat(&mut self, v: bool) {
        self.metal_mat = ::std::option::Option::Some(v);
    }

    // optional bool stone_mat = 4;

    pub fn stone_mat(&self) -> bool {
        self.stone_mat.unwrap_or(false)
    }

    pub fn clear_stone_mat(&mut self) {
        self.stone_mat = ::std::option::Option::None;
    }

    pub fn has_stone_mat(&self) -> bool {
        self.stone_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stone_mat(&mut self, v: bool) {
        self.stone_mat = ::std::option::Option::Some(v);
    }

    // optional bool wood_mat = 5;

    pub fn wood_mat(&self) -> bool {
        self.wood_mat.unwrap_or(false)
    }

    pub fn clear_wood_mat(&mut self) {
        self.wood_mat = ::std::option::Option::None;
    }

    pub fn has_wood_mat(&self) -> bool {
        self.wood_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wood_mat(&mut self, v: bool) {
        self.wood_mat = ::std::option::Option::Some(v);
    }

    // optional bool glass_mat = 6;

    pub fn glass_mat(&self) -> bool {
        self.glass_mat.unwrap_or(false)
    }

    pub fn clear_glass_mat(&mut self) {
        self.glass_mat = ::std::option::Option::None;
    }

    pub fn has_glass_mat(&self) -> bool {
        self.glass_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glass_mat(&mut self, v: bool) {
        self.glass_mat = ::std::option::Option::Some(v);
    }

    // optional bool ceramic_mat = 7;

    pub fn ceramic_mat(&self) -> bool {
        self.ceramic_mat.unwrap_or(false)
    }

    pub fn clear_ceramic_mat(&mut self) {
        self.ceramic_mat = ::std::option::Option::None;
    }

    pub fn has_ceramic_mat(&self) -> bool {
        self.ceramic_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ceramic_mat(&mut self, v: bool) {
        self.ceramic_mat = ::std::option::Option::Some(v);
    }

    // optional bool shell_mat = 8;

    pub fn shell_mat(&self) -> bool {
        self.shell_mat.unwrap_or(false)
    }

    pub fn clear_shell_mat(&mut self) {
        self.shell_mat = ::std::option::Option::None;
    }

    pub fn has_shell_mat(&self) -> bool {
        self.shell_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shell_mat(&mut self, v: bool) {
        self.shell_mat = ::std::option::Option::Some(v);
    }

    // optional bool bone_mat = 9;

    pub fn bone_mat(&self) -> bool {
        self.bone_mat.unwrap_or(false)
    }

    pub fn clear_bone_mat(&mut self) {
        self.bone_mat = ::std::option::Option::None;
    }

    pub fn has_bone_mat(&self) -> bool {
        self.bone_mat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bone_mat(&mut self, v: bool) {
        self.bone_mat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "indefinite_pitch",
            |m: &InstrumentFlags| { &m.indefinite_pitch },
            |m: &mut InstrumentFlags| { &mut m.indefinite_pitch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "placed_as_building",
            |m: &InstrumentFlags| { &m.placed_as_building },
            |m: &mut InstrumentFlags| { &mut m.placed_as_building },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metal_mat",
            |m: &InstrumentFlags| { &m.metal_mat },
            |m: &mut InstrumentFlags| { &mut m.metal_mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stone_mat",
            |m: &InstrumentFlags| { &m.stone_mat },
            |m: &mut InstrumentFlags| { &mut m.stone_mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wood_mat",
            |m: &InstrumentFlags| { &m.wood_mat },
            |m: &mut InstrumentFlags| { &mut m.wood_mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "glass_mat",
            |m: &InstrumentFlags| { &m.glass_mat },
            |m: &mut InstrumentFlags| { &mut m.glass_mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ceramic_mat",
            |m: &InstrumentFlags| { &m.ceramic_mat },
            |m: &mut InstrumentFlags| { &mut m.ceramic_mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shell_mat",
            |m: &InstrumentFlags| { &m.shell_mat },
            |m: &mut InstrumentFlags| { &mut m.shell_mat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bone_mat",
            |m: &InstrumentFlags| { &m.bone_mat },
            |m: &mut InstrumentFlags| { &mut m.bone_mat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstrumentFlags>(
            "InstrumentFlags",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstrumentFlags {
    const NAME: &'static str = "InstrumentFlags";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.indefinite_pitch = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.placed_as_building = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.metal_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.stone_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.wood_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.glass_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.ceramic_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.shell_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.bone_mat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.indefinite_pitch {
            my_size += 1 + 1;
        }
        if let Some(v) = self.placed_as_building {
            my_size += 1 + 1;
        }
        if let Some(v) = self.metal_mat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stone_mat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.wood_mat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.glass_mat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ceramic_mat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.shell_mat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bone_mat {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.indefinite_pitch {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.placed_as_building {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.metal_mat {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.stone_mat {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.wood_mat {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.glass_mat {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.ceramic_mat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.shell_mat {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.bone_mat {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstrumentFlags {
        InstrumentFlags::new()
    }

    fn clear(&mut self) {
        self.indefinite_pitch = ::std::option::Option::None;
        self.placed_as_building = ::std::option::Option::None;
        self.metal_mat = ::std::option::Option::None;
        self.stone_mat = ::std::option::Option::None;
        self.wood_mat = ::std::option::Option::None;
        self.glass_mat = ::std::option::Option::None;
        self.ceramic_mat = ::std::option::Option::None;
        self.shell_mat = ::std::option::Option::None;
        self.bone_mat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstrumentFlags {
        static instance: InstrumentFlags = InstrumentFlags {
            indefinite_pitch: ::std::option::Option::None,
            placed_as_building: ::std::option::Option::None,
            metal_mat: ::std::option::Option::None,
            stone_mat: ::std::option::Option::None,
            wood_mat: ::std::option::Option::None,
            glass_mat: ::std::option::Option::None,
            ceramic_mat: ::std::option::Option::None,
            shell_mat: ::std::option::Option::None,
            bone_mat: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstrumentFlags {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstrumentFlags").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstrumentFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentFlags {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ItemdefInstrument.InstrumentPiece)
pub struct InstrumentPiece {
    // message fields
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentPiece.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentPiece.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentPiece.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentPiece.name_plural)
    pub name_plural: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ItemdefInstrument.InstrumentPiece.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstrumentPiece {
    fn default() -> &'a InstrumentPiece {
        <InstrumentPiece as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentPiece {
    pub fn new() -> InstrumentPiece {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_plural = 4;

    pub fn name_plural(&self) -> &str {
        match self.name_plural.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_plural(&mut self) {
        self.name_plural = ::std::option::Option::None;
    }

    pub fn has_name_plural(&self) -> bool {
        self.name_plural.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_plural(&mut self, v: ::std::string::String) {
        self.name_plural = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_plural(&mut self) -> &mut ::std::string::String {
        if self.name_plural.is_none() {
            self.name_plural = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_plural.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_plural(&mut self) -> ::std::string::String {
        self.name_plural.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &InstrumentPiece| { &m.type_ },
            |m: &mut InstrumentPiece| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &InstrumentPiece| { &m.id },
            |m: &mut InstrumentPiece| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &InstrumentPiece| { &m.name },
            |m: &mut InstrumentPiece| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_plural",
            |m: &InstrumentPiece| { &m.name_plural },
            |m: &mut InstrumentPiece| { &mut m.name_plural },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstrumentPiece>(
            "InstrumentPiece",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstrumentPiece {
    const NAME: &'static str = "InstrumentPiece";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.name_plural = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.name_plural.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.name_plural.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstrumentPiece {
        InstrumentPiece::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.name_plural = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstrumentPiece {
        static instance: InstrumentPiece = InstrumentPiece {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            name_plural: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstrumentPiece {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstrumentPiece").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstrumentPiece {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentPiece {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ItemdefInstrument.InstrumentRegister)
pub struct InstrumentRegister {
    // message fields
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentRegister.pitch_range_min)
    pub pitch_range_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentRegister.pitch_range_max)
    pub pitch_range_max: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ItemdefInstrument.InstrumentRegister.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstrumentRegister {
    fn default() -> &'a InstrumentRegister {
        <InstrumentRegister as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentRegister {
    pub fn new() -> InstrumentRegister {
        ::std::default::Default::default()
    }

    // optional int32 pitch_range_min = 1;

    pub fn pitch_range_min(&self) -> i32 {
        self.pitch_range_min.unwrap_or(0)
    }

    pub fn clear_pitch_range_min(&mut self) {
        self.pitch_range_min = ::std::option::Option::None;
    }

    pub fn has_pitch_range_min(&self) -> bool {
        self.pitch_range_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_min(&mut self, v: i32) {
        self.pitch_range_min = ::std::option::Option::Some(v);
    }

    // optional int32 pitch_range_max = 2;

    pub fn pitch_range_max(&self) -> i32 {
        self.pitch_range_max.unwrap_or(0)
    }

    pub fn clear_pitch_range_max(&mut self) {
        self.pitch_range_max = ::std::option::Option::None;
    }

    pub fn has_pitch_range_max(&self) -> bool {
        self.pitch_range_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_max(&mut self, v: i32) {
        self.pitch_range_max = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch_range_min",
            |m: &InstrumentRegister| { &m.pitch_range_min },
            |m: &mut InstrumentRegister| { &mut m.pitch_range_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch_range_max",
            |m: &InstrumentRegister| { &m.pitch_range_max },
            |m: &mut InstrumentRegister| { &mut m.pitch_range_max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstrumentRegister>(
            "InstrumentRegister",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstrumentRegister {
    const NAME: &'static str = "InstrumentRegister";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pitch_range_min = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pitch_range_max = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pitch_range_min {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pitch_range_max {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pitch_range_min {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pitch_range_max {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstrumentRegister {
        InstrumentRegister::new()
    }

    fn clear(&mut self) {
        self.pitch_range_min = ::std::option::Option::None;
        self.pitch_range_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstrumentRegister {
        static instance: InstrumentRegister = InstrumentRegister {
            pitch_range_min: ::std::option::Option::None,
            pitch_range_max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstrumentRegister {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstrumentRegister").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstrumentRegister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentRegister {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ItemdefInstrument.InstrumentDef)
pub struct InstrumentDef {
    // message fields
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.flags)
    pub flags: ::protobuf::MessageField<InstrumentFlags>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.size)
    pub size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.value)
    pub value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.material_size)
    pub material_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.pieces)
    pub pieces: ::std::vec::Vec<InstrumentPiece>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.pitch_range_min)
    pub pitch_range_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.pitch_range_max)
    pub pitch_range_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.volume_mb_min)
    pub volume_mb_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.volume_mb_max)
    pub volume_mb_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.sound_production)
    pub sound_production: ::std::vec::Vec<::protobuf::EnumOrUnknown<SoundProductionType>>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.sound_production_parm1)
    pub sound_production_parm1: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.sound_production_parm2)
    pub sound_production_parm2: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.pitch_choice)
    pub pitch_choice: ::std::vec::Vec<::protobuf::EnumOrUnknown<PitchChoiceType>>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.pitch_choice_parm1)
    pub pitch_choice_parm1: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.pitch_choice_parm2)
    pub pitch_choice_parm2: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.tuning)
    pub tuning: ::std::vec::Vec<::protobuf::EnumOrUnknown<TuningType>>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.tuning_parm)
    pub tuning_parm: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.registers)
    pub registers: ::std::vec::Vec<InstrumentRegister>,
    // @@protoc_insertion_point(field:ItemdefInstrument.InstrumentDef.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ItemdefInstrument.InstrumentDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstrumentDef {
    fn default() -> &'a InstrumentDef {
        <InstrumentDef as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentDef {
    pub fn new() -> InstrumentDef {
        ::std::default::Default::default()
    }

    // optional int32 size = 2;

    pub fn size(&self) -> i32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional int32 value = 3;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 material_size = 4;

    pub fn material_size(&self) -> i32 {
        self.material_size.unwrap_or(0)
    }

    pub fn clear_material_size(&mut self) {
        self.material_size = ::std::option::Option::None;
    }

    pub fn has_material_size(&self) -> bool {
        self.material_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material_size(&mut self, v: i32) {
        self.material_size = ::std::option::Option::Some(v);
    }

    // optional int32 pitch_range_min = 6;

    pub fn pitch_range_min(&self) -> i32 {
        self.pitch_range_min.unwrap_or(0)
    }

    pub fn clear_pitch_range_min(&mut self) {
        self.pitch_range_min = ::std::option::Option::None;
    }

    pub fn has_pitch_range_min(&self) -> bool {
        self.pitch_range_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_min(&mut self, v: i32) {
        self.pitch_range_min = ::std::option::Option::Some(v);
    }

    // optional int32 pitch_range_max = 7;

    pub fn pitch_range_max(&self) -> i32 {
        self.pitch_range_max.unwrap_or(0)
    }

    pub fn clear_pitch_range_max(&mut self) {
        self.pitch_range_max = ::std::option::Option::None;
    }

    pub fn has_pitch_range_max(&self) -> bool {
        self.pitch_range_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_range_max(&mut self, v: i32) {
        self.pitch_range_max = ::std::option::Option::Some(v);
    }

    // optional int32 volume_mb_min = 8;

    pub fn volume_mb_min(&self) -> i32 {
        self.volume_mb_min.unwrap_or(0)
    }

    pub fn clear_volume_mb_min(&mut self) {
        self.volume_mb_min = ::std::option::Option::None;
    }

    pub fn has_volume_mb_min(&self) -> bool {
        self.volume_mb_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_mb_min(&mut self, v: i32) {
        self.volume_mb_min = ::std::option::Option::Some(v);
    }

    // optional int32 volume_mb_max = 9;

    pub fn volume_mb_max(&self) -> i32 {
        self.volume_mb_max.unwrap_or(0)
    }

    pub fn clear_volume_mb_max(&mut self) {
        self.volume_mb_max = ::std::option::Option::None;
    }

    pub fn has_volume_mb_max(&self) -> bool {
        self.volume_mb_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_mb_max(&mut self, v: i32) {
        self.volume_mb_max = ::std::option::Option::Some(v);
    }

    // optional string description = 19;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InstrumentFlags>(
            "flags",
            |m: &InstrumentDef| { &m.flags },
            |m: &mut InstrumentDef| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &InstrumentDef| { &m.size },
            |m: &mut InstrumentDef| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &InstrumentDef| { &m.value },
            |m: &mut InstrumentDef| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "material_size",
            |m: &InstrumentDef| { &m.material_size },
            |m: &mut InstrumentDef| { &mut m.material_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pieces",
            |m: &InstrumentDef| { &m.pieces },
            |m: &mut InstrumentDef| { &mut m.pieces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch_range_min",
            |m: &InstrumentDef| { &m.pitch_range_min },
            |m: &mut InstrumentDef| { &mut m.pitch_range_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch_range_max",
            |m: &InstrumentDef| { &m.pitch_range_max },
            |m: &mut InstrumentDef| { &mut m.pitch_range_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume_mb_min",
            |m: &InstrumentDef| { &m.volume_mb_min },
            |m: &mut InstrumentDef| { &mut m.volume_mb_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume_mb_max",
            |m: &InstrumentDef| { &m.volume_mb_max },
            |m: &mut InstrumentDef| { &mut m.volume_mb_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sound_production",
            |m: &InstrumentDef| { &m.sound_production },
            |m: &mut InstrumentDef| { &mut m.sound_production },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sound_production_parm1",
            |m: &InstrumentDef| { &m.sound_production_parm1 },
            |m: &mut InstrumentDef| { &mut m.sound_production_parm1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sound_production_parm2",
            |m: &InstrumentDef| { &m.sound_production_parm2 },
            |m: &mut InstrumentDef| { &mut m.sound_production_parm2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pitch_choice",
            |m: &InstrumentDef| { &m.pitch_choice },
            |m: &mut InstrumentDef| { &mut m.pitch_choice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pitch_choice_parm1",
            |m: &InstrumentDef| { &m.pitch_choice_parm1 },
            |m: &mut InstrumentDef| { &mut m.pitch_choice_parm1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pitch_choice_parm2",
            |m: &InstrumentDef| { &m.pitch_choice_parm2 },
            |m: &mut InstrumentDef| { &mut m.pitch_choice_parm2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tuning",
            |m: &InstrumentDef| { &m.tuning },
            |m: &mut InstrumentDef| { &mut m.tuning },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tuning_parm",
            |m: &InstrumentDef| { &m.tuning_parm },
            |m: &mut InstrumentDef| { &mut m.tuning_parm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "registers",
            |m: &InstrumentDef| { &m.registers },
            |m: &mut InstrumentDef| { &mut m.registers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &InstrumentDef| { &m.description },
            |m: &mut InstrumentDef| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstrumentDef>(
            "InstrumentDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstrumentDef {
    const NAME: &'static str = "InstrumentDef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flags)?;
                },
                16 => {
                    self.size = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.material_size = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.pieces.push(is.read_message()?);
                },
                48 => {
                    self.pitch_range_min = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.pitch_range_max = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.volume_mb_min = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.volume_mb_max = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.sound_production.push(is.read_enum_or_unknown()?);
                },
                82 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.sound_production)?
                },
                90 => {
                    self.sound_production_parm1.push(is.read_string()?);
                },
                98 => {
                    self.sound_production_parm2.push(is.read_string()?);
                },
                104 => {
                    self.pitch_choice.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.pitch_choice)?
                },
                114 => {
                    self.pitch_choice_parm1.push(is.read_string()?);
                },
                122 => {
                    self.pitch_choice_parm2.push(is.read_string()?);
                },
                128 => {
                    self.tuning.push(is.read_enum_or_unknown()?);
                },
                130 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.tuning)?
                },
                138 => {
                    self.tuning_parm.push(is.read_string()?);
                },
                146 => {
                    self.registers.push(is.read_message()?);
                },
                154 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.material_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pitch_range_min {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.pitch_range_max {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.volume_mb_min {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.volume_mb_max {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.sound_production {
            my_size += ::protobuf::rt::int32_size(10, value.value());
        };
        for value in &self.sound_production_parm1 {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.sound_production_parm2 {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.pitch_choice {
            my_size += ::protobuf::rt::int32_size(13, value.value());
        };
        for value in &self.pitch_choice_parm1 {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.pitch_choice_parm2 {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.tuning {
            my_size += ::protobuf::rt::int32_size(16, value.value());
        };
        for value in &self.tuning_parm {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.registers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.flags.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.size {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.material_size {
            os.write_int32(4, v)?;
        }
        for v in &self.pieces {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.pitch_range_min {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pitch_range_max {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.volume_mb_min {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.volume_mb_max {
            os.write_int32(9, v)?;
        }
        for v in &self.sound_production {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.sound_production_parm1 {
            os.write_string(11, &v)?;
        };
        for v in &self.sound_production_parm2 {
            os.write_string(12, &v)?;
        };
        for v in &self.pitch_choice {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.pitch_choice_parm1 {
            os.write_string(14, &v)?;
        };
        for v in &self.pitch_choice_parm2 {
            os.write_string(15, &v)?;
        };
        for v in &self.tuning {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.tuning_parm {
            os.write_string(17, &v)?;
        };
        for v in &self.registers {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.description.as_ref() {
            os.write_string(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstrumentDef {
        InstrumentDef::new()
    }

    fn clear(&mut self) {
        self.flags.clear();
        self.size = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.material_size = ::std::option::Option::None;
        self.pieces.clear();
        self.pitch_range_min = ::std::option::Option::None;
        self.pitch_range_max = ::std::option::Option::None;
        self.volume_mb_min = ::std::option::Option::None;
        self.volume_mb_max = ::std::option::Option::None;
        self.sound_production.clear();
        self.sound_production_parm1.clear();
        self.sound_production_parm2.clear();
        self.pitch_choice.clear();
        self.pitch_choice_parm1.clear();
        self.pitch_choice_parm2.clear();
        self.tuning.clear();
        self.tuning_parm.clear();
        self.registers.clear();
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstrumentDef {
        static instance: InstrumentDef = InstrumentDef {
            flags: ::protobuf::MessageField::none(),
            size: ::std::option::Option::None,
            value: ::std::option::Option::None,
            material_size: ::std::option::Option::None,
            pieces: ::std::vec::Vec::new(),
            pitch_range_min: ::std::option::Option::None,
            pitch_range_max: ::std::option::Option::None,
            volume_mb_min: ::std::option::Option::None,
            volume_mb_max: ::std::option::Option::None,
            sound_production: ::std::vec::Vec::new(),
            sound_production_parm1: ::std::vec::Vec::new(),
            sound_production_parm2: ::std::vec::Vec::new(),
            pitch_choice: ::std::vec::Vec::new(),
            pitch_choice_parm1: ::std::vec::Vec::new(),
            pitch_choice_parm2: ::std::vec::Vec::new(),
            tuning: ::std::vec::Vec::new(),
            tuning_parm: ::std::vec::Vec::new(),
            registers: ::std::vec::Vec::new(),
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstrumentDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstrumentDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstrumentDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ItemdefInstrument.PitchChoiceType)
pub enum PitchChoiceType {
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.MEMBRANE_POSITION)
    MEMBRANE_POSITION = 0,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.SUBPART_CHOICE)
    SUBPART_CHOICE = 1,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.KEYBOARD)
    KEYBOARD = 2,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.STOPPING_FRET)
    STOPPING_FRET = 3,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.STOPPING_AGAINST_BODY)
    STOPPING_AGAINST_BODY = 4,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.STOPPING_HOLE)
    STOPPING_HOLE = 5,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.STOPPING_HOLE_KEY)
    STOPPING_HOLE_KEY = 6,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.SLIDE)
    SLIDE = 7,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.HARMONIC_SERIES)
    HARMONIC_SERIES = 8,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.VALVE_ROUTES_AIR)
    VALVE_ROUTES_AIR = 9,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.BP_IN_BELL)
    BP_IN_BELL = 10,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.PitchChoiceType.FOOT_PEDALS)
    FOOT_PEDALS = 11,
}

impl ::protobuf::Enum for PitchChoiceType {
    const NAME: &'static str = "PitchChoiceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PitchChoiceType> {
        match value {
            0 => ::std::option::Option::Some(PitchChoiceType::MEMBRANE_POSITION),
            1 => ::std::option::Option::Some(PitchChoiceType::SUBPART_CHOICE),
            2 => ::std::option::Option::Some(PitchChoiceType::KEYBOARD),
            3 => ::std::option::Option::Some(PitchChoiceType::STOPPING_FRET),
            4 => ::std::option::Option::Some(PitchChoiceType::STOPPING_AGAINST_BODY),
            5 => ::std::option::Option::Some(PitchChoiceType::STOPPING_HOLE),
            6 => ::std::option::Option::Some(PitchChoiceType::STOPPING_HOLE_KEY),
            7 => ::std::option::Option::Some(PitchChoiceType::SLIDE),
            8 => ::std::option::Option::Some(PitchChoiceType::HARMONIC_SERIES),
            9 => ::std::option::Option::Some(PitchChoiceType::VALVE_ROUTES_AIR),
            10 => ::std::option::Option::Some(PitchChoiceType::BP_IN_BELL),
            11 => ::std::option::Option::Some(PitchChoiceType::FOOT_PEDALS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PitchChoiceType] = &[
        PitchChoiceType::MEMBRANE_POSITION,
        PitchChoiceType::SUBPART_CHOICE,
        PitchChoiceType::KEYBOARD,
        PitchChoiceType::STOPPING_FRET,
        PitchChoiceType::STOPPING_AGAINST_BODY,
        PitchChoiceType::STOPPING_HOLE,
        PitchChoiceType::STOPPING_HOLE_KEY,
        PitchChoiceType::SLIDE,
        PitchChoiceType::HARMONIC_SERIES,
        PitchChoiceType::VALVE_ROUTES_AIR,
        PitchChoiceType::BP_IN_BELL,
        PitchChoiceType::FOOT_PEDALS,
    ];
}

impl ::protobuf::EnumFull for PitchChoiceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PitchChoiceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PitchChoiceType {
    fn default() -> Self {
        PitchChoiceType::MEMBRANE_POSITION
    }
}

impl PitchChoiceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PitchChoiceType>("PitchChoiceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ItemdefInstrument.SoundProductionType)
pub enum SoundProductionType {
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.PLUCKED_BY_BP)
    PLUCKED_BY_BP = 0,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.PLUCKED)
    PLUCKED = 1,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BOWED)
    BOWED = 2,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.STRUCK_BY_BP)
    STRUCK_BY_BP = 3,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.STRUCK)
    STRUCK = 4,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.VIBRATE_BP_AGAINST_OPENING)
    VIBRATE_BP_AGAINST_OPENING = 5,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BLOW_AGAINST_FIPPLE)
    BLOW_AGAINST_FIPPLE = 6,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BLOW_OVER_OPENING_SIDE)
    BLOW_OVER_OPENING_SIDE = 7,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BLOW_OVER_OPENING_END)
    BLOW_OVER_OPENING_END = 8,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BLOW_OVER_SINGLE_REED)
    BLOW_OVER_SINGLE_REED = 9,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BLOW_OVER_DOUBLE_REED)
    BLOW_OVER_DOUBLE_REED = 10,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BLOW_OVER_FREE_REED)
    BLOW_OVER_FREE_REED = 11,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.STRUCK_TOGETHER)
    STRUCK_TOGETHER = 12,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.SHAKEN)
    SHAKEN = 13,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.SCRAPED)
    SCRAPED = 14,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.FRICTION)
    FRICTION = 15,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.RESONATOR)
    RESONATOR = 16,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.BAG_OVER_REED)
    BAG_OVER_REED = 17,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.AIR_OVER_REED)
    AIR_OVER_REED = 18,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.AIR_OVER_FREE_REED)
    AIR_OVER_FREE_REED = 19,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.SoundProductionType.AIR_AGAINST_FIPPLE)
    AIR_AGAINST_FIPPLE = 20,
}

impl ::protobuf::Enum for SoundProductionType {
    const NAME: &'static str = "SoundProductionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SoundProductionType> {
        match value {
            0 => ::std::option::Option::Some(SoundProductionType::PLUCKED_BY_BP),
            1 => ::std::option::Option::Some(SoundProductionType::PLUCKED),
            2 => ::std::option::Option::Some(SoundProductionType::BOWED),
            3 => ::std::option::Option::Some(SoundProductionType::STRUCK_BY_BP),
            4 => ::std::option::Option::Some(SoundProductionType::STRUCK),
            5 => ::std::option::Option::Some(SoundProductionType::VIBRATE_BP_AGAINST_OPENING),
            6 => ::std::option::Option::Some(SoundProductionType::BLOW_AGAINST_FIPPLE),
            7 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_OPENING_SIDE),
            8 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_OPENING_END),
            9 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_SINGLE_REED),
            10 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_DOUBLE_REED),
            11 => ::std::option::Option::Some(SoundProductionType::BLOW_OVER_FREE_REED),
            12 => ::std::option::Option::Some(SoundProductionType::STRUCK_TOGETHER),
            13 => ::std::option::Option::Some(SoundProductionType::SHAKEN),
            14 => ::std::option::Option::Some(SoundProductionType::SCRAPED),
            15 => ::std::option::Option::Some(SoundProductionType::FRICTION),
            16 => ::std::option::Option::Some(SoundProductionType::RESONATOR),
            17 => ::std::option::Option::Some(SoundProductionType::BAG_OVER_REED),
            18 => ::std::option::Option::Some(SoundProductionType::AIR_OVER_REED),
            19 => ::std::option::Option::Some(SoundProductionType::AIR_OVER_FREE_REED),
            20 => ::std::option::Option::Some(SoundProductionType::AIR_AGAINST_FIPPLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SoundProductionType] = &[
        SoundProductionType::PLUCKED_BY_BP,
        SoundProductionType::PLUCKED,
        SoundProductionType::BOWED,
        SoundProductionType::STRUCK_BY_BP,
        SoundProductionType::STRUCK,
        SoundProductionType::VIBRATE_BP_AGAINST_OPENING,
        SoundProductionType::BLOW_AGAINST_FIPPLE,
        SoundProductionType::BLOW_OVER_OPENING_SIDE,
        SoundProductionType::BLOW_OVER_OPENING_END,
        SoundProductionType::BLOW_OVER_SINGLE_REED,
        SoundProductionType::BLOW_OVER_DOUBLE_REED,
        SoundProductionType::BLOW_OVER_FREE_REED,
        SoundProductionType::STRUCK_TOGETHER,
        SoundProductionType::SHAKEN,
        SoundProductionType::SCRAPED,
        SoundProductionType::FRICTION,
        SoundProductionType::RESONATOR,
        SoundProductionType::BAG_OVER_REED,
        SoundProductionType::AIR_OVER_REED,
        SoundProductionType::AIR_OVER_FREE_REED,
        SoundProductionType::AIR_AGAINST_FIPPLE,
    ];
}

impl ::protobuf::EnumFull for SoundProductionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SoundProductionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SoundProductionType {
    fn default() -> Self {
        SoundProductionType::PLUCKED_BY_BP
    }
}

impl SoundProductionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SoundProductionType>("SoundProductionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ItemdefInstrument.TuningType)
pub enum TuningType {
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.TuningType.PEGS)
    PEGS = 0,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.TuningType.ADJUSTABLE_BRIDGES)
    ADJUSTABLE_BRIDGES = 1,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.TuningType.CROOKS)
    CROOKS = 2,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.TuningType.TIGHTENING)
    TIGHTENING = 3,
    // @@protoc_insertion_point(enum_value:ItemdefInstrument.TuningType.LEVERS)
    LEVERS = 4,
}

impl ::protobuf::Enum for TuningType {
    const NAME: &'static str = "TuningType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TuningType> {
        match value {
            0 => ::std::option::Option::Some(TuningType::PEGS),
            1 => ::std::option::Option::Some(TuningType::ADJUSTABLE_BRIDGES),
            2 => ::std::option::Option::Some(TuningType::CROOKS),
            3 => ::std::option::Option::Some(TuningType::TIGHTENING),
            4 => ::std::option::Option::Some(TuningType::LEVERS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TuningType] = &[
        TuningType::PEGS,
        TuningType::ADJUSTABLE_BRIDGES,
        TuningType::CROOKS,
        TuningType::TIGHTENING,
        TuningType::LEVERS,
    ];
}

impl ::protobuf::EnumFull for TuningType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TuningType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TuningType {
    fn default() -> Self {
        TuningType::PEGS
    }
}

impl TuningType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TuningType>("TuningType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17ItemdefInstrument.proto\x12\x11ItemdefInstrument\"\xb5\x02\n\x0fIn\
    strumentFlags\x12)\n\x10indefinite_pitch\x18\x01\x20\x01(\x08R\x0findefi\
    nitePitch\x12,\n\x12placed_as_building\x18\x02\x20\x01(\x08R\x10placedAs\
    Building\x12\x1b\n\tmetal_mat\x18\x03\x20\x01(\x08R\x08metalMat\x12\x1b\
    \n\tstone_mat\x18\x04\x20\x01(\x08R\x08stoneMat\x12\x19\n\x08wood_mat\
    \x18\x05\x20\x01(\x08R\x07woodMat\x12\x1b\n\tglass_mat\x18\x06\x20\x01(\
    \x08R\x08glassMat\x12\x1f\n\x0bceramic_mat\x18\x07\x20\x01(\x08R\ncerami\
    cMat\x12\x1b\n\tshell_mat\x18\x08\x20\x01(\x08R\x08shellMat\x12\x19\n\
    \x08bone_mat\x18\t\x20\x01(\x08R\x07boneMat\"j\n\x0fInstrumentPiece\x12\
    \x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x0e\n\x02id\x18\x02\x20\
    \x01(\tR\x02id\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1f\n\
    \x0bname_plural\x18\x04\x20\x01(\tR\nnamePlural\"d\n\x12InstrumentRegist\
    er\x12&\n\x0fpitch_range_min\x18\x01\x20\x01(\x05R\rpitchRangeMin\x12&\n\
    \x0fpitch_range_max\x18\x02\x20\x01(\x05R\rpitchRangeMax\"\x8d\x07\n\rIn\
    strumentDef\x128\n\x05flags\x18\x01\x20\x01(\x0b2\".ItemdefInstrument.In\
    strumentFlagsR\x05flags\x12\x12\n\x04size\x18\x02\x20\x01(\x05R\x04size\
    \x12\x14\n\x05value\x18\x03\x20\x01(\x05R\x05value\x12#\n\rmaterial_size\
    \x18\x04\x20\x01(\x05R\x0cmaterialSize\x12:\n\x06pieces\x18\x05\x20\x03(\
    \x0b2\".ItemdefInstrument.InstrumentPieceR\x06pieces\x12&\n\x0fpitch_ran\
    ge_min\x18\x06\x20\x01(\x05R\rpitchRangeMin\x12&\n\x0fpitch_range_max\
    \x18\x07\x20\x01(\x05R\rpitchRangeMax\x12\"\n\rvolume_mb_min\x18\x08\x20\
    \x01(\x05R\x0bvolumeMbMin\x12\"\n\rvolume_mb_max\x18\t\x20\x01(\x05R\x0b\
    volumeMbMax\x12Q\n\x10sound_production\x18\n\x20\x03(\x0e2&.ItemdefInstr\
    ument.SoundProductionTypeR\x0fsoundProduction\x124\n\x16sound_production\
    _parm1\x18\x0b\x20\x03(\tR\x14soundProductionParm1\x124\n\x16sound_produ\
    ction_parm2\x18\x0c\x20\x03(\tR\x14soundProductionParm2\x12E\n\x0cpitch_\
    choice\x18\r\x20\x03(\x0e2\".ItemdefInstrument.PitchChoiceTypeR\x0bpitch\
    Choice\x12,\n\x12pitch_choice_parm1\x18\x0e\x20\x03(\tR\x10pitchChoicePa\
    rm1\x12,\n\x12pitch_choice_parm2\x18\x0f\x20\x03(\tR\x10pitchChoiceParm2\
    \x125\n\x06tuning\x18\x10\x20\x03(\x0e2\x1d.ItemdefInstrument.TuningType\
    R\x06tuning\x12\x1f\n\x0btuning_parm\x18\x11\x20\x03(\tR\ntuningParm\x12\
    C\n\tregisters\x18\x12\x20\x03(\x0b2%.ItemdefInstrument.InstrumentRegist\
    erR\tregisters\x12\x20\n\x0bdescription\x18\x13\x20\x01(\tR\x0bdescripti\
    on*\xf9\x01\n\x0fPitchChoiceType\x12\x15\n\x11MEMBRANE_POSITION\x10\0\
    \x12\x12\n\x0eSUBPART_CHOICE\x10\x01\x12\x0c\n\x08KEYBOARD\x10\x02\x12\
    \x11\n\rSTOPPING_FRET\x10\x03\x12\x19\n\x15STOPPING_AGAINST_BODY\x10\x04\
    \x12\x11\n\rSTOPPING_HOLE\x10\x05\x12\x15\n\x11STOPPING_HOLE_KEY\x10\x06\
    \x12\t\n\x05SLIDE\x10\x07\x12\x13\n\x0fHARMONIC_SERIES\x10\x08\x12\x14\n\
    \x10VALVE_ROUTES_AIR\x10\t\x12\x0e\n\nBP_IN_BELL\x10\n\x12\x0f\n\x0bFOOT\
    _PEDALS\x10\x0b*\xbe\x03\n\x13SoundProductionType\x12\x11\n\rPLUCKED_BY_\
    BP\x10\0\x12\x0b\n\x07PLUCKED\x10\x01\x12\t\n\x05BOWED\x10\x02\x12\x10\n\
    \x0cSTRUCK_BY_BP\x10\x03\x12\n\n\x06STRUCK\x10\x04\x12\x1e\n\x1aVIBRATE_\
    BP_AGAINST_OPENING\x10\x05\x12\x17\n\x13BLOW_AGAINST_FIPPLE\x10\x06\x12\
    \x1a\n\x16BLOW_OVER_OPENING_SIDE\x10\x07\x12\x19\n\x15BLOW_OVER_OPENING_\
    END\x10\x08\x12\x19\n\x15BLOW_OVER_SINGLE_REED\x10\t\x12\x19\n\x15BLOW_O\
    VER_DOUBLE_REED\x10\n\x12\x17\n\x13BLOW_OVER_FREE_REED\x10\x0b\x12\x13\n\
    \x0fSTRUCK_TOGETHER\x10\x0c\x12\n\n\x06SHAKEN\x10\r\x12\x0b\n\x07SCRAPED\
    \x10\x0e\x12\x0c\n\x08FRICTION\x10\x0f\x12\r\n\tRESONATOR\x10\x10\x12\
    \x11\n\rBAG_OVER_REED\x10\x11\x12\x11\n\rAIR_OVER_REED\x10\x12\x12\x16\n\
    \x12AIR_OVER_FREE_REED\x10\x13\x12\x16\n\x12AIR_AGAINST_FIPPLE\x10\x14*V\
    \n\nTuningType\x12\x08\n\x04PEGS\x10\0\x12\x16\n\x12ADJUSTABLE_BRIDGES\
    \x10\x01\x12\n\n\x06CROOKS\x10\x02\x12\x0e\n\nTIGHTENING\x10\x03\x12\n\n\
    \x06LEVERS\x10\x04B\x02H\x03b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(4);
            messages.push(InstrumentFlags::generated_message_descriptor_data());
            messages.push(InstrumentPiece::generated_message_descriptor_data());
            messages.push(InstrumentRegister::generated_message_descriptor_data());
            messages.push(InstrumentDef::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(PitchChoiceType::generated_enum_descriptor_data());
            enums.push(SoundProductionType::generated_enum_descriptor_data());
            enums.push(TuningType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
