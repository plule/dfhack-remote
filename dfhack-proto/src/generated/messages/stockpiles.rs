// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `stockpiles.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings {
    // message fields
    pub animals: ::protobuf::SingularPtrField<StockpileSettings_AnimalsSet>,
    pub food: ::protobuf::SingularPtrField<StockpileSettings_FoodSet>,
    pub furniture: ::protobuf::SingularPtrField<StockpileSettings_FurnitureSet>,
    unknown1: ::std::option::Option<i32>,
    pub refuse: ::protobuf::SingularPtrField<StockpileSettings_RefuseSet>,
    pub stone: ::protobuf::SingularPtrField<StockpileSettings_StoneSet>,
    pub ore: ::protobuf::SingularPtrField<StockpileSettings_OreSet>,
    pub ammo: ::protobuf::SingularPtrField<StockpileSettings_AmmoSet>,
    pub coin: ::protobuf::SingularPtrField<StockpileSettings_CoinSet>,
    pub barsblocks: ::protobuf::SingularPtrField<StockpileSettings_BarsBlocksSet>,
    pub gems: ::protobuf::SingularPtrField<StockpileSettings_GemsSet>,
    pub finished_goods: ::protobuf::SingularPtrField<StockpileSettings_FinishedGoodsSet>,
    pub leather: ::protobuf::SingularPtrField<StockpileSettings_LeatherSet>,
    pub cloth: ::protobuf::SingularPtrField<StockpileSettings_ClothSet>,
    pub wood: ::protobuf::SingularPtrField<StockpileSettings_WoodSet>,
    pub weapons: ::protobuf::SingularPtrField<StockpileSettings_WeaponsSet>,
    pub armor: ::protobuf::SingularPtrField<StockpileSettings_ArmorSet>,
    allow_organic: ::std::option::Option<bool>,
    allow_inorganic: ::std::option::Option<bool>,
    corpses: ::std::option::Option<bool>,
    max_barrels: ::std::option::Option<i32>,
    max_bins: ::std::option::Option<i32>,
    max_wheelbarrows: ::std::option::Option<i32>,
    use_links_only: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings {
    fn default() -> &'a StockpileSettings {
        <StockpileSettings as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings {
    pub fn new() -> StockpileSettings {
        ::std::default::Default::default()
    }

    // optional .dfstockpiles.StockpileSettings.AnimalsSet animals = 1;


    pub fn get_animals(&self) -> &StockpileSettings_AnimalsSet {
        self.animals.as_ref().unwrap_or_else(|| <StockpileSettings_AnimalsSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_animals(&mut self) {
        self.animals.clear();
    }

    pub fn has_animals(&self) -> bool {
        self.animals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animals(&mut self, v: StockpileSettings_AnimalsSet) {
        self.animals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_animals(&mut self) -> &mut StockpileSettings_AnimalsSet {
        if self.animals.is_none() {
            self.animals.set_default();
        }
        self.animals.as_mut().unwrap()
    }

    // Take field
    pub fn take_animals(&mut self) -> StockpileSettings_AnimalsSet {
        self.animals.take().unwrap_or_else(|| StockpileSettings_AnimalsSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.FoodSet food = 2;


    pub fn get_food(&self) -> &StockpileSettings_FoodSet {
        self.food.as_ref().unwrap_or_else(|| <StockpileSettings_FoodSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_food(&mut self) {
        self.food.clear();
    }

    pub fn has_food(&self) -> bool {
        self.food.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food(&mut self, v: StockpileSettings_FoodSet) {
        self.food = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_food(&mut self) -> &mut StockpileSettings_FoodSet {
        if self.food.is_none() {
            self.food.set_default();
        }
        self.food.as_mut().unwrap()
    }

    // Take field
    pub fn take_food(&mut self) -> StockpileSettings_FoodSet {
        self.food.take().unwrap_or_else(|| StockpileSettings_FoodSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.FurnitureSet furniture = 3;


    pub fn get_furniture(&self) -> &StockpileSettings_FurnitureSet {
        self.furniture.as_ref().unwrap_or_else(|| <StockpileSettings_FurnitureSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_furniture(&mut self) {
        self.furniture.clear();
    }

    pub fn has_furniture(&self) -> bool {
        self.furniture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_furniture(&mut self, v: StockpileSettings_FurnitureSet) {
        self.furniture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_furniture(&mut self) -> &mut StockpileSettings_FurnitureSet {
        if self.furniture.is_none() {
            self.furniture.set_default();
        }
        self.furniture.as_mut().unwrap()
    }

    // Take field
    pub fn take_furniture(&mut self) -> StockpileSettings_FurnitureSet {
        self.furniture.take().unwrap_or_else(|| StockpileSettings_FurnitureSet::new())
    }

    // optional int32 unknown1 = 4;


    pub fn get_unknown1(&self) -> i32 {
        self.unknown1.unwrap_or(0)
    }
    pub fn clear_unknown1(&mut self) {
        self.unknown1 = ::std::option::Option::None;
    }

    pub fn has_unknown1(&self) -> bool {
        self.unknown1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown1(&mut self, v: i32) {
        self.unknown1 = ::std::option::Option::Some(v);
    }

    // optional .dfstockpiles.StockpileSettings.RefuseSet refuse = 5;


    pub fn get_refuse(&self) -> &StockpileSettings_RefuseSet {
        self.refuse.as_ref().unwrap_or_else(|| <StockpileSettings_RefuseSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_refuse(&mut self) {
        self.refuse.clear();
    }

    pub fn has_refuse(&self) -> bool {
        self.refuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refuse(&mut self, v: StockpileSettings_RefuseSet) {
        self.refuse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refuse(&mut self) -> &mut StockpileSettings_RefuseSet {
        if self.refuse.is_none() {
            self.refuse.set_default();
        }
        self.refuse.as_mut().unwrap()
    }

    // Take field
    pub fn take_refuse(&mut self) -> StockpileSettings_RefuseSet {
        self.refuse.take().unwrap_or_else(|| StockpileSettings_RefuseSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.StoneSet stone = 6;


    pub fn get_stone(&self) -> &StockpileSettings_StoneSet {
        self.stone.as_ref().unwrap_or_else(|| <StockpileSettings_StoneSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stone(&mut self) {
        self.stone.clear();
    }

    pub fn has_stone(&self) -> bool {
        self.stone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stone(&mut self, v: StockpileSettings_StoneSet) {
        self.stone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stone(&mut self) -> &mut StockpileSettings_StoneSet {
        if self.stone.is_none() {
            self.stone.set_default();
        }
        self.stone.as_mut().unwrap()
    }

    // Take field
    pub fn take_stone(&mut self) -> StockpileSettings_StoneSet {
        self.stone.take().unwrap_or_else(|| StockpileSettings_StoneSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.OreSet ore = 7;


    pub fn get_ore(&self) -> &StockpileSettings_OreSet {
        self.ore.as_ref().unwrap_or_else(|| <StockpileSettings_OreSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ore(&mut self) {
        self.ore.clear();
    }

    pub fn has_ore(&self) -> bool {
        self.ore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ore(&mut self, v: StockpileSettings_OreSet) {
        self.ore = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ore(&mut self) -> &mut StockpileSettings_OreSet {
        if self.ore.is_none() {
            self.ore.set_default();
        }
        self.ore.as_mut().unwrap()
    }

    // Take field
    pub fn take_ore(&mut self) -> StockpileSettings_OreSet {
        self.ore.take().unwrap_or_else(|| StockpileSettings_OreSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.AmmoSet ammo = 8;


    pub fn get_ammo(&self) -> &StockpileSettings_AmmoSet {
        self.ammo.as_ref().unwrap_or_else(|| <StockpileSettings_AmmoSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ammo(&mut self) {
        self.ammo.clear();
    }

    pub fn has_ammo(&self) -> bool {
        self.ammo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo(&mut self, v: StockpileSettings_AmmoSet) {
        self.ammo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ammo(&mut self) -> &mut StockpileSettings_AmmoSet {
        if self.ammo.is_none() {
            self.ammo.set_default();
        }
        self.ammo.as_mut().unwrap()
    }

    // Take field
    pub fn take_ammo(&mut self) -> StockpileSettings_AmmoSet {
        self.ammo.take().unwrap_or_else(|| StockpileSettings_AmmoSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.CoinSet coin = 9;


    pub fn get_coin(&self) -> &StockpileSettings_CoinSet {
        self.coin.as_ref().unwrap_or_else(|| <StockpileSettings_CoinSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coin(&mut self) {
        self.coin.clear();
    }

    pub fn has_coin(&self) -> bool {
        self.coin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin(&mut self, v: StockpileSettings_CoinSet) {
        self.coin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coin(&mut self) -> &mut StockpileSettings_CoinSet {
        if self.coin.is_none() {
            self.coin.set_default();
        }
        self.coin.as_mut().unwrap()
    }

    // Take field
    pub fn take_coin(&mut self) -> StockpileSettings_CoinSet {
        self.coin.take().unwrap_or_else(|| StockpileSettings_CoinSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.BarsBlocksSet barsblocks = 10;


    pub fn get_barsblocks(&self) -> &StockpileSettings_BarsBlocksSet {
        self.barsblocks.as_ref().unwrap_or_else(|| <StockpileSettings_BarsBlocksSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_barsblocks(&mut self) {
        self.barsblocks.clear();
    }

    pub fn has_barsblocks(&self) -> bool {
        self.barsblocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_barsblocks(&mut self, v: StockpileSettings_BarsBlocksSet) {
        self.barsblocks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_barsblocks(&mut self) -> &mut StockpileSettings_BarsBlocksSet {
        if self.barsblocks.is_none() {
            self.barsblocks.set_default();
        }
        self.barsblocks.as_mut().unwrap()
    }

    // Take field
    pub fn take_barsblocks(&mut self) -> StockpileSettings_BarsBlocksSet {
        self.barsblocks.take().unwrap_or_else(|| StockpileSettings_BarsBlocksSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.GemsSet gems = 11;


    pub fn get_gems(&self) -> &StockpileSettings_GemsSet {
        self.gems.as_ref().unwrap_or_else(|| <StockpileSettings_GemsSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gems(&mut self) {
        self.gems.clear();
    }

    pub fn has_gems(&self) -> bool {
        self.gems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gems(&mut self, v: StockpileSettings_GemsSet) {
        self.gems = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gems(&mut self) -> &mut StockpileSettings_GemsSet {
        if self.gems.is_none() {
            self.gems.set_default();
        }
        self.gems.as_mut().unwrap()
    }

    // Take field
    pub fn take_gems(&mut self) -> StockpileSettings_GemsSet {
        self.gems.take().unwrap_or_else(|| StockpileSettings_GemsSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.FinishedGoodsSet finished_goods = 12;


    pub fn get_finished_goods(&self) -> &StockpileSettings_FinishedGoodsSet {
        self.finished_goods.as_ref().unwrap_or_else(|| <StockpileSettings_FinishedGoodsSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_finished_goods(&mut self) {
        self.finished_goods.clear();
    }

    pub fn has_finished_goods(&self) -> bool {
        self.finished_goods.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finished_goods(&mut self, v: StockpileSettings_FinishedGoodsSet) {
        self.finished_goods = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finished_goods(&mut self) -> &mut StockpileSettings_FinishedGoodsSet {
        if self.finished_goods.is_none() {
            self.finished_goods.set_default();
        }
        self.finished_goods.as_mut().unwrap()
    }

    // Take field
    pub fn take_finished_goods(&mut self) -> StockpileSettings_FinishedGoodsSet {
        self.finished_goods.take().unwrap_or_else(|| StockpileSettings_FinishedGoodsSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.LeatherSet leather = 13;


    pub fn get_leather(&self) -> &StockpileSettings_LeatherSet {
        self.leather.as_ref().unwrap_or_else(|| <StockpileSettings_LeatherSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leather(&mut self) {
        self.leather.clear();
    }

    pub fn has_leather(&self) -> bool {
        self.leather.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leather(&mut self, v: StockpileSettings_LeatherSet) {
        self.leather = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leather(&mut self) -> &mut StockpileSettings_LeatherSet {
        if self.leather.is_none() {
            self.leather.set_default();
        }
        self.leather.as_mut().unwrap()
    }

    // Take field
    pub fn take_leather(&mut self) -> StockpileSettings_LeatherSet {
        self.leather.take().unwrap_or_else(|| StockpileSettings_LeatherSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.ClothSet cloth = 14;


    pub fn get_cloth(&self) -> &StockpileSettings_ClothSet {
        self.cloth.as_ref().unwrap_or_else(|| <StockpileSettings_ClothSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cloth(&mut self) {
        self.cloth.clear();
    }

    pub fn has_cloth(&self) -> bool {
        self.cloth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloth(&mut self, v: StockpileSettings_ClothSet) {
        self.cloth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloth(&mut self) -> &mut StockpileSettings_ClothSet {
        if self.cloth.is_none() {
            self.cloth.set_default();
        }
        self.cloth.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloth(&mut self) -> StockpileSettings_ClothSet {
        self.cloth.take().unwrap_or_else(|| StockpileSettings_ClothSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.WoodSet wood = 15;


    pub fn get_wood(&self) -> &StockpileSettings_WoodSet {
        self.wood.as_ref().unwrap_or_else(|| <StockpileSettings_WoodSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_wood(&mut self) {
        self.wood.clear();
    }

    pub fn has_wood(&self) -> bool {
        self.wood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wood(&mut self, v: StockpileSettings_WoodSet) {
        self.wood = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wood(&mut self) -> &mut StockpileSettings_WoodSet {
        if self.wood.is_none() {
            self.wood.set_default();
        }
        self.wood.as_mut().unwrap()
    }

    // Take field
    pub fn take_wood(&mut self) -> StockpileSettings_WoodSet {
        self.wood.take().unwrap_or_else(|| StockpileSettings_WoodSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.WeaponsSet weapons = 16;


    pub fn get_weapons(&self) -> &StockpileSettings_WeaponsSet {
        self.weapons.as_ref().unwrap_or_else(|| <StockpileSettings_WeaponsSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weapons(&mut self) {
        self.weapons.clear();
    }

    pub fn has_weapons(&self) -> bool {
        self.weapons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weapons(&mut self, v: StockpileSettings_WeaponsSet) {
        self.weapons = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weapons(&mut self) -> &mut StockpileSettings_WeaponsSet {
        if self.weapons.is_none() {
            self.weapons.set_default();
        }
        self.weapons.as_mut().unwrap()
    }

    // Take field
    pub fn take_weapons(&mut self) -> StockpileSettings_WeaponsSet {
        self.weapons.take().unwrap_or_else(|| StockpileSettings_WeaponsSet::new())
    }

    // optional .dfstockpiles.StockpileSettings.ArmorSet armor = 17;


    pub fn get_armor(&self) -> &StockpileSettings_ArmorSet {
        self.armor.as_ref().unwrap_or_else(|| <StockpileSettings_ArmorSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_armor(&mut self) {
        self.armor.clear();
    }

    pub fn has_armor(&self) -> bool {
        self.armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: StockpileSettings_ArmorSet) {
        self.armor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_armor(&mut self) -> &mut StockpileSettings_ArmorSet {
        if self.armor.is_none() {
            self.armor.set_default();
        }
        self.armor.as_mut().unwrap()
    }

    // Take field
    pub fn take_armor(&mut self) -> StockpileSettings_ArmorSet {
        self.armor.take().unwrap_or_else(|| StockpileSettings_ArmorSet::new())
    }

    // optional bool allow_organic = 18;


    pub fn get_allow_organic(&self) -> bool {
        self.allow_organic.unwrap_or(false)
    }
    pub fn clear_allow_organic(&mut self) {
        self.allow_organic = ::std::option::Option::None;
    }

    pub fn has_allow_organic(&self) -> bool {
        self.allow_organic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_organic(&mut self, v: bool) {
        self.allow_organic = ::std::option::Option::Some(v);
    }

    // optional bool allow_inorganic = 19;


    pub fn get_allow_inorganic(&self) -> bool {
        self.allow_inorganic.unwrap_or(false)
    }
    pub fn clear_allow_inorganic(&mut self) {
        self.allow_inorganic = ::std::option::Option::None;
    }

    pub fn has_allow_inorganic(&self) -> bool {
        self.allow_inorganic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_inorganic(&mut self, v: bool) {
        self.allow_inorganic = ::std::option::Option::Some(v);
    }

    // optional bool corpses = 24;


    pub fn get_corpses(&self) -> bool {
        self.corpses.unwrap_or(false)
    }
    pub fn clear_corpses(&mut self) {
        self.corpses = ::std::option::Option::None;
    }

    pub fn has_corpses(&self) -> bool {
        self.corpses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corpses(&mut self, v: bool) {
        self.corpses = ::std::option::Option::Some(v);
    }

    // optional int32 max_barrels = 20;


    pub fn get_max_barrels(&self) -> i32 {
        self.max_barrels.unwrap_or(0)
    }
    pub fn clear_max_barrels(&mut self) {
        self.max_barrels = ::std::option::Option::None;
    }

    pub fn has_max_barrels(&self) -> bool {
        self.max_barrels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_barrels(&mut self, v: i32) {
        self.max_barrels = ::std::option::Option::Some(v);
    }

    // optional int32 max_bins = 21;


    pub fn get_max_bins(&self) -> i32 {
        self.max_bins.unwrap_or(0)
    }
    pub fn clear_max_bins(&mut self) {
        self.max_bins = ::std::option::Option::None;
    }

    pub fn has_max_bins(&self) -> bool {
        self.max_bins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bins(&mut self, v: i32) {
        self.max_bins = ::std::option::Option::Some(v);
    }

    // optional int32 max_wheelbarrows = 22;


    pub fn get_max_wheelbarrows(&self) -> i32 {
        self.max_wheelbarrows.unwrap_or(0)
    }
    pub fn clear_max_wheelbarrows(&mut self) {
        self.max_wheelbarrows = ::std::option::Option::None;
    }

    pub fn has_max_wheelbarrows(&self) -> bool {
        self.max_wheelbarrows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_wheelbarrows(&mut self, v: i32) {
        self.max_wheelbarrows = ::std::option::Option::Some(v);
    }

    // optional bool use_links_only = 23;


    pub fn get_use_links_only(&self) -> bool {
        self.use_links_only.unwrap_or(false)
    }
    pub fn clear_use_links_only(&mut self) {
        self.use_links_only = ::std::option::Option::None;
    }

    pub fn has_use_links_only(&self) -> bool {
        self.use_links_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_links_only(&mut self, v: bool) {
        self.use_links_only = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StockpileSettings {
    fn is_initialized(&self) -> bool {
        for v in &self.animals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.food {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.furniture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refuse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stone {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ore {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ammo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.barsblocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gems {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finished_goods {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leather {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wood {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.weapons {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.armor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.animals)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.food)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.furniture)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknown1 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.refuse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stone)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ore)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ammo)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coin)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.barsblocks)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gems)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finished_goods)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leather)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloth)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wood)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weapons)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.armor)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_organic = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_inorganic = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.corpses = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_barrels = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_bins = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_wheelbarrows = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_links_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.animals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.food.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.furniture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.unknown1 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.refuse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ammo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.barsblocks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gems.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finished_goods.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.leather.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.wood.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.weapons.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.armor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allow_organic {
            my_size += 3;
        }
        if let Some(v) = self.allow_inorganic {
            my_size += 3;
        }
        if let Some(v) = self.corpses {
            my_size += 3;
        }
        if let Some(v) = self.max_barrels {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_bins {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_wheelbarrows {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_links_only {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.animals.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.food.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.furniture.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.unknown1 {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.refuse.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stone.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ore.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ammo.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coin.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.barsblocks.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gems.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finished_goods.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.leather.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloth.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.wood.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.weapons.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.armor.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.allow_organic {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.allow_inorganic {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.corpses {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.max_barrels {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.max_bins {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.max_wheelbarrows {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.use_links_only {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings {
        StockpileSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_AnimalsSet>>(
                "animals",
                |m: &StockpileSettings| { &m.animals },
                |m: &mut StockpileSettings| { &mut m.animals },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_FoodSet>>(
                "food",
                |m: &StockpileSettings| { &m.food },
                |m: &mut StockpileSettings| { &mut m.food },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_FurnitureSet>>(
                "furniture",
                |m: &StockpileSettings| { &m.furniture },
                |m: &mut StockpileSettings| { &mut m.furniture },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown1",
                |m: &StockpileSettings| { &m.unknown1 },
                |m: &mut StockpileSettings| { &mut m.unknown1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_RefuseSet>>(
                "refuse",
                |m: &StockpileSettings| { &m.refuse },
                |m: &mut StockpileSettings| { &mut m.refuse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_StoneSet>>(
                "stone",
                |m: &StockpileSettings| { &m.stone },
                |m: &mut StockpileSettings| { &mut m.stone },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_OreSet>>(
                "ore",
                |m: &StockpileSettings| { &m.ore },
                |m: &mut StockpileSettings| { &mut m.ore },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_AmmoSet>>(
                "ammo",
                |m: &StockpileSettings| { &m.ammo },
                |m: &mut StockpileSettings| { &mut m.ammo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_CoinSet>>(
                "coin",
                |m: &StockpileSettings| { &m.coin },
                |m: &mut StockpileSettings| { &mut m.coin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_BarsBlocksSet>>(
                "barsblocks",
                |m: &StockpileSettings| { &m.barsblocks },
                |m: &mut StockpileSettings| { &mut m.barsblocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_GemsSet>>(
                "gems",
                |m: &StockpileSettings| { &m.gems },
                |m: &mut StockpileSettings| { &mut m.gems },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_FinishedGoodsSet>>(
                "finished_goods",
                |m: &StockpileSettings| { &m.finished_goods },
                |m: &mut StockpileSettings| { &mut m.finished_goods },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_LeatherSet>>(
                "leather",
                |m: &StockpileSettings| { &m.leather },
                |m: &mut StockpileSettings| { &mut m.leather },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_ClothSet>>(
                "cloth",
                |m: &StockpileSettings| { &m.cloth },
                |m: &mut StockpileSettings| { &mut m.cloth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_WoodSet>>(
                "wood",
                |m: &StockpileSettings| { &m.wood },
                |m: &mut StockpileSettings| { &mut m.wood },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_WeaponsSet>>(
                "weapons",
                |m: &StockpileSettings| { &m.weapons },
                |m: &mut StockpileSettings| { &mut m.weapons },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StockpileSettings_ArmorSet>>(
                "armor",
                |m: &StockpileSettings| { &m.armor },
                |m: &mut StockpileSettings| { &mut m.armor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_organic",
                |m: &StockpileSettings| { &m.allow_organic },
                |m: &mut StockpileSettings| { &mut m.allow_organic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_inorganic",
                |m: &StockpileSettings| { &m.allow_inorganic },
                |m: &mut StockpileSettings| { &mut m.allow_inorganic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "corpses",
                |m: &StockpileSettings| { &m.corpses },
                |m: &mut StockpileSettings| { &mut m.corpses },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_barrels",
                |m: &StockpileSettings| { &m.max_barrels },
                |m: &mut StockpileSettings| { &mut m.max_barrels },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_bins",
                |m: &StockpileSettings| { &m.max_bins },
                |m: &mut StockpileSettings| { &mut m.max_bins },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_wheelbarrows",
                |m: &StockpileSettings| { &m.max_wheelbarrows },
                |m: &mut StockpileSettings| { &mut m.max_wheelbarrows },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_links_only",
                |m: &StockpileSettings| { &m.use_links_only },
                |m: &mut StockpileSettings| { &mut m.use_links_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings>(
                "StockpileSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings::new)
    }
}

impl ::protobuf::Clear for StockpileSettings {
    fn clear(&mut self) {
        self.animals.clear();
        self.food.clear();
        self.furniture.clear();
        self.unknown1 = ::std::option::Option::None;
        self.refuse.clear();
        self.stone.clear();
        self.ore.clear();
        self.ammo.clear();
        self.coin.clear();
        self.barsblocks.clear();
        self.gems.clear();
        self.finished_goods.clear();
        self.leather.clear();
        self.cloth.clear();
        self.wood.clear();
        self.weapons.clear();
        self.armor.clear();
        self.allow_organic = ::std::option::Option::None;
        self.allow_inorganic = ::std::option::Option::None;
        self.corpses = ::std::option::Option::None;
        self.max_barrels = ::std::option::Option::None;
        self.max_bins = ::std::option::Option::None;
        self.max_wheelbarrows = ::std::option::Option::None;
        self.use_links_only = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_AnimalsSet {
    // message fields
    empty_cages: ::std::option::Option<bool>,
    empty_traps: ::std::option::Option<bool>,
    pub enabled: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_AnimalsSet {
    fn default() -> &'a StockpileSettings_AnimalsSet {
        <StockpileSettings_AnimalsSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_AnimalsSet {
    pub fn new() -> StockpileSettings_AnimalsSet {
        ::std::default::Default::default()
    }

    // optional bool empty_cages = 1;


    pub fn get_empty_cages(&self) -> bool {
        self.empty_cages.unwrap_or(false)
    }
    pub fn clear_empty_cages(&mut self) {
        self.empty_cages = ::std::option::Option::None;
    }

    pub fn has_empty_cages(&self) -> bool {
        self.empty_cages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_empty_cages(&mut self, v: bool) {
        self.empty_cages = ::std::option::Option::Some(v);
    }

    // optional bool empty_traps = 2;


    pub fn get_empty_traps(&self) -> bool {
        self.empty_traps.unwrap_or(false)
    }
    pub fn clear_empty_traps(&mut self) {
        self.empty_traps = ::std::option::Option::None;
    }

    pub fn has_empty_traps(&self) -> bool {
        self.empty_traps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_empty_traps(&mut self, v: bool) {
        self.empty_traps = ::std::option::Option::Some(v);
    }

    // repeated string enabled = 3;


    pub fn get_enabled(&self) -> &[::std::string::String] {
        &self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled.clear();
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.enabled = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enabled(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.enabled
    }

    // Take field
    pub fn take_enabled(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.enabled, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_AnimalsSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.empty_cages = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.empty_traps = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.enabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.empty_cages {
            my_size += 2;
        }
        if let Some(v) = self.empty_traps {
            my_size += 2;
        }
        for value in &self.enabled {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.empty_cages {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.empty_traps {
            os.write_bool(2, v)?;
        }
        for v in &self.enabled {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_AnimalsSet {
        StockpileSettings_AnimalsSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "empty_cages",
                |m: &StockpileSettings_AnimalsSet| { &m.empty_cages },
                |m: &mut StockpileSettings_AnimalsSet| { &mut m.empty_cages },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "empty_traps",
                |m: &StockpileSettings_AnimalsSet| { &m.empty_traps },
                |m: &mut StockpileSettings_AnimalsSet| { &mut m.empty_traps },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "enabled",
                |m: &StockpileSettings_AnimalsSet| { &m.enabled },
                |m: &mut StockpileSettings_AnimalsSet| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_AnimalsSet>(
                "StockpileSettings.AnimalsSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_AnimalsSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_AnimalsSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_AnimalsSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_AnimalsSet {
    fn clear(&mut self) {
        self.empty_cages = ::std::option::Option::None;
        self.empty_traps = ::std::option::Option::None;
        self.enabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_AnimalsSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_AnimalsSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_FoodSet {
    // message fields
    pub meat: ::protobuf::RepeatedField<::std::string::String>,
    pub fish: ::protobuf::RepeatedField<::std::string::String>,
    pub unprepared_fish: ::protobuf::RepeatedField<::std::string::String>,
    pub egg: ::protobuf::RepeatedField<::std::string::String>,
    pub plants: ::protobuf::RepeatedField<::std::string::String>,
    pub drink_plant: ::protobuf::RepeatedField<::std::string::String>,
    pub drink_animal: ::protobuf::RepeatedField<::std::string::String>,
    pub cheese_plant: ::protobuf::RepeatedField<::std::string::String>,
    pub cheese_animal: ::protobuf::RepeatedField<::std::string::String>,
    pub seeds: ::protobuf::RepeatedField<::std::string::String>,
    pub leaves: ::protobuf::RepeatedField<::std::string::String>,
    pub powder_plant: ::protobuf::RepeatedField<::std::string::String>,
    pub powder_creature: ::protobuf::RepeatedField<::std::string::String>,
    pub glob: ::protobuf::RepeatedField<::std::string::String>,
    pub glob_paste: ::protobuf::RepeatedField<::std::string::String>,
    pub glob_pressed: ::protobuf::RepeatedField<::std::string::String>,
    pub liquid_plant: ::protobuf::RepeatedField<::std::string::String>,
    pub liquid_animal: ::protobuf::RepeatedField<::std::string::String>,
    pub liquid_misc: ::protobuf::RepeatedField<::std::string::String>,
    prepared_meals: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_FoodSet {
    fn default() -> &'a StockpileSettings_FoodSet {
        <StockpileSettings_FoodSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_FoodSet {
    pub fn new() -> StockpileSettings_FoodSet {
        ::std::default::Default::default()
    }

    // repeated string meat = 1;


    pub fn get_meat(&self) -> &[::std::string::String] {
        &self.meat
    }
    pub fn clear_meat(&mut self) {
        self.meat.clear();
    }

    // Param is passed by value, moved
    pub fn set_meat(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.meat = v;
    }

    // Mutable pointer to the field.
    pub fn mut_meat(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.meat
    }

    // Take field
    pub fn take_meat(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.meat, ::protobuf::RepeatedField::new())
    }

    // repeated string fish = 2;


    pub fn get_fish(&self) -> &[::std::string::String] {
        &self.fish
    }
    pub fn clear_fish(&mut self) {
        self.fish.clear();
    }

    // Param is passed by value, moved
    pub fn set_fish(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fish = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fish(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fish
    }

    // Take field
    pub fn take_fish(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fish, ::protobuf::RepeatedField::new())
    }

    // repeated string unprepared_fish = 20;


    pub fn get_unprepared_fish(&self) -> &[::std::string::String] {
        &self.unprepared_fish
    }
    pub fn clear_unprepared_fish(&mut self) {
        self.unprepared_fish.clear();
    }

    // Param is passed by value, moved
    pub fn set_unprepared_fish(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.unprepared_fish = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unprepared_fish(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.unprepared_fish
    }

    // Take field
    pub fn take_unprepared_fish(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.unprepared_fish, ::protobuf::RepeatedField::new())
    }

    // repeated string egg = 3;


    pub fn get_egg(&self) -> &[::std::string::String] {
        &self.egg
    }
    pub fn clear_egg(&mut self) {
        self.egg.clear();
    }

    // Param is passed by value, moved
    pub fn set_egg(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.egg = v;
    }

    // Mutable pointer to the field.
    pub fn mut_egg(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.egg
    }

    // Take field
    pub fn take_egg(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.egg, ::protobuf::RepeatedField::new())
    }

    // repeated string plants = 4;


    pub fn get_plants(&self) -> &[::std::string::String] {
        &self.plants
    }
    pub fn clear_plants(&mut self) {
        self.plants.clear();
    }

    // Param is passed by value, moved
    pub fn set_plants(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.plants = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plants(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.plants
    }

    // Take field
    pub fn take_plants(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.plants, ::protobuf::RepeatedField::new())
    }

    // repeated string drink_plant = 5;


    pub fn get_drink_plant(&self) -> &[::std::string::String] {
        &self.drink_plant
    }
    pub fn clear_drink_plant(&mut self) {
        self.drink_plant.clear();
    }

    // Param is passed by value, moved
    pub fn set_drink_plant(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.drink_plant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drink_plant(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.drink_plant
    }

    // Take field
    pub fn take_drink_plant(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.drink_plant, ::protobuf::RepeatedField::new())
    }

    // repeated string drink_animal = 6;


    pub fn get_drink_animal(&self) -> &[::std::string::String] {
        &self.drink_animal
    }
    pub fn clear_drink_animal(&mut self) {
        self.drink_animal.clear();
    }

    // Param is passed by value, moved
    pub fn set_drink_animal(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.drink_animal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drink_animal(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.drink_animal
    }

    // Take field
    pub fn take_drink_animal(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.drink_animal, ::protobuf::RepeatedField::new())
    }

    // repeated string cheese_plant = 7;


    pub fn get_cheese_plant(&self) -> &[::std::string::String] {
        &self.cheese_plant
    }
    pub fn clear_cheese_plant(&mut self) {
        self.cheese_plant.clear();
    }

    // Param is passed by value, moved
    pub fn set_cheese_plant(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cheese_plant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cheese_plant(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cheese_plant
    }

    // Take field
    pub fn take_cheese_plant(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cheese_plant, ::protobuf::RepeatedField::new())
    }

    // repeated string cheese_animal = 8;


    pub fn get_cheese_animal(&self) -> &[::std::string::String] {
        &self.cheese_animal
    }
    pub fn clear_cheese_animal(&mut self) {
        self.cheese_animal.clear();
    }

    // Param is passed by value, moved
    pub fn set_cheese_animal(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cheese_animal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cheese_animal(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cheese_animal
    }

    // Take field
    pub fn take_cheese_animal(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cheese_animal, ::protobuf::RepeatedField::new())
    }

    // repeated string seeds = 9;


    pub fn get_seeds(&self) -> &[::std::string::String] {
        &self.seeds
    }
    pub fn clear_seeds(&mut self) {
        self.seeds.clear();
    }

    // Param is passed by value, moved
    pub fn set_seeds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.seeds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_seeds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.seeds
    }

    // Take field
    pub fn take_seeds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.seeds, ::protobuf::RepeatedField::new())
    }

    // repeated string leaves = 10;


    pub fn get_leaves(&self) -> &[::std::string::String] {
        &self.leaves
    }
    pub fn clear_leaves(&mut self) {
        self.leaves.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaves(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.leaves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leaves(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.leaves
    }

    // Take field
    pub fn take_leaves(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.leaves, ::protobuf::RepeatedField::new())
    }

    // repeated string powder_plant = 11;


    pub fn get_powder_plant(&self) -> &[::std::string::String] {
        &self.powder_plant
    }
    pub fn clear_powder_plant(&mut self) {
        self.powder_plant.clear();
    }

    // Param is passed by value, moved
    pub fn set_powder_plant(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.powder_plant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_powder_plant(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.powder_plant
    }

    // Take field
    pub fn take_powder_plant(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.powder_plant, ::protobuf::RepeatedField::new())
    }

    // repeated string powder_creature = 12;


    pub fn get_powder_creature(&self) -> &[::std::string::String] {
        &self.powder_creature
    }
    pub fn clear_powder_creature(&mut self) {
        self.powder_creature.clear();
    }

    // Param is passed by value, moved
    pub fn set_powder_creature(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.powder_creature = v;
    }

    // Mutable pointer to the field.
    pub fn mut_powder_creature(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.powder_creature
    }

    // Take field
    pub fn take_powder_creature(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.powder_creature, ::protobuf::RepeatedField::new())
    }

    // repeated string glob = 13;


    pub fn get_glob(&self) -> &[::std::string::String] {
        &self.glob
    }
    pub fn clear_glob(&mut self) {
        self.glob.clear();
    }

    // Param is passed by value, moved
    pub fn set_glob(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.glob = v;
    }

    // Mutable pointer to the field.
    pub fn mut_glob(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.glob
    }

    // Take field
    pub fn take_glob(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.glob, ::protobuf::RepeatedField::new())
    }

    // repeated string glob_paste = 14;


    pub fn get_glob_paste(&self) -> &[::std::string::String] {
        &self.glob_paste
    }
    pub fn clear_glob_paste(&mut self) {
        self.glob_paste.clear();
    }

    // Param is passed by value, moved
    pub fn set_glob_paste(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.glob_paste = v;
    }

    // Mutable pointer to the field.
    pub fn mut_glob_paste(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.glob_paste
    }

    // Take field
    pub fn take_glob_paste(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.glob_paste, ::protobuf::RepeatedField::new())
    }

    // repeated string glob_pressed = 15;


    pub fn get_glob_pressed(&self) -> &[::std::string::String] {
        &self.glob_pressed
    }
    pub fn clear_glob_pressed(&mut self) {
        self.glob_pressed.clear();
    }

    // Param is passed by value, moved
    pub fn set_glob_pressed(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.glob_pressed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_glob_pressed(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.glob_pressed
    }

    // Take field
    pub fn take_glob_pressed(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.glob_pressed, ::protobuf::RepeatedField::new())
    }

    // repeated string liquid_plant = 16;


    pub fn get_liquid_plant(&self) -> &[::std::string::String] {
        &self.liquid_plant
    }
    pub fn clear_liquid_plant(&mut self) {
        self.liquid_plant.clear();
    }

    // Param is passed by value, moved
    pub fn set_liquid_plant(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.liquid_plant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_liquid_plant(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.liquid_plant
    }

    // Take field
    pub fn take_liquid_plant(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.liquid_plant, ::protobuf::RepeatedField::new())
    }

    // repeated string liquid_animal = 17;


    pub fn get_liquid_animal(&self) -> &[::std::string::String] {
        &self.liquid_animal
    }
    pub fn clear_liquid_animal(&mut self) {
        self.liquid_animal.clear();
    }

    // Param is passed by value, moved
    pub fn set_liquid_animal(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.liquid_animal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_liquid_animal(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.liquid_animal
    }

    // Take field
    pub fn take_liquid_animal(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.liquid_animal, ::protobuf::RepeatedField::new())
    }

    // repeated string liquid_misc = 18;


    pub fn get_liquid_misc(&self) -> &[::std::string::String] {
        &self.liquid_misc
    }
    pub fn clear_liquid_misc(&mut self) {
        self.liquid_misc.clear();
    }

    // Param is passed by value, moved
    pub fn set_liquid_misc(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.liquid_misc = v;
    }

    // Mutable pointer to the field.
    pub fn mut_liquid_misc(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.liquid_misc
    }

    // Take field
    pub fn take_liquid_misc(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.liquid_misc, ::protobuf::RepeatedField::new())
    }

    // optional bool prepared_meals = 19;


    pub fn get_prepared_meals(&self) -> bool {
        self.prepared_meals.unwrap_or(false)
    }
    pub fn clear_prepared_meals(&mut self) {
        self.prepared_meals = ::std::option::Option::None;
    }

    pub fn has_prepared_meals(&self) -> bool {
        self.prepared_meals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepared_meals(&mut self, v: bool) {
        self.prepared_meals = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StockpileSettings_FoodSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.meat)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fish)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.unprepared_fish)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.egg)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.plants)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.drink_plant)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.drink_animal)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cheese_plant)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cheese_animal)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.seeds)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.leaves)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.powder_plant)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.powder_creature)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.glob)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.glob_paste)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.glob_pressed)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.liquid_plant)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.liquid_animal)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.liquid_misc)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prepared_meals = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.meat {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.fish {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.unprepared_fish {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.egg {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.plants {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.drink_plant {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.drink_animal {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.cheese_plant {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.cheese_animal {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.seeds {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.leaves {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.powder_plant {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.powder_creature {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.glob {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.glob_paste {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.glob_pressed {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.liquid_plant {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        for value in &self.liquid_animal {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.liquid_misc {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        if let Some(v) = self.prepared_meals {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.meat {
            os.write_string(1, &v)?;
        };
        for v in &self.fish {
            os.write_string(2, &v)?;
        };
        for v in &self.unprepared_fish {
            os.write_string(20, &v)?;
        };
        for v in &self.egg {
            os.write_string(3, &v)?;
        };
        for v in &self.plants {
            os.write_string(4, &v)?;
        };
        for v in &self.drink_plant {
            os.write_string(5, &v)?;
        };
        for v in &self.drink_animal {
            os.write_string(6, &v)?;
        };
        for v in &self.cheese_plant {
            os.write_string(7, &v)?;
        };
        for v in &self.cheese_animal {
            os.write_string(8, &v)?;
        };
        for v in &self.seeds {
            os.write_string(9, &v)?;
        };
        for v in &self.leaves {
            os.write_string(10, &v)?;
        };
        for v in &self.powder_plant {
            os.write_string(11, &v)?;
        };
        for v in &self.powder_creature {
            os.write_string(12, &v)?;
        };
        for v in &self.glob {
            os.write_string(13, &v)?;
        };
        for v in &self.glob_paste {
            os.write_string(14, &v)?;
        };
        for v in &self.glob_pressed {
            os.write_string(15, &v)?;
        };
        for v in &self.liquid_plant {
            os.write_string(16, &v)?;
        };
        for v in &self.liquid_animal {
            os.write_string(17, &v)?;
        };
        for v in &self.liquid_misc {
            os.write_string(18, &v)?;
        };
        if let Some(v) = self.prepared_meals {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_FoodSet {
        StockpileSettings_FoodSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "meat",
                |m: &StockpileSettings_FoodSet| { &m.meat },
                |m: &mut StockpileSettings_FoodSet| { &mut m.meat },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fish",
                |m: &StockpileSettings_FoodSet| { &m.fish },
                |m: &mut StockpileSettings_FoodSet| { &mut m.fish },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unprepared_fish",
                |m: &StockpileSettings_FoodSet| { &m.unprepared_fish },
                |m: &mut StockpileSettings_FoodSet| { &mut m.unprepared_fish },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "egg",
                |m: &StockpileSettings_FoodSet| { &m.egg },
                |m: &mut StockpileSettings_FoodSet| { &mut m.egg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plants",
                |m: &StockpileSettings_FoodSet| { &m.plants },
                |m: &mut StockpileSettings_FoodSet| { &mut m.plants },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "drink_plant",
                |m: &StockpileSettings_FoodSet| { &m.drink_plant },
                |m: &mut StockpileSettings_FoodSet| { &mut m.drink_plant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "drink_animal",
                |m: &StockpileSettings_FoodSet| { &m.drink_animal },
                |m: &mut StockpileSettings_FoodSet| { &mut m.drink_animal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cheese_plant",
                |m: &StockpileSettings_FoodSet| { &m.cheese_plant },
                |m: &mut StockpileSettings_FoodSet| { &mut m.cheese_plant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cheese_animal",
                |m: &StockpileSettings_FoodSet| { &m.cheese_animal },
                |m: &mut StockpileSettings_FoodSet| { &mut m.cheese_animal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seeds",
                |m: &StockpileSettings_FoodSet| { &m.seeds },
                |m: &mut StockpileSettings_FoodSet| { &mut m.seeds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "leaves",
                |m: &StockpileSettings_FoodSet| { &m.leaves },
                |m: &mut StockpileSettings_FoodSet| { &mut m.leaves },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "powder_plant",
                |m: &StockpileSettings_FoodSet| { &m.powder_plant },
                |m: &mut StockpileSettings_FoodSet| { &mut m.powder_plant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "powder_creature",
                |m: &StockpileSettings_FoodSet| { &m.powder_creature },
                |m: &mut StockpileSettings_FoodSet| { &mut m.powder_creature },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "glob",
                |m: &StockpileSettings_FoodSet| { &m.glob },
                |m: &mut StockpileSettings_FoodSet| { &mut m.glob },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "glob_paste",
                |m: &StockpileSettings_FoodSet| { &m.glob_paste },
                |m: &mut StockpileSettings_FoodSet| { &mut m.glob_paste },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "glob_pressed",
                |m: &StockpileSettings_FoodSet| { &m.glob_pressed },
                |m: &mut StockpileSettings_FoodSet| { &mut m.glob_pressed },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "liquid_plant",
                |m: &StockpileSettings_FoodSet| { &m.liquid_plant },
                |m: &mut StockpileSettings_FoodSet| { &mut m.liquid_plant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "liquid_animal",
                |m: &StockpileSettings_FoodSet| { &m.liquid_animal },
                |m: &mut StockpileSettings_FoodSet| { &mut m.liquid_animal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "liquid_misc",
                |m: &StockpileSettings_FoodSet| { &m.liquid_misc },
                |m: &mut StockpileSettings_FoodSet| { &mut m.liquid_misc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prepared_meals",
                |m: &StockpileSettings_FoodSet| { &m.prepared_meals },
                |m: &mut StockpileSettings_FoodSet| { &mut m.prepared_meals },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_FoodSet>(
                "StockpileSettings.FoodSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_FoodSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_FoodSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_FoodSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_FoodSet {
    fn clear(&mut self) {
        self.meat.clear();
        self.fish.clear();
        self.unprepared_fish.clear();
        self.egg.clear();
        self.plants.clear();
        self.drink_plant.clear();
        self.drink_animal.clear();
        self.cheese_plant.clear();
        self.cheese_animal.clear();
        self.seeds.clear();
        self.leaves.clear();
        self.powder_plant.clear();
        self.powder_creature.clear();
        self.glob.clear();
        self.glob_paste.clear();
        self.glob_pressed.clear();
        self.liquid_plant.clear();
        self.liquid_animal.clear();
        self.liquid_misc.clear();
        self.prepared_meals = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_FoodSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_FoodSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_FurnitureSet {
    // message fields
    pub field_type: ::protobuf::RepeatedField<::std::string::String>,
    pub other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_core: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_total: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_FurnitureSet {
    fn default() -> &'a StockpileSettings_FurnitureSet {
        <StockpileSettings_FurnitureSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_FurnitureSet {
    pub fn new() -> StockpileSettings_FurnitureSet {
        ::std::default::Default::default()
    }

    // repeated string type = 1;


    pub fn get_field_type(&self) -> &[::std::string::String] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.field_type, ::protobuf::RepeatedField::new())
    }

    // repeated string other_mats = 2;


    pub fn get_other_mats(&self) -> &[::std::string::String] {
        &self.other_mats
    }
    pub fn clear_other_mats(&mut self) {
        self.other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.other_mats
    }

    // Take field
    pub fn take_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string mats = 3;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_core = 4;


    pub fn get_quality_core(&self) -> &[::std::string::String] {
        &self.quality_core
    }
    pub fn clear_quality_core(&mut self) {
        self.quality_core.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_core(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_core = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_core(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_core
    }

    // Take field
    pub fn take_quality_core(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_core, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_total = 5;


    pub fn get_quality_total(&self) -> &[::std::string::String] {
        &self.quality_total
    }
    pub fn clear_quality_total(&mut self) {
        self.quality_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_total(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_total(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_total
    }

    // Take field
    pub fn take_quality_total(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_total, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_FurnitureSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.other_mats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_core)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_total)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_type {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.other_mats {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.quality_core {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.quality_total {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_type {
            os.write_string(1, &v)?;
        };
        for v in &self.other_mats {
            os.write_string(2, &v)?;
        };
        for v in &self.mats {
            os.write_string(3, &v)?;
        };
        for v in &self.quality_core {
            os.write_string(4, &v)?;
        };
        for v in &self.quality_total {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_FurnitureSet {
        StockpileSettings_FurnitureSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &StockpileSettings_FurnitureSet| { &m.field_type },
                |m: &mut StockpileSettings_FurnitureSet| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_mats",
                |m: &StockpileSettings_FurnitureSet| { &m.other_mats },
                |m: &mut StockpileSettings_FurnitureSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_FurnitureSet| { &m.mats },
                |m: &mut StockpileSettings_FurnitureSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_core",
                |m: &StockpileSettings_FurnitureSet| { &m.quality_core },
                |m: &mut StockpileSettings_FurnitureSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_total",
                |m: &StockpileSettings_FurnitureSet| { &m.quality_total },
                |m: &mut StockpileSettings_FurnitureSet| { &mut m.quality_total },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_FurnitureSet>(
                "StockpileSettings.FurnitureSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_FurnitureSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_FurnitureSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_FurnitureSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_FurnitureSet {
    fn clear(&mut self) {
        self.field_type.clear();
        self.other_mats.clear();
        self.mats.clear();
        self.quality_core.clear();
        self.quality_total.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_FurnitureSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_FurnitureSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_RefuseSet {
    // message fields
    pub field_type: ::protobuf::RepeatedField<::std::string::String>,
    pub corpses: ::protobuf::RepeatedField<::std::string::String>,
    pub body_parts: ::protobuf::RepeatedField<::std::string::String>,
    pub skulls: ::protobuf::RepeatedField<::std::string::String>,
    pub bones: ::protobuf::RepeatedField<::std::string::String>,
    pub hair: ::protobuf::RepeatedField<::std::string::String>,
    pub shells: ::protobuf::RepeatedField<::std::string::String>,
    pub teeth: ::protobuf::RepeatedField<::std::string::String>,
    pub horns: ::protobuf::RepeatedField<::std::string::String>,
    fresh_raw_hide: ::std::option::Option<bool>,
    rotten_raw_hide: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_RefuseSet {
    fn default() -> &'a StockpileSettings_RefuseSet {
        <StockpileSettings_RefuseSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_RefuseSet {
    pub fn new() -> StockpileSettings_RefuseSet {
        ::std::default::Default::default()
    }

    // repeated string type = 1;


    pub fn get_field_type(&self) -> &[::std::string::String] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.field_type, ::protobuf::RepeatedField::new())
    }

    // repeated string corpses = 2;


    pub fn get_corpses(&self) -> &[::std::string::String] {
        &self.corpses
    }
    pub fn clear_corpses(&mut self) {
        self.corpses.clear();
    }

    // Param is passed by value, moved
    pub fn set_corpses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.corpses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_corpses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.corpses
    }

    // Take field
    pub fn take_corpses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.corpses, ::protobuf::RepeatedField::new())
    }

    // repeated string body_parts = 3;


    pub fn get_body_parts(&self) -> &[::std::string::String] {
        &self.body_parts
    }
    pub fn clear_body_parts(&mut self) {
        self.body_parts.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_parts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body_parts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_parts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body_parts
    }

    // Take field
    pub fn take_body_parts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body_parts, ::protobuf::RepeatedField::new())
    }

    // repeated string skulls = 4;


    pub fn get_skulls(&self) -> &[::std::string::String] {
        &self.skulls
    }
    pub fn clear_skulls(&mut self) {
        self.skulls.clear();
    }

    // Param is passed by value, moved
    pub fn set_skulls(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.skulls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_skulls(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.skulls
    }

    // Take field
    pub fn take_skulls(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.skulls, ::protobuf::RepeatedField::new())
    }

    // repeated string bones = 5;


    pub fn get_bones(&self) -> &[::std::string::String] {
        &self.bones
    }
    pub fn clear_bones(&mut self) {
        self.bones.clear();
    }

    // Param is passed by value, moved
    pub fn set_bones(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.bones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bones(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.bones
    }

    // Take field
    pub fn take_bones(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.bones, ::protobuf::RepeatedField::new())
    }

    // repeated string hair = 6;


    pub fn get_hair(&self) -> &[::std::string::String] {
        &self.hair
    }
    pub fn clear_hair(&mut self) {
        self.hair.clear();
    }

    // Param is passed by value, moved
    pub fn set_hair(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hair = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hair(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hair
    }

    // Take field
    pub fn take_hair(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hair, ::protobuf::RepeatedField::new())
    }

    // repeated string shells = 7;


    pub fn get_shells(&self) -> &[::std::string::String] {
        &self.shells
    }
    pub fn clear_shells(&mut self) {
        self.shells.clear();
    }

    // Param is passed by value, moved
    pub fn set_shells(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.shells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shells(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.shells
    }

    // Take field
    pub fn take_shells(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.shells, ::protobuf::RepeatedField::new())
    }

    // repeated string teeth = 8;


    pub fn get_teeth(&self) -> &[::std::string::String] {
        &self.teeth
    }
    pub fn clear_teeth(&mut self) {
        self.teeth.clear();
    }

    // Param is passed by value, moved
    pub fn set_teeth(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.teeth = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teeth(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.teeth
    }

    // Take field
    pub fn take_teeth(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.teeth, ::protobuf::RepeatedField::new())
    }

    // repeated string horns = 9;


    pub fn get_horns(&self) -> &[::std::string::String] {
        &self.horns
    }
    pub fn clear_horns(&mut self) {
        self.horns.clear();
    }

    // Param is passed by value, moved
    pub fn set_horns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.horns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_horns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.horns
    }

    // Take field
    pub fn take_horns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.horns, ::protobuf::RepeatedField::new())
    }

    // optional bool fresh_raw_hide = 10;


    pub fn get_fresh_raw_hide(&self) -> bool {
        self.fresh_raw_hide.unwrap_or(false)
    }
    pub fn clear_fresh_raw_hide(&mut self) {
        self.fresh_raw_hide = ::std::option::Option::None;
    }

    pub fn has_fresh_raw_hide(&self) -> bool {
        self.fresh_raw_hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fresh_raw_hide(&mut self, v: bool) {
        self.fresh_raw_hide = ::std::option::Option::Some(v);
    }

    // optional bool rotten_raw_hide = 11;


    pub fn get_rotten_raw_hide(&self) -> bool {
        self.rotten_raw_hide.unwrap_or(false)
    }
    pub fn clear_rotten_raw_hide(&mut self) {
        self.rotten_raw_hide = ::std::option::Option::None;
    }

    pub fn has_rotten_raw_hide(&self) -> bool {
        self.rotten_raw_hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotten_raw_hide(&mut self, v: bool) {
        self.rotten_raw_hide = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StockpileSettings_RefuseSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.corpses)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body_parts)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.skulls)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.bones)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hair)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.shells)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.teeth)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.horns)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fresh_raw_hide = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rotten_raw_hide = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_type {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.corpses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.body_parts {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.skulls {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.bones {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.hair {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.shells {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.teeth {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.horns {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.fresh_raw_hide {
            my_size += 2;
        }
        if let Some(v) = self.rotten_raw_hide {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_type {
            os.write_string(1, &v)?;
        };
        for v in &self.corpses {
            os.write_string(2, &v)?;
        };
        for v in &self.body_parts {
            os.write_string(3, &v)?;
        };
        for v in &self.skulls {
            os.write_string(4, &v)?;
        };
        for v in &self.bones {
            os.write_string(5, &v)?;
        };
        for v in &self.hair {
            os.write_string(6, &v)?;
        };
        for v in &self.shells {
            os.write_string(7, &v)?;
        };
        for v in &self.teeth {
            os.write_string(8, &v)?;
        };
        for v in &self.horns {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.fresh_raw_hide {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.rotten_raw_hide {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_RefuseSet {
        StockpileSettings_RefuseSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &StockpileSettings_RefuseSet| { &m.field_type },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "corpses",
                |m: &StockpileSettings_RefuseSet| { &m.corpses },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.corpses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body_parts",
                |m: &StockpileSettings_RefuseSet| { &m.body_parts },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.body_parts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "skulls",
                |m: &StockpileSettings_RefuseSet| { &m.skulls },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.skulls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bones",
                |m: &StockpileSettings_RefuseSet| { &m.bones },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.bones },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hair",
                |m: &StockpileSettings_RefuseSet| { &m.hair },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.hair },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shells",
                |m: &StockpileSettings_RefuseSet| { &m.shells },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.shells },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "teeth",
                |m: &StockpileSettings_RefuseSet| { &m.teeth },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.teeth },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "horns",
                |m: &StockpileSettings_RefuseSet| { &m.horns },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.horns },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fresh_raw_hide",
                |m: &StockpileSettings_RefuseSet| { &m.fresh_raw_hide },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.fresh_raw_hide },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rotten_raw_hide",
                |m: &StockpileSettings_RefuseSet| { &m.rotten_raw_hide },
                |m: &mut StockpileSettings_RefuseSet| { &mut m.rotten_raw_hide },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_RefuseSet>(
                "StockpileSettings.RefuseSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_RefuseSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_RefuseSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_RefuseSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_RefuseSet {
    fn clear(&mut self) {
        self.field_type.clear();
        self.corpses.clear();
        self.body_parts.clear();
        self.skulls.clear();
        self.bones.clear();
        self.hair.clear();
        self.shells.clear();
        self.teeth.clear();
        self.horns.clear();
        self.fresh_raw_hide = ::std::option::Option::None;
        self.rotten_raw_hide = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_RefuseSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_RefuseSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_StoneSet {
    // message fields
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_StoneSet {
    fn default() -> &'a StockpileSettings_StoneSet {
        <StockpileSettings_StoneSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_StoneSet {
    pub fn new() -> StockpileSettings_StoneSet {
        ::std::default::Default::default()
    }

    // repeated string mats = 1;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_StoneSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mats {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_StoneSet {
        StockpileSettings_StoneSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_StoneSet| { &m.mats },
                |m: &mut StockpileSettings_StoneSet| { &mut m.mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_StoneSet>(
                "StockpileSettings.StoneSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_StoneSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_StoneSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_StoneSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_StoneSet {
    fn clear(&mut self) {
        self.mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_StoneSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_StoneSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_OreSet {
    // message fields
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_OreSet {
    fn default() -> &'a StockpileSettings_OreSet {
        <StockpileSettings_OreSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_OreSet {
    pub fn new() -> StockpileSettings_OreSet {
        ::std::default::Default::default()
    }

    // repeated string mats = 1;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_OreSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mats {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_OreSet {
        StockpileSettings_OreSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_OreSet| { &m.mats },
                |m: &mut StockpileSettings_OreSet| { &mut m.mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_OreSet>(
                "StockpileSettings.OreSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_OreSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_OreSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_OreSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_OreSet {
    fn clear(&mut self) {
        self.mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_OreSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_OreSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_AmmoSet {
    // message fields
    pub field_type: ::protobuf::RepeatedField<::std::string::String>,
    pub other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_core: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_total: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_AmmoSet {
    fn default() -> &'a StockpileSettings_AmmoSet {
        <StockpileSettings_AmmoSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_AmmoSet {
    pub fn new() -> StockpileSettings_AmmoSet {
        ::std::default::Default::default()
    }

    // repeated string type = 1;


    pub fn get_field_type(&self) -> &[::std::string::String] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.field_type, ::protobuf::RepeatedField::new())
    }

    // repeated string other_mats = 2;


    pub fn get_other_mats(&self) -> &[::std::string::String] {
        &self.other_mats
    }
    pub fn clear_other_mats(&mut self) {
        self.other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.other_mats
    }

    // Take field
    pub fn take_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string mats = 3;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_core = 4;


    pub fn get_quality_core(&self) -> &[::std::string::String] {
        &self.quality_core
    }
    pub fn clear_quality_core(&mut self) {
        self.quality_core.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_core(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_core = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_core(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_core
    }

    // Take field
    pub fn take_quality_core(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_core, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_total = 5;


    pub fn get_quality_total(&self) -> &[::std::string::String] {
        &self.quality_total
    }
    pub fn clear_quality_total(&mut self) {
        self.quality_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_total(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_total(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_total
    }

    // Take field
    pub fn take_quality_total(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_total, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_AmmoSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.other_mats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_core)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_total)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_type {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.other_mats {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.quality_core {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.quality_total {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_type {
            os.write_string(1, &v)?;
        };
        for v in &self.other_mats {
            os.write_string(2, &v)?;
        };
        for v in &self.mats {
            os.write_string(3, &v)?;
        };
        for v in &self.quality_core {
            os.write_string(4, &v)?;
        };
        for v in &self.quality_total {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_AmmoSet {
        StockpileSettings_AmmoSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &StockpileSettings_AmmoSet| { &m.field_type },
                |m: &mut StockpileSettings_AmmoSet| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_mats",
                |m: &StockpileSettings_AmmoSet| { &m.other_mats },
                |m: &mut StockpileSettings_AmmoSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_AmmoSet| { &m.mats },
                |m: &mut StockpileSettings_AmmoSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_core",
                |m: &StockpileSettings_AmmoSet| { &m.quality_core },
                |m: &mut StockpileSettings_AmmoSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_total",
                |m: &StockpileSettings_AmmoSet| { &m.quality_total },
                |m: &mut StockpileSettings_AmmoSet| { &mut m.quality_total },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_AmmoSet>(
                "StockpileSettings.AmmoSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_AmmoSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_AmmoSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_AmmoSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_AmmoSet {
    fn clear(&mut self) {
        self.field_type.clear();
        self.other_mats.clear();
        self.mats.clear();
        self.quality_core.clear();
        self.quality_total.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_AmmoSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_AmmoSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_CoinSet {
    // message fields
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_CoinSet {
    fn default() -> &'a StockpileSettings_CoinSet {
        <StockpileSettings_CoinSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_CoinSet {
    pub fn new() -> StockpileSettings_CoinSet {
        ::std::default::Default::default()
    }

    // repeated string mats = 1;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_CoinSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mats {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_CoinSet {
        StockpileSettings_CoinSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_CoinSet| { &m.mats },
                |m: &mut StockpileSettings_CoinSet| { &mut m.mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_CoinSet>(
                "StockpileSettings.CoinSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_CoinSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_CoinSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_CoinSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_CoinSet {
    fn clear(&mut self) {
        self.mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_CoinSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_CoinSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_BarsBlocksSet {
    // message fields
    pub bars_other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub blocks_other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub bars_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub blocks_mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_BarsBlocksSet {
    fn default() -> &'a StockpileSettings_BarsBlocksSet {
        <StockpileSettings_BarsBlocksSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_BarsBlocksSet {
    pub fn new() -> StockpileSettings_BarsBlocksSet {
        ::std::default::Default::default()
    }

    // repeated string bars_other_mats = 1;


    pub fn get_bars_other_mats(&self) -> &[::std::string::String] {
        &self.bars_other_mats
    }
    pub fn clear_bars_other_mats(&mut self) {
        self.bars_other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_bars_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.bars_other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bars_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.bars_other_mats
    }

    // Take field
    pub fn take_bars_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.bars_other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string blocks_other_mats = 2;


    pub fn get_blocks_other_mats(&self) -> &[::std::string::String] {
        &self.blocks_other_mats
    }
    pub fn clear_blocks_other_mats(&mut self) {
        self.blocks_other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.blocks_other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.blocks_other_mats
    }

    // Take field
    pub fn take_blocks_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.blocks_other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string bars_mats = 3;


    pub fn get_bars_mats(&self) -> &[::std::string::String] {
        &self.bars_mats
    }
    pub fn clear_bars_mats(&mut self) {
        self.bars_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_bars_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.bars_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bars_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.bars_mats
    }

    // Take field
    pub fn take_bars_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.bars_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string blocks_mats = 4;


    pub fn get_blocks_mats(&self) -> &[::std::string::String] {
        &self.blocks_mats
    }
    pub fn clear_blocks_mats(&mut self) {
        self.blocks_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.blocks_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.blocks_mats
    }

    // Take field
    pub fn take_blocks_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.blocks_mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_BarsBlocksSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.bars_other_mats)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.blocks_other_mats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.bars_mats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.blocks_mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bars_other_mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.blocks_other_mats {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.bars_mats {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.blocks_mats {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bars_other_mats {
            os.write_string(1, &v)?;
        };
        for v in &self.blocks_other_mats {
            os.write_string(2, &v)?;
        };
        for v in &self.bars_mats {
            os.write_string(3, &v)?;
        };
        for v in &self.blocks_mats {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_BarsBlocksSet {
        StockpileSettings_BarsBlocksSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bars_other_mats",
                |m: &StockpileSettings_BarsBlocksSet| { &m.bars_other_mats },
                |m: &mut StockpileSettings_BarsBlocksSet| { &mut m.bars_other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blocks_other_mats",
                |m: &StockpileSettings_BarsBlocksSet| { &m.blocks_other_mats },
                |m: &mut StockpileSettings_BarsBlocksSet| { &mut m.blocks_other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bars_mats",
                |m: &StockpileSettings_BarsBlocksSet| { &m.bars_mats },
                |m: &mut StockpileSettings_BarsBlocksSet| { &mut m.bars_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blocks_mats",
                |m: &StockpileSettings_BarsBlocksSet| { &m.blocks_mats },
                |m: &mut StockpileSettings_BarsBlocksSet| { &mut m.blocks_mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_BarsBlocksSet>(
                "StockpileSettings.BarsBlocksSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_BarsBlocksSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_BarsBlocksSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_BarsBlocksSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_BarsBlocksSet {
    fn clear(&mut self) {
        self.bars_other_mats.clear();
        self.blocks_other_mats.clear();
        self.bars_mats.clear();
        self.blocks_mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_BarsBlocksSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_BarsBlocksSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_GemsSet {
    // message fields
    pub rough_other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub cut_other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub rough_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub cut_mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_GemsSet {
    fn default() -> &'a StockpileSettings_GemsSet {
        <StockpileSettings_GemsSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_GemsSet {
    pub fn new() -> StockpileSettings_GemsSet {
        ::std::default::Default::default()
    }

    // repeated string rough_other_mats = 1;


    pub fn get_rough_other_mats(&self) -> &[::std::string::String] {
        &self.rough_other_mats
    }
    pub fn clear_rough_other_mats(&mut self) {
        self.rough_other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_rough_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rough_other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rough_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rough_other_mats
    }

    // Take field
    pub fn take_rough_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rough_other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string cut_other_mats = 2;


    pub fn get_cut_other_mats(&self) -> &[::std::string::String] {
        &self.cut_other_mats
    }
    pub fn clear_cut_other_mats(&mut self) {
        self.cut_other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_cut_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cut_other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cut_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cut_other_mats
    }

    // Take field
    pub fn take_cut_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cut_other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string rough_mats = 3;


    pub fn get_rough_mats(&self) -> &[::std::string::String] {
        &self.rough_mats
    }
    pub fn clear_rough_mats(&mut self) {
        self.rough_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_rough_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rough_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rough_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rough_mats
    }

    // Take field
    pub fn take_rough_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rough_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string cut_mats = 4;


    pub fn get_cut_mats(&self) -> &[::std::string::String] {
        &self.cut_mats
    }
    pub fn clear_cut_mats(&mut self) {
        self.cut_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_cut_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cut_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cut_mats
    }

    // Take field
    pub fn take_cut_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cut_mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_GemsSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rough_other_mats)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cut_other_mats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rough_mats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cut_mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rough_other_mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.cut_other_mats {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.rough_mats {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.cut_mats {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rough_other_mats {
            os.write_string(1, &v)?;
        };
        for v in &self.cut_other_mats {
            os.write_string(2, &v)?;
        };
        for v in &self.rough_mats {
            os.write_string(3, &v)?;
        };
        for v in &self.cut_mats {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_GemsSet {
        StockpileSettings_GemsSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rough_other_mats",
                |m: &StockpileSettings_GemsSet| { &m.rough_other_mats },
                |m: &mut StockpileSettings_GemsSet| { &mut m.rough_other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cut_other_mats",
                |m: &StockpileSettings_GemsSet| { &m.cut_other_mats },
                |m: &mut StockpileSettings_GemsSet| { &mut m.cut_other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rough_mats",
                |m: &StockpileSettings_GemsSet| { &m.rough_mats },
                |m: &mut StockpileSettings_GemsSet| { &mut m.rough_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cut_mats",
                |m: &StockpileSettings_GemsSet| { &m.cut_mats },
                |m: &mut StockpileSettings_GemsSet| { &mut m.cut_mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_GemsSet>(
                "StockpileSettings.GemsSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_GemsSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_GemsSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_GemsSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_GemsSet {
    fn clear(&mut self) {
        self.rough_other_mats.clear();
        self.cut_other_mats.clear();
        self.rough_mats.clear();
        self.cut_mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_GemsSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_GemsSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_FinishedGoodsSet {
    // message fields
    pub field_type: ::protobuf::RepeatedField<::std::string::String>,
    pub other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_core: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_total: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_FinishedGoodsSet {
    fn default() -> &'a StockpileSettings_FinishedGoodsSet {
        <StockpileSettings_FinishedGoodsSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_FinishedGoodsSet {
    pub fn new() -> StockpileSettings_FinishedGoodsSet {
        ::std::default::Default::default()
    }

    // repeated string type = 1;


    pub fn get_field_type(&self) -> &[::std::string::String] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.field_type, ::protobuf::RepeatedField::new())
    }

    // repeated string other_mats = 2;


    pub fn get_other_mats(&self) -> &[::std::string::String] {
        &self.other_mats
    }
    pub fn clear_other_mats(&mut self) {
        self.other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.other_mats
    }

    // Take field
    pub fn take_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string mats = 3;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_core = 4;


    pub fn get_quality_core(&self) -> &[::std::string::String] {
        &self.quality_core
    }
    pub fn clear_quality_core(&mut self) {
        self.quality_core.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_core(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_core = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_core(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_core
    }

    // Take field
    pub fn take_quality_core(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_core, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_total = 5;


    pub fn get_quality_total(&self) -> &[::std::string::String] {
        &self.quality_total
    }
    pub fn clear_quality_total(&mut self) {
        self.quality_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_total(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_total(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_total
    }

    // Take field
    pub fn take_quality_total(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_total, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_FinishedGoodsSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.other_mats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_core)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_total)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_type {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.other_mats {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.quality_core {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.quality_total {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_type {
            os.write_string(1, &v)?;
        };
        for v in &self.other_mats {
            os.write_string(2, &v)?;
        };
        for v in &self.mats {
            os.write_string(3, &v)?;
        };
        for v in &self.quality_core {
            os.write_string(4, &v)?;
        };
        for v in &self.quality_total {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_FinishedGoodsSet {
        StockpileSettings_FinishedGoodsSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &StockpileSettings_FinishedGoodsSet| { &m.field_type },
                |m: &mut StockpileSettings_FinishedGoodsSet| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_mats",
                |m: &StockpileSettings_FinishedGoodsSet| { &m.other_mats },
                |m: &mut StockpileSettings_FinishedGoodsSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_FinishedGoodsSet| { &m.mats },
                |m: &mut StockpileSettings_FinishedGoodsSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_core",
                |m: &StockpileSettings_FinishedGoodsSet| { &m.quality_core },
                |m: &mut StockpileSettings_FinishedGoodsSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_total",
                |m: &StockpileSettings_FinishedGoodsSet| { &m.quality_total },
                |m: &mut StockpileSettings_FinishedGoodsSet| { &mut m.quality_total },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_FinishedGoodsSet>(
                "StockpileSettings.FinishedGoodsSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_FinishedGoodsSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_FinishedGoodsSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_FinishedGoodsSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_FinishedGoodsSet {
    fn clear(&mut self) {
        self.field_type.clear();
        self.other_mats.clear();
        self.mats.clear();
        self.quality_core.clear();
        self.quality_total.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_FinishedGoodsSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_FinishedGoodsSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_LeatherSet {
    // message fields
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_LeatherSet {
    fn default() -> &'a StockpileSettings_LeatherSet {
        <StockpileSettings_LeatherSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_LeatherSet {
    pub fn new() -> StockpileSettings_LeatherSet {
        ::std::default::Default::default()
    }

    // repeated string mats = 1;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_LeatherSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mats {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_LeatherSet {
        StockpileSettings_LeatherSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_LeatherSet| { &m.mats },
                |m: &mut StockpileSettings_LeatherSet| { &mut m.mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_LeatherSet>(
                "StockpileSettings.LeatherSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_LeatherSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_LeatherSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_LeatherSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_LeatherSet {
    fn clear(&mut self) {
        self.mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_LeatherSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_LeatherSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_ClothSet {
    // message fields
    pub thread_silk: ::protobuf::RepeatedField<::std::string::String>,
    pub thread_plant: ::protobuf::RepeatedField<::std::string::String>,
    pub thread_yarn: ::protobuf::RepeatedField<::std::string::String>,
    pub thread_metal: ::protobuf::RepeatedField<::std::string::String>,
    pub cloth_silk: ::protobuf::RepeatedField<::std::string::String>,
    pub cloth_plant: ::protobuf::RepeatedField<::std::string::String>,
    pub cloth_yarn: ::protobuf::RepeatedField<::std::string::String>,
    pub cloth_metal: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_ClothSet {
    fn default() -> &'a StockpileSettings_ClothSet {
        <StockpileSettings_ClothSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_ClothSet {
    pub fn new() -> StockpileSettings_ClothSet {
        ::std::default::Default::default()
    }

    // repeated string thread_silk = 1;


    pub fn get_thread_silk(&self) -> &[::std::string::String] {
        &self.thread_silk
    }
    pub fn clear_thread_silk(&mut self) {
        self.thread_silk.clear();
    }

    // Param is passed by value, moved
    pub fn set_thread_silk(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.thread_silk = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thread_silk(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.thread_silk
    }

    // Take field
    pub fn take_thread_silk(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.thread_silk, ::protobuf::RepeatedField::new())
    }

    // repeated string thread_plant = 2;


    pub fn get_thread_plant(&self) -> &[::std::string::String] {
        &self.thread_plant
    }
    pub fn clear_thread_plant(&mut self) {
        self.thread_plant.clear();
    }

    // Param is passed by value, moved
    pub fn set_thread_plant(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.thread_plant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thread_plant(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.thread_plant
    }

    // Take field
    pub fn take_thread_plant(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.thread_plant, ::protobuf::RepeatedField::new())
    }

    // repeated string thread_yarn = 3;


    pub fn get_thread_yarn(&self) -> &[::std::string::String] {
        &self.thread_yarn
    }
    pub fn clear_thread_yarn(&mut self) {
        self.thread_yarn.clear();
    }

    // Param is passed by value, moved
    pub fn set_thread_yarn(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.thread_yarn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thread_yarn(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.thread_yarn
    }

    // Take field
    pub fn take_thread_yarn(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.thread_yarn, ::protobuf::RepeatedField::new())
    }

    // repeated string thread_metal = 4;


    pub fn get_thread_metal(&self) -> &[::std::string::String] {
        &self.thread_metal
    }
    pub fn clear_thread_metal(&mut self) {
        self.thread_metal.clear();
    }

    // Param is passed by value, moved
    pub fn set_thread_metal(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.thread_metal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thread_metal(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.thread_metal
    }

    // Take field
    pub fn take_thread_metal(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.thread_metal, ::protobuf::RepeatedField::new())
    }

    // repeated string cloth_silk = 5;


    pub fn get_cloth_silk(&self) -> &[::std::string::String] {
        &self.cloth_silk
    }
    pub fn clear_cloth_silk(&mut self) {
        self.cloth_silk.clear();
    }

    // Param is passed by value, moved
    pub fn set_cloth_silk(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cloth_silk = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cloth_silk(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cloth_silk
    }

    // Take field
    pub fn take_cloth_silk(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cloth_silk, ::protobuf::RepeatedField::new())
    }

    // repeated string cloth_plant = 6;


    pub fn get_cloth_plant(&self) -> &[::std::string::String] {
        &self.cloth_plant
    }
    pub fn clear_cloth_plant(&mut self) {
        self.cloth_plant.clear();
    }

    // Param is passed by value, moved
    pub fn set_cloth_plant(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cloth_plant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cloth_plant(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cloth_plant
    }

    // Take field
    pub fn take_cloth_plant(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cloth_plant, ::protobuf::RepeatedField::new())
    }

    // repeated string cloth_yarn = 7;


    pub fn get_cloth_yarn(&self) -> &[::std::string::String] {
        &self.cloth_yarn
    }
    pub fn clear_cloth_yarn(&mut self) {
        self.cloth_yarn.clear();
    }

    // Param is passed by value, moved
    pub fn set_cloth_yarn(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cloth_yarn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cloth_yarn(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cloth_yarn
    }

    // Take field
    pub fn take_cloth_yarn(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cloth_yarn, ::protobuf::RepeatedField::new())
    }

    // repeated string cloth_metal = 8;


    pub fn get_cloth_metal(&self) -> &[::std::string::String] {
        &self.cloth_metal
    }
    pub fn clear_cloth_metal(&mut self) {
        self.cloth_metal.clear();
    }

    // Param is passed by value, moved
    pub fn set_cloth_metal(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cloth_metal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cloth_metal(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cloth_metal
    }

    // Take field
    pub fn take_cloth_metal(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cloth_metal, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_ClothSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.thread_silk)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.thread_plant)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.thread_yarn)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.thread_metal)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cloth_silk)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cloth_plant)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cloth_yarn)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cloth_metal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.thread_silk {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.thread_plant {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.thread_yarn {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.thread_metal {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.cloth_silk {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.cloth_plant {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.cloth_yarn {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.cloth_metal {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.thread_silk {
            os.write_string(1, &v)?;
        };
        for v in &self.thread_plant {
            os.write_string(2, &v)?;
        };
        for v in &self.thread_yarn {
            os.write_string(3, &v)?;
        };
        for v in &self.thread_metal {
            os.write_string(4, &v)?;
        };
        for v in &self.cloth_silk {
            os.write_string(5, &v)?;
        };
        for v in &self.cloth_plant {
            os.write_string(6, &v)?;
        };
        for v in &self.cloth_yarn {
            os.write_string(7, &v)?;
        };
        for v in &self.cloth_metal {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_ClothSet {
        StockpileSettings_ClothSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thread_silk",
                |m: &StockpileSettings_ClothSet| { &m.thread_silk },
                |m: &mut StockpileSettings_ClothSet| { &mut m.thread_silk },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thread_plant",
                |m: &StockpileSettings_ClothSet| { &m.thread_plant },
                |m: &mut StockpileSettings_ClothSet| { &mut m.thread_plant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thread_yarn",
                |m: &StockpileSettings_ClothSet| { &m.thread_yarn },
                |m: &mut StockpileSettings_ClothSet| { &mut m.thread_yarn },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thread_metal",
                |m: &StockpileSettings_ClothSet| { &m.thread_metal },
                |m: &mut StockpileSettings_ClothSet| { &mut m.thread_metal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cloth_silk",
                |m: &StockpileSettings_ClothSet| { &m.cloth_silk },
                |m: &mut StockpileSettings_ClothSet| { &mut m.cloth_silk },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cloth_plant",
                |m: &StockpileSettings_ClothSet| { &m.cloth_plant },
                |m: &mut StockpileSettings_ClothSet| { &mut m.cloth_plant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cloth_yarn",
                |m: &StockpileSettings_ClothSet| { &m.cloth_yarn },
                |m: &mut StockpileSettings_ClothSet| { &mut m.cloth_yarn },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cloth_metal",
                |m: &StockpileSettings_ClothSet| { &m.cloth_metal },
                |m: &mut StockpileSettings_ClothSet| { &mut m.cloth_metal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_ClothSet>(
                "StockpileSettings.ClothSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_ClothSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_ClothSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_ClothSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_ClothSet {
    fn clear(&mut self) {
        self.thread_silk.clear();
        self.thread_plant.clear();
        self.thread_yarn.clear();
        self.thread_metal.clear();
        self.cloth_silk.clear();
        self.cloth_plant.clear();
        self.cloth_yarn.clear();
        self.cloth_metal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_ClothSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_ClothSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_WoodSet {
    // message fields
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_WoodSet {
    fn default() -> &'a StockpileSettings_WoodSet {
        <StockpileSettings_WoodSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_WoodSet {
    pub fn new() -> StockpileSettings_WoodSet {
        ::std::default::Default::default()
    }

    // repeated string mats = 1;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StockpileSettings_WoodSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mats {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_WoodSet {
        StockpileSettings_WoodSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_WoodSet| { &m.mats },
                |m: &mut StockpileSettings_WoodSet| { &mut m.mats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_WoodSet>(
                "StockpileSettings.WoodSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_WoodSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_WoodSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_WoodSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_WoodSet {
    fn clear(&mut self) {
        self.mats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_WoodSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_WoodSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_WeaponsSet {
    // message fields
    pub weapon_type: ::protobuf::RepeatedField<::std::string::String>,
    pub trapcomp_type: ::protobuf::RepeatedField<::std::string::String>,
    pub other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_core: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_total: ::protobuf::RepeatedField<::std::string::String>,
    usable: ::std::option::Option<bool>,
    unusable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_WeaponsSet {
    fn default() -> &'a StockpileSettings_WeaponsSet {
        <StockpileSettings_WeaponsSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_WeaponsSet {
    pub fn new() -> StockpileSettings_WeaponsSet {
        ::std::default::Default::default()
    }

    // repeated string weapon_type = 1;


    pub fn get_weapon_type(&self) -> &[::std::string::String] {
        &self.weapon_type
    }
    pub fn clear_weapon_type(&mut self) {
        self.weapon_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_weapon_type(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.weapon_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_weapon_type(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.weapon_type
    }

    // Take field
    pub fn take_weapon_type(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.weapon_type, ::protobuf::RepeatedField::new())
    }

    // repeated string trapcomp_type = 2;


    pub fn get_trapcomp_type(&self) -> &[::std::string::String] {
        &self.trapcomp_type
    }
    pub fn clear_trapcomp_type(&mut self) {
        self.trapcomp_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_trapcomp_type(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.trapcomp_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trapcomp_type(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.trapcomp_type
    }

    // Take field
    pub fn take_trapcomp_type(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.trapcomp_type, ::protobuf::RepeatedField::new())
    }

    // repeated string other_mats = 3;


    pub fn get_other_mats(&self) -> &[::std::string::String] {
        &self.other_mats
    }
    pub fn clear_other_mats(&mut self) {
        self.other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.other_mats
    }

    // Take field
    pub fn take_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string mats = 4;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_core = 5;


    pub fn get_quality_core(&self) -> &[::std::string::String] {
        &self.quality_core
    }
    pub fn clear_quality_core(&mut self) {
        self.quality_core.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_core(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_core = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_core(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_core
    }

    // Take field
    pub fn take_quality_core(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_core, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_total = 6;


    pub fn get_quality_total(&self) -> &[::std::string::String] {
        &self.quality_total
    }
    pub fn clear_quality_total(&mut self) {
        self.quality_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_total(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_total(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_total
    }

    // Take field
    pub fn take_quality_total(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_total, ::protobuf::RepeatedField::new())
    }

    // optional bool usable = 7;


    pub fn get_usable(&self) -> bool {
        self.usable.unwrap_or(false)
    }
    pub fn clear_usable(&mut self) {
        self.usable = ::std::option::Option::None;
    }

    pub fn has_usable(&self) -> bool {
        self.usable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable(&mut self, v: bool) {
        self.usable = ::std::option::Option::Some(v);
    }

    // optional bool unusable = 8;


    pub fn get_unusable(&self) -> bool {
        self.unusable.unwrap_or(false)
    }
    pub fn clear_unusable(&mut self) {
        self.unusable = ::std::option::Option::None;
    }

    pub fn has_unusable(&self) -> bool {
        self.unusable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unusable(&mut self, v: bool) {
        self.unusable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StockpileSettings_WeaponsSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.weapon_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.trapcomp_type)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.other_mats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_core)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_total)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.usable = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unusable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.weapon_type {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.trapcomp_type {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.other_mats {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.quality_core {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.quality_total {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.usable {
            my_size += 2;
        }
        if let Some(v) = self.unusable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.weapon_type {
            os.write_string(1, &v)?;
        };
        for v in &self.trapcomp_type {
            os.write_string(2, &v)?;
        };
        for v in &self.other_mats {
            os.write_string(3, &v)?;
        };
        for v in &self.mats {
            os.write_string(4, &v)?;
        };
        for v in &self.quality_core {
            os.write_string(5, &v)?;
        };
        for v in &self.quality_total {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.usable {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.unusable {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_WeaponsSet {
        StockpileSettings_WeaponsSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "weapon_type",
                |m: &StockpileSettings_WeaponsSet| { &m.weapon_type },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.weapon_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trapcomp_type",
                |m: &StockpileSettings_WeaponsSet| { &m.trapcomp_type },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.trapcomp_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_mats",
                |m: &StockpileSettings_WeaponsSet| { &m.other_mats },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_WeaponsSet| { &m.mats },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_core",
                |m: &StockpileSettings_WeaponsSet| { &m.quality_core },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_total",
                |m: &StockpileSettings_WeaponsSet| { &m.quality_total },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.quality_total },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "usable",
                |m: &StockpileSettings_WeaponsSet| { &m.usable },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.usable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unusable",
                |m: &StockpileSettings_WeaponsSet| { &m.unusable },
                |m: &mut StockpileSettings_WeaponsSet| { &mut m.unusable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_WeaponsSet>(
                "StockpileSettings.WeaponsSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_WeaponsSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_WeaponsSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_WeaponsSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_WeaponsSet {
    fn clear(&mut self) {
        self.weapon_type.clear();
        self.trapcomp_type.clear();
        self.other_mats.clear();
        self.mats.clear();
        self.quality_core.clear();
        self.quality_total.clear();
        self.usable = ::std::option::Option::None;
        self.unusable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_WeaponsSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_WeaponsSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StockpileSettings_ArmorSet {
    // message fields
    pub body: ::protobuf::RepeatedField<::std::string::String>,
    pub head: ::protobuf::RepeatedField<::std::string::String>,
    pub feet: ::protobuf::RepeatedField<::std::string::String>,
    pub hands: ::protobuf::RepeatedField<::std::string::String>,
    pub legs: ::protobuf::RepeatedField<::std::string::String>,
    pub shield: ::protobuf::RepeatedField<::std::string::String>,
    pub other_mats: ::protobuf::RepeatedField<::std::string::String>,
    pub mats: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_core: ::protobuf::RepeatedField<::std::string::String>,
    pub quality_total: ::protobuf::RepeatedField<::std::string::String>,
    usable: ::std::option::Option<bool>,
    unusable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StockpileSettings_ArmorSet {
    fn default() -> &'a StockpileSettings_ArmorSet {
        <StockpileSettings_ArmorSet as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings_ArmorSet {
    pub fn new() -> StockpileSettings_ArmorSet {
        ::std::default::Default::default()
    }

    // repeated string body = 1;


    pub fn get_body(&self) -> &[::std::string::String] {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body, ::protobuf::RepeatedField::new())
    }

    // repeated string head = 2;


    pub fn get_head(&self) -> &[::std::string::String] {
        &self.head
    }
    pub fn clear_head(&mut self) {
        self.head.clear();
    }

    // Param is passed by value, moved
    pub fn set_head(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.head = v;
    }

    // Mutable pointer to the field.
    pub fn mut_head(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.head
    }

    // Take field
    pub fn take_head(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.head, ::protobuf::RepeatedField::new())
    }

    // repeated string feet = 3;


    pub fn get_feet(&self) -> &[::std::string::String] {
        &self.feet
    }
    pub fn clear_feet(&mut self) {
        self.feet.clear();
    }

    // Param is passed by value, moved
    pub fn set_feet(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.feet = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feet(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.feet
    }

    // Take field
    pub fn take_feet(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.feet, ::protobuf::RepeatedField::new())
    }

    // repeated string hands = 4;


    pub fn get_hands(&self) -> &[::std::string::String] {
        &self.hands
    }
    pub fn clear_hands(&mut self) {
        self.hands.clear();
    }

    // Param is passed by value, moved
    pub fn set_hands(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hands(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hands
    }

    // Take field
    pub fn take_hands(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hands, ::protobuf::RepeatedField::new())
    }

    // repeated string legs = 5;


    pub fn get_legs(&self) -> &[::std::string::String] {
        &self.legs
    }
    pub fn clear_legs(&mut self) {
        self.legs.clear();
    }

    // Param is passed by value, moved
    pub fn set_legs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.legs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.legs
    }

    // Take field
    pub fn take_legs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.legs, ::protobuf::RepeatedField::new())
    }

    // repeated string shield = 6;


    pub fn get_shield(&self) -> &[::std::string::String] {
        &self.shield
    }
    pub fn clear_shield(&mut self) {
        self.shield.clear();
    }

    // Param is passed by value, moved
    pub fn set_shield(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.shield = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shield(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.shield
    }

    // Take field
    pub fn take_shield(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.shield, ::protobuf::RepeatedField::new())
    }

    // repeated string other_mats = 7;


    pub fn get_other_mats(&self) -> &[::std::string::String] {
        &self.other_mats
    }
    pub fn clear_other_mats(&mut self) {
        self.other_mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.other_mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_other_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.other_mats
    }

    // Take field
    pub fn take_other_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.other_mats, ::protobuf::RepeatedField::new())
    }

    // repeated string mats = 8;


    pub fn get_mats(&self) -> &[::std::string::String] {
        &self.mats
    }
    pub fn clear_mats(&mut self) {
        self.mats.clear();
    }

    // Param is passed by value, moved
    pub fn set_mats(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mats(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mats
    }

    // Take field
    pub fn take_mats(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mats, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_core = 9;


    pub fn get_quality_core(&self) -> &[::std::string::String] {
        &self.quality_core
    }
    pub fn clear_quality_core(&mut self) {
        self.quality_core.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_core(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_core = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_core(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_core
    }

    // Take field
    pub fn take_quality_core(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_core, ::protobuf::RepeatedField::new())
    }

    // repeated string quality_total = 10;


    pub fn get_quality_total(&self) -> &[::std::string::String] {
        &self.quality_total
    }
    pub fn clear_quality_total(&mut self) {
        self.quality_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_quality_total(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quality_total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quality_total(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quality_total
    }

    // Take field
    pub fn take_quality_total(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quality_total, ::protobuf::RepeatedField::new())
    }

    // optional bool usable = 11;


    pub fn get_usable(&self) -> bool {
        self.usable.unwrap_or(false)
    }
    pub fn clear_usable(&mut self) {
        self.usable = ::std::option::Option::None;
    }

    pub fn has_usable(&self) -> bool {
        self.usable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable(&mut self, v: bool) {
        self.usable = ::std::option::Option::Some(v);
    }

    // optional bool unusable = 12;


    pub fn get_unusable(&self) -> bool {
        self.unusable.unwrap_or(false)
    }
    pub fn clear_unusable(&mut self) {
        self.unusable = ::std::option::Option::None;
    }

    pub fn has_unusable(&self) -> bool {
        self.unusable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unusable(&mut self, v: bool) {
        self.unusable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StockpileSettings_ArmorSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.head)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.feet)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hands)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.legs)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.shield)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.other_mats)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mats)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_core)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quality_total)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.usable = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unusable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.body {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.head {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.feet {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.hands {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.legs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.shield {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.other_mats {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.mats {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.quality_core {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.quality_total {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.usable {
            my_size += 2;
        }
        if let Some(v) = self.unusable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.body {
            os.write_string(1, &v)?;
        };
        for v in &self.head {
            os.write_string(2, &v)?;
        };
        for v in &self.feet {
            os.write_string(3, &v)?;
        };
        for v in &self.hands {
            os.write_string(4, &v)?;
        };
        for v in &self.legs {
            os.write_string(5, &v)?;
        };
        for v in &self.shield {
            os.write_string(6, &v)?;
        };
        for v in &self.other_mats {
            os.write_string(7, &v)?;
        };
        for v in &self.mats {
            os.write_string(8, &v)?;
        };
        for v in &self.quality_core {
            os.write_string(9, &v)?;
        };
        for v in &self.quality_total {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.usable {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.unusable {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StockpileSettings_ArmorSet {
        StockpileSettings_ArmorSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &StockpileSettings_ArmorSet| { &m.body },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "head",
                |m: &StockpileSettings_ArmorSet| { &m.head },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.head },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "feet",
                |m: &StockpileSettings_ArmorSet| { &m.feet },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.feet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hands",
                |m: &StockpileSettings_ArmorSet| { &m.hands },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.hands },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "legs",
                |m: &StockpileSettings_ArmorSet| { &m.legs },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.legs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shield",
                |m: &StockpileSettings_ArmorSet| { &m.shield },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.shield },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_mats",
                |m: &StockpileSettings_ArmorSet| { &m.other_mats },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mats",
                |m: &StockpileSettings_ArmorSet| { &m.mats },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_core",
                |m: &StockpileSettings_ArmorSet| { &m.quality_core },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quality_total",
                |m: &StockpileSettings_ArmorSet| { &m.quality_total },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.quality_total },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "usable",
                |m: &StockpileSettings_ArmorSet| { &m.usable },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.usable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unusable",
                |m: &StockpileSettings_ArmorSet| { &m.unusable },
                |m: &mut StockpileSettings_ArmorSet| { &mut m.unusable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StockpileSettings_ArmorSet>(
                "StockpileSettings.ArmorSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StockpileSettings_ArmorSet {
        static instance: ::protobuf::rt::LazyV2<StockpileSettings_ArmorSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StockpileSettings_ArmorSet::new)
    }
}

impl ::protobuf::Clear for StockpileSettings_ArmorSet {
    fn clear(&mut self) {
        self.body.clear();
        self.head.clear();
        self.feet.clear();
        self.hands.clear();
        self.legs.clear();
        self.shield.clear();
        self.other_mats.clear();
        self.mats.clear();
        self.quality_core.clear();
        self.quality_total.clear();
        self.usable = ::std::option::Option::None;
        self.unusable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StockpileSettings_ArmorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings_ArmorSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10stockpiles.proto\x12\x0cdfstockpiles\"\xf4\"\n\x11StockpileSetting\
    s\x12F\n\x07animals\x18\x01\x20\x01(\x0b2*.dfstockpiles.StockpileSetting\
    s.AnimalsSetR\x07animalsB\0\x12=\n\x04food\x18\x02\x20\x01(\x0b2'.dfstoc\
    kpiles.StockpileSettings.FoodSetR\x04foodB\0\x12L\n\tfurniture\x18\x03\
    \x20\x01(\x0b2,.dfstockpiles.StockpileSettings.FurnitureSetR\tfurnitureB\
    \0\x12\x1c\n\x08unknown1\x18\x04\x20\x01(\x05R\x08unknown1B\0\x12C\n\x06\
    refuse\x18\x05\x20\x01(\x0b2).dfstockpiles.StockpileSettings.RefuseSetR\
    \x06refuseB\0\x12@\n\x05stone\x18\x06\x20\x01(\x0b2(.dfstockpiles.Stockp\
    ileSettings.StoneSetR\x05stoneB\0\x12:\n\x03ore\x18\x07\x20\x01(\x0b2&.d\
    fstockpiles.StockpileSettings.OreSetR\x03oreB\0\x12=\n\x04ammo\x18\x08\
    \x20\x01(\x0b2'.dfstockpiles.StockpileSettings.AmmoSetR\x04ammoB\0\x12=\
    \n\x04coin\x18\t\x20\x01(\x0b2'.dfstockpiles.StockpileSettings.CoinSetR\
    \x04coinB\0\x12O\n\nbarsblocks\x18\n\x20\x01(\x0b2-.dfstockpiles.Stockpi\
    leSettings.BarsBlocksSetR\nbarsblocksB\0\x12=\n\x04gems\x18\x0b\x20\x01(\
    \x0b2'.dfstockpiles.StockpileSettings.GemsSetR\x04gemsB\0\x12Y\n\x0efini\
    shed_goods\x18\x0c\x20\x01(\x0b20.dfstockpiles.StockpileSettings.Finishe\
    dGoodsSetR\rfinishedGoodsB\0\x12F\n\x07leather\x18\r\x20\x01(\x0b2*.dfst\
    ockpiles.StockpileSettings.LeatherSetR\x07leatherB\0\x12@\n\x05cloth\x18\
    \x0e\x20\x01(\x0b2(.dfstockpiles.StockpileSettings.ClothSetR\x05clothB\0\
    \x12=\n\x04wood\x18\x0f\x20\x01(\x0b2'.dfstockpiles.StockpileSettings.Wo\
    odSetR\x04woodB\0\x12F\n\x07weapons\x18\x10\x20\x01(\x0b2*.dfstockpiles.\
    StockpileSettings.WeaponsSetR\x07weaponsB\0\x12@\n\x05armor\x18\x11\x20\
    \x01(\x0b2(.dfstockpiles.StockpileSettings.ArmorSetR\x05armorB\0\x12%\n\
    \rallow_organic\x18\x12\x20\x01(\x08R\x0callowOrganicB\0\x12)\n\x0fallow\
    _inorganic\x18\x13\x20\x01(\x08R\x0eallowInorganicB\0\x12\x1a\n\x07corps\
    es\x18\x18\x20\x01(\x08R\x07corpsesB\0\x12!\n\x0bmax_barrels\x18\x14\x20\
    \x01(\x05R\nmaxBarrelsB\0\x12\x1b\n\x08max_bins\x18\x15\x20\x01(\x05R\
    \x07maxBinsB\0\x12+\n\x10max_wheelbarrows\x18\x16\x20\x01(\x05R\x0fmaxWh\
    eelbarrowsB\0\x12&\n\x0euse_links_only\x18\x17\x20\x01(\x08R\x0cuseLinks\
    OnlyB\0\x1ap\n\nAnimalsSet\x12!\n\x0bempty_cages\x18\x01\x20\x01(\x08R\n\
    emptyCagesB\0\x12!\n\x0bempty_traps\x18\x02\x20\x01(\x08R\nemptyTrapsB\0\
    \x12\x1a\n\x07enabled\x18\x03\x20\x03(\tR\x07enabledB\0:\0\x1a\x9a\x05\n\
    \x07FoodSet\x12\x14\n\x04meat\x18\x01\x20\x03(\tR\x04meatB\0\x12\x14\n\
    \x04fish\x18\x02\x20\x03(\tR\x04fishB\0\x12)\n\x0funprepared_fish\x18\
    \x14\x20\x03(\tR\x0eunpreparedFishB\0\x12\x12\n\x03egg\x18\x03\x20\x03(\
    \tR\x03eggB\0\x12\x18\n\x06plants\x18\x04\x20\x03(\tR\x06plantsB\0\x12!\
    \n\x0bdrink_plant\x18\x05\x20\x03(\tR\ndrinkPlantB\0\x12#\n\x0cdrink_ani\
    mal\x18\x06\x20\x03(\tR\x0bdrinkAnimalB\0\x12#\n\x0ccheese_plant\x18\x07\
    \x20\x03(\tR\x0bcheesePlantB\0\x12%\n\rcheese_animal\x18\x08\x20\x03(\tR\
    \x0ccheeseAnimalB\0\x12\x16\n\x05seeds\x18\t\x20\x03(\tR\x05seedsB\0\x12\
    \x18\n\x06leaves\x18\n\x20\x03(\tR\x06leavesB\0\x12#\n\x0cpowder_plant\
    \x18\x0b\x20\x03(\tR\x0bpowderPlantB\0\x12)\n\x0fpowder_creature\x18\x0c\
    \x20\x03(\tR\x0epowderCreatureB\0\x12\x14\n\x04glob\x18\r\x20\x03(\tR\
    \x04globB\0\x12\x1f\n\nglob_paste\x18\x0e\x20\x03(\tR\tglobPasteB\0\x12#\
    \n\x0cglob_pressed\x18\x0f\x20\x03(\tR\x0bglobPressedB\0\x12#\n\x0cliqui\
    d_plant\x18\x10\x20\x03(\tR\x0bliquidPlantB\0\x12%\n\rliquid_animal\x18\
    \x11\x20\x03(\tR\x0cliquidAnimalB\0\x12!\n\x0bliquid_misc\x18\x12\x20\
    \x03(\tR\nliquidMiscB\0\x12'\n\x0eprepared_meals\x18\x13\x20\x01(\x08R\r\
    preparedMealsB\0:\0\x1a\xa9\x01\n\x0cFurnitureSet\x12\x14\n\x04type\x18\
    \x01\x20\x03(\tR\x04typeB\0\x12\x1f\n\nother_mats\x18\x02\x20\x03(\tR\to\
    therMatsB\0\x12\x14\n\x04mats\x18\x03\x20\x03(\tR\x04matsB\0\x12#\n\x0cq\
    uality_core\x18\x04\x20\x03(\tR\x0bqualityCoreB\0\x12%\n\rquality_total\
    \x18\x05\x20\x03(\tR\x0cqualityTotalB\0:\0\x1a\xc4\x02\n\tRefuseSet\x12\
    \x14\n\x04type\x18\x01\x20\x03(\tR\x04typeB\0\x12\x1a\n\x07corpses\x18\
    \x02\x20\x03(\tR\x07corpsesB\0\x12\x1f\n\nbody_parts\x18\x03\x20\x03(\tR\
    \tbodyPartsB\0\x12\x18\n\x06skulls\x18\x04\x20\x03(\tR\x06skullsB\0\x12\
    \x16\n\x05bones\x18\x05\x20\x03(\tR\x05bonesB\0\x12\x14\n\x04hair\x18\
    \x06\x20\x03(\tR\x04hairB\0\x12\x18\n\x06shells\x18\x07\x20\x03(\tR\x06s\
    hellsB\0\x12\x16\n\x05teeth\x18\x08\x20\x03(\tR\x05teethB\0\x12\x16\n\
    \x05horns\x18\t\x20\x03(\tR\x05hornsB\0\x12&\n\x0efresh_raw_hide\x18\n\
    \x20\x01(\x08R\x0cfreshRawHideB\0\x12(\n\x0frotten_raw_hide\x18\x0b\x20\
    \x01(\x08R\rrottenRawHideB\0:\0\x1a\"\n\x08StoneSet\x12\x14\n\x04mats\
    \x18\x01\x20\x03(\tR\x04matsB\0:\0\x1a\x20\n\x06OreSet\x12\x14\n\x04mats\
    \x18\x01\x20\x03(\tR\x04matsB\0:\0\x1a\xa4\x01\n\x07AmmoSet\x12\x14\n\
    \x04type\x18\x01\x20\x03(\tR\x04typeB\0\x12\x1f\n\nother_mats\x18\x02\
    \x20\x03(\tR\totherMatsB\0\x12\x14\n\x04mats\x18\x03\x20\x03(\tR\x04mats\
    B\0\x12#\n\x0cquality_core\x18\x04\x20\x03(\tR\x0bqualityCoreB\0\x12%\n\
    \rquality_total\x18\x05\x20\x03(\tR\x0cqualityTotalB\0:\0\x1a!\n\x07Coin\
    Set\x12\x14\n\x04mats\x18\x01\x20\x03(\tR\x04matsB\0:\0\x1a\xab\x01\n\rB\
    arsBlocksSet\x12(\n\x0fbars_other_mats\x18\x01\x20\x03(\tR\rbarsOtherMat\
    sB\0\x12,\n\x11blocks_other_mats\x18\x02\x20\x03(\tR\x0fblocksOtherMatsB\
    \0\x12\x1d\n\tbars_mats\x18\x03\x20\x03(\tR\x08barsMatsB\0\x12!\n\x0bblo\
    cks_mats\x18\x04\x20\x03(\tR\nblocksMatsB\0:\0\x1a\x9d\x01\n\x07GemsSet\
    \x12*\n\x10rough_other_mats\x18\x01\x20\x03(\tR\x0eroughOtherMatsB\0\x12\
    &\n\x0ecut_other_mats\x18\x02\x20\x03(\tR\x0ccutOtherMatsB\0\x12\x1f\n\n\
    rough_mats\x18\x03\x20\x03(\tR\troughMatsB\0\x12\x1b\n\x08cut_mats\x18\
    \x04\x20\x03(\tR\x07cutMatsB\0:\0\x1a\xad\x01\n\x10FinishedGoodsSet\x12\
    \x14\n\x04type\x18\x01\x20\x03(\tR\x04typeB\0\x12\x1f\n\nother_mats\x18\
    \x02\x20\x03(\tR\totherMatsB\0\x12\x14\n\x04mats\x18\x03\x20\x03(\tR\x04\
    matsB\0\x12#\n\x0cquality_core\x18\x04\x20\x03(\tR\x0bqualityCoreB\0\x12\
    %\n\rquality_total\x18\x05\x20\x03(\tR\x0cqualityTotalB\0:\0\x1a$\n\nLea\
    therSet\x12\x14\n\x04mats\x18\x01\x20\x03(\tR\x04matsB\0:\0\x1a\xa4\x02\
    \n\x08ClothSet\x12!\n\x0bthread_silk\x18\x01\x20\x03(\tR\nthreadSilkB\0\
    \x12#\n\x0cthread_plant\x18\x02\x20\x03(\tR\x0bthreadPlantB\0\x12!\n\x0b\
    thread_yarn\x18\x03\x20\x03(\tR\nthreadYarnB\0\x12#\n\x0cthread_metal\
    \x18\x04\x20\x03(\tR\x0bthreadMetalB\0\x12\x1f\n\ncloth_silk\x18\x05\x20\
    \x03(\tR\tclothSilkB\0\x12!\n\x0bcloth_plant\x18\x06\x20\x03(\tR\nclothP\
    lantB\0\x12\x1f\n\ncloth_yarn\x18\x07\x20\x03(\tR\tclothYarnB\0\x12!\n\
    \x0bcloth_metal\x18\x08\x20\x03(\tR\nclothMetalB\0:\0\x1a!\n\x07WoodSet\
    \x12\x14\n\x04mats\x18\x01\x20\x03(\tR\x04matsB\0:\0\x1a\x93\x02\n\nWeap\
    onsSet\x12!\n\x0bweapon_type\x18\x01\x20\x03(\tR\nweaponTypeB\0\x12%\n\r\
    trapcomp_type\x18\x02\x20\x03(\tR\x0ctrapcompTypeB\0\x12\x1f\n\nother_ma\
    ts\x18\x03\x20\x03(\tR\totherMatsB\0\x12\x14\n\x04mats\x18\x04\x20\x03(\
    \tR\x04matsB\0\x12#\n\x0cquality_core\x18\x05\x20\x03(\tR\x0bqualityCore\
    B\0\x12%\n\rquality_total\x18\x06\x20\x03(\tR\x0cqualityTotalB\0\x12\x18\
    \n\x06usable\x18\x07\x20\x01(\x08R\x06usableB\0\x12\x1c\n\x08unusable\
    \x18\x08\x20\x01(\x08R\x08unusableB\0:\0\x1a\xd1\x02\n\x08ArmorSet\x12\
    \x14\n\x04body\x18\x01\x20\x03(\tR\x04bodyB\0\x12\x14\n\x04head\x18\x02\
    \x20\x03(\tR\x04headB\0\x12\x14\n\x04feet\x18\x03\x20\x03(\tR\x04feetB\0\
    \x12\x16\n\x05hands\x18\x04\x20\x03(\tR\x05handsB\0\x12\x14\n\x04legs\
    \x18\x05\x20\x03(\tR\x04legsB\0\x12\x18\n\x06shield\x18\x06\x20\x03(\tR\
    \x06shieldB\0\x12\x1f\n\nother_mats\x18\x07\x20\x03(\tR\totherMatsB\0\
    \x12\x14\n\x04mats\x18\x08\x20\x03(\tR\x04matsB\0\x12#\n\x0cquality_core\
    \x18\t\x20\x03(\tR\x0bqualityCoreB\0\x12%\n\rquality_total\x18\n\x20\x03\
    (\tR\x0cqualityTotalB\0\x12\x18\n\x06usable\x18\x0b\x20\x01(\x08R\x06usa\
    bleB\0\x12\x1c\n\x08unusable\x18\x0c\x20\x01(\x08R\x08unusableB\0:\0:\0B\
    \0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
