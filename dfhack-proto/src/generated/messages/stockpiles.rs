// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `stockpiles.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:dfstockpiles.StockpileSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StockpileSettings {
    // message fields
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.animals)
    pub animals: ::protobuf::MessageField<stockpile_settings::AnimalsSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.food)
    pub food: ::protobuf::MessageField<stockpile_settings::FoodSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.furniture)
    pub furniture: ::protobuf::MessageField<stockpile_settings::FurnitureSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.unknown1)
    pub unknown1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.refuse)
    pub refuse: ::protobuf::MessageField<stockpile_settings::RefuseSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.stone)
    pub stone: ::protobuf::MessageField<stockpile_settings::StoneSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ore)
    pub ore: ::protobuf::MessageField<stockpile_settings::OreSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ammo)
    pub ammo: ::protobuf::MessageField<stockpile_settings::AmmoSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.coin)
    pub coin: ::protobuf::MessageField<stockpile_settings::CoinSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.barsblocks)
    pub barsblocks: ::protobuf::MessageField<stockpile_settings::BarsBlocksSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.gems)
    pub gems: ::protobuf::MessageField<stockpile_settings::GemsSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.finished_goods)
    pub finished_goods: ::protobuf::MessageField<stockpile_settings::FinishedGoodsSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.leather)
    pub leather: ::protobuf::MessageField<stockpile_settings::LeatherSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.cloth)
    pub cloth: ::protobuf::MessageField<stockpile_settings::ClothSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.wood)
    pub wood: ::protobuf::MessageField<stockpile_settings::WoodSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.weapons)
    pub weapons: ::protobuf::MessageField<stockpile_settings::WeaponsSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.armor)
    pub armor: ::protobuf::MessageField<stockpile_settings::ArmorSet>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.allow_organic)
    pub allow_organic: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.allow_inorganic)
    pub allow_inorganic: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.corpses)
    pub corpses: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.max_barrels)
    pub max_barrels: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.max_bins)
    pub max_bins: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.max_wheelbarrows)
    pub max_wheelbarrows: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.use_links_only)
    pub use_links_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StockpileSettings {
    fn default() -> &'a StockpileSettings {
        <StockpileSettings as ::protobuf::Message>::default_instance()
    }
}

impl StockpileSettings {
    pub fn new() -> StockpileSettings {
        ::std::default::Default::default()
    }

    // optional int32 unknown1 = 4;

    pub fn unknown1(&self) -> i32 {
        self.unknown1.unwrap_or(0)
    }

    pub fn clear_unknown1(&mut self) {
        self.unknown1 = ::std::option::Option::None;
    }

    pub fn has_unknown1(&self) -> bool {
        self.unknown1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown1(&mut self, v: i32) {
        self.unknown1 = ::std::option::Option::Some(v);
    }

    // optional bool allow_organic = 18;

    pub fn allow_organic(&self) -> bool {
        self.allow_organic.unwrap_or(false)
    }

    pub fn clear_allow_organic(&mut self) {
        self.allow_organic = ::std::option::Option::None;
    }

    pub fn has_allow_organic(&self) -> bool {
        self.allow_organic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_organic(&mut self, v: bool) {
        self.allow_organic = ::std::option::Option::Some(v);
    }

    // optional bool allow_inorganic = 19;

    pub fn allow_inorganic(&self) -> bool {
        self.allow_inorganic.unwrap_or(false)
    }

    pub fn clear_allow_inorganic(&mut self) {
        self.allow_inorganic = ::std::option::Option::None;
    }

    pub fn has_allow_inorganic(&self) -> bool {
        self.allow_inorganic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_inorganic(&mut self, v: bool) {
        self.allow_inorganic = ::std::option::Option::Some(v);
    }

    // optional bool corpses = 24;

    pub fn corpses(&self) -> bool {
        self.corpses.unwrap_or(false)
    }

    pub fn clear_corpses(&mut self) {
        self.corpses = ::std::option::Option::None;
    }

    pub fn has_corpses(&self) -> bool {
        self.corpses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corpses(&mut self, v: bool) {
        self.corpses = ::std::option::Option::Some(v);
    }

    // optional int32 max_barrels = 20;

    pub fn max_barrels(&self) -> i32 {
        self.max_barrels.unwrap_or(0)
    }

    pub fn clear_max_barrels(&mut self) {
        self.max_barrels = ::std::option::Option::None;
    }

    pub fn has_max_barrels(&self) -> bool {
        self.max_barrels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_barrels(&mut self, v: i32) {
        self.max_barrels = ::std::option::Option::Some(v);
    }

    // optional int32 max_bins = 21;

    pub fn max_bins(&self) -> i32 {
        self.max_bins.unwrap_or(0)
    }

    pub fn clear_max_bins(&mut self) {
        self.max_bins = ::std::option::Option::None;
    }

    pub fn has_max_bins(&self) -> bool {
        self.max_bins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bins(&mut self, v: i32) {
        self.max_bins = ::std::option::Option::Some(v);
    }

    // optional int32 max_wheelbarrows = 22;

    pub fn max_wheelbarrows(&self) -> i32 {
        self.max_wheelbarrows.unwrap_or(0)
    }

    pub fn clear_max_wheelbarrows(&mut self) {
        self.max_wheelbarrows = ::std::option::Option::None;
    }

    pub fn has_max_wheelbarrows(&self) -> bool {
        self.max_wheelbarrows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_wheelbarrows(&mut self, v: i32) {
        self.max_wheelbarrows = ::std::option::Option::Some(v);
    }

    // optional bool use_links_only = 23;

    pub fn use_links_only(&self) -> bool {
        self.use_links_only.unwrap_or(false)
    }

    pub fn clear_use_links_only(&mut self) {
        self.use_links_only = ::std::option::Option::None;
    }

    pub fn has_use_links_only(&self) -> bool {
        self.use_links_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_links_only(&mut self, v: bool) {
        self.use_links_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::AnimalsSet>(
            "animals",
            |m: &StockpileSettings| { &m.animals },
            |m: &mut StockpileSettings| { &mut m.animals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::FoodSet>(
            "food",
            |m: &StockpileSettings| { &m.food },
            |m: &mut StockpileSettings| { &mut m.food },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::FurnitureSet>(
            "furniture",
            |m: &StockpileSettings| { &m.furniture },
            |m: &mut StockpileSettings| { &mut m.furniture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unknown1",
            |m: &StockpileSettings| { &m.unknown1 },
            |m: &mut StockpileSettings| { &mut m.unknown1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::RefuseSet>(
            "refuse",
            |m: &StockpileSettings| { &m.refuse },
            |m: &mut StockpileSettings| { &mut m.refuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::StoneSet>(
            "stone",
            |m: &StockpileSettings| { &m.stone },
            |m: &mut StockpileSettings| { &mut m.stone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::OreSet>(
            "ore",
            |m: &StockpileSettings| { &m.ore },
            |m: &mut StockpileSettings| { &mut m.ore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::AmmoSet>(
            "ammo",
            |m: &StockpileSettings| { &m.ammo },
            |m: &mut StockpileSettings| { &mut m.ammo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::CoinSet>(
            "coin",
            |m: &StockpileSettings| { &m.coin },
            |m: &mut StockpileSettings| { &mut m.coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::BarsBlocksSet>(
            "barsblocks",
            |m: &StockpileSettings| { &m.barsblocks },
            |m: &mut StockpileSettings| { &mut m.barsblocks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::GemsSet>(
            "gems",
            |m: &StockpileSettings| { &m.gems },
            |m: &mut StockpileSettings| { &mut m.gems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::FinishedGoodsSet>(
            "finished_goods",
            |m: &StockpileSettings| { &m.finished_goods },
            |m: &mut StockpileSettings| { &mut m.finished_goods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::LeatherSet>(
            "leather",
            |m: &StockpileSettings| { &m.leather },
            |m: &mut StockpileSettings| { &mut m.leather },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::ClothSet>(
            "cloth",
            |m: &StockpileSettings| { &m.cloth },
            |m: &mut StockpileSettings| { &mut m.cloth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::WoodSet>(
            "wood",
            |m: &StockpileSettings| { &m.wood },
            |m: &mut StockpileSettings| { &mut m.wood },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::WeaponsSet>(
            "weapons",
            |m: &StockpileSettings| { &m.weapons },
            |m: &mut StockpileSettings| { &mut m.weapons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stockpile_settings::ArmorSet>(
            "armor",
            |m: &StockpileSettings| { &m.armor },
            |m: &mut StockpileSettings| { &mut m.armor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_organic",
            |m: &StockpileSettings| { &m.allow_organic },
            |m: &mut StockpileSettings| { &mut m.allow_organic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_inorganic",
            |m: &StockpileSettings| { &m.allow_inorganic },
            |m: &mut StockpileSettings| { &mut m.allow_inorganic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "corpses",
            |m: &StockpileSettings| { &m.corpses },
            |m: &mut StockpileSettings| { &mut m.corpses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_barrels",
            |m: &StockpileSettings| { &m.max_barrels },
            |m: &mut StockpileSettings| { &mut m.max_barrels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_bins",
            |m: &StockpileSettings| { &m.max_bins },
            |m: &mut StockpileSettings| { &mut m.max_bins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_wheelbarrows",
            |m: &StockpileSettings| { &m.max_wheelbarrows },
            |m: &mut StockpileSettings| { &mut m.max_wheelbarrows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_links_only",
            |m: &StockpileSettings| { &m.use_links_only },
            |m: &mut StockpileSettings| { &mut m.use_links_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StockpileSettings>(
            "StockpileSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StockpileSettings {
    const NAME: &'static str = "StockpileSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.animals)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.food)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.furniture)?;
                },
                32 => {
                    self.unknown1 = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.refuse)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stone)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ore)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ammo)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coin)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.barsblocks)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gems)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.finished_goods)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leather)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cloth)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wood)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.weapons)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.armor)?;
                },
                144 => {
                    self.allow_organic = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.allow_inorganic = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.corpses = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.max_barrels = ::std::option::Option::Some(is.read_int32()?);
                },
                168 => {
                    self.max_bins = ::std::option::Option::Some(is.read_int32()?);
                },
                176 => {
                    self.max_wheelbarrows = ::std::option::Option::Some(is.read_int32()?);
                },
                184 => {
                    self.use_links_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.animals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.food.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.furniture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unknown1 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.refuse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ammo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.barsblocks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gems.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.finished_goods.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.leather.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cloth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wood.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.weapons.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.armor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allow_organic {
            my_size += 2 + 1;
        }
        if let Some(v) = self.allow_inorganic {
            my_size += 2 + 1;
        }
        if let Some(v) = self.corpses {
            my_size += 2 + 1;
        }
        if let Some(v) = self.max_barrels {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.max_bins {
            my_size += ::protobuf::rt::int32_size(21, v);
        }
        if let Some(v) = self.max_wheelbarrows {
            my_size += ::protobuf::rt::int32_size(22, v);
        }
        if let Some(v) = self.use_links_only {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.animals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.food.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.furniture.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.unknown1 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.refuse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.stone.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.ore.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.ammo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.barsblocks.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.gems.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.finished_goods.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.leather.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.cloth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.wood.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.weapons.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.armor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.allow_organic {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.allow_inorganic {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.corpses {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.max_barrels {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.max_bins {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.max_wheelbarrows {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.use_links_only {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StockpileSettings {
        StockpileSettings::new()
    }

    fn clear(&mut self) {
        self.animals.clear();
        self.food.clear();
        self.furniture.clear();
        self.unknown1 = ::std::option::Option::None;
        self.refuse.clear();
        self.stone.clear();
        self.ore.clear();
        self.ammo.clear();
        self.coin.clear();
        self.barsblocks.clear();
        self.gems.clear();
        self.finished_goods.clear();
        self.leather.clear();
        self.cloth.clear();
        self.wood.clear();
        self.weapons.clear();
        self.armor.clear();
        self.allow_organic = ::std::option::Option::None;
        self.allow_inorganic = ::std::option::Option::None;
        self.corpses = ::std::option::Option::None;
        self.max_barrels = ::std::option::Option::None;
        self.max_bins = ::std::option::Option::None;
        self.max_wheelbarrows = ::std::option::Option::None;
        self.use_links_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StockpileSettings {
        static instance: StockpileSettings = StockpileSettings {
            animals: ::protobuf::MessageField::none(),
            food: ::protobuf::MessageField::none(),
            furniture: ::protobuf::MessageField::none(),
            unknown1: ::std::option::Option::None,
            refuse: ::protobuf::MessageField::none(),
            stone: ::protobuf::MessageField::none(),
            ore: ::protobuf::MessageField::none(),
            ammo: ::protobuf::MessageField::none(),
            coin: ::protobuf::MessageField::none(),
            barsblocks: ::protobuf::MessageField::none(),
            gems: ::protobuf::MessageField::none(),
            finished_goods: ::protobuf::MessageField::none(),
            leather: ::protobuf::MessageField::none(),
            cloth: ::protobuf::MessageField::none(),
            wood: ::protobuf::MessageField::none(),
            weapons: ::protobuf::MessageField::none(),
            armor: ::protobuf::MessageField::none(),
            allow_organic: ::std::option::Option::None,
            allow_inorganic: ::std::option::Option::None,
            corpses: ::std::option::Option::None,
            max_barrels: ::std::option::Option::None,
            max_bins: ::std::option::Option::None,
            max_wheelbarrows: ::std::option::Option::None,
            use_links_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StockpileSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StockpileSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StockpileSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StockpileSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StockpileSettings`
pub mod stockpile_settings {
    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.AnimalsSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnimalsSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AnimalsSet.empty_cages)
        pub empty_cages: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AnimalsSet.empty_traps)
        pub empty_traps: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AnimalsSet.enabled)
        pub enabled: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.AnimalsSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnimalsSet {
        fn default() -> &'a AnimalsSet {
            <AnimalsSet as ::protobuf::Message>::default_instance()
        }
    }

    impl AnimalsSet {
        pub fn new() -> AnimalsSet {
            ::std::default::Default::default()
        }

        // optional bool empty_cages = 1;

        pub fn empty_cages(&self) -> bool {
            self.empty_cages.unwrap_or(false)
        }

        pub fn clear_empty_cages(&mut self) {
            self.empty_cages = ::std::option::Option::None;
        }

        pub fn has_empty_cages(&self) -> bool {
            self.empty_cages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_empty_cages(&mut self, v: bool) {
            self.empty_cages = ::std::option::Option::Some(v);
        }

        // optional bool empty_traps = 2;

        pub fn empty_traps(&self) -> bool {
            self.empty_traps.unwrap_or(false)
        }

        pub fn clear_empty_traps(&mut self) {
            self.empty_traps = ::std::option::Option::None;
        }

        pub fn has_empty_traps(&self) -> bool {
            self.empty_traps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_empty_traps(&mut self, v: bool) {
            self.empty_traps = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "empty_cages",
                |m: &AnimalsSet| { &m.empty_cages },
                |m: &mut AnimalsSet| { &mut m.empty_cages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "empty_traps",
                |m: &AnimalsSet| { &m.empty_traps },
                |m: &mut AnimalsSet| { &mut m.empty_traps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "enabled",
                |m: &AnimalsSet| { &m.enabled },
                |m: &mut AnimalsSet| { &mut m.enabled },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnimalsSet>(
                "StockpileSettings.AnimalsSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnimalsSet {
        const NAME: &'static str = "AnimalsSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.empty_cages = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.empty_traps = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.enabled.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.empty_cages {
                my_size += 1 + 1;
            }
            if let Some(v) = self.empty_traps {
                my_size += 1 + 1;
            }
            for value in &self.enabled {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.empty_cages {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.empty_traps {
                os.write_bool(2, v)?;
            }
            for v in &self.enabled {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnimalsSet {
            AnimalsSet::new()
        }

        fn clear(&mut self) {
            self.empty_cages = ::std::option::Option::None;
            self.empty_traps = ::std::option::Option::None;
            self.enabled.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnimalsSet {
            static instance: AnimalsSet = AnimalsSet {
                empty_cages: ::std::option::Option::None,
                empty_traps: ::std::option::Option::None,
                enabled: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnimalsSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.AnimalsSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnimalsSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnimalsSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.FoodSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FoodSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.meat)
        pub meat: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.fish)
        pub fish: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.unprepared_fish)
        pub unprepared_fish: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.egg)
        pub egg: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.plants)
        pub plants: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.drink_plant)
        pub drink_plant: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.drink_animal)
        pub drink_animal: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.cheese_plant)
        pub cheese_plant: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.cheese_animal)
        pub cheese_animal: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.seeds)
        pub seeds: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.leaves)
        pub leaves: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.powder_plant)
        pub powder_plant: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.powder_creature)
        pub powder_creature: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.glob)
        pub glob: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.glob_paste)
        pub glob_paste: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.glob_pressed)
        pub glob_pressed: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.liquid_plant)
        pub liquid_plant: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.liquid_animal)
        pub liquid_animal: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.liquid_misc)
        pub liquid_misc: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FoodSet.prepared_meals)
        pub prepared_meals: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.FoodSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FoodSet {
        fn default() -> &'a FoodSet {
            <FoodSet as ::protobuf::Message>::default_instance()
        }
    }

    impl FoodSet {
        pub fn new() -> FoodSet {
            ::std::default::Default::default()
        }

        // optional bool prepared_meals = 19;

        pub fn prepared_meals(&self) -> bool {
            self.prepared_meals.unwrap_or(false)
        }

        pub fn clear_prepared_meals(&mut self) {
            self.prepared_meals = ::std::option::Option::None;
        }

        pub fn has_prepared_meals(&self) -> bool {
            self.prepared_meals.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prepared_meals(&mut self, v: bool) {
            self.prepared_meals = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(20);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "meat",
                |m: &FoodSet| { &m.meat },
                |m: &mut FoodSet| { &mut m.meat },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fish",
                |m: &FoodSet| { &m.fish },
                |m: &mut FoodSet| { &mut m.fish },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "unprepared_fish",
                |m: &FoodSet| { &m.unprepared_fish },
                |m: &mut FoodSet| { &mut m.unprepared_fish },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "egg",
                |m: &FoodSet| { &m.egg },
                |m: &mut FoodSet| { &mut m.egg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "plants",
                |m: &FoodSet| { &m.plants },
                |m: &mut FoodSet| { &mut m.plants },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "drink_plant",
                |m: &FoodSet| { &m.drink_plant },
                |m: &mut FoodSet| { &mut m.drink_plant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "drink_animal",
                |m: &FoodSet| { &m.drink_animal },
                |m: &mut FoodSet| { &mut m.drink_animal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cheese_plant",
                |m: &FoodSet| { &m.cheese_plant },
                |m: &mut FoodSet| { &mut m.cheese_plant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cheese_animal",
                |m: &FoodSet| { &m.cheese_animal },
                |m: &mut FoodSet| { &mut m.cheese_animal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "seeds",
                |m: &FoodSet| { &m.seeds },
                |m: &mut FoodSet| { &mut m.seeds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "leaves",
                |m: &FoodSet| { &m.leaves },
                |m: &mut FoodSet| { &mut m.leaves },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "powder_plant",
                |m: &FoodSet| { &m.powder_plant },
                |m: &mut FoodSet| { &mut m.powder_plant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "powder_creature",
                |m: &FoodSet| { &m.powder_creature },
                |m: &mut FoodSet| { &mut m.powder_creature },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "glob",
                |m: &FoodSet| { &m.glob },
                |m: &mut FoodSet| { &mut m.glob },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "glob_paste",
                |m: &FoodSet| { &m.glob_paste },
                |m: &mut FoodSet| { &mut m.glob_paste },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "glob_pressed",
                |m: &FoodSet| { &m.glob_pressed },
                |m: &mut FoodSet| { &mut m.glob_pressed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "liquid_plant",
                |m: &FoodSet| { &m.liquid_plant },
                |m: &mut FoodSet| { &mut m.liquid_plant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "liquid_animal",
                |m: &FoodSet| { &m.liquid_animal },
                |m: &mut FoodSet| { &mut m.liquid_animal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "liquid_misc",
                |m: &FoodSet| { &m.liquid_misc },
                |m: &mut FoodSet| { &mut m.liquid_misc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "prepared_meals",
                |m: &FoodSet| { &m.prepared_meals },
                |m: &mut FoodSet| { &mut m.prepared_meals },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FoodSet>(
                "StockpileSettings.FoodSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FoodSet {
        const NAME: &'static str = "FoodSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.meat.push(is.read_string()?);
                    },
                    18 => {
                        self.fish.push(is.read_string()?);
                    },
                    162 => {
                        self.unprepared_fish.push(is.read_string()?);
                    },
                    26 => {
                        self.egg.push(is.read_string()?);
                    },
                    34 => {
                        self.plants.push(is.read_string()?);
                    },
                    42 => {
                        self.drink_plant.push(is.read_string()?);
                    },
                    50 => {
                        self.drink_animal.push(is.read_string()?);
                    },
                    58 => {
                        self.cheese_plant.push(is.read_string()?);
                    },
                    66 => {
                        self.cheese_animal.push(is.read_string()?);
                    },
                    74 => {
                        self.seeds.push(is.read_string()?);
                    },
                    82 => {
                        self.leaves.push(is.read_string()?);
                    },
                    90 => {
                        self.powder_plant.push(is.read_string()?);
                    },
                    98 => {
                        self.powder_creature.push(is.read_string()?);
                    },
                    106 => {
                        self.glob.push(is.read_string()?);
                    },
                    114 => {
                        self.glob_paste.push(is.read_string()?);
                    },
                    122 => {
                        self.glob_pressed.push(is.read_string()?);
                    },
                    130 => {
                        self.liquid_plant.push(is.read_string()?);
                    },
                    138 => {
                        self.liquid_animal.push(is.read_string()?);
                    },
                    146 => {
                        self.liquid_misc.push(is.read_string()?);
                    },
                    152 => {
                        self.prepared_meals = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.meat {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.fish {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.unprepared_fish {
                my_size += ::protobuf::rt::string_size(20, &value);
            };
            for value in &self.egg {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.plants {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.drink_plant {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.drink_animal {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            for value in &self.cheese_plant {
                my_size += ::protobuf::rt::string_size(7, &value);
            };
            for value in &self.cheese_animal {
                my_size += ::protobuf::rt::string_size(8, &value);
            };
            for value in &self.seeds {
                my_size += ::protobuf::rt::string_size(9, &value);
            };
            for value in &self.leaves {
                my_size += ::protobuf::rt::string_size(10, &value);
            };
            for value in &self.powder_plant {
                my_size += ::protobuf::rt::string_size(11, &value);
            };
            for value in &self.powder_creature {
                my_size += ::protobuf::rt::string_size(12, &value);
            };
            for value in &self.glob {
                my_size += ::protobuf::rt::string_size(13, &value);
            };
            for value in &self.glob_paste {
                my_size += ::protobuf::rt::string_size(14, &value);
            };
            for value in &self.glob_pressed {
                my_size += ::protobuf::rt::string_size(15, &value);
            };
            for value in &self.liquid_plant {
                my_size += ::protobuf::rt::string_size(16, &value);
            };
            for value in &self.liquid_animal {
                my_size += ::protobuf::rt::string_size(17, &value);
            };
            for value in &self.liquid_misc {
                my_size += ::protobuf::rt::string_size(18, &value);
            };
            if let Some(v) = self.prepared_meals {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.meat {
                os.write_string(1, &v)?;
            };
            for v in &self.fish {
                os.write_string(2, &v)?;
            };
            for v in &self.unprepared_fish {
                os.write_string(20, &v)?;
            };
            for v in &self.egg {
                os.write_string(3, &v)?;
            };
            for v in &self.plants {
                os.write_string(4, &v)?;
            };
            for v in &self.drink_plant {
                os.write_string(5, &v)?;
            };
            for v in &self.drink_animal {
                os.write_string(6, &v)?;
            };
            for v in &self.cheese_plant {
                os.write_string(7, &v)?;
            };
            for v in &self.cheese_animal {
                os.write_string(8, &v)?;
            };
            for v in &self.seeds {
                os.write_string(9, &v)?;
            };
            for v in &self.leaves {
                os.write_string(10, &v)?;
            };
            for v in &self.powder_plant {
                os.write_string(11, &v)?;
            };
            for v in &self.powder_creature {
                os.write_string(12, &v)?;
            };
            for v in &self.glob {
                os.write_string(13, &v)?;
            };
            for v in &self.glob_paste {
                os.write_string(14, &v)?;
            };
            for v in &self.glob_pressed {
                os.write_string(15, &v)?;
            };
            for v in &self.liquid_plant {
                os.write_string(16, &v)?;
            };
            for v in &self.liquid_animal {
                os.write_string(17, &v)?;
            };
            for v in &self.liquid_misc {
                os.write_string(18, &v)?;
            };
            if let Some(v) = self.prepared_meals {
                os.write_bool(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FoodSet {
            FoodSet::new()
        }

        fn clear(&mut self) {
            self.meat.clear();
            self.fish.clear();
            self.unprepared_fish.clear();
            self.egg.clear();
            self.plants.clear();
            self.drink_plant.clear();
            self.drink_animal.clear();
            self.cheese_plant.clear();
            self.cheese_animal.clear();
            self.seeds.clear();
            self.leaves.clear();
            self.powder_plant.clear();
            self.powder_creature.clear();
            self.glob.clear();
            self.glob_paste.clear();
            self.glob_pressed.clear();
            self.liquid_plant.clear();
            self.liquid_animal.clear();
            self.liquid_misc.clear();
            self.prepared_meals = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FoodSet {
            static instance: FoodSet = FoodSet {
                meat: ::std::vec::Vec::new(),
                fish: ::std::vec::Vec::new(),
                unprepared_fish: ::std::vec::Vec::new(),
                egg: ::std::vec::Vec::new(),
                plants: ::std::vec::Vec::new(),
                drink_plant: ::std::vec::Vec::new(),
                drink_animal: ::std::vec::Vec::new(),
                cheese_plant: ::std::vec::Vec::new(),
                cheese_animal: ::std::vec::Vec::new(),
                seeds: ::std::vec::Vec::new(),
                leaves: ::std::vec::Vec::new(),
                powder_plant: ::std::vec::Vec::new(),
                powder_creature: ::std::vec::Vec::new(),
                glob: ::std::vec::Vec::new(),
                glob_paste: ::std::vec::Vec::new(),
                glob_pressed: ::std::vec::Vec::new(),
                liquid_plant: ::std::vec::Vec::new(),
                liquid_animal: ::std::vec::Vec::new(),
                liquid_misc: ::std::vec::Vec::new(),
                prepared_meals: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FoodSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.FoodSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FoodSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FoodSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.FurnitureSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FurnitureSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FurnitureSet.type)
        pub type_: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FurnitureSet.other_mats)
        pub other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FurnitureSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FurnitureSet.quality_core)
        pub quality_core: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FurnitureSet.quality_total)
        pub quality_total: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.FurnitureSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FurnitureSet {
        fn default() -> &'a FurnitureSet {
            <FurnitureSet as ::protobuf::Message>::default_instance()
        }
    }

    impl FurnitureSet {
        pub fn new() -> FurnitureSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type",
                |m: &FurnitureSet| { &m.type_ },
                |m: &mut FurnitureSet| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "other_mats",
                |m: &FurnitureSet| { &m.other_mats },
                |m: &mut FurnitureSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &FurnitureSet| { &m.mats },
                |m: &mut FurnitureSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_core",
                |m: &FurnitureSet| { &m.quality_core },
                |m: &mut FurnitureSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_total",
                |m: &FurnitureSet| { &m.quality_total },
                |m: &mut FurnitureSet| { &mut m.quality_total },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FurnitureSet>(
                "StockpileSettings.FurnitureSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FurnitureSet {
        const NAME: &'static str = "FurnitureSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_.push(is.read_string()?);
                    },
                    18 => {
                        self.other_mats.push(is.read_string()?);
                    },
                    26 => {
                        self.mats.push(is.read_string()?);
                    },
                    34 => {
                        self.quality_core.push(is.read_string()?);
                    },
                    42 => {
                        self.quality_total.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_ {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.other_mats {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.quality_core {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.quality_total {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_ {
                os.write_string(1, &v)?;
            };
            for v in &self.other_mats {
                os.write_string(2, &v)?;
            };
            for v in &self.mats {
                os.write_string(3, &v)?;
            };
            for v in &self.quality_core {
                os.write_string(4, &v)?;
            };
            for v in &self.quality_total {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FurnitureSet {
            FurnitureSet::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.other_mats.clear();
            self.mats.clear();
            self.quality_core.clear();
            self.quality_total.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FurnitureSet {
            static instance: FurnitureSet = FurnitureSet {
                type_: ::std::vec::Vec::new(),
                other_mats: ::std::vec::Vec::new(),
                mats: ::std::vec::Vec::new(),
                quality_core: ::std::vec::Vec::new(),
                quality_total: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FurnitureSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.FurnitureSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FurnitureSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FurnitureSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.RefuseSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RefuseSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.type)
        pub type_: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.corpses)
        pub corpses: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.body_parts)
        pub body_parts: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.skulls)
        pub skulls: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.bones)
        pub bones: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.hair)
        pub hair: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.shells)
        pub shells: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.teeth)
        pub teeth: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.horns)
        pub horns: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.fresh_raw_hide)
        pub fresh_raw_hide: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.RefuseSet.rotten_raw_hide)
        pub rotten_raw_hide: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.RefuseSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RefuseSet {
        fn default() -> &'a RefuseSet {
            <RefuseSet as ::protobuf::Message>::default_instance()
        }
    }

    impl RefuseSet {
        pub fn new() -> RefuseSet {
            ::std::default::Default::default()
        }

        // optional bool fresh_raw_hide = 10;

        pub fn fresh_raw_hide(&self) -> bool {
            self.fresh_raw_hide.unwrap_or(false)
        }

        pub fn clear_fresh_raw_hide(&mut self) {
            self.fresh_raw_hide = ::std::option::Option::None;
        }

        pub fn has_fresh_raw_hide(&self) -> bool {
            self.fresh_raw_hide.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fresh_raw_hide(&mut self, v: bool) {
            self.fresh_raw_hide = ::std::option::Option::Some(v);
        }

        // optional bool rotten_raw_hide = 11;

        pub fn rotten_raw_hide(&self) -> bool {
            self.rotten_raw_hide.unwrap_or(false)
        }

        pub fn clear_rotten_raw_hide(&mut self) {
            self.rotten_raw_hide = ::std::option::Option::None;
        }

        pub fn has_rotten_raw_hide(&self) -> bool {
            self.rotten_raw_hide.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rotten_raw_hide(&mut self, v: bool) {
            self.rotten_raw_hide = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type",
                |m: &RefuseSet| { &m.type_ },
                |m: &mut RefuseSet| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "corpses",
                |m: &RefuseSet| { &m.corpses },
                |m: &mut RefuseSet| { &mut m.corpses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "body_parts",
                |m: &RefuseSet| { &m.body_parts },
                |m: &mut RefuseSet| { &mut m.body_parts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "skulls",
                |m: &RefuseSet| { &m.skulls },
                |m: &mut RefuseSet| { &mut m.skulls },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bones",
                |m: &RefuseSet| { &m.bones },
                |m: &mut RefuseSet| { &mut m.bones },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hair",
                |m: &RefuseSet| { &m.hair },
                |m: &mut RefuseSet| { &mut m.hair },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "shells",
                |m: &RefuseSet| { &m.shells },
                |m: &mut RefuseSet| { &mut m.shells },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "teeth",
                |m: &RefuseSet| { &m.teeth },
                |m: &mut RefuseSet| { &mut m.teeth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "horns",
                |m: &RefuseSet| { &m.horns },
                |m: &mut RefuseSet| { &mut m.horns },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fresh_raw_hide",
                |m: &RefuseSet| { &m.fresh_raw_hide },
                |m: &mut RefuseSet| { &mut m.fresh_raw_hide },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rotten_raw_hide",
                |m: &RefuseSet| { &m.rotten_raw_hide },
                |m: &mut RefuseSet| { &mut m.rotten_raw_hide },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefuseSet>(
                "StockpileSettings.RefuseSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RefuseSet {
        const NAME: &'static str = "RefuseSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_.push(is.read_string()?);
                    },
                    18 => {
                        self.corpses.push(is.read_string()?);
                    },
                    26 => {
                        self.body_parts.push(is.read_string()?);
                    },
                    34 => {
                        self.skulls.push(is.read_string()?);
                    },
                    42 => {
                        self.bones.push(is.read_string()?);
                    },
                    50 => {
                        self.hair.push(is.read_string()?);
                    },
                    58 => {
                        self.shells.push(is.read_string()?);
                    },
                    66 => {
                        self.teeth.push(is.read_string()?);
                    },
                    74 => {
                        self.horns.push(is.read_string()?);
                    },
                    80 => {
                        self.fresh_raw_hide = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.rotten_raw_hide = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_ {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.corpses {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.body_parts {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.skulls {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.bones {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.hair {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            for value in &self.shells {
                my_size += ::protobuf::rt::string_size(7, &value);
            };
            for value in &self.teeth {
                my_size += ::protobuf::rt::string_size(8, &value);
            };
            for value in &self.horns {
                my_size += ::protobuf::rt::string_size(9, &value);
            };
            if let Some(v) = self.fresh_raw_hide {
                my_size += 1 + 1;
            }
            if let Some(v) = self.rotten_raw_hide {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_ {
                os.write_string(1, &v)?;
            };
            for v in &self.corpses {
                os.write_string(2, &v)?;
            };
            for v in &self.body_parts {
                os.write_string(3, &v)?;
            };
            for v in &self.skulls {
                os.write_string(4, &v)?;
            };
            for v in &self.bones {
                os.write_string(5, &v)?;
            };
            for v in &self.hair {
                os.write_string(6, &v)?;
            };
            for v in &self.shells {
                os.write_string(7, &v)?;
            };
            for v in &self.teeth {
                os.write_string(8, &v)?;
            };
            for v in &self.horns {
                os.write_string(9, &v)?;
            };
            if let Some(v) = self.fresh_raw_hide {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.rotten_raw_hide {
                os.write_bool(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RefuseSet {
            RefuseSet::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.corpses.clear();
            self.body_parts.clear();
            self.skulls.clear();
            self.bones.clear();
            self.hair.clear();
            self.shells.clear();
            self.teeth.clear();
            self.horns.clear();
            self.fresh_raw_hide = ::std::option::Option::None;
            self.rotten_raw_hide = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RefuseSet {
            static instance: RefuseSet = RefuseSet {
                type_: ::std::vec::Vec::new(),
                corpses: ::std::vec::Vec::new(),
                body_parts: ::std::vec::Vec::new(),
                skulls: ::std::vec::Vec::new(),
                bones: ::std::vec::Vec::new(),
                hair: ::std::vec::Vec::new(),
                shells: ::std::vec::Vec::new(),
                teeth: ::std::vec::Vec::new(),
                horns: ::std::vec::Vec::new(),
                fresh_raw_hide: ::std::option::Option::None,
                rotten_raw_hide: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RefuseSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.RefuseSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RefuseSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RefuseSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.StoneSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StoneSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.StoneSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.StoneSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StoneSet {
        fn default() -> &'a StoneSet {
            <StoneSet as ::protobuf::Message>::default_instance()
        }
    }

    impl StoneSet {
        pub fn new() -> StoneSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &StoneSet| { &m.mats },
                |m: &mut StoneSet| { &mut m.mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoneSet>(
                "StockpileSettings.StoneSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StoneSet {
        const NAME: &'static str = "StoneSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.mats {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StoneSet {
            StoneSet::new()
        }

        fn clear(&mut self) {
            self.mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StoneSet {
            static instance: StoneSet = StoneSet {
                mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StoneSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.StoneSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StoneSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StoneSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.OreSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OreSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.OreSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.OreSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OreSet {
        fn default() -> &'a OreSet {
            <OreSet as ::protobuf::Message>::default_instance()
        }
    }

    impl OreSet {
        pub fn new() -> OreSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &OreSet| { &m.mats },
                |m: &mut OreSet| { &mut m.mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OreSet>(
                "StockpileSettings.OreSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OreSet {
        const NAME: &'static str = "OreSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.mats {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OreSet {
            OreSet::new()
        }

        fn clear(&mut self) {
            self.mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OreSet {
            static instance: OreSet = OreSet {
                mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OreSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.OreSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OreSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OreSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.AmmoSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AmmoSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AmmoSet.type)
        pub type_: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AmmoSet.other_mats)
        pub other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AmmoSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AmmoSet.quality_core)
        pub quality_core: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.AmmoSet.quality_total)
        pub quality_total: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.AmmoSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AmmoSet {
        fn default() -> &'a AmmoSet {
            <AmmoSet as ::protobuf::Message>::default_instance()
        }
    }

    impl AmmoSet {
        pub fn new() -> AmmoSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type",
                |m: &AmmoSet| { &m.type_ },
                |m: &mut AmmoSet| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "other_mats",
                |m: &AmmoSet| { &m.other_mats },
                |m: &mut AmmoSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &AmmoSet| { &m.mats },
                |m: &mut AmmoSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_core",
                |m: &AmmoSet| { &m.quality_core },
                |m: &mut AmmoSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_total",
                |m: &AmmoSet| { &m.quality_total },
                |m: &mut AmmoSet| { &mut m.quality_total },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AmmoSet>(
                "StockpileSettings.AmmoSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AmmoSet {
        const NAME: &'static str = "AmmoSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_.push(is.read_string()?);
                    },
                    18 => {
                        self.other_mats.push(is.read_string()?);
                    },
                    26 => {
                        self.mats.push(is.read_string()?);
                    },
                    34 => {
                        self.quality_core.push(is.read_string()?);
                    },
                    42 => {
                        self.quality_total.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_ {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.other_mats {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.quality_core {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.quality_total {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_ {
                os.write_string(1, &v)?;
            };
            for v in &self.other_mats {
                os.write_string(2, &v)?;
            };
            for v in &self.mats {
                os.write_string(3, &v)?;
            };
            for v in &self.quality_core {
                os.write_string(4, &v)?;
            };
            for v in &self.quality_total {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AmmoSet {
            AmmoSet::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.other_mats.clear();
            self.mats.clear();
            self.quality_core.clear();
            self.quality_total.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AmmoSet {
            static instance: AmmoSet = AmmoSet {
                type_: ::std::vec::Vec::new(),
                other_mats: ::std::vec::Vec::new(),
                mats: ::std::vec::Vec::new(),
                quality_core: ::std::vec::Vec::new(),
                quality_total: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AmmoSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.AmmoSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AmmoSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AmmoSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.CoinSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CoinSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.CoinSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.CoinSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CoinSet {
        fn default() -> &'a CoinSet {
            <CoinSet as ::protobuf::Message>::default_instance()
        }
    }

    impl CoinSet {
        pub fn new() -> CoinSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &CoinSet| { &m.mats },
                |m: &mut CoinSet| { &mut m.mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoinSet>(
                "StockpileSettings.CoinSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CoinSet {
        const NAME: &'static str = "CoinSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.mats {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CoinSet {
            CoinSet::new()
        }

        fn clear(&mut self) {
            self.mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CoinSet {
            static instance: CoinSet = CoinSet {
                mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CoinSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.CoinSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CoinSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CoinSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.BarsBlocksSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BarsBlocksSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.BarsBlocksSet.bars_other_mats)
        pub bars_other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.BarsBlocksSet.blocks_other_mats)
        pub blocks_other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.BarsBlocksSet.bars_mats)
        pub bars_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.BarsBlocksSet.blocks_mats)
        pub blocks_mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.BarsBlocksSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BarsBlocksSet {
        fn default() -> &'a BarsBlocksSet {
            <BarsBlocksSet as ::protobuf::Message>::default_instance()
        }
    }

    impl BarsBlocksSet {
        pub fn new() -> BarsBlocksSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bars_other_mats",
                |m: &BarsBlocksSet| { &m.bars_other_mats },
                |m: &mut BarsBlocksSet| { &mut m.bars_other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "blocks_other_mats",
                |m: &BarsBlocksSet| { &m.blocks_other_mats },
                |m: &mut BarsBlocksSet| { &mut m.blocks_other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bars_mats",
                |m: &BarsBlocksSet| { &m.bars_mats },
                |m: &mut BarsBlocksSet| { &mut m.bars_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "blocks_mats",
                |m: &BarsBlocksSet| { &m.blocks_mats },
                |m: &mut BarsBlocksSet| { &mut m.blocks_mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BarsBlocksSet>(
                "StockpileSettings.BarsBlocksSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BarsBlocksSet {
        const NAME: &'static str = "BarsBlocksSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.bars_other_mats.push(is.read_string()?);
                    },
                    18 => {
                        self.blocks_other_mats.push(is.read_string()?);
                    },
                    26 => {
                        self.bars_mats.push(is.read_string()?);
                    },
                    34 => {
                        self.blocks_mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.bars_other_mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.blocks_other_mats {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.bars_mats {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.blocks_mats {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.bars_other_mats {
                os.write_string(1, &v)?;
            };
            for v in &self.blocks_other_mats {
                os.write_string(2, &v)?;
            };
            for v in &self.bars_mats {
                os.write_string(3, &v)?;
            };
            for v in &self.blocks_mats {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BarsBlocksSet {
            BarsBlocksSet::new()
        }

        fn clear(&mut self) {
            self.bars_other_mats.clear();
            self.blocks_other_mats.clear();
            self.bars_mats.clear();
            self.blocks_mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BarsBlocksSet {
            static instance: BarsBlocksSet = BarsBlocksSet {
                bars_other_mats: ::std::vec::Vec::new(),
                blocks_other_mats: ::std::vec::Vec::new(),
                bars_mats: ::std::vec::Vec::new(),
                blocks_mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BarsBlocksSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.BarsBlocksSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BarsBlocksSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BarsBlocksSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.GemsSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GemsSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.GemsSet.rough_other_mats)
        pub rough_other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.GemsSet.cut_other_mats)
        pub cut_other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.GemsSet.rough_mats)
        pub rough_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.GemsSet.cut_mats)
        pub cut_mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.GemsSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GemsSet {
        fn default() -> &'a GemsSet {
            <GemsSet as ::protobuf::Message>::default_instance()
        }
    }

    impl GemsSet {
        pub fn new() -> GemsSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "rough_other_mats",
                |m: &GemsSet| { &m.rough_other_mats },
                |m: &mut GemsSet| { &mut m.rough_other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cut_other_mats",
                |m: &GemsSet| { &m.cut_other_mats },
                |m: &mut GemsSet| { &mut m.cut_other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "rough_mats",
                |m: &GemsSet| { &m.rough_mats },
                |m: &mut GemsSet| { &mut m.rough_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cut_mats",
                |m: &GemsSet| { &m.cut_mats },
                |m: &mut GemsSet| { &mut m.cut_mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GemsSet>(
                "StockpileSettings.GemsSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GemsSet {
        const NAME: &'static str = "GemsSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.rough_other_mats.push(is.read_string()?);
                    },
                    18 => {
                        self.cut_other_mats.push(is.read_string()?);
                    },
                    26 => {
                        self.rough_mats.push(is.read_string()?);
                    },
                    34 => {
                        self.cut_mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.rough_other_mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.cut_other_mats {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.rough_mats {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.cut_mats {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.rough_other_mats {
                os.write_string(1, &v)?;
            };
            for v in &self.cut_other_mats {
                os.write_string(2, &v)?;
            };
            for v in &self.rough_mats {
                os.write_string(3, &v)?;
            };
            for v in &self.cut_mats {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GemsSet {
            GemsSet::new()
        }

        fn clear(&mut self) {
            self.rough_other_mats.clear();
            self.cut_other_mats.clear();
            self.rough_mats.clear();
            self.cut_mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GemsSet {
            static instance: GemsSet = GemsSet {
                rough_other_mats: ::std::vec::Vec::new(),
                cut_other_mats: ::std::vec::Vec::new(),
                rough_mats: ::std::vec::Vec::new(),
                cut_mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GemsSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.GemsSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GemsSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GemsSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.FinishedGoodsSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FinishedGoodsSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FinishedGoodsSet.type)
        pub type_: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FinishedGoodsSet.other_mats)
        pub other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FinishedGoodsSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FinishedGoodsSet.quality_core)
        pub quality_core: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.FinishedGoodsSet.quality_total)
        pub quality_total: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.FinishedGoodsSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FinishedGoodsSet {
        fn default() -> &'a FinishedGoodsSet {
            <FinishedGoodsSet as ::protobuf::Message>::default_instance()
        }
    }

    impl FinishedGoodsSet {
        pub fn new() -> FinishedGoodsSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type",
                |m: &FinishedGoodsSet| { &m.type_ },
                |m: &mut FinishedGoodsSet| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "other_mats",
                |m: &FinishedGoodsSet| { &m.other_mats },
                |m: &mut FinishedGoodsSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &FinishedGoodsSet| { &m.mats },
                |m: &mut FinishedGoodsSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_core",
                |m: &FinishedGoodsSet| { &m.quality_core },
                |m: &mut FinishedGoodsSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_total",
                |m: &FinishedGoodsSet| { &m.quality_total },
                |m: &mut FinishedGoodsSet| { &mut m.quality_total },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FinishedGoodsSet>(
                "StockpileSettings.FinishedGoodsSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FinishedGoodsSet {
        const NAME: &'static str = "FinishedGoodsSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_.push(is.read_string()?);
                    },
                    18 => {
                        self.other_mats.push(is.read_string()?);
                    },
                    26 => {
                        self.mats.push(is.read_string()?);
                    },
                    34 => {
                        self.quality_core.push(is.read_string()?);
                    },
                    42 => {
                        self.quality_total.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_ {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.other_mats {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.quality_core {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.quality_total {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_ {
                os.write_string(1, &v)?;
            };
            for v in &self.other_mats {
                os.write_string(2, &v)?;
            };
            for v in &self.mats {
                os.write_string(3, &v)?;
            };
            for v in &self.quality_core {
                os.write_string(4, &v)?;
            };
            for v in &self.quality_total {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FinishedGoodsSet {
            FinishedGoodsSet::new()
        }

        fn clear(&mut self) {
            self.type_.clear();
            self.other_mats.clear();
            self.mats.clear();
            self.quality_core.clear();
            self.quality_total.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FinishedGoodsSet {
            static instance: FinishedGoodsSet = FinishedGoodsSet {
                type_: ::std::vec::Vec::new(),
                other_mats: ::std::vec::Vec::new(),
                mats: ::std::vec::Vec::new(),
                quality_core: ::std::vec::Vec::new(),
                quality_total: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FinishedGoodsSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.FinishedGoodsSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FinishedGoodsSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FinishedGoodsSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.LeatherSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LeatherSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.LeatherSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.LeatherSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LeatherSet {
        fn default() -> &'a LeatherSet {
            <LeatherSet as ::protobuf::Message>::default_instance()
        }
    }

    impl LeatherSet {
        pub fn new() -> LeatherSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &LeatherSet| { &m.mats },
                |m: &mut LeatherSet| { &mut m.mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LeatherSet>(
                "StockpileSettings.LeatherSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LeatherSet {
        const NAME: &'static str = "LeatherSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.mats {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LeatherSet {
            LeatherSet::new()
        }

        fn clear(&mut self) {
            self.mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LeatherSet {
            static instance: LeatherSet = LeatherSet {
                mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LeatherSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.LeatherSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LeatherSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LeatherSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.ClothSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ClothSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.thread_silk)
        pub thread_silk: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.thread_plant)
        pub thread_plant: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.thread_yarn)
        pub thread_yarn: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.thread_metal)
        pub thread_metal: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.cloth_silk)
        pub cloth_silk: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.cloth_plant)
        pub cloth_plant: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.cloth_yarn)
        pub cloth_yarn: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ClothSet.cloth_metal)
        pub cloth_metal: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.ClothSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ClothSet {
        fn default() -> &'a ClothSet {
            <ClothSet as ::protobuf::Message>::default_instance()
        }
    }

    impl ClothSet {
        pub fn new() -> ClothSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "thread_silk",
                |m: &ClothSet| { &m.thread_silk },
                |m: &mut ClothSet| { &mut m.thread_silk },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "thread_plant",
                |m: &ClothSet| { &m.thread_plant },
                |m: &mut ClothSet| { &mut m.thread_plant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "thread_yarn",
                |m: &ClothSet| { &m.thread_yarn },
                |m: &mut ClothSet| { &mut m.thread_yarn },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "thread_metal",
                |m: &ClothSet| { &m.thread_metal },
                |m: &mut ClothSet| { &mut m.thread_metal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cloth_silk",
                |m: &ClothSet| { &m.cloth_silk },
                |m: &mut ClothSet| { &mut m.cloth_silk },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cloth_plant",
                |m: &ClothSet| { &m.cloth_plant },
                |m: &mut ClothSet| { &mut m.cloth_plant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cloth_yarn",
                |m: &ClothSet| { &m.cloth_yarn },
                |m: &mut ClothSet| { &mut m.cloth_yarn },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "cloth_metal",
                |m: &ClothSet| { &m.cloth_metal },
                |m: &mut ClothSet| { &mut m.cloth_metal },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClothSet>(
                "StockpileSettings.ClothSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ClothSet {
        const NAME: &'static str = "ClothSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.thread_silk.push(is.read_string()?);
                    },
                    18 => {
                        self.thread_plant.push(is.read_string()?);
                    },
                    26 => {
                        self.thread_yarn.push(is.read_string()?);
                    },
                    34 => {
                        self.thread_metal.push(is.read_string()?);
                    },
                    42 => {
                        self.cloth_silk.push(is.read_string()?);
                    },
                    50 => {
                        self.cloth_plant.push(is.read_string()?);
                    },
                    58 => {
                        self.cloth_yarn.push(is.read_string()?);
                    },
                    66 => {
                        self.cloth_metal.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.thread_silk {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.thread_plant {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.thread_yarn {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.thread_metal {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.cloth_silk {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.cloth_plant {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            for value in &self.cloth_yarn {
                my_size += ::protobuf::rt::string_size(7, &value);
            };
            for value in &self.cloth_metal {
                my_size += ::protobuf::rt::string_size(8, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.thread_silk {
                os.write_string(1, &v)?;
            };
            for v in &self.thread_plant {
                os.write_string(2, &v)?;
            };
            for v in &self.thread_yarn {
                os.write_string(3, &v)?;
            };
            for v in &self.thread_metal {
                os.write_string(4, &v)?;
            };
            for v in &self.cloth_silk {
                os.write_string(5, &v)?;
            };
            for v in &self.cloth_plant {
                os.write_string(6, &v)?;
            };
            for v in &self.cloth_yarn {
                os.write_string(7, &v)?;
            };
            for v in &self.cloth_metal {
                os.write_string(8, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ClothSet {
            ClothSet::new()
        }

        fn clear(&mut self) {
            self.thread_silk.clear();
            self.thread_plant.clear();
            self.thread_yarn.clear();
            self.thread_metal.clear();
            self.cloth_silk.clear();
            self.cloth_plant.clear();
            self.cloth_yarn.clear();
            self.cloth_metal.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ClothSet {
            static instance: ClothSet = ClothSet {
                thread_silk: ::std::vec::Vec::new(),
                thread_plant: ::std::vec::Vec::new(),
                thread_yarn: ::std::vec::Vec::new(),
                thread_metal: ::std::vec::Vec::new(),
                cloth_silk: ::std::vec::Vec::new(),
                cloth_plant: ::std::vec::Vec::new(),
                cloth_yarn: ::std::vec::Vec::new(),
                cloth_metal: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ClothSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.ClothSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ClothSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ClothSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.WoodSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WoodSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WoodSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.WoodSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WoodSet {
        fn default() -> &'a WoodSet {
            <WoodSet as ::protobuf::Message>::default_instance()
        }
    }

    impl WoodSet {
        pub fn new() -> WoodSet {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &WoodSet| { &m.mats },
                |m: &mut WoodSet| { &mut m.mats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WoodSet>(
                "StockpileSettings.WoodSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WoodSet {
        const NAME: &'static str = "WoodSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.mats {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WoodSet {
            WoodSet::new()
        }

        fn clear(&mut self) {
            self.mats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WoodSet {
            static instance: WoodSet = WoodSet {
                mats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WoodSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.WoodSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WoodSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WoodSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.WeaponsSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeaponsSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.weapon_type)
        pub weapon_type: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.trapcomp_type)
        pub trapcomp_type: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.other_mats)
        pub other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.quality_core)
        pub quality_core: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.quality_total)
        pub quality_total: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.usable)
        pub usable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.WeaponsSet.unusable)
        pub unusable: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.WeaponsSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeaponsSet {
        fn default() -> &'a WeaponsSet {
            <WeaponsSet as ::protobuf::Message>::default_instance()
        }
    }

    impl WeaponsSet {
        pub fn new() -> WeaponsSet {
            ::std::default::Default::default()
        }

        // optional bool usable = 7;

        pub fn usable(&self) -> bool {
            self.usable.unwrap_or(false)
        }

        pub fn clear_usable(&mut self) {
            self.usable = ::std::option::Option::None;
        }

        pub fn has_usable(&self) -> bool {
            self.usable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_usable(&mut self, v: bool) {
            self.usable = ::std::option::Option::Some(v);
        }

        // optional bool unusable = 8;

        pub fn unusable(&self) -> bool {
            self.unusable.unwrap_or(false)
        }

        pub fn clear_unusable(&mut self) {
            self.unusable = ::std::option::Option::None;
        }

        pub fn has_unusable(&self) -> bool {
            self.unusable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unusable(&mut self, v: bool) {
            self.unusable = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "weapon_type",
                |m: &WeaponsSet| { &m.weapon_type },
                |m: &mut WeaponsSet| { &mut m.weapon_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "trapcomp_type",
                |m: &WeaponsSet| { &m.trapcomp_type },
                |m: &mut WeaponsSet| { &mut m.trapcomp_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "other_mats",
                |m: &WeaponsSet| { &m.other_mats },
                |m: &mut WeaponsSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &WeaponsSet| { &m.mats },
                |m: &mut WeaponsSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_core",
                |m: &WeaponsSet| { &m.quality_core },
                |m: &mut WeaponsSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_total",
                |m: &WeaponsSet| { &m.quality_total },
                |m: &mut WeaponsSet| { &mut m.quality_total },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "usable",
                |m: &WeaponsSet| { &m.usable },
                |m: &mut WeaponsSet| { &mut m.usable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unusable",
                |m: &WeaponsSet| { &m.unusable },
                |m: &mut WeaponsSet| { &mut m.unusable },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WeaponsSet>(
                "StockpileSettings.WeaponsSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WeaponsSet {
        const NAME: &'static str = "WeaponsSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.weapon_type.push(is.read_string()?);
                    },
                    18 => {
                        self.trapcomp_type.push(is.read_string()?);
                    },
                    26 => {
                        self.other_mats.push(is.read_string()?);
                    },
                    34 => {
                        self.mats.push(is.read_string()?);
                    },
                    42 => {
                        self.quality_core.push(is.read_string()?);
                    },
                    50 => {
                        self.quality_total.push(is.read_string()?);
                    },
                    56 => {
                        self.usable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.unusable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.weapon_type {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.trapcomp_type {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.other_mats {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.quality_core {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.quality_total {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            if let Some(v) = self.usable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.unusable {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.weapon_type {
                os.write_string(1, &v)?;
            };
            for v in &self.trapcomp_type {
                os.write_string(2, &v)?;
            };
            for v in &self.other_mats {
                os.write_string(3, &v)?;
            };
            for v in &self.mats {
                os.write_string(4, &v)?;
            };
            for v in &self.quality_core {
                os.write_string(5, &v)?;
            };
            for v in &self.quality_total {
                os.write_string(6, &v)?;
            };
            if let Some(v) = self.usable {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.unusable {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeaponsSet {
            WeaponsSet::new()
        }

        fn clear(&mut self) {
            self.weapon_type.clear();
            self.trapcomp_type.clear();
            self.other_mats.clear();
            self.mats.clear();
            self.quality_core.clear();
            self.quality_total.clear();
            self.usable = ::std::option::Option::None;
            self.unusable = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeaponsSet {
            static instance: WeaponsSet = WeaponsSet {
                weapon_type: ::std::vec::Vec::new(),
                trapcomp_type: ::std::vec::Vec::new(),
                other_mats: ::std::vec::Vec::new(),
                mats: ::std::vec::Vec::new(),
                quality_core: ::std::vec::Vec::new(),
                quality_total: ::std::vec::Vec::new(),
                usable: ::std::option::Option::None,
                unusable: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WeaponsSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.WeaponsSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WeaponsSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WeaponsSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:dfstockpiles.StockpileSettings.ArmorSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ArmorSet {
        // message fields
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.body)
        pub body: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.head)
        pub head: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.feet)
        pub feet: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.hands)
        pub hands: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.legs)
        pub legs: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.shield)
        pub shield: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.other_mats)
        pub other_mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.mats)
        pub mats: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.quality_core)
        pub quality_core: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.quality_total)
        pub quality_total: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.usable)
        pub usable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:dfstockpiles.StockpileSettings.ArmorSet.unusable)
        pub unusable: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:dfstockpiles.StockpileSettings.ArmorSet.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ArmorSet {
        fn default() -> &'a ArmorSet {
            <ArmorSet as ::protobuf::Message>::default_instance()
        }
    }

    impl ArmorSet {
        pub fn new() -> ArmorSet {
            ::std::default::Default::default()
        }

        // optional bool usable = 11;

        pub fn usable(&self) -> bool {
            self.usable.unwrap_or(false)
        }

        pub fn clear_usable(&mut self) {
            self.usable = ::std::option::Option::None;
        }

        pub fn has_usable(&self) -> bool {
            self.usable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_usable(&mut self, v: bool) {
            self.usable = ::std::option::Option::Some(v);
        }

        // optional bool unusable = 12;

        pub fn unusable(&self) -> bool {
            self.unusable.unwrap_or(false)
        }

        pub fn clear_unusable(&mut self) {
            self.unusable = ::std::option::Option::None;
        }

        pub fn has_unusable(&self) -> bool {
            self.unusable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unusable(&mut self, v: bool) {
            self.unusable = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "body",
                |m: &ArmorSet| { &m.body },
                |m: &mut ArmorSet| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "head",
                |m: &ArmorSet| { &m.head },
                |m: &mut ArmorSet| { &mut m.head },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "feet",
                |m: &ArmorSet| { &m.feet },
                |m: &mut ArmorSet| { &mut m.feet },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hands",
                |m: &ArmorSet| { &m.hands },
                |m: &mut ArmorSet| { &mut m.hands },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "legs",
                |m: &ArmorSet| { &m.legs },
                |m: &mut ArmorSet| { &mut m.legs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "shield",
                |m: &ArmorSet| { &m.shield },
                |m: &mut ArmorSet| { &mut m.shield },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "other_mats",
                |m: &ArmorSet| { &m.other_mats },
                |m: &mut ArmorSet| { &mut m.other_mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mats",
                |m: &ArmorSet| { &m.mats },
                |m: &mut ArmorSet| { &mut m.mats },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_core",
                |m: &ArmorSet| { &m.quality_core },
                |m: &mut ArmorSet| { &mut m.quality_core },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "quality_total",
                |m: &ArmorSet| { &m.quality_total },
                |m: &mut ArmorSet| { &mut m.quality_total },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "usable",
                |m: &ArmorSet| { &m.usable },
                |m: &mut ArmorSet| { &mut m.usable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unusable",
                |m: &ArmorSet| { &m.unusable },
                |m: &mut ArmorSet| { &mut m.unusable },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArmorSet>(
                "StockpileSettings.ArmorSet",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ArmorSet {
        const NAME: &'static str = "ArmorSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.body.push(is.read_string()?);
                    },
                    18 => {
                        self.head.push(is.read_string()?);
                    },
                    26 => {
                        self.feet.push(is.read_string()?);
                    },
                    34 => {
                        self.hands.push(is.read_string()?);
                    },
                    42 => {
                        self.legs.push(is.read_string()?);
                    },
                    50 => {
                        self.shield.push(is.read_string()?);
                    },
                    58 => {
                        self.other_mats.push(is.read_string()?);
                    },
                    66 => {
                        self.mats.push(is.read_string()?);
                    },
                    74 => {
                        self.quality_core.push(is.read_string()?);
                    },
                    82 => {
                        self.quality_total.push(is.read_string()?);
                    },
                    88 => {
                        self.usable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    96 => {
                        self.unusable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.body {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.head {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.feet {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.hands {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.legs {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.shield {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            for value in &self.other_mats {
                my_size += ::protobuf::rt::string_size(7, &value);
            };
            for value in &self.mats {
                my_size += ::protobuf::rt::string_size(8, &value);
            };
            for value in &self.quality_core {
                my_size += ::protobuf::rt::string_size(9, &value);
            };
            for value in &self.quality_total {
                my_size += ::protobuf::rt::string_size(10, &value);
            };
            if let Some(v) = self.usable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.unusable {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.body {
                os.write_string(1, &v)?;
            };
            for v in &self.head {
                os.write_string(2, &v)?;
            };
            for v in &self.feet {
                os.write_string(3, &v)?;
            };
            for v in &self.hands {
                os.write_string(4, &v)?;
            };
            for v in &self.legs {
                os.write_string(5, &v)?;
            };
            for v in &self.shield {
                os.write_string(6, &v)?;
            };
            for v in &self.other_mats {
                os.write_string(7, &v)?;
            };
            for v in &self.mats {
                os.write_string(8, &v)?;
            };
            for v in &self.quality_core {
                os.write_string(9, &v)?;
            };
            for v in &self.quality_total {
                os.write_string(10, &v)?;
            };
            if let Some(v) = self.usable {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.unusable {
                os.write_bool(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ArmorSet {
            ArmorSet::new()
        }

        fn clear(&mut self) {
            self.body.clear();
            self.head.clear();
            self.feet.clear();
            self.hands.clear();
            self.legs.clear();
            self.shield.clear();
            self.other_mats.clear();
            self.mats.clear();
            self.quality_core.clear();
            self.quality_total.clear();
            self.usable = ::std::option::Option::None;
            self.unusable = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ArmorSet {
            static instance: ArmorSet = ArmorSet {
                body: ::std::vec::Vec::new(),
                head: ::std::vec::Vec::new(),
                feet: ::std::vec::Vec::new(),
                hands: ::std::vec::Vec::new(),
                legs: ::std::vec::Vec::new(),
                shield: ::std::vec::Vec::new(),
                other_mats: ::std::vec::Vec::new(),
                mats: ::std::vec::Vec::new(),
                quality_core: ::std::vec::Vec::new(),
                quality_total: ::std::vec::Vec::new(),
                usable: ::std::option::Option::None,
                unusable: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ArmorSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StockpileSettings.ArmorSet").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ArmorSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ArmorSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10stockpiles.proto\x12\x0cdfstockpiles\"\xee\x20\n\x11StockpileSetti\
    ngs\x12D\n\x07animals\x18\x01\x20\x01(\x0b2*.dfstockpiles.StockpileSetti\
    ngs.AnimalsSetR\x07animals\x12;\n\x04food\x18\x02\x20\x01(\x0b2'.dfstock\
    piles.StockpileSettings.FoodSetR\x04food\x12J\n\tfurniture\x18\x03\x20\
    \x01(\x0b2,.dfstockpiles.StockpileSettings.FurnitureSetR\tfurniture\x12\
    \x1a\n\x08unknown1\x18\x04\x20\x01(\x05R\x08unknown1\x12A\n\x06refuse\
    \x18\x05\x20\x01(\x0b2).dfstockpiles.StockpileSettings.RefuseSetR\x06ref\
    use\x12>\n\x05stone\x18\x06\x20\x01(\x0b2(.dfstockpiles.StockpileSetting\
    s.StoneSetR\x05stone\x128\n\x03ore\x18\x07\x20\x01(\x0b2&.dfstockpiles.S\
    tockpileSettings.OreSetR\x03ore\x12;\n\x04ammo\x18\x08\x20\x01(\x0b2'.df\
    stockpiles.StockpileSettings.AmmoSetR\x04ammo\x12;\n\x04coin\x18\t\x20\
    \x01(\x0b2'.dfstockpiles.StockpileSettings.CoinSetR\x04coin\x12M\n\nbars\
    blocks\x18\n\x20\x01(\x0b2-.dfstockpiles.StockpileSettings.BarsBlocksSet\
    R\nbarsblocks\x12;\n\x04gems\x18\x0b\x20\x01(\x0b2'.dfstockpiles.Stockpi\
    leSettings.GemsSetR\x04gems\x12W\n\x0efinished_goods\x18\x0c\x20\x01(\
    \x0b20.dfstockpiles.StockpileSettings.FinishedGoodsSetR\rfinishedGoods\
    \x12D\n\x07leather\x18\r\x20\x01(\x0b2*.dfstockpiles.StockpileSettings.L\
    eatherSetR\x07leather\x12>\n\x05cloth\x18\x0e\x20\x01(\x0b2(.dfstockpile\
    s.StockpileSettings.ClothSetR\x05cloth\x12;\n\x04wood\x18\x0f\x20\x01(\
    \x0b2'.dfstockpiles.StockpileSettings.WoodSetR\x04wood\x12D\n\x07weapons\
    \x18\x10\x20\x01(\x0b2*.dfstockpiles.StockpileSettings.WeaponsSetR\x07we\
    apons\x12>\n\x05armor\x18\x11\x20\x01(\x0b2(.dfstockpiles.StockpileSetti\
    ngs.ArmorSetR\x05armor\x12#\n\rallow_organic\x18\x12\x20\x01(\x08R\x0cal\
    lowOrganic\x12'\n\x0fallow_inorganic\x18\x13\x20\x01(\x08R\x0eallowInorg\
    anic\x12\x18\n\x07corpses\x18\x18\x20\x01(\x08R\x07corpses\x12\x1f\n\x0b\
    max_barrels\x18\x14\x20\x01(\x05R\nmaxBarrels\x12\x19\n\x08max_bins\x18\
    \x15\x20\x01(\x05R\x07maxBins\x12)\n\x10max_wheelbarrows\x18\x16\x20\x01\
    (\x05R\x0fmaxWheelbarrows\x12$\n\x0euse_links_only\x18\x17\x20\x01(\x08R\
    \x0cuseLinksOnly\x1ah\n\nAnimalsSet\x12\x1f\n\x0bempty_cages\x18\x01\x20\
    \x01(\x08R\nemptyCages\x12\x1f\n\x0bempty_traps\x18\x02\x20\x01(\x08R\ne\
    mptyTraps\x12\x18\n\x07enabled\x18\x03\x20\x03(\tR\x07enabled\x1a\xf0\
    \x04\n\x07FoodSet\x12\x12\n\x04meat\x18\x01\x20\x03(\tR\x04meat\x12\x12\
    \n\x04fish\x18\x02\x20\x03(\tR\x04fish\x12'\n\x0funprepared_fish\x18\x14\
    \x20\x03(\tR\x0eunpreparedFish\x12\x10\n\x03egg\x18\x03\x20\x03(\tR\x03e\
    gg\x12\x16\n\x06plants\x18\x04\x20\x03(\tR\x06plants\x12\x1f\n\x0bdrink_\
    plant\x18\x05\x20\x03(\tR\ndrinkPlant\x12!\n\x0cdrink_animal\x18\x06\x20\
    \x03(\tR\x0bdrinkAnimal\x12!\n\x0ccheese_plant\x18\x07\x20\x03(\tR\x0bch\
    eesePlant\x12#\n\rcheese_animal\x18\x08\x20\x03(\tR\x0ccheeseAnimal\x12\
    \x14\n\x05seeds\x18\t\x20\x03(\tR\x05seeds\x12\x16\n\x06leaves\x18\n\x20\
    \x03(\tR\x06leaves\x12!\n\x0cpowder_plant\x18\x0b\x20\x03(\tR\x0bpowderP\
    lant\x12'\n\x0fpowder_creature\x18\x0c\x20\x03(\tR\x0epowderCreature\x12\
    \x12\n\x04glob\x18\r\x20\x03(\tR\x04glob\x12\x1d\n\nglob_paste\x18\x0e\
    \x20\x03(\tR\tglobPaste\x12!\n\x0cglob_pressed\x18\x0f\x20\x03(\tR\x0bgl\
    obPressed\x12!\n\x0cliquid_plant\x18\x10\x20\x03(\tR\x0bliquidPlant\x12#\
    \n\rliquid_animal\x18\x11\x20\x03(\tR\x0cliquidAnimal\x12\x1f\n\x0bliqui\
    d_misc\x18\x12\x20\x03(\tR\nliquidMisc\x12%\n\x0eprepared_meals\x18\x13\
    \x20\x01(\x08R\rpreparedMeals\x1a\x9d\x01\n\x0cFurnitureSet\x12\x12\n\
    \x04type\x18\x01\x20\x03(\tR\x04type\x12\x1d\n\nother_mats\x18\x02\x20\
    \x03(\tR\totherMats\x12\x12\n\x04mats\x18\x03\x20\x03(\tR\x04mats\x12!\n\
    \x0cquality_core\x18\x04\x20\x03(\tR\x0bqualityCore\x12#\n\rquality_tota\
    l\x18\x05\x20\x03(\tR\x0cqualityTotal\x1a\xac\x02\n\tRefuseSet\x12\x12\n\
    \x04type\x18\x01\x20\x03(\tR\x04type\x12\x18\n\x07corpses\x18\x02\x20\
    \x03(\tR\x07corpses\x12\x1d\n\nbody_parts\x18\x03\x20\x03(\tR\tbodyParts\
    \x12\x16\n\x06skulls\x18\x04\x20\x03(\tR\x06skulls\x12\x14\n\x05bones\
    \x18\x05\x20\x03(\tR\x05bones\x12\x12\n\x04hair\x18\x06\x20\x03(\tR\x04h\
    air\x12\x16\n\x06shells\x18\x07\x20\x03(\tR\x06shells\x12\x14\n\x05teeth\
    \x18\x08\x20\x03(\tR\x05teeth\x12\x14\n\x05horns\x18\t\x20\x03(\tR\x05ho\
    rns\x12$\n\x0efresh_raw_hide\x18\n\x20\x01(\x08R\x0cfreshRawHide\x12&\n\
    \x0frotten_raw_hide\x18\x0b\x20\x01(\x08R\rrottenRawHide\x1a\x1e\n\x08St\
    oneSet\x12\x12\n\x04mats\x18\x01\x20\x03(\tR\x04mats\x1a\x1c\n\x06OreSet\
    \x12\x12\n\x04mats\x18\x01\x20\x03(\tR\x04mats\x1a\x98\x01\n\x07AmmoSet\
    \x12\x12\n\x04type\x18\x01\x20\x03(\tR\x04type\x12\x1d\n\nother_mats\x18\
    \x02\x20\x03(\tR\totherMats\x12\x12\n\x04mats\x18\x03\x20\x03(\tR\x04mat\
    s\x12!\n\x0cquality_core\x18\x04\x20\x03(\tR\x0bqualityCore\x12#\n\rqual\
    ity_total\x18\x05\x20\x03(\tR\x0cqualityTotal\x1a\x1d\n\x07CoinSet\x12\
    \x12\n\x04mats\x18\x01\x20\x03(\tR\x04mats\x1a\xa1\x01\n\rBarsBlocksSet\
    \x12&\n\x0fbars_other_mats\x18\x01\x20\x03(\tR\rbarsOtherMats\x12*\n\x11\
    blocks_other_mats\x18\x02\x20\x03(\tR\x0fblocksOtherMats\x12\x1b\n\tbars\
    _mats\x18\x03\x20\x03(\tR\x08barsMats\x12\x1f\n\x0bblocks_mats\x18\x04\
    \x20\x03(\tR\nblocksMats\x1a\x93\x01\n\x07GemsSet\x12(\n\x10rough_other_\
    mats\x18\x01\x20\x03(\tR\x0eroughOtherMats\x12$\n\x0ecut_other_mats\x18\
    \x02\x20\x03(\tR\x0ccutOtherMats\x12\x1d\n\nrough_mats\x18\x03\x20\x03(\
    \tR\troughMats\x12\x19\n\x08cut_mats\x18\x04\x20\x03(\tR\x07cutMats\x1a\
    \xa1\x01\n\x10FinishedGoodsSet\x12\x12\n\x04type\x18\x01\x20\x03(\tR\x04\
    type\x12\x1d\n\nother_mats\x18\x02\x20\x03(\tR\totherMats\x12\x12\n\x04m\
    ats\x18\x03\x20\x03(\tR\x04mats\x12!\n\x0cquality_core\x18\x04\x20\x03(\
    \tR\x0bqualityCore\x12#\n\rquality_total\x18\x05\x20\x03(\tR\x0cqualityT\
    otal\x1a\x20\n\nLeatherSet\x12\x12\n\x04mats\x18\x01\x20\x03(\tR\x04mats\
    \x1a\x92\x02\n\x08ClothSet\x12\x1f\n\x0bthread_silk\x18\x01\x20\x03(\tR\
    \nthreadSilk\x12!\n\x0cthread_plant\x18\x02\x20\x03(\tR\x0bthreadPlant\
    \x12\x1f\n\x0bthread_yarn\x18\x03\x20\x03(\tR\nthreadYarn\x12!\n\x0cthre\
    ad_metal\x18\x04\x20\x03(\tR\x0bthreadMetal\x12\x1d\n\ncloth_silk\x18\
    \x05\x20\x03(\tR\tclothSilk\x12\x1f\n\x0bcloth_plant\x18\x06\x20\x03(\tR\
    \nclothPlant\x12\x1d\n\ncloth_yarn\x18\x07\x20\x03(\tR\tclothYarn\x12\
    \x1f\n\x0bcloth_metal\x18\x08\x20\x03(\tR\nclothMetal\x1a\x1d\n\x07WoodS\
    et\x12\x12\n\x04mats\x18\x01\x20\x03(\tR\x04mats\x1a\x81\x02\n\nWeaponsS\
    et\x12\x1f\n\x0bweapon_type\x18\x01\x20\x03(\tR\nweaponType\x12#\n\rtrap\
    comp_type\x18\x02\x20\x03(\tR\x0ctrapcompType\x12\x1d\n\nother_mats\x18\
    \x03\x20\x03(\tR\totherMats\x12\x12\n\x04mats\x18\x04\x20\x03(\tR\x04mat\
    s\x12!\n\x0cquality_core\x18\x05\x20\x03(\tR\x0bqualityCore\x12#\n\rqual\
    ity_total\x18\x06\x20\x03(\tR\x0cqualityTotal\x12\x16\n\x06usable\x18\
    \x07\x20\x01(\x08R\x06usable\x12\x1a\n\x08unusable\x18\x08\x20\x01(\x08R\
    \x08unusable\x1a\xb7\x02\n\x08ArmorSet\x12\x12\n\x04body\x18\x01\x20\x03\
    (\tR\x04body\x12\x12\n\x04head\x18\x02\x20\x03(\tR\x04head\x12\x12\n\x04\
    feet\x18\x03\x20\x03(\tR\x04feet\x12\x14\n\x05hands\x18\x04\x20\x03(\tR\
    \x05hands\x12\x12\n\x04legs\x18\x05\x20\x03(\tR\x04legs\x12\x16\n\x06shi\
    eld\x18\x06\x20\x03(\tR\x06shield\x12\x1d\n\nother_mats\x18\x07\x20\x03(\
    \tR\totherMats\x12\x12\n\x04mats\x18\x08\x20\x03(\tR\x04mats\x12!\n\x0cq\
    uality_core\x18\t\x20\x03(\tR\x0bqualityCore\x12#\n\rquality_total\x18\n\
    \x20\x03(\tR\x0cqualityTotal\x12\x16\n\x06usable\x18\x0b\x20\x01(\x08R\
    \x06usable\x12\x1a\n\x08unusable\x18\x0c\x20\x01(\x08R\x08unusableB\x02H\
    \x03b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(StockpileSettings::generated_message_descriptor_data());
            messages.push(stockpile_settings::AnimalsSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::FoodSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::FurnitureSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::RefuseSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::StoneSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::OreSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::AmmoSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::CoinSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::BarsBlocksSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::GemsSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::FinishedGoodsSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::LeatherSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::ClothSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::WoodSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::WeaponsSet::generated_message_descriptor_data());
            messages.push(stockpile_settings::ArmorSet::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
