// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `Basic.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:dfproto.EnumItemName)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumItemName {
    // message fields
    // @@protoc_insertion_point(field:dfproto.EnumItemName.value)
    pub value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.EnumItemName.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.EnumItemName.bit_size)
    pub bit_size: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.EnumItemName.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumItemName {
    fn default() -> &'a EnumItemName {
        <EnumItemName as ::protobuf::Message>::default_instance()
    }
}

impl EnumItemName {
    pub fn new() -> EnumItemName {
        ::std::default::Default::default()
    }

    // required int32 value = 1;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 bit_size = 3;

    pub fn bit_size(&self) -> i32 {
        self.bit_size.unwrap_or(1i32)
    }

    pub fn clear_bit_size(&mut self) {
        self.bit_size = ::std::option::Option::None;
    }

    pub fn has_bit_size(&self) -> bool {
        self.bit_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bit_size(&mut self, v: i32) {
        self.bit_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &EnumItemName| { &m.value },
            |m: &mut EnumItemName| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumItemName| { &m.name },
            |m: &mut EnumItemName| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bit_size",
            |m: &EnumItemName| { &m.bit_size },
            |m: &mut EnumItemName| { &mut m.bit_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumItemName>(
            "EnumItemName",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumItemName {
    const NAME: &'static str = "EnumItemName";

    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.bit_size = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bit_size {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.bit_size {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumItemName {
        EnumItemName::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.bit_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumItemName {
        static instance: EnumItemName = EnumItemName {
            value: ::std::option::Option::None,
            name: ::std::option::Option::None,
            bit_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumItemName {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumItemName").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumItemName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumItemName {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.BasicMaterialId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicMaterialId {
    // message fields
    // @@protoc_insertion_point(field:dfproto.BasicMaterialId.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialId.index)
    pub index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.BasicMaterialId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicMaterialId {
    fn default() -> &'a BasicMaterialId {
        <BasicMaterialId as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialId {
    pub fn new() -> BasicMaterialId {
        ::std::default::Default::default()
    }

    // required int32 type = 1;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // required sint32 index = 2;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &BasicMaterialId| { &m.type_ },
            |m: &mut BasicMaterialId| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &BasicMaterialId| { &m.index },
            |m: &mut BasicMaterialId| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicMaterialId>(
            "BasicMaterialId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicMaterialId {
    const NAME: &'static str = "BasicMaterialId";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicMaterialId {
        BasicMaterialId::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicMaterialId {
        static instance: BasicMaterialId = BasicMaterialId {
            type_: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BasicMaterialId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicMaterialId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicMaterialId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.BasicMaterialInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicMaterialInfo {
    // message fields
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.flags)
    pub flags: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.subtype)
    pub subtype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.creature_id)
    pub creature_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.plant_id)
    pub plant_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.histfig_id)
    pub histfig_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.name_prefix)
    pub name_prefix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.state_color)
    pub state_color: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.state_name)
    pub state_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.state_adj)
    pub state_adj: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.reaction_class)
    pub reaction_class: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.reaction_product)
    pub reaction_product: ::std::vec::Vec<basic_material_info::Product>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.inorganic_flags)
    pub inorganic_flags: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.BasicMaterialInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicMaterialInfo {
    fn default() -> &'a BasicMaterialInfo {
        <BasicMaterialInfo as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialInfo {
    pub fn new() -> BasicMaterialInfo {
        ::std::default::Default::default()
    }

    // required int32 type = 1;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // required sint32 index = 2;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // required string token = 3;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 subtype = 5;

    pub fn subtype(&self) -> i32 {
        self.subtype.unwrap_or(-1i32)
    }

    pub fn clear_subtype(&mut self) {
        self.subtype = ::std::option::Option::None;
    }

    pub fn has_subtype(&self) -> bool {
        self.subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subtype(&mut self, v: i32) {
        self.subtype = ::std::option::Option::Some(v);
    }

    // optional int32 creature_id = 6;

    pub fn creature_id(&self) -> i32 {
        self.creature_id.unwrap_or(-1i32)
    }

    pub fn clear_creature_id(&mut self) {
        self.creature_id = ::std::option::Option::None;
    }

    pub fn has_creature_id(&self) -> bool {
        self.creature_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creature_id(&mut self, v: i32) {
        self.creature_id = ::std::option::Option::Some(v);
    }

    // optional int32 plant_id = 7;

    pub fn plant_id(&self) -> i32 {
        self.plant_id.unwrap_or(-1i32)
    }

    pub fn clear_plant_id(&mut self) {
        self.plant_id = ::std::option::Option::None;
    }

    pub fn has_plant_id(&self) -> bool {
        self.plant_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plant_id(&mut self, v: i32) {
        self.plant_id = ::std::option::Option::Some(v);
    }

    // optional int32 histfig_id = 8;

    pub fn histfig_id(&self) -> i32 {
        self.histfig_id.unwrap_or(-1i32)
    }

    pub fn clear_histfig_id(&mut self) {
        self.histfig_id = ::std::option::Option::None;
    }

    pub fn has_histfig_id(&self) -> bool {
        self.histfig_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_histfig_id(&mut self, v: i32) {
        self.histfig_id = ::std::option::Option::Some(v);
    }

    // optional string name_prefix = 9;

    pub fn name_prefix(&self) -> &str {
        match self.name_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_prefix(&mut self) {
        self.name_prefix = ::std::option::Option::None;
    }

    pub fn has_name_prefix(&self) -> bool {
        self.name_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_prefix(&mut self, v: ::std::string::String) {
        self.name_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_prefix(&mut self) -> &mut ::std::string::String {
        if self.name_prefix.is_none() {
            self.name_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_prefix(&mut self) -> ::std::string::String {
        self.name_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &BasicMaterialInfo| { &m.type_ },
            |m: &mut BasicMaterialInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &BasicMaterialInfo| { &m.index },
            |m: &mut BasicMaterialInfo| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &BasicMaterialInfo| { &m.token },
            |m: &mut BasicMaterialInfo| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flags",
            |m: &BasicMaterialInfo| { &m.flags },
            |m: &mut BasicMaterialInfo| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subtype",
            |m: &BasicMaterialInfo| { &m.subtype },
            |m: &mut BasicMaterialInfo| { &mut m.subtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creature_id",
            |m: &BasicMaterialInfo| { &m.creature_id },
            |m: &mut BasicMaterialInfo| { &mut m.creature_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plant_id",
            |m: &BasicMaterialInfo| { &m.plant_id },
            |m: &mut BasicMaterialInfo| { &mut m.plant_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "histfig_id",
            |m: &BasicMaterialInfo| { &m.histfig_id },
            |m: &mut BasicMaterialInfo| { &mut m.histfig_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_prefix",
            |m: &BasicMaterialInfo| { &m.name_prefix },
            |m: &mut BasicMaterialInfo| { &mut m.name_prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "state_color",
            |m: &BasicMaterialInfo| { &m.state_color },
            |m: &mut BasicMaterialInfo| { &mut m.state_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "state_name",
            |m: &BasicMaterialInfo| { &m.state_name },
            |m: &mut BasicMaterialInfo| { &mut m.state_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "state_adj",
            |m: &BasicMaterialInfo| { &m.state_adj },
            |m: &mut BasicMaterialInfo| { &mut m.state_adj },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reaction_class",
            |m: &BasicMaterialInfo| { &m.reaction_class },
            |m: &mut BasicMaterialInfo| { &mut m.reaction_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reaction_product",
            |m: &BasicMaterialInfo| { &m.reaction_product },
            |m: &mut BasicMaterialInfo| { &mut m.reaction_product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inorganic_flags",
            |m: &BasicMaterialInfo| { &m.inorganic_flags },
            |m: &mut BasicMaterialInfo| { &mut m.inorganic_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicMaterialInfo>(
            "BasicMaterialInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicMaterialInfo {
    const NAME: &'static str = "BasicMaterialInfo";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        if self.token.is_none() {
            return false;
        }
        for v in &self.reaction_product {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_sint32()?);
                },
                26 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.flags)?;
                },
                32 => {
                    self.flags.push(is.read_int32()?);
                },
                40 => {
                    self.subtype = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.creature_id = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.plant_id = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.histfig_id = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.name_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_fixed32_into(&mut self.state_color)?;
                },
                85 => {
                    self.state_color.push(is.read_fixed32()?);
                },
                90 => {
                    self.state_name.push(is.read_string()?);
                },
                98 => {
                    self.state_adj.push(is.read_string()?);
                },
                106 => {
                    self.reaction_class.push(is.read_string()?);
                },
                114 => {
                    self.reaction_product.push(is.read_message()?);
                },
                122 => {
                    is.read_repeated_packed_int32_into(&mut self.inorganic_flags)?;
                },
                120 => {
                    self.inorganic_flags.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.flags {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        if let Some(v) = self.subtype {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.creature_id {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.plant_id {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.histfig_id {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.name_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += 5 * self.state_color.len() as u64;
        for value in &self.state_name {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.state_adj {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.reaction_class {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.reaction_product {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.inorganic_flags {
            my_size += ::protobuf::rt::int32_size(15, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.flags {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.subtype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.creature_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.plant_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.histfig_id {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.name_prefix.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.state_color {
            os.write_fixed32(10, *v)?;
        };
        for v in &self.state_name {
            os.write_string(11, &v)?;
        };
        for v in &self.state_adj {
            os.write_string(12, &v)?;
        };
        for v in &self.reaction_class {
            os.write_string(13, &v)?;
        };
        for v in &self.reaction_product {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.inorganic_flags {
            os.write_int32(15, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicMaterialInfo {
        BasicMaterialInfo::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.flags.clear();
        self.subtype = ::std::option::Option::None;
        self.creature_id = ::std::option::Option::None;
        self.plant_id = ::std::option::Option::None;
        self.histfig_id = ::std::option::Option::None;
        self.name_prefix = ::std::option::Option::None;
        self.state_color.clear();
        self.state_name.clear();
        self.state_adj.clear();
        self.reaction_class.clear();
        self.reaction_product.clear();
        self.inorganic_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicMaterialInfo {
        static instance: BasicMaterialInfo = BasicMaterialInfo {
            type_: ::std::option::Option::None,
            index: ::std::option::Option::None,
            token: ::std::option::Option::None,
            flags: ::std::vec::Vec::new(),
            subtype: ::std::option::Option::None,
            creature_id: ::std::option::Option::None,
            plant_id: ::std::option::Option::None,
            histfig_id: ::std::option::Option::None,
            name_prefix: ::std::option::Option::None,
            state_color: ::std::vec::Vec::new(),
            state_name: ::std::vec::Vec::new(),
            state_adj: ::std::vec::Vec::new(),
            reaction_class: ::std::vec::Vec::new(),
            reaction_product: ::std::vec::Vec::new(),
            inorganic_flags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BasicMaterialInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicMaterialInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicMaterialInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BasicMaterialInfo`
pub mod basic_material_info {
    // @@protoc_insertion_point(message:dfproto.BasicMaterialInfo.Product)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Product {
        // message fields
        // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.Product.id)
        pub id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.Product.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:dfproto.BasicMaterialInfo.Product.index)
        pub index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:dfproto.BasicMaterialInfo.Product.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Product {
        fn default() -> &'a Product {
            <Product as ::protobuf::Message>::default_instance()
        }
    }

    impl Product {
        pub fn new() -> Product {
            ::std::default::Default::default()
        }

        // required string id = 1;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required int32 type = 2;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // required sint32 index = 3;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Product| { &m.id },
                |m: &mut Product| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Product| { &m.type_ },
                |m: &mut Product| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &Product| { &m.index },
                |m: &mut Product| { &mut m.index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Product>(
                "BasicMaterialInfo.Product",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Product {
        const NAME: &'static str = "Product";

        fn is_initialized(&self) -> bool {
            if self.id.is_none() {
                return false;
            }
            if self.type_.is_none() {
                return false;
            }
            if self.index.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.index = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::sint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.index {
                os.write_sint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Product {
            Product::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Product {
            static instance: Product = Product {
                id: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Product {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BasicMaterialInfo.Product").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Product {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Product {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:dfproto.BasicMaterialInfoMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicMaterialInfoMask {
    // message fields
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfoMask.states)
    pub states: ::std::vec::Vec<::protobuf::EnumOrUnknown<basic_material_info_mask::StateType>>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfoMask.temperature)
    pub temperature: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfoMask.flags)
    pub flags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfproto.BasicMaterialInfoMask.reaction)
    pub reaction: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.BasicMaterialInfoMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicMaterialInfoMask {
    fn default() -> &'a BasicMaterialInfoMask {
        <BasicMaterialInfoMask as ::protobuf::Message>::default_instance()
    }
}

impl BasicMaterialInfoMask {
    pub fn new() -> BasicMaterialInfoMask {
        ::std::default::Default::default()
    }

    // optional int32 temperature = 4;

    pub fn temperature(&self) -> i32 {
        self.temperature.unwrap_or(10015i32)
    }

    pub fn clear_temperature(&mut self) {
        self.temperature = ::std::option::Option::None;
    }

    pub fn has_temperature(&self) -> bool {
        self.temperature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: i32) {
        self.temperature = ::std::option::Option::Some(v);
    }

    // optional bool flags = 2;

    pub fn flags(&self) -> bool {
        self.flags.unwrap_or(false)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: bool) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool reaction = 3;

    pub fn reaction(&self) -> bool {
        self.reaction.unwrap_or(false)
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: bool) {
        self.reaction = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "states",
            |m: &BasicMaterialInfoMask| { &m.states },
            |m: &mut BasicMaterialInfoMask| { &mut m.states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "temperature",
            |m: &BasicMaterialInfoMask| { &m.temperature },
            |m: &mut BasicMaterialInfoMask| { &mut m.temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &BasicMaterialInfoMask| { &m.flags },
            |m: &mut BasicMaterialInfoMask| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &BasicMaterialInfoMask| { &m.reaction },
            |m: &mut BasicMaterialInfoMask| { &mut m.reaction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicMaterialInfoMask>(
            "BasicMaterialInfoMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicMaterialInfoMask {
    const NAME: &'static str = "BasicMaterialInfoMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.states.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.states)?
                },
                32 => {
                    self.temperature = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.reaction = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.states {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        if let Some(v) = self.temperature {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.flags {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reaction {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.states {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.temperature {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.reaction {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicMaterialInfoMask {
        BasicMaterialInfoMask::new()
    }

    fn clear(&mut self) {
        self.states.clear();
        self.temperature = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicMaterialInfoMask {
        static instance: BasicMaterialInfoMask = BasicMaterialInfoMask {
            states: ::std::vec::Vec::new(),
            temperature: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BasicMaterialInfoMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicMaterialInfoMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicMaterialInfoMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicMaterialInfoMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BasicMaterialInfoMask`
pub mod basic_material_info_mask {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:dfproto.BasicMaterialInfoMask.StateType)
    pub enum StateType {
        // @@protoc_insertion_point(enum_value:dfproto.BasicMaterialInfoMask.StateType.Solid)
        Solid = 0,
        // @@protoc_insertion_point(enum_value:dfproto.BasicMaterialInfoMask.StateType.Liquid)
        Liquid = 1,
        // @@protoc_insertion_point(enum_value:dfproto.BasicMaterialInfoMask.StateType.Gas)
        Gas = 2,
        // @@protoc_insertion_point(enum_value:dfproto.BasicMaterialInfoMask.StateType.Powder)
        Powder = 3,
        // @@protoc_insertion_point(enum_value:dfproto.BasicMaterialInfoMask.StateType.Paste)
        Paste = 4,
        // @@protoc_insertion_point(enum_value:dfproto.BasicMaterialInfoMask.StateType.Pressed)
        Pressed = 5,
    }

    impl ::protobuf::Enum for StateType {
        const NAME: &'static str = "StateType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<StateType> {
            match value {
                0 => ::std::option::Option::Some(StateType::Solid),
                1 => ::std::option::Option::Some(StateType::Liquid),
                2 => ::std::option::Option::Some(StateType::Gas),
                3 => ::std::option::Option::Some(StateType::Powder),
                4 => ::std::option::Option::Some(StateType::Paste),
                5 => ::std::option::Option::Some(StateType::Pressed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<StateType> {
            match str {
                "Solid" => ::std::option::Option::Some(StateType::Solid),
                "Liquid" => ::std::option::Option::Some(StateType::Liquid),
                "Gas" => ::std::option::Option::Some(StateType::Gas),
                "Powder" => ::std::option::Option::Some(StateType::Powder),
                "Paste" => ::std::option::Option::Some(StateType::Paste),
                "Pressed" => ::std::option::Option::Some(StateType::Pressed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [StateType] = &[
            StateType::Solid,
            StateType::Liquid,
            StateType::Gas,
            StateType::Powder,
            StateType::Paste,
            StateType::Pressed,
        ];
    }

    impl ::protobuf::EnumFull for StateType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BasicMaterialInfoMask.StateType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for StateType {
        fn default() -> Self {
            StateType::Solid
        }
    }

    impl StateType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StateType>("BasicMaterialInfoMask.StateType")
        }
    }
}

// @@protoc_insertion_point(message:dfproto.JobSkillAttr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JobSkillAttr {
    // message fields
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.caption_noun)
    pub caption_noun: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.profession)
    pub profession: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.labor)
    pub labor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.JobSkillAttr.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.JobSkillAttr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JobSkillAttr {
    fn default() -> &'a JobSkillAttr {
        <JobSkillAttr as ::protobuf::Message>::default_instance()
    }
}

impl JobSkillAttr {
    pub fn new() -> JobSkillAttr {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption_noun = 4;

    pub fn caption_noun(&self) -> &str {
        match self.caption_noun.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption_noun(&mut self) {
        self.caption_noun = ::std::option::Option::None;
    }

    pub fn has_caption_noun(&self) -> bool {
        self.caption_noun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption_noun(&mut self, v: ::std::string::String) {
        self.caption_noun = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption_noun(&mut self) -> &mut ::std::string::String {
        if self.caption_noun.is_none() {
            self.caption_noun = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption_noun.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption_noun(&mut self) -> ::std::string::String {
        self.caption_noun.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 profession = 5;

    pub fn profession(&self) -> i32 {
        self.profession.unwrap_or(0)
    }

    pub fn clear_profession(&mut self) {
        self.profession = ::std::option::Option::None;
    }

    pub fn has_profession(&self) -> bool {
        self.profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: i32) {
        self.profession = ::std::option::Option::Some(v);
    }

    // optional int32 labor = 6;

    pub fn labor(&self) -> i32 {
        self.labor.unwrap_or(0)
    }

    pub fn clear_labor(&mut self) {
        self.labor = ::std::option::Option::None;
    }

    pub fn has_labor(&self) -> bool {
        self.labor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labor(&mut self, v: i32) {
        self.labor = ::std::option::Option::Some(v);
    }

    // optional string type = 7;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &JobSkillAttr| { &m.id },
            |m: &mut JobSkillAttr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &JobSkillAttr| { &m.key },
            |m: &mut JobSkillAttr| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &JobSkillAttr| { &m.caption },
            |m: &mut JobSkillAttr| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption_noun",
            |m: &JobSkillAttr| { &m.caption_noun },
            |m: &mut JobSkillAttr| { &mut m.caption_noun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "profession",
            |m: &JobSkillAttr| { &m.profession },
            |m: &mut JobSkillAttr| { &mut m.profession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labor",
            |m: &JobSkillAttr| { &m.labor },
            |m: &mut JobSkillAttr| { &mut m.labor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &JobSkillAttr| { &m.type_ },
            |m: &mut JobSkillAttr| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JobSkillAttr>(
            "JobSkillAttr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JobSkillAttr {
    const NAME: &'static str = "JobSkillAttr";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.caption_noun = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.profession = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.labor = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.caption_noun.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.profession {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.labor {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.caption_noun.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.profession {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.labor {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JobSkillAttr {
        JobSkillAttr::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.caption_noun = ::std::option::Option::None;
        self.profession = ::std::option::Option::None;
        self.labor = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JobSkillAttr {
        static instance: JobSkillAttr = JobSkillAttr {
            id: ::std::option::Option::None,
            key: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            caption_noun: ::std::option::Option::None,
            profession: ::std::option::Option::None,
            labor: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JobSkillAttr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JobSkillAttr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JobSkillAttr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobSkillAttr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.ProfessionAttr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProfessionAttr {
    // message fields
    // @@protoc_insertion_point(field:dfproto.ProfessionAttr.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.ProfessionAttr.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.ProfessionAttr.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.ProfessionAttr.military)
    pub military: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfproto.ProfessionAttr.can_assign_labor)
    pub can_assign_labor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfproto.ProfessionAttr.parent)
    pub parent: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.ProfessionAttr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProfessionAttr {
    fn default() -> &'a ProfessionAttr {
        <ProfessionAttr as ::protobuf::Message>::default_instance()
    }
}

impl ProfessionAttr {
    pub fn new() -> ProfessionAttr {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool military = 4;

    pub fn military(&self) -> bool {
        self.military.unwrap_or(false)
    }

    pub fn clear_military(&mut self) {
        self.military = ::std::option::Option::None;
    }

    pub fn has_military(&self) -> bool {
        self.military.is_some()
    }

    // Param is passed by value, moved
    pub fn set_military(&mut self, v: bool) {
        self.military = ::std::option::Option::Some(v);
    }

    // optional bool can_assign_labor = 5;

    pub fn can_assign_labor(&self) -> bool {
        self.can_assign_labor.unwrap_or(false)
    }

    pub fn clear_can_assign_labor(&mut self) {
        self.can_assign_labor = ::std::option::Option::None;
    }

    pub fn has_can_assign_labor(&self) -> bool {
        self.can_assign_labor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_assign_labor(&mut self, v: bool) {
        self.can_assign_labor = ::std::option::Option::Some(v);
    }

    // optional int32 parent = 6;

    pub fn parent(&self) -> i32 {
        self.parent.unwrap_or(0)
    }

    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: i32) {
        self.parent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ProfessionAttr| { &m.id },
            |m: &mut ProfessionAttr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &ProfessionAttr| { &m.key },
            |m: &mut ProfessionAttr| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &ProfessionAttr| { &m.caption },
            |m: &mut ProfessionAttr| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "military",
            |m: &ProfessionAttr| { &m.military },
            |m: &mut ProfessionAttr| { &mut m.military },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_assign_labor",
            |m: &ProfessionAttr| { &m.can_assign_labor },
            |m: &mut ProfessionAttr| { &mut m.can_assign_labor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &ProfessionAttr| { &m.parent },
            |m: &mut ProfessionAttr| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfessionAttr>(
            "ProfessionAttr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProfessionAttr {
    const NAME: &'static str = "ProfessionAttr";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.military = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.can_assign_labor = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.parent = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.military {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_assign_labor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.military {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_assign_labor {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.parent {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProfessionAttr {
        ProfessionAttr::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.military = ::std::option::Option::None;
        self.can_assign_labor = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProfessionAttr {
        static instance: ProfessionAttr = ProfessionAttr {
            id: ::std::option::Option::None,
            key: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            military: ::std::option::Option::None,
            can_assign_labor: ::std::option::Option::None,
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProfessionAttr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProfessionAttr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProfessionAttr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfessionAttr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.UnitLaborAttr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnitLaborAttr {
    // message fields
    // @@protoc_insertion_point(field:dfproto.UnitLaborAttr.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.UnitLaborAttr.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.UnitLaborAttr.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.UnitLaborAttr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitLaborAttr {
    fn default() -> &'a UnitLaborAttr {
        <UnitLaborAttr as ::protobuf::Message>::default_instance()
    }
}

impl UnitLaborAttr {
    pub fn new() -> UnitLaborAttr {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &UnitLaborAttr| { &m.id },
            |m: &mut UnitLaborAttr| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &UnitLaborAttr| { &m.key },
            |m: &mut UnitLaborAttr| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &UnitLaborAttr| { &m.caption },
            |m: &mut UnitLaborAttr| { &mut m.caption },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitLaborAttr>(
            "UnitLaborAttr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitLaborAttr {
    const NAME: &'static str = "UnitLaborAttr";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitLaborAttr {
        UnitLaborAttr::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitLaborAttr {
        static instance: UnitLaborAttr = UnitLaborAttr {
            id: ::std::option::Option::None,
            key: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitLaborAttr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitLaborAttr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitLaborAttr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitLaborAttr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.NameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NameInfo {
    // message fields
    // @@protoc_insertion_point(field:dfproto.NameInfo.first_name)
    pub first_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.NameInfo.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.NameInfo.language_id)
    pub language_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.NameInfo.last_name)
    pub last_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.NameInfo.english_name)
    pub english_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.NameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NameInfo {
    fn default() -> &'a NameInfo {
        <NameInfo as ::protobuf::Message>::default_instance()
    }
}

impl NameInfo {
    pub fn new() -> NameInfo {
        ::std::default::Default::default()
    }

    // optional string first_name = 1;

    pub fn first_name(&self) -> &str {
        match self.first_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_first_name(&mut self) {
        self.first_name = ::std::option::Option::None;
    }

    pub fn has_first_name(&self) -> bool {
        self.first_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        if self.first_name.is_none() {
            self.first_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.first_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        self.first_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nickname = 2;

    pub fn nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nickname(&mut self) {
        self.nickname = ::std::option::Option::None;
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language_id = 3;

    pub fn language_id(&self) -> i32 {
        self.language_id.unwrap_or(-1i32)
    }

    pub fn clear_language_id(&mut self) {
        self.language_id = ::std::option::Option::None;
    }

    pub fn has_language_id(&self) -> bool {
        self.language_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_id(&mut self, v: i32) {
        self.language_id = ::std::option::Option::Some(v);
    }

    // optional string last_name = 4;

    pub fn last_name(&self) -> &str {
        match self.last_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_name(&mut self) {
        self.last_name = ::std::option::Option::None;
    }

    pub fn has_last_name(&self) -> bool {
        self.last_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        if self.last_name.is_none() {
            self.last_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        self.last_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string english_name = 5;

    pub fn english_name(&self) -> &str {
        match self.english_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_english_name(&mut self) {
        self.english_name = ::std::option::Option::None;
    }

    pub fn has_english_name(&self) -> bool {
        self.english_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_english_name(&mut self, v: ::std::string::String) {
        self.english_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_english_name(&mut self) -> &mut ::std::string::String {
        if self.english_name.is_none() {
            self.english_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.english_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_english_name(&mut self) -> ::std::string::String {
        self.english_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_name",
            |m: &NameInfo| { &m.first_name },
            |m: &mut NameInfo| { &mut m.first_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nickname",
            |m: &NameInfo| { &m.nickname },
            |m: &mut NameInfo| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language_id",
            |m: &NameInfo| { &m.language_id },
            |m: &mut NameInfo| { &mut m.language_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_name",
            |m: &NameInfo| { &m.last_name },
            |m: &mut NameInfo| { &mut m.last_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "english_name",
            |m: &NameInfo| { &m.english_name },
            |m: &mut NameInfo| { &mut m.english_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NameInfo>(
            "NameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NameInfo {
    const NAME: &'static str = "NameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.first_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.language_id = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.last_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.english_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.first_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.last_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.english_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.first_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.last_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.english_name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NameInfo {
        NameInfo::new()
    }

    fn clear(&mut self) {
        self.first_name = ::std::option::Option::None;
        self.nickname = ::std::option::Option::None;
        self.language_id = ::std::option::Option::None;
        self.last_name = ::std::option::Option::None;
        self.english_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NameInfo {
        static instance: NameInfo = NameInfo {
            first_name: ::std::option::Option::None,
            nickname: ::std::option::Option::None,
            language_id: ::std::option::Option::None,
            last_name: ::std::option::Option::None,
            english_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.NameTriple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NameTriple {
    // message fields
    // @@protoc_insertion_point(field:dfproto.NameTriple.normal)
    pub normal: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.NameTriple.plural)
    pub plural: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.NameTriple.adjective)
    pub adjective: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.NameTriple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NameTriple {
    fn default() -> &'a NameTriple {
        <NameTriple as ::protobuf::Message>::default_instance()
    }
}

impl NameTriple {
    pub fn new() -> NameTriple {
        ::std::default::Default::default()
    }

    // required string normal = 1;

    pub fn normal(&self) -> &str {
        match self.normal.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_normal(&mut self) {
        self.normal = ::std::option::Option::None;
    }

    pub fn has_normal(&self) -> bool {
        self.normal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal(&mut self, v: ::std::string::String) {
        self.normal = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normal(&mut self) -> &mut ::std::string::String {
        if self.normal.is_none() {
            self.normal = ::std::option::Option::Some(::std::string::String::new());
        }
        self.normal.as_mut().unwrap()
    }

    // Take field
    pub fn take_normal(&mut self) -> ::std::string::String {
        self.normal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string plural = 2;

    pub fn plural(&self) -> &str {
        match self.plural.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_plural(&mut self) {
        self.plural = ::std::option::Option::None;
    }

    pub fn has_plural(&self) -> bool {
        self.plural.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plural(&mut self, v: ::std::string::String) {
        self.plural = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plural(&mut self) -> &mut ::std::string::String {
        if self.plural.is_none() {
            self.plural = ::std::option::Option::Some(::std::string::String::new());
        }
        self.plural.as_mut().unwrap()
    }

    // Take field
    pub fn take_plural(&mut self) -> ::std::string::String {
        self.plural.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string adjective = 3;

    pub fn adjective(&self) -> &str {
        match self.adjective.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_adjective(&mut self) {
        self.adjective = ::std::option::Option::None;
    }

    pub fn has_adjective(&self) -> bool {
        self.adjective.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjective(&mut self, v: ::std::string::String) {
        self.adjective = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjective(&mut self) -> &mut ::std::string::String {
        if self.adjective.is_none() {
            self.adjective = ::std::option::Option::Some(::std::string::String::new());
        }
        self.adjective.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjective(&mut self) -> ::std::string::String {
        self.adjective.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "normal",
            |m: &NameTriple| { &m.normal },
            |m: &mut NameTriple| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plural",
            |m: &NameTriple| { &m.plural },
            |m: &mut NameTriple| { &mut m.plural },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adjective",
            |m: &NameTriple| { &m.adjective },
            |m: &mut NameTriple| { &mut m.adjective },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NameTriple>(
            "NameTriple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NameTriple {
    const NAME: &'static str = "NameTriple";

    fn is_initialized(&self) -> bool {
        if self.normal.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.normal = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.plural = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.adjective = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.normal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.plural.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.adjective.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.normal.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.plural.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.adjective.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NameTriple {
        NameTriple::new()
    }

    fn clear(&mut self) {
        self.normal = ::std::option::Option::None;
        self.plural = ::std::option::Option::None;
        self.adjective = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NameTriple {
        static instance: NameTriple = NameTriple {
            normal: ::std::option::Option::None,
            plural: ::std::option::Option::None,
            adjective: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NameTriple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NameTriple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NameTriple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameTriple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.UnitCurseInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnitCurseInfo {
    // message fields
    // @@protoc_insertion_point(field:dfproto.UnitCurseInfo.add_tags1)
    pub add_tags1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.UnitCurseInfo.rem_tags1)
    pub rem_tags1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.UnitCurseInfo.add_tags2)
    pub add_tags2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.UnitCurseInfo.rem_tags2)
    pub rem_tags2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.UnitCurseInfo.name)
    pub name: ::protobuf::MessageField<NameTriple>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.UnitCurseInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitCurseInfo {
    fn default() -> &'a UnitCurseInfo {
        <UnitCurseInfo as ::protobuf::Message>::default_instance()
    }
}

impl UnitCurseInfo {
    pub fn new() -> UnitCurseInfo {
        ::std::default::Default::default()
    }

    // required fixed32 add_tags1 = 1;

    pub fn add_tags1(&self) -> u32 {
        self.add_tags1.unwrap_or(0)
    }

    pub fn clear_add_tags1(&mut self) {
        self.add_tags1 = ::std::option::Option::None;
    }

    pub fn has_add_tags1(&self) -> bool {
        self.add_tags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_tags1(&mut self, v: u32) {
        self.add_tags1 = ::std::option::Option::Some(v);
    }

    // required fixed32 rem_tags1 = 2;

    pub fn rem_tags1(&self) -> u32 {
        self.rem_tags1.unwrap_or(0)
    }

    pub fn clear_rem_tags1(&mut self) {
        self.rem_tags1 = ::std::option::Option::None;
    }

    pub fn has_rem_tags1(&self) -> bool {
        self.rem_tags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rem_tags1(&mut self, v: u32) {
        self.rem_tags1 = ::std::option::Option::Some(v);
    }

    // required fixed32 add_tags2 = 3;

    pub fn add_tags2(&self) -> u32 {
        self.add_tags2.unwrap_or(0)
    }

    pub fn clear_add_tags2(&mut self) {
        self.add_tags2 = ::std::option::Option::None;
    }

    pub fn has_add_tags2(&self) -> bool {
        self.add_tags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_tags2(&mut self, v: u32) {
        self.add_tags2 = ::std::option::Option::Some(v);
    }

    // required fixed32 rem_tags2 = 4;

    pub fn rem_tags2(&self) -> u32 {
        self.rem_tags2.unwrap_or(0)
    }

    pub fn clear_rem_tags2(&mut self) {
        self.rem_tags2 = ::std::option::Option::None;
    }

    pub fn has_rem_tags2(&self) -> bool {
        self.rem_tags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rem_tags2(&mut self, v: u32) {
        self.rem_tags2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_tags1",
            |m: &UnitCurseInfo| { &m.add_tags1 },
            |m: &mut UnitCurseInfo| { &mut m.add_tags1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rem_tags1",
            |m: &UnitCurseInfo| { &m.rem_tags1 },
            |m: &mut UnitCurseInfo| { &mut m.rem_tags1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_tags2",
            |m: &UnitCurseInfo| { &m.add_tags2 },
            |m: &mut UnitCurseInfo| { &mut m.add_tags2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rem_tags2",
            |m: &UnitCurseInfo| { &m.rem_tags2 },
            |m: &mut UnitCurseInfo| { &mut m.rem_tags2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NameTriple>(
            "name",
            |m: &UnitCurseInfo| { &m.name },
            |m: &mut UnitCurseInfo| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitCurseInfo>(
            "UnitCurseInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitCurseInfo {
    const NAME: &'static str = "UnitCurseInfo";

    fn is_initialized(&self) -> bool {
        if self.add_tags1.is_none() {
            return false;
        }
        if self.rem_tags1.is_none() {
            return false;
        }
        if self.add_tags2.is_none() {
            return false;
        }
        if self.rem_tags2.is_none() {
            return false;
        }
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.add_tags1 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.rem_tags1 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.add_tags2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.rem_tags2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.add_tags1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rem_tags1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.add_tags2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rem_tags2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.add_tags1 {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.rem_tags1 {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.add_tags2 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.rem_tags2 {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitCurseInfo {
        UnitCurseInfo::new()
    }

    fn clear(&mut self) {
        self.add_tags1 = ::std::option::Option::None;
        self.rem_tags1 = ::std::option::Option::None;
        self.add_tags2 = ::std::option::Option::None;
        self.rem_tags2 = ::std::option::Option::None;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitCurseInfo {
        static instance: UnitCurseInfo = UnitCurseInfo {
            add_tags1: ::std::option::Option::None,
            rem_tags1: ::std::option::Option::None,
            add_tags2: ::std::option::Option::None,
            rem_tags2: ::std::option::Option::None,
            name: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitCurseInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitCurseInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitCurseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitCurseInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.SkillInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SkillInfo {
    // message fields
    // @@protoc_insertion_point(field:dfproto.SkillInfo.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.SkillInfo.level)
    pub level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.SkillInfo.experience)
    pub experience: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.SkillInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SkillInfo {
    fn default() -> &'a SkillInfo {
        <SkillInfo as ::protobuf::Message>::default_instance()
    }
}

impl SkillInfo {
    pub fn new() -> SkillInfo {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required int32 level = 2;

    pub fn level(&self) -> i32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = ::std::option::Option::Some(v);
    }

    // required int32 experience = 3;

    pub fn experience(&self) -> i32 {
        self.experience.unwrap_or(0)
    }

    pub fn clear_experience(&mut self) {
        self.experience = ::std::option::Option::None;
    }

    pub fn has_experience(&self) -> bool {
        self.experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience(&mut self, v: i32) {
        self.experience = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &SkillInfo| { &m.id },
            |m: &mut SkillInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &SkillInfo| { &m.level },
            |m: &mut SkillInfo| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experience",
            |m: &SkillInfo| { &m.experience },
            |m: &mut SkillInfo| { &mut m.experience },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SkillInfo>(
            "SkillInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SkillInfo {
    const NAME: &'static str = "SkillInfo";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.level.is_none() {
            return false;
        }
        if self.experience.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.level = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.experience = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.experience {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.level {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.experience {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SkillInfo {
        SkillInfo::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.experience = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SkillInfo {
        static instance: SkillInfo = SkillInfo {
            id: ::std::option::Option::None,
            level: ::std::option::Option::None,
            experience: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SkillInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SkillInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SkillInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SkillInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.UnitMiscTrait)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnitMiscTrait {
    // message fields
    // @@protoc_insertion_point(field:dfproto.UnitMiscTrait.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.UnitMiscTrait.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.UnitMiscTrait.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitMiscTrait {
    fn default() -> &'a UnitMiscTrait {
        <UnitMiscTrait as ::protobuf::Message>::default_instance()
    }
}

impl UnitMiscTrait {
    pub fn new() -> UnitMiscTrait {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required int32 value = 2;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &UnitMiscTrait| { &m.id },
            |m: &mut UnitMiscTrait| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &UnitMiscTrait| { &m.value },
            |m: &mut UnitMiscTrait| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitMiscTrait>(
            "UnitMiscTrait",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitMiscTrait {
    const NAME: &'static str = "UnitMiscTrait";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitMiscTrait {
        UnitMiscTrait::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitMiscTrait {
        static instance: UnitMiscTrait = UnitMiscTrait {
            id: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitMiscTrait {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitMiscTrait").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitMiscTrait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitMiscTrait {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.BasicUnitInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicUnitInfo {
    // message fields
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.unit_id)
    pub unit_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.pos_x)
    pub pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.pos_y)
    pub pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.pos_z)
    pub pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.name)
    pub name: ::protobuf::MessageField<NameInfo>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.flags1)
    pub flags1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.flags2)
    pub flags2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.flags3)
    pub flags3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.race)
    pub race: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.caste)
    pub caste: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.gender)
    pub gender: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.civ_id)
    pub civ_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.histfig_id)
    pub histfig_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.death_id)
    pub death_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.death_flags)
    pub death_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.squad_id)
    pub squad_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.squad_position)
    pub squad_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.profession)
    pub profession: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.custom_profession)
    pub custom_profession: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.labors)
    pub labors: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.skills)
    pub skills: ::std::vec::Vec<SkillInfo>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.misc_traits)
    pub misc_traits: ::std::vec::Vec<UnitMiscTrait>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.curse)
    pub curse: ::protobuf::MessageField<UnitCurseInfo>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfo.burrows)
    pub burrows: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.BasicUnitInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicUnitInfo {
    fn default() -> &'a BasicUnitInfo {
        <BasicUnitInfo as ::protobuf::Message>::default_instance()
    }
}

impl BasicUnitInfo {
    pub fn new() -> BasicUnitInfo {
        ::std::default::Default::default()
    }

    // required int32 unit_id = 1;

    pub fn unit_id(&self) -> i32 {
        self.unit_id.unwrap_or(0)
    }

    pub fn clear_unit_id(&mut self) {
        self.unit_id = ::std::option::Option::None;
    }

    pub fn has_unit_id(&self) -> bool {
        self.unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_id(&mut self, v: i32) {
        self.unit_id = ::std::option::Option::Some(v);
    }

    // required int32 pos_x = 13;

    pub fn pos_x(&self) -> i32 {
        self.pos_x.unwrap_or(0)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: i32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // required int32 pos_y = 14;

    pub fn pos_y(&self) -> i32 {
        self.pos_y.unwrap_or(0)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: i32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // required int32 pos_z = 15;

    pub fn pos_z(&self) -> i32 {
        self.pos_z.unwrap_or(0)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: i32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // required fixed32 flags1 = 3;

    pub fn flags1(&self) -> u32 {
        self.flags1.unwrap_or(0)
    }

    pub fn clear_flags1(&mut self) {
        self.flags1 = ::std::option::Option::None;
    }

    pub fn has_flags1(&self) -> bool {
        self.flags1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags1(&mut self, v: u32) {
        self.flags1 = ::std::option::Option::Some(v);
    }

    // required fixed32 flags2 = 4;

    pub fn flags2(&self) -> u32 {
        self.flags2.unwrap_or(0)
    }

    pub fn clear_flags2(&mut self) {
        self.flags2 = ::std::option::Option::None;
    }

    pub fn has_flags2(&self) -> bool {
        self.flags2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags2(&mut self, v: u32) {
        self.flags2 = ::std::option::Option::Some(v);
    }

    // required fixed32 flags3 = 5;

    pub fn flags3(&self) -> u32 {
        self.flags3.unwrap_or(0)
    }

    pub fn clear_flags3(&mut self) {
        self.flags3 = ::std::option::Option::None;
    }

    pub fn has_flags3(&self) -> bool {
        self.flags3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags3(&mut self, v: u32) {
        self.flags3 = ::std::option::Option::Some(v);
    }

    // required int32 race = 6;

    pub fn race(&self) -> i32 {
        self.race.unwrap_or(0)
    }

    pub fn clear_race(&mut self) {
        self.race = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        self.race.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: i32) {
        self.race = ::std::option::Option::Some(v);
    }

    // required int32 caste = 7;

    pub fn caste(&self) -> i32 {
        self.caste.unwrap_or(0)
    }

    pub fn clear_caste(&mut self) {
        self.caste = ::std::option::Option::None;
    }

    pub fn has_caste(&self) -> bool {
        self.caste.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caste(&mut self, v: i32) {
        self.caste = ::std::option::Option::Some(v);
    }

    // optional int32 gender = 8;

    pub fn gender(&self) -> i32 {
        self.gender.unwrap_or(-1i32)
    }

    pub fn clear_gender(&mut self) {
        self.gender = ::std::option::Option::None;
    }

    pub fn has_gender(&self) -> bool {
        self.gender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: i32) {
        self.gender = ::std::option::Option::Some(v);
    }

    // optional int32 civ_id = 9;

    pub fn civ_id(&self) -> i32 {
        self.civ_id.unwrap_or(-1i32)
    }

    pub fn clear_civ_id(&mut self) {
        self.civ_id = ::std::option::Option::None;
    }

    pub fn has_civ_id(&self) -> bool {
        self.civ_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_civ_id(&mut self, v: i32) {
        self.civ_id = ::std::option::Option::Some(v);
    }

    // optional int32 histfig_id = 10;

    pub fn histfig_id(&self) -> i32 {
        self.histfig_id.unwrap_or(-1i32)
    }

    pub fn clear_histfig_id(&mut self) {
        self.histfig_id = ::std::option::Option::None;
    }

    pub fn has_histfig_id(&self) -> bool {
        self.histfig_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_histfig_id(&mut self, v: i32) {
        self.histfig_id = ::std::option::Option::Some(v);
    }

    // optional int32 death_id = 17;

    pub fn death_id(&self) -> i32 {
        self.death_id.unwrap_or(-1i32)
    }

    pub fn clear_death_id(&mut self) {
        self.death_id = ::std::option::Option::None;
    }

    pub fn has_death_id(&self) -> bool {
        self.death_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_id(&mut self, v: i32) {
        self.death_id = ::std::option::Option::Some(v);
    }

    // optional uint32 death_flags = 18;

    pub fn death_flags(&self) -> u32 {
        self.death_flags.unwrap_or(0)
    }

    pub fn clear_death_flags(&mut self) {
        self.death_flags = ::std::option::Option::None;
    }

    pub fn has_death_flags(&self) -> bool {
        self.death_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_flags(&mut self, v: u32) {
        self.death_flags = ::std::option::Option::Some(v);
    }

    // optional int32 squad_id = 19;

    pub fn squad_id(&self) -> i32 {
        self.squad_id.unwrap_or(-1i32)
    }

    pub fn clear_squad_id(&mut self) {
        self.squad_id = ::std::option::Option::None;
    }

    pub fn has_squad_id(&self) -> bool {
        self.squad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_id(&mut self, v: i32) {
        self.squad_id = ::std::option::Option::Some(v);
    }

    // optional int32 squad_position = 20;

    pub fn squad_position(&self) -> i32 {
        self.squad_position.unwrap_or(-1i32)
    }

    pub fn clear_squad_position(&mut self) {
        self.squad_position = ::std::option::Option::None;
    }

    pub fn has_squad_position(&self) -> bool {
        self.squad_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_position(&mut self, v: i32) {
        self.squad_position = ::std::option::Option::Some(v);
    }

    // optional int32 profession = 22;

    pub fn profession(&self) -> i32 {
        self.profession.unwrap_or(-1i32)
    }

    pub fn clear_profession(&mut self) {
        self.profession = ::std::option::Option::None;
    }

    pub fn has_profession(&self) -> bool {
        self.profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: i32) {
        self.profession = ::std::option::Option::Some(v);
    }

    // optional string custom_profession = 23;

    pub fn custom_profession(&self) -> &str {
        match self.custom_profession.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_profession(&mut self) {
        self.custom_profession = ::std::option::Option::None;
    }

    pub fn has_custom_profession(&self) -> bool {
        self.custom_profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_profession(&mut self, v: ::std::string::String) {
        self.custom_profession = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_profession(&mut self) -> &mut ::std::string::String {
        if self.custom_profession.is_none() {
            self.custom_profession = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_profession.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_profession(&mut self) -> ::std::string::String {
        self.custom_profession.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_id",
            |m: &BasicUnitInfo| { &m.unit_id },
            |m: &mut BasicUnitInfo| { &mut m.unit_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &BasicUnitInfo| { &m.pos_x },
            |m: &mut BasicUnitInfo| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &BasicUnitInfo| { &m.pos_y },
            |m: &mut BasicUnitInfo| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &BasicUnitInfo| { &m.pos_z },
            |m: &mut BasicUnitInfo| { &mut m.pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NameInfo>(
            "name",
            |m: &BasicUnitInfo| { &m.name },
            |m: &mut BasicUnitInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags1",
            |m: &BasicUnitInfo| { &m.flags1 },
            |m: &mut BasicUnitInfo| { &mut m.flags1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags2",
            |m: &BasicUnitInfo| { &m.flags2 },
            |m: &mut BasicUnitInfo| { &mut m.flags2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags3",
            |m: &BasicUnitInfo| { &m.flags3 },
            |m: &mut BasicUnitInfo| { &mut m.flags3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "race",
            |m: &BasicUnitInfo| { &m.race },
            |m: &mut BasicUnitInfo| { &mut m.race },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caste",
            |m: &BasicUnitInfo| { &m.caste },
            |m: &mut BasicUnitInfo| { &mut m.caste },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gender",
            |m: &BasicUnitInfo| { &m.gender },
            |m: &mut BasicUnitInfo| { &mut m.gender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "civ_id",
            |m: &BasicUnitInfo| { &m.civ_id },
            |m: &mut BasicUnitInfo| { &mut m.civ_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "histfig_id",
            |m: &BasicUnitInfo| { &m.histfig_id },
            |m: &mut BasicUnitInfo| { &mut m.histfig_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "death_id",
            |m: &BasicUnitInfo| { &m.death_id },
            |m: &mut BasicUnitInfo| { &mut m.death_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "death_flags",
            |m: &BasicUnitInfo| { &m.death_flags },
            |m: &mut BasicUnitInfo| { &mut m.death_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "squad_id",
            |m: &BasicUnitInfo| { &m.squad_id },
            |m: &mut BasicUnitInfo| { &mut m.squad_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "squad_position",
            |m: &BasicUnitInfo| { &m.squad_position },
            |m: &mut BasicUnitInfo| { &mut m.squad_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "profession",
            |m: &BasicUnitInfo| { &m.profession },
            |m: &mut BasicUnitInfo| { &mut m.profession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_profession",
            |m: &BasicUnitInfo| { &m.custom_profession },
            |m: &mut BasicUnitInfo| { &mut m.custom_profession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labors",
            |m: &BasicUnitInfo| { &m.labors },
            |m: &mut BasicUnitInfo| { &mut m.labors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skills",
            |m: &BasicUnitInfo| { &m.skills },
            |m: &mut BasicUnitInfo| { &mut m.skills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "misc_traits",
            |m: &BasicUnitInfo| { &m.misc_traits },
            |m: &mut BasicUnitInfo| { &mut m.misc_traits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitCurseInfo>(
            "curse",
            |m: &BasicUnitInfo| { &m.curse },
            |m: &mut BasicUnitInfo| { &mut m.curse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "burrows",
            |m: &BasicUnitInfo| { &m.burrows },
            |m: &mut BasicUnitInfo| { &mut m.burrows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicUnitInfo>(
            "BasicUnitInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicUnitInfo {
    const NAME: &'static str = "BasicUnitInfo";

    fn is_initialized(&self) -> bool {
        if self.unit_id.is_none() {
            return false;
        }
        if self.pos_x.is_none() {
            return false;
        }
        if self.pos_y.is_none() {
            return false;
        }
        if self.pos_z.is_none() {
            return false;
        }
        if self.flags1.is_none() {
            return false;
        }
        if self.flags2.is_none() {
            return false;
        }
        if self.flags3.is_none() {
            return false;
        }
        if self.race.is_none() {
            return false;
        }
        if self.caste.is_none() {
            return false;
        }
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.skills {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.misc_traits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.curse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_id = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name)?;
                },
                29 => {
                    self.flags1 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.flags2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.flags3 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.race = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.caste = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.gender = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.civ_id = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.histfig_id = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.death_id = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.death_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.squad_id = ::std::option::Option::Some(is.read_int32()?);
                },
                160 => {
                    self.squad_position = ::std::option::Option::Some(is.read_int32()?);
                },
                176 => {
                    self.profession = ::std::option::Option::Some(is.read_int32()?);
                },
                186 => {
                    self.custom_profession = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.labors)?;
                },
                88 => {
                    self.labors.push(is.read_int32()?);
                },
                98 => {
                    self.skills.push(is.read_message()?);
                },
                194 => {
                    self.misc_traits.push(is.read_message()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.curse)?;
                },
                170 => {
                    is.read_repeated_packed_int32_into(&mut self.burrows)?;
                },
                168 => {
                    self.burrows.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.pos_y {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.pos_z {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flags1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.flags2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.flags3 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.race {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.caste {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.gender {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.civ_id {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.histfig_id {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.death_id {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.death_flags {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.squad_id {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        if let Some(v) = self.squad_position {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.profession {
            my_size += ::protobuf::rt::int32_size(22, v);
        }
        if let Some(v) = self.custom_profession.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        for value in &self.labors {
            my_size += ::protobuf::rt::int32_size(11, *value);
        };
        for value in &self.skills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.misc_traits {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.curse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.burrows {
            my_size += ::protobuf::rt::int32_size(21, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.flags1 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.flags2 {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.flags3 {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.race {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.caste {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.gender {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.civ_id {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.histfig_id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.death_id {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.death_flags {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.squad_id {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.squad_position {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.profession {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.custom_profession.as_ref() {
            os.write_string(23, v)?;
        }
        for v in &self.labors {
            os.write_int32(11, *v)?;
        };
        for v in &self.skills {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.misc_traits {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        if let Some(v) = self.curse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        for v in &self.burrows {
            os.write_int32(21, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicUnitInfo {
        BasicUnitInfo::new()
    }

    fn clear(&mut self) {
        self.unit_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.name.clear();
        self.flags1 = ::std::option::Option::None;
        self.flags2 = ::std::option::Option::None;
        self.flags3 = ::std::option::Option::None;
        self.race = ::std::option::Option::None;
        self.caste = ::std::option::Option::None;
        self.gender = ::std::option::Option::None;
        self.civ_id = ::std::option::Option::None;
        self.histfig_id = ::std::option::Option::None;
        self.death_id = ::std::option::Option::None;
        self.death_flags = ::std::option::Option::None;
        self.squad_id = ::std::option::Option::None;
        self.squad_position = ::std::option::Option::None;
        self.profession = ::std::option::Option::None;
        self.custom_profession = ::std::option::Option::None;
        self.labors.clear();
        self.skills.clear();
        self.misc_traits.clear();
        self.curse.clear();
        self.burrows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicUnitInfo {
        static instance: BasicUnitInfo = BasicUnitInfo {
            unit_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            name: ::protobuf::MessageField::none(),
            flags1: ::std::option::Option::None,
            flags2: ::std::option::Option::None,
            flags3: ::std::option::Option::None,
            race: ::std::option::Option::None,
            caste: ::std::option::Option::None,
            gender: ::std::option::Option::None,
            civ_id: ::std::option::Option::None,
            histfig_id: ::std::option::Option::None,
            death_id: ::std::option::Option::None,
            death_flags: ::std::option::Option::None,
            squad_id: ::std::option::Option::None,
            squad_position: ::std::option::Option::None,
            profession: ::std::option::Option::None,
            custom_profession: ::std::option::Option::None,
            labors: ::std::vec::Vec::new(),
            skills: ::std::vec::Vec::new(),
            misc_traits: ::std::vec::Vec::new(),
            curse: ::protobuf::MessageField::none(),
            burrows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BasicUnitInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicUnitInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicUnitInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicUnitInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.BasicUnitInfoMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicUnitInfoMask {
    // message fields
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfoMask.labors)
    pub labors: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfoMask.skills)
    pub skills: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfoMask.profession)
    pub profession: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dfproto.BasicUnitInfoMask.misc_traits)
    pub misc_traits: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.BasicUnitInfoMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicUnitInfoMask {
    fn default() -> &'a BasicUnitInfoMask {
        <BasicUnitInfoMask as ::protobuf::Message>::default_instance()
    }
}

impl BasicUnitInfoMask {
    pub fn new() -> BasicUnitInfoMask {
        ::std::default::Default::default()
    }

    // optional bool labors = 1;

    pub fn labors(&self) -> bool {
        self.labors.unwrap_or(false)
    }

    pub fn clear_labors(&mut self) {
        self.labors = ::std::option::Option::None;
    }

    pub fn has_labors(&self) -> bool {
        self.labors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labors(&mut self, v: bool) {
        self.labors = ::std::option::Option::Some(v);
    }

    // optional bool skills = 2;

    pub fn skills(&self) -> bool {
        self.skills.unwrap_or(false)
    }

    pub fn clear_skills(&mut self) {
        self.skills = ::std::option::Option::None;
    }

    pub fn has_skills(&self) -> bool {
        self.skills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skills(&mut self, v: bool) {
        self.skills = ::std::option::Option::Some(v);
    }

    // optional bool profession = 3;

    pub fn profession(&self) -> bool {
        self.profession.unwrap_or(false)
    }

    pub fn clear_profession(&mut self) {
        self.profession = ::std::option::Option::None;
    }

    pub fn has_profession(&self) -> bool {
        self.profession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profession(&mut self, v: bool) {
        self.profession = ::std::option::Option::Some(v);
    }

    // optional bool misc_traits = 4;

    pub fn misc_traits(&self) -> bool {
        self.misc_traits.unwrap_or(false)
    }

    pub fn clear_misc_traits(&mut self) {
        self.misc_traits = ::std::option::Option::None;
    }

    pub fn has_misc_traits(&self) -> bool {
        self.misc_traits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_misc_traits(&mut self, v: bool) {
        self.misc_traits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labors",
            |m: &BasicUnitInfoMask| { &m.labors },
            |m: &mut BasicUnitInfoMask| { &mut m.labors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skills",
            |m: &BasicUnitInfoMask| { &m.skills },
            |m: &mut BasicUnitInfoMask| { &mut m.skills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "profession",
            |m: &BasicUnitInfoMask| { &m.profession },
            |m: &mut BasicUnitInfoMask| { &mut m.profession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "misc_traits",
            |m: &BasicUnitInfoMask| { &m.misc_traits },
            |m: &mut BasicUnitInfoMask| { &mut m.misc_traits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicUnitInfoMask>(
            "BasicUnitInfoMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicUnitInfoMask {
    const NAME: &'static str = "BasicUnitInfoMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.labors = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.skills = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.profession = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.misc_traits = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labors {
            my_size += 1 + 1;
        }
        if let Some(v) = self.skills {
            my_size += 1 + 1;
        }
        if let Some(v) = self.profession {
            my_size += 1 + 1;
        }
        if let Some(v) = self.misc_traits {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labors {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.skills {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.profession {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.misc_traits {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicUnitInfoMask {
        BasicUnitInfoMask::new()
    }

    fn clear(&mut self) {
        self.labors = ::std::option::Option::None;
        self.skills = ::std::option::Option::None;
        self.profession = ::std::option::Option::None;
        self.misc_traits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicUnitInfoMask {
        static instance: BasicUnitInfoMask = BasicUnitInfoMask {
            labors: ::std::option::Option::None,
            skills: ::std::option::Option::None,
            profession: ::std::option::Option::None,
            misc_traits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BasicUnitInfoMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicUnitInfoMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicUnitInfoMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicUnitInfoMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.BasicSquadInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicSquadInfo {
    // message fields
    // @@protoc_insertion_point(field:dfproto.BasicSquadInfo.squad_id)
    pub squad_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.BasicSquadInfo.name)
    pub name: ::protobuf::MessageField<NameInfo>,
    // @@protoc_insertion_point(field:dfproto.BasicSquadInfo.alias)
    pub alias: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dfproto.BasicSquadInfo.members)
    pub members: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.BasicSquadInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicSquadInfo {
    fn default() -> &'a BasicSquadInfo {
        <BasicSquadInfo as ::protobuf::Message>::default_instance()
    }
}

impl BasicSquadInfo {
    pub fn new() -> BasicSquadInfo {
        ::std::default::Default::default()
    }

    // required int32 squad_id = 1;

    pub fn squad_id(&self) -> i32 {
        self.squad_id.unwrap_or(0)
    }

    pub fn clear_squad_id(&mut self) {
        self.squad_id = ::std::option::Option::None;
    }

    pub fn has_squad_id(&self) -> bool {
        self.squad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_id(&mut self, v: i32) {
        self.squad_id = ::std::option::Option::Some(v);
    }

    // optional string alias = 3;

    pub fn alias(&self) -> &str {
        match self.alias.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_alias(&mut self) {
        self.alias = ::std::option::Option::None;
    }

    pub fn has_alias(&self) -> bool {
        self.alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        if self.alias.is_none() {
            self.alias = ::std::option::Option::Some(::std::string::String::new());
        }
        self.alias.as_mut().unwrap()
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        self.alias.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "squad_id",
            |m: &BasicSquadInfo| { &m.squad_id },
            |m: &mut BasicSquadInfo| { &mut m.squad_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NameInfo>(
            "name",
            |m: &BasicSquadInfo| { &m.name },
            |m: &mut BasicSquadInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alias",
            |m: &BasicSquadInfo| { &m.alias },
            |m: &mut BasicSquadInfo| { &mut m.alias },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &BasicSquadInfo| { &m.members },
            |m: &mut BasicSquadInfo| { &mut m.members },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicSquadInfo>(
            "BasicSquadInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicSquadInfo {
    const NAME: &'static str = "BasicSquadInfo";

    fn is_initialized(&self) -> bool {
        if self.squad_id.is_none() {
            return false;
        }
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.squad_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name)?;
                },
                26 => {
                    self.alias = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_sint32_into(&mut self.members)?;
                },
                32 => {
                    self.members.push(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.squad_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.alias.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.members {
            my_size += ::protobuf::rt::sint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.squad_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.alias.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.members {
            os.write_sint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicSquadInfo {
        BasicSquadInfo::new()
    }

    fn clear(&mut self) {
        self.squad_id = ::std::option::Option::None;
        self.name.clear();
        self.alias = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicSquadInfo {
        static instance: BasicSquadInfo = BasicSquadInfo {
            squad_id: ::std::option::Option::None,
            name: ::protobuf::MessageField::none(),
            alias: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BasicSquadInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicSquadInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicSquadInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicSquadInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dfproto.UnitLaborState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnitLaborState {
    // message fields
    // @@protoc_insertion_point(field:dfproto.UnitLaborState.unit_id)
    pub unit_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.UnitLaborState.labor)
    pub labor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:dfproto.UnitLaborState.value)
    pub value: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:dfproto.UnitLaborState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitLaborState {
    fn default() -> &'a UnitLaborState {
        <UnitLaborState as ::protobuf::Message>::default_instance()
    }
}

impl UnitLaborState {
    pub fn new() -> UnitLaborState {
        ::std::default::Default::default()
    }

    // required int32 unit_id = 1;

    pub fn unit_id(&self) -> i32 {
        self.unit_id.unwrap_or(0)
    }

    pub fn clear_unit_id(&mut self) {
        self.unit_id = ::std::option::Option::None;
    }

    pub fn has_unit_id(&self) -> bool {
        self.unit_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_id(&mut self, v: i32) {
        self.unit_id = ::std::option::Option::Some(v);
    }

    // required int32 labor = 2;

    pub fn labor(&self) -> i32 {
        self.labor.unwrap_or(0)
    }

    pub fn clear_labor(&mut self) {
        self.labor = ::std::option::Option::None;
    }

    pub fn has_labor(&self) -> bool {
        self.labor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labor(&mut self, v: i32) {
        self.labor = ::std::option::Option::Some(v);
    }

    // required bool value = 3;

    pub fn value(&self) -> bool {
        self.value.unwrap_or(false)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_id",
            |m: &UnitLaborState| { &m.unit_id },
            |m: &mut UnitLaborState| { &mut m.unit_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labor",
            |m: &UnitLaborState| { &m.labor },
            |m: &mut UnitLaborState| { &mut m.labor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &UnitLaborState| { &m.value },
            |m: &mut UnitLaborState| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitLaborState>(
            "UnitLaborState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitLaborState {
    const NAME: &'static str = "UnitLaborState";

    fn is_initialized(&self) -> bool {
        if self.unit_id.is_none() {
            return false;
        }
        if self.labor.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.labor = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.value = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.labor {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.labor {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitLaborState {
        UnitLaborState::new()
    }

    fn clear(&mut self) {
        self.unit_id = ::std::option::Option::None;
        self.labor = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitLaborState {
        static instance: UnitLaborState = UnitLaborState {
            unit_id: ::std::option::Option::None,
            labor: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitLaborState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitLaborState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitLaborState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitLaborState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bBasic.proto\x12\x07dfproto\"X\n\x0cEnumItemName\x12\x14\n\x05value\
    \x18\x01\x20\x02(\x05R\x05value\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x1e\n\x08bit_size\x18\x03\x20\x01(\x05:\x011R\x07bitSizeB\0\
    \";\n\x0fBasicMaterialId\x12\x12\n\x04type\x18\x01\x20\x02(\x05R\x04type\
    \x12\x14\n\x05index\x18\x02\x20\x02(\x11R\x05index\"\xdc\x04\n\x11BasicM\
    aterialInfo\x12\x12\n\x04type\x18\x01\x20\x02(\x05R\x04type\x12\x14\n\
    \x05index\x18\x02\x20\x02(\x11R\x05index\x12\x14\n\x05token\x18\x03\x20\
    \x02(\tR\x05token\x12\x14\n\x05flags\x18\x04\x20\x03(\x05R\x05flags\x12\
    \x1e\n\x07subtype\x18\x05\x20\x01(\x05:\x02-1R\x07subtypeB\0\x12%\n\x0bc\
    reature_id\x18\x06\x20\x01(\x05:\x02-1R\ncreatureIdB\0\x12\x1f\n\x08plan\
    t_id\x18\x07\x20\x01(\x05:\x02-1R\x07plantIdB\0\x12#\n\nhistfig_id\x18\
    \x08\x20\x01(\x05:\x02-1R\thistfigIdB\0\x12#\n\x0bname_prefix\x18\t\x20\
    \x01(\t:\0R\nnamePrefixB\0\x12\x1f\n\x0bstate_color\x18\n\x20\x03(\x07R\
    \nstateColor\x12\x1d\n\nstate_name\x18\x0b\x20\x03(\tR\tstateName\x12\
    \x1b\n\tstate_adj\x18\x0c\x20\x03(\tR\x08stateAdj\x12%\n\x0ereaction_cla\
    ss\x18\r\x20\x03(\tR\rreactionClass\x12M\n\x10reaction_product\x18\x0e\
    \x20\x03(\x0b2\".dfproto.BasicMaterialInfo.ProductR\x0freactionProduct\
    \x12'\n\x0finorganic_flags\x18\x0f\x20\x03(\x05R\x0einorganicFlags\x1aC\
    \n\x07Product\x12\x0e\n\x02id\x18\x01\x20\x02(\tR\x02id\x12\x12\n\x04typ\
    e\x18\x02\x20\x02(\x05R\x04type\x12\x14\n\x05index\x18\x03\x20\x02(\x11R\
    \x05index\"\x99\x02\n\x15BasicMaterialInfoMask\x12@\n\x06states\x18\x01\
    \x20\x03(\x0e2(.dfproto.BasicMaterialInfoMask.StateTypeR\x06states\x12)\
    \n\x0btemperature\x18\x04\x20\x01(\x05:\x0510015R\x0btemperatureB\0\x12\
    \x1d\n\x05flags\x18\x02\x20\x01(\x08:\x05falseR\x05flagsB\0\x12#\n\x08re\
    action\x18\x03\x20\x01(\x08:\x05falseR\x08reactionB\0\"O\n\tStateType\
    \x12\t\n\x05Solid\x10\0\x12\n\n\x06Liquid\x10\x01\x12\x07\n\x03Gas\x10\
    \x02\x12\n\n\x06Powder\x10\x03\x12\t\n\x05Paste\x10\x04\x12\x0b\n\x07Pre\
    ssed\x10\x05\"\xb7\x01\n\x0cJobSkillAttr\x12\x0e\n\x02id\x18\x01\x20\x02\
    (\x05R\x02id\x12\x10\n\x03key\x18\x02\x20\x02(\tR\x03key\x12\x18\n\x07ca\
    ption\x18\x03\x20\x01(\tR\x07caption\x12!\n\x0ccaption_noun\x18\x04\x20\
    \x01(\tR\x0bcaptionNoun\x12\x1e\n\nprofession\x18\x05\x20\x01(\x05R\npro\
    fession\x12\x14\n\x05labor\x18\x06\x20\x01(\x05R\x05labor\x12\x12\n\x04t\
    ype\x18\x07\x20\x01(\tR\x04type\"\xaa\x01\n\x0eProfessionAttr\x12\x0e\n\
    \x02id\x18\x01\x20\x02(\x05R\x02id\x12\x10\n\x03key\x18\x02\x20\x02(\tR\
    \x03key\x12\x18\n\x07caption\x18\x03\x20\x01(\tR\x07caption\x12\x1a\n\
    \x08military\x18\x04\x20\x01(\x08R\x08military\x12(\n\x10can_assign_labo\
    r\x18\x05\x20\x01(\x08R\x0ecanAssignLabor\x12\x16\n\x06parent\x18\x06\
    \x20\x01(\x05R\x06parent\"K\n\rUnitLaborAttr\x12\x0e\n\x02id\x18\x01\x20\
    \x02(\x05R\x02id\x12\x10\n\x03key\x18\x02\x20\x02(\tR\x03key\x12\x18\n\
    \x07caption\x18\x03\x20\x01(\tR\x07caption\"\xac\x01\n\x08NameInfo\x12\
    \x1d\n\nfirst_name\x18\x01\x20\x01(\tR\tfirstName\x12\x1a\n\x08nickname\
    \x18\x02\x20\x01(\tR\x08nickname\x12%\n\x0blanguage_id\x18\x03\x20\x01(\
    \x05:\x02-1R\nlanguageIdB\0\x12\x1b\n\tlast_name\x18\x04\x20\x01(\tR\x08\
    lastName\x12!\n\x0cenglish_name\x18\x05\x20\x01(\tR\x0benglishName\"Z\n\
    \nNameTriple\x12\x16\n\x06normal\x18\x01\x20\x02(\tR\x06normal\x12\x16\n\
    \x06plural\x18\x02\x20\x01(\tR\x06plural\x12\x1c\n\tadjective\x18\x03\
    \x20\x01(\tR\tadjective\"\xac\x01\n\rUnitCurseInfo\x12\x1b\n\tadd_tags1\
    \x18\x01\x20\x02(\x07R\x08addTags1\x12\x1b\n\trem_tags1\x18\x02\x20\x02(\
    \x07R\x08remTags1\x12\x1b\n\tadd_tags2\x18\x03\x20\x02(\x07R\x08addTags2\
    \x12\x1b\n\trem_tags2\x18\x04\x20\x02(\x07R\x08remTags2\x12'\n\x04name\
    \x18\x05\x20\x01(\x0b2\x13.dfproto.NameTripleR\x04name\"Q\n\tSkillInfo\
    \x12\x0e\n\x02id\x18\x01\x20\x02(\x05R\x02id\x12\x14\n\x05level\x18\x02\
    \x20\x02(\x05R\x05level\x12\x1e\n\nexperience\x18\x03\x20\x02(\x05R\nexp\
    erience\"5\n\rUnitMiscTrait\x12\x0e\n\x02id\x18\x01\x20\x02(\x05R\x02id\
    \x12\x14\n\x05value\x18\x02\x20\x02(\x05R\x05value\"\x88\x06\n\rBasicUni\
    tInfo\x12\x17\n\x07unit_id\x18\x01\x20\x02(\x05R\x06unitId\x12\x13\n\x05\
    pos_x\x18\r\x20\x02(\x05R\x04posX\x12\x13\n\x05pos_y\x18\x0e\x20\x02(\
    \x05R\x04posY\x12\x13\n\x05pos_z\x18\x0f\x20\x02(\x05R\x04posZ\x12%\n\
    \x04name\x18\x02\x20\x01(\x0b2\x11.dfproto.NameInfoR\x04name\x12\x16\n\
    \x06flags1\x18\x03\x20\x02(\x07R\x06flags1\x12\x16\n\x06flags2\x18\x04\
    \x20\x02(\x07R\x06flags2\x12\x16\n\x06flags3\x18\x05\x20\x02(\x07R\x06fl\
    ags3\x12\x12\n\x04race\x18\x06\x20\x02(\x05R\x04race\x12\x14\n\x05caste\
    \x18\x07\x20\x02(\x05R\x05caste\x12\x1c\n\x06gender\x18\x08\x20\x01(\x05\
    :\x02-1R\x06genderB\0\x12\x1b\n\x06civ_id\x18\t\x20\x01(\x05:\x02-1R\x05\
    civIdB\0\x12#\n\nhistfig_id\x18\n\x20\x01(\x05:\x02-1R\thistfigIdB\0\x12\
    \x1f\n\x08death_id\x18\x11\x20\x01(\x05:\x02-1R\x07deathIdB\0\x12\x1f\n\
    \x0bdeath_flags\x18\x12\x20\x01(\rR\ndeathFlags\x12\x1f\n\x08squad_id\
    \x18\x13\x20\x01(\x05:\x02-1R\x07squadIdB\0\x12+\n\x0esquad_position\x18\
    \x14\x20\x01(\x05:\x02-1R\rsquadPositionB\0\x12$\n\nprofession\x18\x16\
    \x20\x01(\x05:\x02-1R\nprofessionB\0\x12+\n\x11custom_profession\x18\x17\
    \x20\x01(\tR\x10customProfession\x12\x16\n\x06labors\x18\x0b\x20\x03(\
    \x05R\x06labors\x12*\n\x06skills\x18\x0c\x20\x03(\x0b2\x12.dfproto.Skill\
    InfoR\x06skills\x127\n\x0bmisc_traits\x18\x18\x20\x03(\x0b2\x16.dfproto.\
    UnitMiscTraitR\nmiscTraits\x12,\n\x05curse\x18\x10\x20\x01(\x0b2\x16.dfp\
    roto.UnitCurseInfoR\x05curse\x12\x18\n\x07burrows\x18\x15\x20\x03(\x05R\
    \x07burrows\"\xa8\x01\n\x11BasicUnitInfoMask\x12\x1f\n\x06labors\x18\x01\
    \x20\x01(\x08:\x05falseR\x06laborsB\0\x12\x1f\n\x06skills\x18\x02\x20\
    \x01(\x08:\x05falseR\x06skillsB\0\x12'\n\nprofession\x18\x03\x20\x01(\
    \x08:\x05falseR\nprofessionB\0\x12(\n\x0bmisc_traits\x18\x04\x20\x01(\
    \x08:\x05falseR\nmiscTraitsB\0\"\x82\x01\n\x0eBasicSquadInfo\x12\x19\n\
    \x08squad_id\x18\x01\x20\x02(\x05R\x07squadId\x12%\n\x04name\x18\x02\x20\
    \x01(\x0b2\x11.dfproto.NameInfoR\x04name\x12\x14\n\x05alias\x18\x03\x20\
    \x01(\tR\x05alias\x12\x18\n\x07members\x18\x04\x20\x03(\x11R\x07members\
    \"U\n\x0eUnitLaborState\x12\x17\n\x07unit_id\x18\x01\x20\x02(\x05R\x06un\
    itId\x12\x14\n\x05labor\x18\x02\x20\x02(\x05R\x05labor\x12\x14\n\x05valu\
    e\x18\x03\x20\x02(\x08R\x05valueB\x02H\x03b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(EnumItemName::generated_message_descriptor_data());
            messages.push(BasicMaterialId::generated_message_descriptor_data());
            messages.push(BasicMaterialInfo::generated_message_descriptor_data());
            messages.push(BasicMaterialInfoMask::generated_message_descriptor_data());
            messages.push(JobSkillAttr::generated_message_descriptor_data());
            messages.push(ProfessionAttr::generated_message_descriptor_data());
            messages.push(UnitLaborAttr::generated_message_descriptor_data());
            messages.push(NameInfo::generated_message_descriptor_data());
            messages.push(NameTriple::generated_message_descriptor_data());
            messages.push(UnitCurseInfo::generated_message_descriptor_data());
            messages.push(SkillInfo::generated_message_descriptor_data());
            messages.push(UnitMiscTrait::generated_message_descriptor_data());
            messages.push(BasicUnitInfo::generated_message_descriptor_data());
            messages.push(BasicUnitInfoMask::generated_message_descriptor_data());
            messages.push(BasicSquadInfo::generated_message_descriptor_data());
            messages.push(UnitLaborState::generated_message_descriptor_data());
            messages.push(basic_material_info::Product::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(basic_material_info_mask::StateType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
